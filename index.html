<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>FitnessMate - AI Workout Hub</title>
 
 <meta name="description" content="FitnessMate — AI workout plans and guided sessions. Personalized home & gym workouts, bodyweight routines, and progress tracking.">
<meta property="og:title" content="FitnessMate - AI Workout Hub">
<meta property="og:description" content="Personalized AI workout plans for home and gym.">
<meta property="og:image" content="https://fitnessmate.netlify.app/og-image.png">
<meta property="og:type" content="website">
<meta property="og:url" content="https://fitnessmate.netlify.app/">
<meta name="keywords" content="AI workout app, fitness planner, gym tracker, home workouts, FitnessMate">

<meta name="twitter:card" content="summary_large_image">
<meta name="author" content="FitnessMate Team">
<meta name="robots" content="index, follow">


<link rel="canonical" href="https://fitnessmate.netlify.app/">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="preconnect" href="https://cdn.tailwindcss.com">
  <link rel="preconnect" href="https://unpkg.com">
  <link rel="prefetch" href="/workout.html">
  <link rel="prefetch" href="/icon-192.png">
  


  <link rel="icon" type="image/x-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' fill='%23ec4899'/><text x='50' y='70' text-anchor='middle' fill='white' font-family='Arial, sans-serif' font-weight='bold' font-size='60'>F</text></svg>">
  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      darkMode: 'class',
    }
  </script>
  
  <script>
    // Prevent white flash on page load - apply background immediately
    (function() {
      const isDarkMode = localStorage.getItem('fitmate-dark-mode') === 'true';
      if (isDarkMode) {
        document.documentElement.classList.add('dark');
        document.documentElement.style.backgroundColor = '#111827';
      } else {
        document.documentElement.style.backgroundColor = '#f9fafb';
      }
    })();
  </script>
  <script>
    (function(){
      function todayInSelectedTZ(){
        try {
          const tz = localStorage.getItem('userTimeZone') || Intl.DateTimeFormat().resolvedOptions().timeZone;
          const parts = new Intl.DateTimeFormat('en-CA', { timeZone: tz, year:'numeric', month:'2-digit', day:'2-digit' }).formatToParts(new Date());
          const y = parts.find(p=>p.type==='year')?.value;
          const m = parts.find(p=>p.type==='month')?.value;
          const d = parts.find(p=>p.type==='day')?.value;
          return `${y}-${m}-${d}`;
        } catch(_){
          const d = new Date();
          return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
        }
      }

      function sanitize(){
        try {
          // No-op: keep current intake; only ensure it exists on first launch
          const zero = { calories:0, protein:0, carbs:0, fat:0, activity:0, water:0 };
          if (!localStorage.getItem('dailyIntake')) {
            localStorage.setItem('dailyIntake', JSON.stringify(zero));
          }
        } catch(_) {}
      }

      // Run at first paint and on visibility return
      sanitize();
      document.addEventListener('visibilitychange', function(){ if(!document.hidden) sanitize(); }, true);
    })();
  </script>
  
  <!-- Supabase SDK -->
  <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
  
  <!-- Custom Booking System - No longer using Calendly -->
  
  <!-- Stripe.js removed - using invoice-based payment system -->
  
  <!-- Whereby for video meetings -->
  
  <!-- EmailJS for email sending -->
  <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@emailjs/browser@3/dist/email.min.js"></script>
  <script>
    (function() {
      // Initialize EmailJS with your public key
      emailjs.init("NBoWj-4wIbDY-qLS8"); // Replace with your actual EmailJS public key
      
      /* 
      IMPORTANT: To set up EmailJS for booking confirmations:
      
      1. Sign up at https://www.emailjs.com/ (free tier available)
      2. Create a new Email Service (Gmail, Outlook, etc.)
      3. Create two email templates:
         - For free sessions (template_id): Include {{to_name}}, {{session_date}}, {{session_time}}, {{session_type}}, {{meeting_link}}
         - For paid sessions (template_paid_id): Include all above plus {{sessions_count}} and {{amount_paid}}
      4. Replace 'YOUR_PUBLIC_KEY' above with your EmailJS public key
      5. Replace 'service_id', 'template_id', and 'template_paid_id' in the code with your actual IDs
      */
    })();
  </script>
  
  <!-- Custom Booking Calendar Styles -->
  <style>
    .booking-calendar-container {
      width: 100%;
      min-height: 650px;
    }
    
    .booking-step {
      animation: fadeIn 0.3s ease-in-out;
    }
    
    .calendar-container {
      width: 100%;
    }
    
    .calendar-day {
      aspect-ratio: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }
    
    .time-slots-container {
      max-height: 400px;
      overflow-y: auto;
    }
    
    .time-slot {
      transition: all 0.2s ease;
    }
    
    .package-card {
      height: 100%;
      display: flex;
      flex-direction: column;
      transition: all 0.2s ease;
    }
    
    .package-price {
      margin-bottom: 1rem;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* Merch teaser text with subtle glow and shadow */
    .merch-teaser {
      font-weight: 600;
      text-shadow: 0 1px 2px rgba(0,0,0,0.18), 0 0 10px rgba(236,72,153,0.25), 0 0 6px rgba(59,130,246,0.25);
    }
    .merch-teaser .twinkle-star {
      display: inline-block;
      margin: 0 6px;
      animation: twinkle 1.2s ease-in-out infinite;
    }
    .merch-teaser .twinkle-star.delay { animation-delay: .6s; }
    /* Starry overlay effect on the text itself */
    .merch-teaser.starry { position: relative; }
    .merch-teaser.starry::after {
      content: '';
      position: absolute;
      inset: 0;
      pointer-events: none;
      mix-blend-mode: screen;
      background:
        radial-gradient(circle at 12% 35%, rgba(255,255,255,0.9) 0, rgba(255,255,255,0.9) 1.5px, transparent 2.6px),
        radial-gradient(circle at 28% 62%, rgba(255,255,255,0.8) 0, rgba(255,255,255,0.8) 1.2px, transparent 2.2px),
        radial-gradient(circle at 56% 28%, rgba(255,255,255,0.85) 0, rgba(255,255,255,0.85) 1.2px, transparent 2.2px),
        radial-gradient(circle at 74% 66%, rgba(255,255,255,0.8) 0, rgba(255,255,255,0.8) 1.2px, transparent 2.2px),
        radial-gradient(circle at 88% 42%, rgba(255,255,255,0.85) 0, rgba(255,255,255,0.85) 1.2px, transparent 2.2px);
      animation: sparkle 2.8s ease-in-out infinite;
    }
    /* Hard blink on/off for the whole line */
    .merch-teaser.blink { animation: blinker 1.6s steps(2, start) infinite; }
    @keyframes blinker { 0% { opacity: 1; } 50% { opacity: 0; } 100% { opacity: 1; } }
    @keyframes sparkle {
      0%, 100% { opacity: .45; filter: brightness(1); }
      50% { opacity: 1; filter: brightness(1.25); }
    }
    @keyframes twinkle {
      0%, 100% { opacity: 0.35; transform: scale(0.9); filter: drop-shadow(0 0 0 rgba(255,255,255,0)); }
      50% { opacity: 1; transform: scale(1.1); filter: drop-shadow(0 0 6px rgba(255,215,0,0.9)); }
    }
    #installBannerIOS {
      position: fixed;
      bottom: -100px;
      left: 0;
      right: 0;
      background: #2563EB;
      color: white;
      text-align: center;
      padding: 10px;
      font-family: system-ui, sans-serif;
      font-size: 14px;
      z-index: 9999;
      box-shadow: 0 -2px 8px rgba(0,0,0,0.3);
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      transition: bottom 0.4s ease;
    }
    #installBannerIOS .banner-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2px;
    }
    #installBannerIOS .main-text {
      display: flex;
      align-items: center;
      font-weight: 600;
      font-size: 15px;
    }
    #installBannerIOS .main-text .app-name { margin-left: 4px; }
    #installBannerIOS .sub-text {
      font-size: 11px;
      opacity: 0.9;
      line-height: 1.2;
    }
    #installBannerIOS.show { bottom: 0; }
    #installBannerIOS button {
      background: white;
      color: #2563EB;
      border: none;
      border-radius: 6px;
      padding: 6px 10px;
      font-size: 13px;
      font-weight: 600;
      line-height: 1.2;
      cursor: pointer;
    }
    #installBannerIOS .ios-icon {
      display: inline-flex;
      width: 22px;
      height: 22px;
      color: #fff;
      margin-right: 6px;
      flex-shrink: 0;
      align-items: center;
      justify-content: center;
    }
    #closeBannerIOS {
      background: transparent;
      border: none;
      color: white;
      font-size: 20px;
      line-height: 1;
      cursor: pointer;
      position: absolute;
      right: 12px;
      top: 8px;
    }
    @media (max-width: 480px) {
      #installBannerIOS {
        padding: 8px;
        font-size: 13px;
        gap: 8px;
      }
      #closeBannerIOS {
        position: static;
        right: auto;
        top: auto;
        margin-left: auto;
      }
    }
  </style>
  <style>
    /* Android install banner icon styling */
    #installBanner .android-icon {
      display: inline-flex;
      width: 30px;
      height: 30px;
      color: #ec4899; /* Tailwind pink-500 to match header icon */
      margin-right: 8px;
      vertical-align: middle;
    }
  </style>
  <!-- PWA manifest + theme -->
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#ec4899"> <!-- main app pink -->
  <meta name="color-scheme" content="light dark"> <!-- Let browser auto-select Light/dark -->

  <!-- icons (ensure these files exist at repo root) -->
  <link rel="icon" href="/icon.png">
  <link rel="apple-touch-icon" href="/icon-192.png">
  
  <script>
    // Conditionally load AdSense: iOS (iPhone/iPad/iPod) and desktop only. Never on Android.
    // Also disable for subscribed users (Stripe/Play), and react to runtime subscription changes.
    (function(){
      try {
        var ua = navigator.userAgent || '';
        var plat = (navigator.userAgentData && navigator.userAgentData.platform) || '';
        var isAndroid = /Android/i.test(ua) || /Android/i.test(plat);
        var isIPhone = /iPhone/i.test(ua);
        var isIPadUA = /iPad/i.test(ua);
        var isIPadLikeMac = /Macintosh/.test(ua) && navigator.maxTouchPoints > 1; // iPadOS 13+ masquerades as Mac
        var isIPad = isIPadUA || isIPadLikeMac;
        var isIPod = /iPod/i.test(ua);
        var isIOS = isIPhone || isIPad || isIPod;
        // Desktop: anything not mobile (exclude Android/iOS)
        var isDesktop = !(isAndroid || isIOS || /Mobile/i.test(ua));
        var subscribed = false; try { subscribed = JSON.parse(localStorage.getItem('subscriptionActive') || 'false') === true; } catch(_) {}

        function qualifiesForAdsense(){ return (isIOS || isDesktop) && !subscribed; }
        function injectAdsense(){
          if (!window.__adsenseLoaded) {
            var s = document.createElement('script');
            s.async = true;
            s.src = 'https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4496629998193729';
            s.crossOrigin = 'anonymous';
            document.head.appendChild(s);
            window.__adsenseLoaded = true;
          }
        }
        function hideAdsenseUnits(){
          try {
            document.querySelectorAll('ins.adsbygoogle, iframe[id^="google_ads_iframe"], .google-auto-placed').forEach(function(el){ el.style.display = 'none'; });
          } catch(_) {}
        }

        var shouldLoadAdsense = qualifiesForAdsense();
        if (shouldLoadAdsense) injectAdsense(); else hideAdsenseUnits();

        window.__fitmateAds = { android: isAndroid, iphone: isIPhone, ipad: isIPad, ipod: isIPod, ios: isIOS, desktop: isDesktop, subscribed: subscribed, adsense: shouldLoadAdsense };

        // React to runtime subscription changes
        window.addEventListener('subscription-status-changed', function(e){
          try {
            subscribed = !!(e && e.detail && e.detail.active);
            window.__fitmateAds.subscribed = subscribed;
            window.__fitmateAds.adsense = qualifiesForAdsense();
            if (window.__fitmateAds.adsense) {
              injectAdsense();
            } else {
              hideAdsenseUnits();
            }
          } catch(_) {}
        });
      } catch (e) { /* no-op */ }
    })();
  </script>
</head>
<body class="bg-gray-50 dark:bg-gray-900">
  <!-- Hidden Netlify Form for Support -->
  <form name="support-form" netlify hidden>
    <input type="text" name="full-name" />
    <input type="email" name="email" />
    <input type="text" name="subject" />
    <textarea name="message"></textarea>
  </form>
  
  <!-- Background Music Audio Element -->
  <audio id="background-music" loop preload="auto">
    <source src="./Gym.mp3" type="audio/mpeg">
    Your browser does not support the audio element.
  </audio>
  
  <div id="root"></div>

  <!-- React + ReactDOM + Babel (for JSX in-browser) -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    const { useState, useRef, useEffect, useCallback } = React;

    // Global safe stub to avoid ReferenceError before the real helper is defined
    if (typeof window !== 'undefined' && typeof window.setLocalStorageWithSync === 'undefined') {
      window.setLocalStorageWithSync = function (key, value) {
        try {
          localStorage.setItem(key, value);
        } catch (error) {
          if (error && (error.name === 'QuotaExceededError' || error.code === 22)) {
            try {
              ['pantryChef_imagePreview','menuDecoder_imagePreview','pantryChef_ingredients','pantryChef_recipes','menuDecoder_menuItems','menuDecoder_recommendations','dailyQuote','lastQuoteFetchDate']
                .forEach(k => { try { localStorage.removeItem(k); } catch (_) {} });
              localStorage.setItem(key, value);
            } catch (e) {
              if (key === 'profilePicture' || /imagePreview/.test(key)) return;
              console.warn('setLocalStorageWithSync stub failed after cleanup:', e);
            }
          } else {
            console.warn('setLocalStorageWithSync stub store failed:', error);
          }
        }
      };

      // Enhanced multi-frame analysis for better accuracy on uploads
      const enhancedAnalyzeForm = async (videoBlob) => {
        setIsLoading(true);
        setError(null);
        try {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d', { willReadFrequently: true });
          const video = document.createElement('video');
          video.src = URL.createObjectURL(videoBlob);
          video.muted = true;
          video.playsInline = true;

          const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error('Video processing timeout')), 30000));

          const loadMeta = new Promise((resolve, reject) => {
            video.onloadedmetadata = () => resolve(true);
            video.onerror = () => reject(new Error('Failed to load video metadata'));
            try { video.load(); } catch (_) {}
          });

          await Promise.race([loadMeta, timeoutPromise]);
          if (!video.videoWidth || !video.videoHeight) throw new Error('Invalid video dimensions');

          const duration = Math.max(0.5, isFinite(video.duration) ? video.duration : 3);
          const times = Array.from({ length: 4 }, (_, i) => Math.min(duration - 0.1, Math.max(0.1, ((i + 1) / 5) * duration)));

          const seekTo = (t) => new Promise((resolve, reject) => {
            const onSeeked = () => { video.removeEventListener('seeked', onSeeked); resolve(true); };
            const onError = () => { video.removeEventListener('error', onError); reject(new Error('Failed to seek video')); };
            video.addEventListener('seeked', onSeeked, { once: true });
            video.addEventListener('error', onError, { once: true });
            try { video.currentTime = t; } catch (_) { reject(new Error('Seek failed')); }
          });

          const computeMetrics = (imageData, w, h) => {
            const data = imageData.data;
            const step = Math.max(1, Math.floor(Math.min(w, h) / 160));
            let sumL = 0, count = 0;
            const gray = new Float32Array(w * h);
            for (let y = 0; y < h; y += step) {
              for (let x = 0; x < w; x += step) {
                const idx = (y * w + x) * 4;
                const r = data[idx], g = data[idx + 1], b = data[idx + 2];
                const l = 0.299 * r + 0.587 * g + 0.114 * b;
                gray[y * w + x] = l;
                sumL += l; count++;
              }
            }
            const meanL = sumL / Math.max(1, count) / 255; // 0..1
            let sharpSum = 0, sCount = 0;
            for (let y = step; y < h - step; y += step) {
              for (let x = step; x < w - step; x += step) {
                const rx = gray[y * w + (x + step)] - gray[y * w + (x - step)];
                const ry = gray[(y + step) * w + x] - gray[(y - step) * w + x];
                const mag = Math.abs(rx) + Math.abs(ry);
                sharpSum += mag; sCount++;
              }
            }
            const sharpness = (sharpSum / Math.max(1, sCount)) / 255; // normalized
            return { brightness: meanL, sharpness };
          };

          const captureFrame = () => {
            const maxSide = 640;
            const scale = Math.min(1, maxSide / Math.max(video.videoWidth, video.videoHeight));
            const w = Math.max(1, Math.floor(video.videoWidth * scale));
            const h = Math.max(1, Math.floor(video.videoHeight * scale));
            canvas.width = w; canvas.height = h;
            ctx.drawImage(video, 0, 0, w, h);
            const imgData = ctx.getImageData(0, 0, w, h);
            const { brightness, sharpness } = computeMetrics(imgData, w, h);
            const base64 = canvas.toDataURL('image/jpeg', 0.7).split(',')[1];
            return { base64, brightness, sharpness, w, h };
          };

          const frames = [];
          for (const t of times) {
            try {
              await Promise.race([seekTo(t), timeoutPromise]);
              frames.push({ t, ...captureFrame() });
            } catch (e) { console.warn('Frame capture failed at', t, e); }
          }

          if (frames.length === 0) {
            await Promise.race([seekTo(Math.min(duration / 2, duration - 0.1)), timeoutPromise]);
            frames.push({ t: duration / 2, ...captureFrame() });
          }

          const scored = frames.map(f => ({
            ...f,
            quality: f.sharpness * 0.8 + (1 - Math.abs(f.brightness - 0.55)) * 0.2
          }))
          .sort((a, b) => b.quality - a.quality)
          .slice(0, Math.min(3, frames.length));

          const selectedExerciseData = exercises.find(ex => ex.id === selectedExercise);
          if (!selectedExerciseData) throw new Error('No exercise selected');

          const prompt = `You will analyze multiple frames from a video of a ${selectedExerciseData.name} exercise.

Use the sequence to judge posture, joint angles, and safety across the movement. Do not penalize for limited visible motion per frame; consider consistency across frames. If visibility is partial or lighting is poor, avoid overly low scores—provide constructive feedback instead.

Focus on:
1. Body alignment and posture
2. Joint positioning and angles
3. Common mistakes to avoid
4. Specific improvements for better form
5. Safety considerations
6. Reference relevant FitMate features (e.g., Workout Planner videos for ${selectedExerciseData.name})

Respond ONLY with a valid JSON object in this exact format:
{
  "exercise_detected": "${selectedExerciseData.name}",
  "overall_score": 1-10,
  "form_analysis": {
    "posture": "...",
    "technique": "...",
    "safety": "..."
  },
  "feedback": {
    "positive_points": ["..."],
    "improvements": ["..."],
    "tips": ["..."]
  },
  "next_steps": "..."
}`;

          const contentImages = scored.map(s => ({ type: 'image_url', image_url: `data:image/jpeg;base64,${s.base64}` }));

          const response = await fetch(getDirectGeminiConfig().url, {
            method: 'POST',
            headers: getDirectGeminiConfig().headers,
            body: JSON.stringify({
              model: OPENROUTER_QWEN_VL_MODEL,
              messages: [{
                role: 'user',
                content: [
                  { type: 'text', text: prompt },
                  ...contentImages
                ]
              }]
            })
          });

          if (!response.ok) {
            const errorText = await response.text();
            console.error('API Error Response:', errorText);
            throw new Error(`API Error: ${response.status} ${response.statusText}`);
          }

          const result = await response.json();
          const textResponse = (result.choices?.[0]?.message?.content || '');
          if (!textResponse) throw new Error('Invalid API response format');

          let jsonString = textResponse.replace(/```json|```/g, '').trim();
          if (jsonString.includes('```')) {
            const jsonMatchMd = jsonString.match(/```(?:json)?\s*({[\s\S]*?})\s*```/);
            if (jsonMatchMd) jsonString = jsonMatchMd[1];
          }
          const jsonMatch = jsonString.match(/{[\s\S]*}/);
          if (jsonMatch) jsonString = jsonMatch[0];

          const data = JSON.parse(jsonString);

          if (!data.overall_score && data.overall_score !== 0) data.overall_score = 3;
          if (!data.form_analysis) {
            data.form_analysis = {
              posture: data.posture || 'Unable to analyze posture from this video.',
              technique: data.technique || 'Unable to assess technique from this video.',
              safety: data.safety || 'Please ensure proper form and safety when exercising.'
            };
          }
          if (!data.feedback) {
            data.feedback = {
              positive_points: data.positive_points || [],
              improvements: data.improvements || ['Please upload a clearer video showing the full exercise movement'],
              tips: data.tips || ['Ensure good lighting and clear view of your full body', 'Upload from a side or slightly angled perspective']
            };
          }
          if (data.exercise_detected && data.exercise_detected.toLowerCase().includes('no ') && data.exercise_detected.toLowerCase().includes('detected')) {
            const sel = exercises.find(ex => ex.id === selectedExercise);
            data.exercise_detected = sel ? sel.name : 'Exercise';
            data.overall_score = 2;
            data.feedback.improvements = [
              'The selected exercise was not clearly visible in the video',
              'Please ensure your full body is visible in the frame',
              'Use a side angle for clearer joint visibility',
              'Ensure adequate lighting and a clear background'
            ];
            data.feedback.tips = [
              'Place camera 6-8 feet away to capture full body',
              'Avoid backlighting; face the light source',
              'Perform the movement slowly with full range of motion',
              'Keep the camera stable at chest height'
            ];
            data.next_steps = 'Please upload another video with better positioning and lighting for accurate form analysis.';
          }
          if (!data.next_steps) data.next_steps = 'Continue practicing with proper form and consider uploading from different angles for comprehensive analysis.';

          setFormAnalysis(data);
        } catch (err) {
          console.error('Enhanced form analysis failed, falling back to single-frame:', err);
          try {
            await analyzeForm(videoBlob);
            return;
          } catch (fallbackErr) {
            console.error('Fallback analyzeForm also failed:', fallbackErr);
            setError('Could not analyze form. Please upload a clearer video.');
          }
        } finally {
          setIsLoading(false);
        }
      };
    }

    // Supabase Configuration
    const getSupabaseConfig = () => {
      // Replace these with your actual Supabase project URL and anon key
      return {
        url: 'https://bhtabgrcxaahkuwrdwec.supabase.co',
        anonKey: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJodGFiZ3JjeGFhaGt1d3Jkd2VjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgzNzc1MjMsImV4cCI6MjA3Mzk1MzUyM30._Cydy4B6QMF353OG8jnhK7juWgz2j4RirATIfCgAflQ'
      };
    };

    const supabaseConfig = getSupabaseConfig();

    // Initialize Supabase
    let supabase, auth, currentUser = null;
    const USERS_REALTIME_ENABLED = true;
    try {
      const { createClient } = window.supabase;
      supabase = createClient(supabaseConfig.url, supabaseConfig.anonKey);
      auth = supabase.auth;
      
      // Expose for console access (e.g., repair scripts)
      window.__fitmateSupabase = supabase;
      
      // Join a single realtime channel for AI-usage broadcasts
      try {
        if (!window.__aiUsageChannel) {
          window.__aiUsageChannel = supabase.channel('ai-usage');
          window.__aiUsageChannel.subscribe();
        }
      } catch(_) {}
      
      // Auth state change listener will be set up inside React component
    } catch (error) {
      console.log('Supabase not configured yet:', error.message);
      // Show user-friendly error message
      setTimeout(() => {
        const errorDiv = document.createElement('div');
        errorDiv.className = 'supabase-error';
        errorDiv.innerHTML = `
          <div style="position: fixed; top: 20px; left: 20px; right: 20px; background: #fee; border: 1px solid #fcc; color: #c33; padding: 15px; border-radius: 8px; z-index: 9999; font-family: Arial, sans-serif;">
            <strong>⚠️ Supabase Connection Issue:</strong><br>
            The app is running in offline mode. Some features may be limited.<br>
            <small>Error: ${error.message}</small>
          </div>
        `;
        document.body.appendChild(errorDiv);
        setTimeout(() => errorDiv.remove(), 10000);
      }, 1000);
    }

    // Database helper functions for Supabase
    const db = {
      // Helper function to clean and validate user data
      cleanUserData(data) {
        const cleaned = {};
        
        for (const [key, value] of Object.entries(data)) {
          // Skip null or undefined values
          if (value === null || value === undefined) {
            continue;
          }
          
          // Handle different data types
          if (typeof value === 'string') {
            // Ensure strings are not empty unless they should be
            if (value.trim() !== '' || ['profile_picture', 'habit_ai_advice'].includes(key)) {
              cleaned[key] = value;
            }
          } else if (typeof value === 'boolean') {
            cleaned[key] = value;
          } else if (typeof value === 'number') {
            cleaned[key] = value;
          } else if (typeof value === 'object') {
            // For JSONB fields, ensure they're valid JSON
            try {
              if (Array.isArray(value) || (value && typeof value === 'object')) {
                cleaned[key] = value;
              }
            } catch (e) {
              console.warn(`Skipping invalid JSON data for field ${key}:`, e);
            }
          }
        }
        
        return cleaned;
      },
      // User operations
      async createUser(userId, userData) {
        const { data, error } = await supabase
          .from('users')
          .insert([{ id: userId, ...userData }], { returning: 'minimal' });
        if (error) throw error;
        return data;
      },

      async getUser(userId) {
        const { data, error } = await supabase
          .from('users')
          .select('id, updated_at, goals, profile_picture, notifications_enabled, dark_mode, daily_intake, recent_meals, daily_history, coach_messages, habit_ai_advice, habits, meal_plan, workout_plan, scan_result, form_analysis, subscription, ai_usage')
          .eq('id', userId)
          .single();
        if (error && error.code !== 'PGRST116') throw error; // PGRST116 = not found
        return data;
      },

      async updateUser(userId, updates) {
        // Validate user ID
        if (!userId || typeof userId !== 'string') {
          throw new Error('Invalid user ID provided to updateUser');
        }
        
        // Ensure updated_at is always set to current timestamp
        const updateData = { ...updates };
        if (!updateData.updated_at) {
          updateData.updated_at = new Date().toISOString();
        }
        
        // Validate and clean data before sending to Supabase
        const cleanedData = this.cleanUserData(updateData);
        
        // Don't update if no valid data to update
        if (Object.keys(cleanedData).length === 0) {
          console.log('No valid data to update, skipping');
          return [];
        }
        
        console.log('Updating user data:', { userId, cleanedData });
        
        const { data, error } = await supabase
          .from('users')
          .update(cleanedData, { returning: 'minimal' })
          .eq('id', userId);
        if (error) {
          console.error('Supabase update error:', error);
          throw error;
        }
        return data;
      },

      async upsertUser(userId, userData) {
        // Validate user ID
        if (!userId || typeof userId !== 'string') {
          throw new Error('Invalid user ID provided to upsertUser');
        }
        
        // Ensure updated_at is always set to current timestamp
        const upsertData = { id: userId, ...userData };
        if (!upsertData.updated_at) {
          upsertData.updated_at = new Date().toISOString();
        }
        
        // Validate and clean data before sending to Supabase
        const cleanedData = this.cleanUserData(upsertData);
        
        console.log('Upserting user data:', { userId, cleanedData });
        
        const { data, error } = await supabase
          .from('users')
          .upsert([cleanedData], { returning: 'minimal' });
        if (error) {
          console.error('Supabase upsert error:', error);
          throw error;
        }
        return data;
      },

      // Workout history operations
      async addWorkoutHistory(userId, workoutData) {
        const { data, error } = await supabase
          .from('workout_history')
          .insert([{ user_id: userId, ...workoutData }], { returning: 'minimal' });
        if (error) throw error;
        return data;
      },

      // Booking operations
      async addBooking(userId, bookingData) {
        const { data, error } = await supabase
          .from('bookings')
          .insert([{ user_id: userId, ...bookingData }], { returning: 'minimal' });
        if (error) throw error;
        return data;
      },

      async getBookings(userId) {
        const { data, error } = await supabase
          .from('bookings')
          .select('*')
          .eq('user_id', userId)
          .order('created_at', { ascending: false });
        if (error) throw error;
        return data || [];
      },

      async getGlobalBookings(date) {
        const { data, error } = await supabase
          .from('bookings')
          .select('date, time, status')
          .eq('date', date);
        if (error) throw error;
        return data || [];
      },

      // General query operations
      async query(table, options = {}) {
        let query = supabase.from(table).select(options.select || '*');
        
        if (options.eq) {
          for (const [column, value] of Object.entries(options.eq)) {
            query = query.eq(column, value);
          }
        }
        
        if (options.order) {
          query = query.order(options.order.column, { ascending: options.order.ascending !== false });
        }
        
        if (options.limit) {
          query = query.limit(options.limit);
        }
        
        const { data, error } = await query;
        if (error) throw error;
        return data || [];
      },

      // Real-time subscriptions (similar to Firebase's .on())
      subscribe(table, callback, options = {}) {
        let subscription = supabase
          .channel(`${table}_changes`)
          .on('postgres_changes', { 
            event: '*', 
            schema: 'public', 
            table: table,
            ...options 
          }, callback);
        
        subscription.subscribe();
        return subscription;
      }
    };

    // Authentication Context
    const AuthContext = React.createContext();

    const AuthProvider = ({ children }) => {
      const [user, setUser] = useState(null);
      const [loading, setLoading] = useState(true);
      const [authError, setAuthError] = useState(null);
      const forceNextRemoteOnlyRef = useRef(false);
      // Track when remote data has been applied at least once on this device
      const authInitialRemoteAppliedRef = useRef(false);

      // Expose current user on window for console access (e.g., repair scripts)
      useEffect(() => {
        window.__fitmateUser = user;
      }, [user]);

      useEffect(() => {
        if (!auth) {
          setLoading(false);
          return;
        }

        // Get initial session
        auth.getSession().then(({ data: { session } }) => {
          setUser(session?.user || null);
          setLoading(false);
          if (session?.user) {
            // Sync user data when authenticated
            // Treat initial session like a sign-in for one cycle: fetch remote only
            forceNextRemoteOnlyRef.current = true;
            // Purge local profile so we only accept remote
            try { clearLocalProfileForRemoteOnly(); } catch (_) {}
            syncUserData(session.user);
          }
        });

        // Mark remote applied completion when event fires (initial or realtime)
        const onRemoteApplied = () => { authInitialRemoteAppliedRef.current = true; };
        window.addEventListener('remoteDataApplied', onRemoteApplied);

        // Listen for auth state changes
        const { data: { subscription } } = auth.onAuthStateChange((event, session) => {
          const currentUser = session?.user || null;
          setUser(currentUser);
          setLoading(false);
          
          if (currentUser) {
            console.log('User signed in:', currentUser.id);
            // Enforce remote-only fetch on explicit sign-in events
            if (event === 'SIGNED_IN') {
              forceNextRemoteOnlyRef.current = true;
              // Purge local profile so we only accept remote
              try { clearLocalProfileForRemoteOnly(); } catch (_) {}
              // DO NOT clear aiUsage on sign-in - use handshake to sync MAX value across devices
            }
            // Sync user data when authenticated
            syncUserData(currentUser);
          } else {
            console.log('User signed out');
            // Force UI to reflect signed-out state immediately
            try { localStorage.setItem('subscriptionActive', JSON.stringify(false)); } catch (_) {}
            try { window.dispatchEvent(new CustomEvent('subscription-status-changed', { detail: { active: false } })); } catch (_) {}
            try { window.dispatchEvent(new CustomEvent('ads-control', { detail: { enabled: true } })); } catch (_) {}
            try { localStorage.removeItem('aiUsage'); } catch (_) {}
            try { window.dispatchEvent(new Event('userDataSynced')); } catch (_) {}
          }
          // Surface password recovery flow even if URL lacks type=recovery
          if (event === 'PASSWORD_RECOVERY') {
            try {
              window.dispatchEvent(new CustomEvent('supabase-password-recovery', { detail: { session } }));
            } catch (_) { /* no-op */ }
          }
        });

        return () => {
          subscription?.unsubscribe();
          window.removeEventListener('remoteDataApplied', onRemoteApplied);
        };
      }, [auth]);

      const createInitialUserDocument = async (user) => {
        if (!supabase) return;
        
        try {
          // Ensure we have a valid session before creating user document
          const { data: { session } } = await auth.getSession();
          if (!session?.user) {
            console.log('⏳ No valid session found, skipping user document creation');
            return;
          }
          
          await db.upsertUser(user.id, {
            // Basic user info
            display_name: user.user_metadata?.display_name || user.email?.split('@')[0] || 'User',
            email: user.email,
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString(),
            
            // Profile data
            goals: JSON.parse(localStorage.getItem('goals') || '{}'),
            // profile_picture omitted to avoid overwriting remote value during remote-only mode,
            notifications_enabled: JSON.parse(localStorage.getItem('notificationsEnabled') || 'true'),
            dark_mode: JSON.parse(localStorage.getItem('fitmate-dark-mode') || 'false'),
            
            // Fitness data
            daily_intake: JSON.parse(localStorage.getItem('dailyIntake') || '{"calories":0,"protein":0,"carbs":0,"fat":0,"activity":0,"water":0}'),
            recent_meals: JSON.parse(localStorage.getItem('recentMeals') || '[]'),
            daily_history: JSON.parse(localStorage.getItem('dailyHistory') || '{}'),
            
            // AI and coaching data
            coach_messages: JSON.parse(localStorage.getItem('coachMessages') || '[{"text":"Hello! I\'m your AI Health Coach. Ask me anything about your nutrition or meals.","sender":"ai"}]'),
            habit_ai_advice: localStorage.getItem('habitAIAdvice') || '',
            habits: JSON.parse(localStorage.getItem('habits') || '[]'),
            
            // AI-generated content
            meal_plan: JSON.parse(localStorage.getItem('mealPlan') || 'null'),
            workout_plan: JSON.parse(localStorage.getItem('workoutPlan') || 'null'),
            // workout_history: JSON.parse(localStorage.getItem('workoutHistory') || '[]'), // Removed - using separate table
            scan_result: JSON.parse(localStorage.getItem('scanResult') || 'null'),
            form_analysis: JSON.parse(localStorage.getItem('formAnalysis') || 'null'),
            
            // AI usage tracking removed - using localStorage only for quota sync
          });
          console.log('✅ Comprehensive user document created in Supabase Database');
        } catch (error) {
          console.error('Error creating initial user document:', error);
          console.error('Error details:', {
            message: error.message,
            code: error.code,
            details: error.details,
            hint: error.hint
          });
        }
      };

      // Helper function to detect if local data has meaningful content (not just defaults)
      const hasMeaningfulLocalData = () => {
        // Check if we have any meaningful data in localStorage
        const goals = JSON.parse(localStorage.getItem('goals') || '{}');
        const dailyIntake = JSON.parse(localStorage.getItem('dailyIntake') || '{}');
        const recentMeals = JSON.parse(localStorage.getItem('recentMeals') || '[]');
        const dailyHistory = JSON.parse(localStorage.getItem('dailyHistory') || '{}');
        const coachMessages = JSON.parse(localStorage.getItem('coachMessages') || '[]');
        const habits = JSON.parse(localStorage.getItem('habits') || '[]');
        const mealPlan = JSON.parse(localStorage.getItem('mealPlan') || 'null');
        const workoutPlan = JSON.parse(localStorage.getItem('workoutPlan') || 'null');
        
        // Check if any of these have meaningful content
        const isDefaultGoals = (() => { try { return JSON.stringify(goals) === JSON.stringify(defaultGoals); } catch { return false; } })();
        const hasGoals = Object.keys(goals).length > 0 && !isDefaultGoals;
        const hasIntake = dailyIntake.calories > 0 || dailyIntake.protein > 0 || dailyIntake.carbs > 0 || dailyIntake.fat > 0 || dailyIntake.activity > 0 || dailyIntake.water > 0;
        const hasMeals = recentMeals.length > 0;
        const hasHistory = Object.keys(dailyHistory).length > 0;
        const hasCoachMessages = coachMessages.length > 1; // More than just the default welcome message
        const hasHabits = habits.length > 0;
        const hasMealPlan = mealPlan !== null && mealPlan !== 'null';
        const hasWorkoutPlan = workoutPlan !== null && workoutPlan !== 'null';
        
        return hasGoals || hasIntake || hasMeals || hasHistory || hasCoachMessages || hasHabits || hasMealPlan || hasWorkoutPlan;
      };

      // Purge local profile data so sign-in always starts from remote source of truth
      const clearLocalProfileForRemoteOnly = () => {
        const keys = [
          'goals',
          'dailyIntake',
          'recentMeals',
          'dailyHistory'
        ];
        // Preserve 'dailyIntakeDate' and 'lastSavedDate' to retain midnight rollover guard
        keys.forEach(k => { try { localStorage.removeItem(k); } catch (_) {} });
      };

      const syncUserData = async (u, retryCount = 0) => {
        if (!supabase) {
          console.log('Supabase Database not available - data will be stored locally only');
          return;
        }
        const effectiveUser = u || currentUser || user;
        if (!effectiveUser || !effectiveUser.id) {
          console.log('No authenticated user found for sync; skipping.');
          return;
        }
        
        // If set, enforce a one-time remote-only fetch (no local->remote writes)
        const remoteOnly = forceNextRemoteOnlyRef?.current === true;
        if (remoteOnly) {
          console.log('🔒 Remote-only sync mode is active for this sign-in.');
        }
        
        try {
          console.log('🔍 Starting sync process for user:', effectiveUser.id);
          const userData = await db.getUser(effectiveUser.id);
          console.log('📊 Remote user data received:', userData ? 'YES' : 'NO');
          
          if (userData) {
            const localLastSync = localStorage.getItem('lastSyncTimestamp');
            const remoteLastSync = userData.updated_at;
            const localLastSyncTs = localLastSync ? parseInt(localLastSync) : 0;
            const remoteLastSyncTs = remoteLastSync ? new Date(remoteLastSync).getTime() : 0;
            
            console.log('🔄 Intelligent sync - comparing timestamps...');
            console.log('Local last sync:', localLastSync);
            console.log('Remote last sync:', remoteLastSync);
            console.log('📊 Remote data summary:', {
              hasGoals: !!userData.goals,
              hasDailyIntake: !!userData.daily_intake,
              hasRecentMeals: !!userData.recent_meals,
              hasDailyHistory: !!userData.daily_history,
              hasProfilePicture: !!userData.profile_picture,
              updatedAt: userData.updated_at
            });
            
            // Enhanced sync logic: prioritize remote data for new devices
            const isNewDevice = !localLastSync;
            const hasLocalData = hasMeaningfulLocalData();
            const remoteIsNewer = remoteLastSyncTs > localLastSyncTs;
            
            console.log('🔍 Local data analysis:', {
              isNewDevice,
              hasLocalData,
              remoteIsNewer,
              localGoals: JSON.parse(localStorage.getItem('goals') || '{}'),
              localDailyIntake: JSON.parse(localStorage.getItem('dailyIntake') || '{}'),
              localRecentMeals: JSON.parse(localStorage.getItem('recentMeals') || '[]')
            });
            
            // Always sync from remote if:
            // 1. This is a new device (no local sync timestamp), OR
            // 2. Remote data is newer than local, OR
            // 3. Local data is empty/default (no meaningful content)
            const shouldSyncFromRemote = remoteOnly || isNewDevice || remoteIsNewer || !hasLocalData;
            
            console.log('📊 Sync decision factors:', {
              isNewDevice,
              hasLocalData,
              remoteIsNewer,
              shouldSyncFromRemote
            });
            
            if (shouldSyncFromRemote) {
              console.log('📥 Syncing newer data from remote to local');
              console.log('📊 Remote data received:', {
                hasGoals: !!userData.goals,
                hasDailyIntake: !!userData.daily_intake,
                hasRecentMeals: !!userData.recent_meals,
                hasDailyHistory: !!userData.daily_history,
                hasProfilePicture: !!userData.profile_picture,
                hasNotifications: userData.notifications_enabled !== undefined,
                hasDarkMode: userData.dark_mode !== undefined
              });
              
              // Sync all user data to localStorage
              if (userData.goals) {
                localStorage.setItem('goals', JSON.stringify(userData.goals));
                console.log('✅ Goals synced to localStorage');
              }
              if (userData.profile_picture) {
                localStorage.setItem('profilePicture', userData.profile_picture);
                console.log('✅ Profile picture synced to localStorage');
              }
              if (userData.notifications_enabled !== undefined) {
                localStorage.setItem('notificationsEnabled', JSON.stringify(userData.notifications_enabled));
                console.log('✅ Notifications setting synced to localStorage');
              }
              
              // Sync additional user data - REMOTE-ONLY on sign-in (like workout_history)
              if (remoteOnly) {
                // Remote-only: guard overwrites after reset; otherwise set from remote
                if (userData.daily_intake) {
                  try {
                    const todayISO = toLocalISODate(new Date());
                    const remoteUpdateIsToday = !!userData.updated_at && toLocalISODate(new Date(userData.updated_at)) === todayISO;
                    if (!remoteUpdateIsToday) {
                      console.log('⏭️ Remote-only: skipping remote daily_intake (updated_at not today)');
                    } else {
                      const localIntakeDate = localStorage.getItem('dailyIntakeDate');
                      const lastSaved = localStorage.getItem('lastSavedDate');
                      const rolledToToday = (localIntakeDate === todayISO && lastSaved === todayISO);
                      const currentLocal = (() => { try { return JSON.parse(localStorage.getItem('dailyIntake') || '{}') || {}; } catch { return {}; } })();
                      const localIsZero = ['calories','protein','carbs','fat','activity','water'].every(k => Number(currentLocal[k]||0) === 0);
                      const remoteHasNonZero = ['calories','protein','carbs','fat','activity','water'].some(k => Number(userData.daily_intake?.[k]||0) > 0);
                      const localMeals = (() => { try { return JSON.parse(localStorage.getItem('recentMeals') || '[]') || []; } catch { return []; } })();
                      const localHasStarted = !localIsZero || (Array.isArray(localMeals) && localMeals.length > 0);
                      if (rolledToToday && !localHasStarted && remoteHasNonZero) {
                        console.log('⏭️ Remote-only: skipping remote daily_intake until local day start');
                      } else {
                        const merged = { 
                          ...userData.daily_intake, 
                          activity: Number(userData.daily_intake?.activity || 0)
                        };
                        localStorage.setItem('dailyIntake', JSON.stringify(merged));
                        console.log('🔒 Remote-only: set daily_intake from remote (activity remote-only)');
                      }
                    }
                  } catch (_) {
                    console.log('⚠️ Remote-only: intake import failed; leaving local untouched');
                  }
                }
                if (userData.recent_meals) {
                  try {
                    const todayISO = toLocalISODate(new Date());
                    const remoteUpdateIsToday = !!userData.updated_at && toLocalISODate(new Date(userData.updated_at)) === todayISO;
                    if (!remoteUpdateIsToday) {
                      console.log('⏭️ Remote-only: skipping recent_meals (updated_at not today)');
                    } else {
                      const localIntakeDate = localStorage.getItem('dailyIntakeDate');
                      const lastSaved = localStorage.getItem('lastSavedDate');
                      const rolledToToday = (localIntakeDate === todayISO && lastSaved === todayISO);
                      const localMeals = (() => { try { return JSON.parse(localStorage.getItem('recentMeals') || '[]') || []; } catch { return []; } })();
                      const localIsEmpty = !Array.isArray(localMeals) || localMeals.length === 0;
                      const remoteHasMeals = Array.isArray(userData.recent_meals) && userData.recent_meals.length > 0;
                      if (rolledToToday && localIsEmpty && remoteHasMeals) {
                        console.log('⏭️ Remote-only: skipping recent_meals overwrite after local midnight reset');
                      } else {
                        localStorage.setItem('recentMeals', JSON.stringify(userData.recent_meals));
                        console.log('🔒 Remote-only: set recent_meals from remote');
                      }
                    }
                  } catch (_) {
                    localStorage.setItem('recentMeals', JSON.stringify(userData.recent_meals));
                    console.log('🔒 Remote-only: set recent_meals from remote');
                  }
                }
                if (userData.daily_history) {
                  try {
                    const localHistory = (() => { try { return JSON.parse(localStorage.getItem('dailyHistory') || '{}') || {}; } catch { return {}; } })();
                    const remoteHistory = userData.daily_history || {};
                    const merged = { ...remoteHistory, ...localHistory };
                    localStorage.setItem('dailyHistory', JSON.stringify(merged));
                    console.log('🔒 Remote-only: merged daily_history (prefer local)');
                  } catch (_) {
                    localStorage.setItem('dailyHistory', JSON.stringify(userData.daily_history));
                    console.log('🔒 Remote-only: set daily_history from remote');
                  }
                }
              } else {
                // Normal sync: guard overwrites after reset; otherwise merge
                if (userData.daily_intake) {
                  try {
                    const todayISO = toLocalISODate(new Date());
                    const remoteUpdateIsToday = !!userData.updated_at && toLocalISODate(new Date(userData.updated_at)) === todayISO;
                    if (!remoteUpdateIsToday) {
                      console.log('⏭️ Normal sync: skipping remote daily_intake (updated_at not today)');
                    } else {
                      const localIntakeDate = localStorage.getItem('dailyIntakeDate');
                      const lastSaved = localStorage.getItem('lastSavedDate');
                      const rolledToToday = (localIntakeDate === todayISO && lastSaved === todayISO);
                      const currentLocal = (() => { try { return JSON.parse(localStorage.getItem('dailyIntake') || '{}') || {}; } catch { return {}; } })();
                      const localIsZero = ['calories','protein','carbs','fat','activity','water'].every(k => Number(currentLocal[k]||0) === 0);
                      const remoteHasNonZero = ['calories','protein','carbs','fat','activity','water'].some(k => Number(userData.daily_intake?.[k]||0) > 0);
                      if (rolledToToday && localIsZero && remoteHasNonZero) {
                        console.log('⏭️ Normal sync: skipping remote daily_intake after midnight reset (no overwrites)');
                      } else {
                        const merged = { 
                          ...userData.daily_intake, 
                          activity: Number(userData.daily_intake?.activity || 0)
                        };
                        localStorage.setItem('dailyIntake', JSON.stringify(merged));
                        console.log('✅ Daily intake synced (activity remote-only)');
                      }
                    }
                  } catch (_) {
                    console.log('⚠️ Normal sync: intake merge failed; leaving local untouched');
                  }
                }
                if (userData.recent_meals) {
                  try {
                    const todayISO = toLocalISODate(new Date());
                    const remoteUpdateIsToday = !!userData.updated_at && toLocalISODate(new Date(userData.updated_at)) === todayISO;
                    if (!remoteUpdateIsToday) {
                      console.log('⏭️ Normal sync: skipping remote recent_meals (updated_at not today)');
                    } else {
                      const localIntakeDate = localStorage.getItem('dailyIntakeDate');
                      const lastSaved = localStorage.getItem('lastSavedDate');
                      const rolledToToday = (localIntakeDate === todayISO && lastSaved === todayISO);
                      const localMeals = (() => { try { return JSON.parse(localStorage.getItem('recentMeals') || '[]') || []; } catch { return []; } })();
                      const localIsEmpty = !Array.isArray(localMeals) || localMeals.length === 0;
                      const remoteHasMeals = Array.isArray(userData.recent_meals) && userData.recent_meals.length > 0;
                      if (rolledToToday && localIsEmpty && remoteHasMeals) {
                        console.log('⏭️ Skipping remote recent_meals to prevent post-rollover flicker');
                      } else {
                        localStorage.setItem('recentMeals', JSON.stringify(userData.recent_meals));
                        console.log('✅ Recent meals synced to localStorage');
                      }
                    }
                  } catch (_) {
                    localStorage.setItem('recentMeals', JSON.stringify(userData.recent_meals));
                    console.log('✅ Recent meals synced to localStorage');
                  }
                }
                if (userData.daily_history) {
                  try {
                    const localDH = JSON.parse(localStorage.getItem('dailyHistory') || '{}') || {};
                    const merged = { ...userData.daily_history, ...localDH };
                    localStorage.setItem('dailyHistory', JSON.stringify(merged));
                    console.log('✅ Daily history merged to localStorage (prefer local)');
                  } catch (_) {
                    localStorage.setItem('dailyHistory', JSON.stringify(userData.daily_history));
                    console.log('✅ Daily history synced to localStorage');
                  }
                }
              }
              if (userData.coach_messages) {
                localStorage.setItem('coachMessages', JSON.stringify(userData.coach_messages));
                console.log('✅ Coach messages synced to localStorage');
              }
              if (userData.habit_ai_advice) {
                localStorage.setItem('habitAIAdvice', userData.habit_ai_advice);
                console.log('✅ Habit AI advice synced to localStorage');
              }
              if (userData.habits) {
                localStorage.setItem('habits', JSON.stringify(userData.habits));
                console.log('✅ Habits synced to localStorage');
              }
              if (userData.subscription) {
                try { localStorage.setItem('subscriptionActive', JSON.stringify(!!userData.subscription.active)); } catch (_) {}
                try { window.dispatchEvent(new CustomEvent('subscription-status-changed', { detail: { active: !!userData.subscription.active } })); } catch (_) {}
              }
              
              // AI usage: remote-authoritative merge with local using MAX across all dates
              try {
                const remoteUsage = (userData && userData.ai_usage) ? userData.ai_usage : {};
                const localUsage = (() => { try { return JSON.parse(localStorage.getItem('aiUsage') || '{}') || {}; } catch { return {}; } })();
                const merged = {};

                // First, copy remote into merged
                Object.keys(remoteUsage || {}).forEach(date => {
                  merged[date] = { ...(remoteUsage[date] || {}) };
                });

                // Re-key 'anon' to user across all dates in local, then MAX against remote
                const uid = effectiveUser.id;
                Object.keys(localUsage || {}).forEach(date => {
                  if (!merged[date]) merged[date] = {};
                  const l = localUsage[date] || {};
                  const localAnon = Number(l['anon'] || 0);
                  const localUser = Number(l[uid] || 0);
                  const localMaxForUser = Math.max(localAnon, localUser);
                  const remoteUser = Number((merged[date] && merged[date][uid]) || 0);
                  const maxForUser = Math.max(remoteUser, localMaxForUser);
                  if (maxForUser > 0) merged[date][uid] = maxForUser;

                  // Also take MAX for any other keys present (future-proofing shared devices)
                  Object.keys(l).forEach(k => {
                    const lc = Number(l[k] || 0);
                    const rc = Number((merged[date] && merged[date][k]) || 0);
                    if (lc > rc) merged[date][k] = lc;
                  });
                });

                // Persist merged to local
                localStorage.setItem('aiUsage', JSON.stringify(merged));

                // If remote differs, write merged back to DB to make it authoritative
                const remoteStr = JSON.stringify(remoteUsage || {});
                const mergedStr = JSON.stringify(merged);
                if (remoteStr !== mergedStr) {
                  try { await db.updateUser(uid, { ai_usage: merged }); } catch (e) { console.warn('AI usage: failed to persist merged to DB', e); }
                }
                console.log('✅ AI usage merged (remote-first MAX) and persisted');
              } catch (err) {
                console.error('Error syncing AI usage:', err);
              }
              
              // Skip syncing dark_mode from remote - it's a local UI preference
              // if (userData.dark_mode !== undefined) {
              //   localStorage.setItem('fitmate-dark-mode', userData.dark_mode.toString());
              //   console.log('✅ Dark mode setting synced to localStorage');
              // }
              
              // Sync AI-generated content
              if (userData.meal_plan) {
                localStorage.setItem('mealPlan', JSON.stringify(userData.meal_plan));
                console.log('✅ Meal plan synced to localStorage');
              }
              if (userData.workout_plan) {
                localStorage.setItem('workoutPlan', JSON.stringify(userData.workout_plan));
                console.log('✅ Workout plan synced to localStorage');
              }
              // Special handling for workout_history
              if (remoteOnly) {
                try {
                  // Remote-only: fetch remote history and set locally (no merge, no local upsert)
                  const { data: remoteHistory, error: historyError } = await supabase
                    .from('workout_history')
                    .select('id, user_id, timestamp, duration, exercises_completed, total_exercises, completion_rate, type, workout_title, workout_level, incomplete')
                    .eq('user_id', effectiveUser.id)
                    .order('timestamp', { ascending: false })
                    .limit(100);

                  if (historyError) throw historyError;

                  localStorage.setItem('workoutHistory', JSON.stringify(remoteHistory || []));
                  setWorkoutHistory(remoteHistory || []);
                  console.log('🔒 Remote-only: set workout history from remote without merging');

                } catch (error) {
                  console.error('Remote-only workout history fetch failed:', error);
                }
              } else {
                try {
                  // First, get local history that hasn't been synced to Supabase
                  const localHistory = JSON.parse(localStorage.getItem('workoutHistory') || '[]');
                  
                  // If we have local history, sync it to Supabase first
                  if (localHistory.length > 0) {
                    try {
                      // Get the most recent local workout timestamp
                      const mostRecentLocal = localHistory[0]?.timestamp;
                      
                      // Find workouts that don't exist in Supabase yet
                      const { data: recentRemoteWorkouts, error: fetchError } = await supabase
                        .from('workout_history')
                        .select('timestamp')
                        .eq('user_id', effectiveUser.id)
                        .gte('timestamp', new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString()) // Last 30 days
                        .order('timestamp', { ascending: false });
                        
                      if (fetchError) throw fetchError;
                      
                      const remoteTimestamps = new Set(recentRemoteWorkouts?.map(w => w.timestamp) || []);
                      const workoutsToSync = localHistory.filter(w => w.timestamp && !remoteTimestamps.has(w.timestamp));
                      
                      // Sync any missing workouts to Supabase
                      if (workoutsToSync.length > 0) {
                        const { error: syncError } = await supabase
                          .from('workout_history')
                          .upsert(
                            workoutsToSync.map(workout => ({
                              ...workout,
                              user_id: effectiveUser.id,
                              // Ensure all required fields have default values
                              duration: workout.duration || 0,
                              calories_burned: workout.calories_burned || 0,
                              exercises_completed: workout.exercises_completed || 0,
                              workout_title: workout.workout_title || 'Custom Workout',
                              created_at: workout.timestamp || new Date().toISOString()
                            })),
                            { onConflict: 'user_id,timestamp' }
                          );
                          
                        if (syncError) throw syncError;
                        console.log(`✅ Synced ${workoutsToSync.length} local workouts to Supabase`);
                      }
                    } catch (syncError) {
                      console.error('Error syncing local workouts to Supabase:', syncError);
                    }
                  }
                  
                  // Now fetch complete history from Supabase
                  const { data: remoteHistory, error: historyError } = await supabase
                    .from('workout_history')
                    .select('id, user_id, timestamp, duration, exercises_completed, total_exercises, completion_rate, type, workout_title, workout_level, incomplete')
                    .eq('user_id', effectiveUser.id)
                    .order('timestamp', { ascending: false })
                    .limit(100); // Get more history for better sync

                  if (historyError) throw historyError;
                  
                  // If no remote history, keep local history
                  if (!remoteHistory || remoteHistory.length === 0) {
                    if (localHistory.length > 0) {
                      localStorage.setItem('workoutHistory', JSON.stringify(localHistory));
                      console.log('Using local workout history (no remote data)');
                    }
                    return;
                  }
                  
                  // If no local history, use remote
                  if (localHistory.length === 0) {
                    localStorage.setItem('workoutHistory', JSON.stringify(remoteHistory));
                    setWorkoutHistory(remoteHistory);
                    console.log('Using remote workout history (no local data)');
                    return;
                  }
                  
                  // Merge both histories, preferring remote data in case of conflicts
                  const historyMap = new Map();
                  
                  // Add remote workouts to map first (lower priority)
                  remoteHistory.forEach(workout => {
                    if (workout.timestamp) {
                      historyMap.set(workout.timestamp, workout);
                    }
                  });
                  
                  // Add local workouts (will only add if timestamp doesn't exist in remote)
                  localHistory.forEach(workout => {
                    if (workout.timestamp && !historyMap.has(workout.timestamp)) {
                      historyMap.set(workout.timestamp, workout);
                    }
                  });

                  // Convert map back to array and sort by timestamp
                  let mergedHistory = Array.from(historyMap.values())
                    .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))
                    .slice(0, 100); // Keep most recent 100 workouts

                  // Save merged history
                  localStorage.setItem('workoutHistory', JSON.stringify(mergedHistory));
                  setWorkoutHistory(mergedHistory);
                  console.log(`✅ Workout history synced: ${mergedHistory.length} workouts`);
                  
                } catch (error) {
                  console.error('Error syncing workout history:', error);
                  // If sync fails, keep using local history
                  const localHistory = JSON.parse(localStorage.getItem('workoutHistory') || '[]');
                  setWorkoutHistory(localHistory);
                }
              }

              if (userData.scan_result) {
                localStorage.setItem('scanResult', JSON.stringify(userData.scan_result));
                console.log('✅ Scan result synced to localStorage');
              }
              if (userData.form_analysis) {
                localStorage.setItem('formAnalysis', JSON.stringify(userData.form_analysis));
                console.log('✅ Form analysis synced to localStorage');
              }
              
              // Update local sync timestamp
              localStorage.setItem('lastSyncTimestamp', remoteLastSync.toString());
              
              console.log('✅ All remote data synced to local storage');
              
              // Directly notify UI to hydrate from fresh remote payload (no manual refresh)
              try {
                localStorage.setItem('pendingHydratePayload', JSON.stringify(userData));
                if (window.fitmateHydrateFromRemote) window.fitmateHydrateFromRemote(userData);
              } catch (_) {}

              // Trigger UI refresh and mark remote applied (with retries for late listeners)
              console.log('📡 Dispatching userDataSynced and remoteDataApplied events...');
              try { localStorage.setItem('pendingUserDataSynced', '1'); } catch (_) {}
              window.dispatchEvent(new CustomEvent('userDataSynced', { detail: { userData } }));
              window.dispatchEvent(new CustomEvent('remoteDataApplied', { detail: { userData } }));
              // Re-dispatch after short delays to catch listeners that mount slightly later
              setTimeout(() => {
                try { window.dispatchEvent(new CustomEvent('userDataSynced', { detail: { userData } })); } catch (_) {}
              }, 300);
              setTimeout(() => {
                try { window.dispatchEvent(new CustomEvent('userDataSynced', { detail: { userData } })); } catch (_) {}
                try { localStorage.removeItem('pendingUserDataSynced'); } catch (_) {}
              }, 800);
              setTimeout(() => {
                try { window.dispatchEvent(new CustomEvent('userDataSynced', { detail: { userData } })); } catch (_) {}
              }, 1500);
            } else {
              if (remoteOnly) {
                console.log('🔒 Remote-only mode active; skipping local-to-remote sync.');
              } else {
                // Only push if local is truly newer (timestamp comparison) and has meaningful content
                if (hasLocalData && localLastSyncTs > remoteLastSyncTs) {
                  console.log('📤 Local data is newer (timestamp), syncing to remote');
                  await syncAllDataToSupabase();
                  console.log('✅ Local data synced to remote successfully');
                } else {
                  console.log('⚠️ Skipping local->remote push to avoid overwriting newer/authoritative remote data');
                }
              }
            }
          } else {
            if (remoteOnly) {
              console.log('🔒 Remote-only mode: remote profile missing; not creating from local on sign-in.');
            } else {
              console.log('No user document found, creating new one');
              // Create comprehensive initial user document
              await createInitialUserDocument(effectiveUser);
            }
          }
        } catch (error) {
          if (error.code === 'PERMISSION_DENIED') {
            console.log('Realtime Database access denied - using local storage only');
          } else if (error.message && error.message.includes('NetworkError')) {
            console.log('🌐 Network error during sync - will retry on next user action');
            // Retry logic for network errors
            if (retryCount < 2) {
              console.log(`🔄 Retrying sync (attempt ${retryCount + 1}/3)...`);
              setTimeout(() => {
                syncUserData(effectiveUser, retryCount + 1);
              }, 2000 * (retryCount + 1)); // Exponential backoff
            }
          } else {
            console.error('Error syncing user data:', error);
          }
        } finally {
          // Reset remote-only mode after one sync cycle
          if (forceNextRemoteOnlyRef?.current) {
            forceNextRemoteOnlyRef.current = false;
          }
        }
      };

      const signUp = async (email, password, displayName) => {
        if (!auth) throw new Error('Supabase Authentication not available');
        
        setAuthError(null);
        
        // Validate password strength
        const passwordValidation = validatePassword(password);
        if (!passwordValidation.isValid) {
          setAuthError(passwordValidation.message);
          throw new Error(passwordValidation.message);
        }
        
        try {
          const { data, error } = await auth.signUp({
            email,
            password,
            options: {
              data: {
                display_name: displayName
              }
            }
          });
          
          if (error) throw error;
          
          // Wait a moment for the user to be fully authenticated
          setTimeout(async () => {
            if (supabase && data.user) {
              try {
                // Ensure we have a valid session before creating user document
                const { data: { session } } = await auth.getSession();
                if (session?.user) {
                  await createInitialUserDocument(data.user);
                  console.log('✅ Initial user document created from local storage (sign-up)');
                } else {
                  console.log('⏳ User not fully authenticated yet, will retry later');
                }
              } catch (dbError) {
                console.warn('⚠️ Could not create user document in Supabase Database:', dbError.message);
                // Continue without Database - user can still use the app
              }
            } else {
              console.log('📱 Account created successfully (local mode)');
            }
          }, 1000); // Wait 1 second for authentication to complete
          
          return data.user;
        } catch (error) {
          let friendlyMessage = error.message;
          
          // Provide user-friendly error messages
          if (error.message?.includes('already registered')) {
            friendlyMessage = 'This email is already registered. Try signing in instead.';
          } else if (error.message?.includes('Password should be at least')) {
            friendlyMessage = 'Password is too weak. Please use at least 6 characters.';
          } else if (error.message?.includes('Invalid email')) {
            friendlyMessage = 'Please enter a valid email address.';
          }
          
          setAuthError(friendlyMessage);
          throw new Error(friendlyMessage);
        }
      };

      const signIn = async (email, password) => {
        if (!auth) throw new Error('Supabase Authentication not available');
        
        setAuthError(null);
        try {
          const { data, error } = await auth.signInWithPassword({
            email,
            password
          });
          
          if (error) throw error;
          
          console.log('✅ User signed in successfully');
          // Enforce remote-only fetch for this sign-in so local data cannot overwrite remote
          try { localStorage.removeItem('lastSyncTimestamp'); } catch (_) {}
          try { forceNextRemoteOnlyRef.current = true; } catch (_) {}
          // DO NOT clear aiUsage on sign-in - use handshake to sync MAX value across devices
          // Trigger immediate remote fetch (onAuthStateChange will also call this, this is safe)
          try { await syncUserData(data.user); } catch (_) {}
          return data.user;
        } catch (error) {
          let friendlyMessage = error.message;
          
          // Provide user-friendly error messages
          if (error.message?.includes('Invalid login credentials')) {
            friendlyMessage = 'Invalid email or password. Please check your credentials and try again.';
          } else if (error.message?.includes('Email not confirmed')) {
            friendlyMessage = 'Please check your email and confirm your account before signing in.';
          } else if (error.message?.includes('Invalid email')) {
            friendlyMessage = 'Please enter a valid email address.';
          } else if (error.message?.includes('Too many requests')) {
            friendlyMessage = 'Too many failed attempts. Please try again later.';
          }
          
          setAuthError(friendlyMessage);
          throw new Error(friendlyMessage);
        }
      };

      const signOut = async () => {
        if (!auth) return true; // If no auth, consider it a success
        
        try {
          // First try to sign out properly
          try {
            const { error } = await auth.signOut();
            if (error) throw error;
          } catch (signOutError) {
            // If the session is already invalid on server, proceed with local cleanup
            const msg = signOutError?.message || '';
            if (
              msg.includes('Auth session missing') ||
              msg.includes('Invalid Refresh Token') ||
              msg.includes('Forbidden') ||
              msg.includes('403')
            ) {
              console.log('Session already invalidated on server, proceeding with local cleanup');
            } else {
              throw signOutError; // Re-throw other errors
            }
          }
          
          // Ensure local sign-out and purge cached tokens so UI updates immediately
          try {
            await auth.signOut({ scope: 'local' });
          } catch (_) {
            // ignore
          }

          // Reset subscription and quota local flags on sign-out so UI reflects anon state
          try { localStorage.setItem('subscriptionActive', JSON.stringify(false)); } catch (_) {}
          try { window.dispatchEvent(new CustomEvent('subscription-status-changed', { detail: { active: false } })); } catch (_) {}
          try { window.dispatchEvent(new CustomEvent('ads-control', { detail: { enabled: true } })); } catch (_) {}
          try { localStorage.removeItem('aiUsage'); } catch (_) {}
          try { window.dispatchEvent(new Event('userDataSynced')); } catch (_) {}

          // Clear Supabase v2 auth cache keys (sb-<projectRef>-auth-token) plus legacy key
          try {
            const projectRef = new URL(supabaseConfig.url).host.split('.')[0];
            const prefixes = [
              `sb-${projectRef}-auth-token`,
              'sb-' // fallback in case projectRef parsing fails
            ];
            [localStorage, sessionStorage].forEach((store) => {
              for (let i = store.length - 1; i >= 0; i--) {
                const key = store.key(i);
                if (key && prefixes.some(p => key.startsWith(p))) {
                  store.removeItem(key);
                }
              }
            });
          } catch (_) {
            // ignore
          }

          // Clear any legacy local tokens/storage
          localStorage.removeItem('supabase.auth.token');
          sessionStorage.removeItem('supabase.auth.token');
          
          // Immediately reflect sign-out in UI to avoid requiring a second click
          try { setUser(null); } catch (_) { /* no-op */ }

          return true;
        } catch (error) {
          console.error('Error during sign out:', error);
          const errorMessage = error.message || 'Failed to sign out';
          setAuthError(errorMessage);
          throw new Error(errorMessage);
        }
      };

      const resetPassword = async (email) => {
        if (!auth) throw new Error('Supabase Authentication not available');
        
        setAuthError(null);
        try {
          const { error } = await auth.resetPasswordForEmail(email, {
            redirectTo: 'https://fitnessmate.netlify.app/?type=recovery'
          });
          if (error) throw error;
          return true;
        } catch (error) {
          let friendlyMessage = error.message;
          
          if (error.message?.includes('User not found')) {
            friendlyMessage = 'No account found with this email address.';
          } else if (error.message?.includes('Invalid email')) {
            friendlyMessage = 'Please enter a valid email address.';
          }
          
          setAuthError(friendlyMessage);
          throw new Error(friendlyMessage);
        }
      };

      const validatePassword = (password) => {
        const minLength = 8;
        const hasUpperCase = /[A-Z]/.test(password);
        const hasLowerCase = /[a-z]/.test(password);
        const hasNumbers = /\d/.test(password);
        const hasSpecialChar = /[!@#$%^&*(),.?":{}|<>]/.test(password);
        
        const errors = [];
        
        if (password.length < minLength) {
          errors.push(`At least ${minLength} characters`);
        }
        if (!hasUpperCase) {
          errors.push('One uppercase letter');
        }
        if (!hasLowerCase) {
          errors.push('One lowercase letter');
        }
        if (!hasNumbers) {
          errors.push('One number');
        }
        if (!hasSpecialChar) {
          errors.push('One special character (!@#$%^&*)');
        }
        
        return {
          isValid: errors.length === 0,
          message: errors.length > 0 ? `Password must contain: ${errors.join(', ')}` : 'Password is valid',
          errors: errors
        };
      };

      // Write coalescing queue to serialize Supabase updates and handle timeouts safely
      let userUpdateQueue = {
        inFlight: false,
        pending: null,
        resolvers: [],
        backoffMs: 0,
        flushTimer: null,
      };

      const mergeUserUpdatePayloads = (base, add) => {
        const a = base || {};
        const b = add || {};
        const result = { ...a };
        for (const [k, v] of Object.entries(b)) {
          if (
            v && typeof v === 'object' && !Array.isArray(v) &&
            result[k] && typeof result[k] === 'object' && !Array.isArray(result[k])
          ) {
            // shallow merge nested objects to avoid overwriting entire JSONB fields
            result[k] = { ...result[k], ...v };
          } else {
            result[k] = v;
          }
        }
        return result;
      };

      const flushUserUpdate = async (userId) => {
        if (userUpdateQueue.inFlight || !userUpdateQueue.pending) return;
        userUpdateQueue.inFlight = true;
        const payload = userUpdateQueue.pending;
        userUpdateQueue.pending = null;
        try {
          await db.updateUser(userId, payload);
          const resolvers = userUpdateQueue.resolvers;
          userUpdateQueue.resolvers = [];
          userUpdateQueue.backoffMs = 0;
          userUpdateQueue.inFlight = false;
          resolvers.forEach(fn => fn());
        } catch (err) {
          // Handle statement timeout: retry with exponential backoff, do NOT create doc here
          const msg = (err && err.message || '').toLowerCase();
          if (err && (err.code === '57014' || msg.includes('statement timeout'))) {
            userUpdateQueue.inFlight = false;
            userUpdateQueue.pending = mergeUserUpdatePayloads(userUpdateQueue.pending, payload) || payload;
            userUpdateQueue.backoffMs = Math.min(userUpdateQueue.backoffMs ? userUpdateQueue.backoffMs * 2 : 2000, 8000);
            if (userUpdateQueue.flushTimer) clearTimeout(userUpdateQueue.flushTimer);
            userUpdateQueue.flushTimer = setTimeout(() => flushUserUpdate(userId), userUpdateQueue.backoffMs);
            return;
          }
          // Handle not found: create initial document then retry once
          if (err && err.code === 'PGRST116') {
            try { await createInitialUserDocument(user); } catch (e) { console.warn('createInitialUserDocument failed:', e); }
            userUpdateQueue.inFlight = false;
            if (userUpdateQueue.flushTimer) clearTimeout(userUpdateQueue.flushTimer);
            userUpdateQueue.flushTimer = setTimeout(() => flushUserUpdate(userId), 250);
            return;
          }
          // Propagate other errors to callers to preserve behavior
          const resolvers = userUpdateQueue.resolvers;
          userUpdateQueue.resolvers = [];
          userUpdateQueue.inFlight = false;
          resolvers.forEach(fn => fn(err));
        }
      };

      const scheduleUserUpdateFlush = (userId) => {
        if (userUpdateQueue.flushTimer) clearTimeout(userUpdateQueue.flushTimer);
        // Debounce flush to coalesce bursts of updates
        userUpdateQueue.flushTimer = setTimeout(() => flushUserUpdate(userId), 1000);
      };

      const queueUserUpdate = (userId, update) => {
        userUpdateQueue.pending = mergeUserUpdatePayloads(userUpdateQueue.pending, update);
        return new Promise((resolve, reject) => {
          userUpdateQueue.resolvers.push((err) => err ? reject(err) : resolve());
          if (!userUpdateQueue.inFlight) scheduleUserUpdateFlush(userId);
        });
      };

      const updateUserData = async (data) => {
        if (!user) {
          console.log('No user signed in');
          return;
        }
        
        if (!supabase) {
          console.log('Supabase Database not available, data saved locally only');
          return;
        }
        // Prevent writes during remote-only sign-in fetch
        if (forceNextRemoteOnlyRef?.current) {
          console.log('🔒 Remote-only mode active: skipping updateUserData to avoid overwriting remote during sign-in');
          return;
        }
        // Block any writes until initial remote has been applied to this device
        if (!authInitialRemoteAppliedRef.current) {
          console.log('⏸️ Skipping updateUserData until initial remote sync completes (AuthProvider)');
          return;
        }
        
        try {
          const currentTimestamp = new Date().toISOString();

          // Build payload and guard against overwriting valid remote intake with local defaults on fresh devices
          let payload = { ...data };
          if (payload && typeof payload === 'object' && 'daily_intake' in payload) {
            const localIntake = payload.daily_intake || {};
            const isLocalDefault = Object.values(localIntake).every(v => Number(v) === 0);
            const localSyncTs = parseInt(localStorage.getItem('lastSyncTimestamp') || '0');
            try {
              const remote = await db.getUser(user.id);
              const remoteIntake = remote?.daily_intake || {};
              const remoteHasNonZero = Object.values(remoteIntake).some(v => Number(v) > 0);
              if (localSyncTs === 0 && isLocalDefault && remoteHasNonZero) {
                // Skip overwriting remote with zeros
                delete payload.daily_intake;
              } else {
                // CRITICAL: Never import activity from remote; only explicit local logging allowed
                payload.daily_intake = { ...localIntake, activity: Number(localIntake.activity || 0) };
              }
            } catch (cmpErr) {
              console.warn('Safe-guard compare failed, proceeding:', cmpErr);
            }
          }

          if (Object.keys(payload).length === 0) {
            console.log('⏭️ Skipping update to avoid overwriting remote with defaults on fresh device');
            return;
          }

          await queueUserUpdate(user.id, {
            ...payload,
            updated_at: new Date().toISOString()
          });
          
          // Update local sync timestamp
          localStorage.setItem('lastSyncTimestamp', Date.now().toString());
          
          console.log('✅ User data updated in Supabase Database with timestamp:', currentTimestamp);
        } catch (error) {
          console.error('Error updating user data:', error);
          console.error('Error details:', {
            message: error.message,
            code: error.code,
            details: error.details,
            hint: error.hint
          });
          // Avoid creating user document here on timeouts; queue handles not-found and backoff.
        }
      };


      // Debounced auto-sync function to prevent excessive syncing
      let autoSyncTimeout = null;
      const triggerAutoSync = () => {
        if (!user || !db) return;
        // Do not auto-sync while in remote-only sign-in phase
        if (forceNextRemoteOnlyRef?.current) {
          console.log('⏸️ Auto-sync skipped (remote-only sign-in in progress)');
          return;
        }
        
        // Clear existing timeout
        if (autoSyncTimeout) {
          clearTimeout(autoSyncTimeout);
        }
        
        // Set new timeout for 2 seconds
        autoSyncTimeout = setTimeout(async () => {
          try {
            console.log('🔄 Auto-sync triggered');
            await syncUserData(user);
          } catch (error) {
            console.error('Auto-sync failed:', error);
          }
        }, 2000);
      };

      // Enhanced localStorage setter with auto-sync trigger and quota management
      // Safe setter that auto-cleans once and retries when quota is exceeded
      const setLocalStorageWithSync = (key, value) => {
        try {
          localStorage.setItem(key, value);
        } catch (error) {
          if (error && (error.name === 'QuotaExceededError' || error.name === 'NS_ERROR_DOM_QUOTA_REACHED')) {
            console.warn('⚠️ LocalStorage full — cleaning up and retrying...');
            cleanupLocalStorage();
            try {
              localStorage.setItem(key, value);
            } catch (retryError) {
              console.error('Failed to store data even after cleanup:', retryError);
              // Avoid storing heavy images if still failing
              if (key.includes('imagePreview') || key === 'profilePicture') {
                console.warn('Skipping image storage due to quota limits');
                return;
              }
              throw retryError;
            }
          } else {
            throw error;
          }
        }
        
        // Skip auto-sync for UI-only keys that don't need server sync
        const uiOnlyKeys = [
          'workoutPlanner_activeTab',
          'mealPlanner_activeTab',
          'progress_activeTab',
          'fitmate-current-screen',
          'fitmate-dark-mode',
          'lastSavedDate',
          'completedWorkoutIndex'
        ];
        const shouldSkipSync = uiOnlyKeys.some(prefix => key.startsWith(prefix) || key === prefix);
        if (!shouldSkipSync) {
          triggerAutoSync();
        }
      };
      if (typeof window !== 'undefined') { window.setLocalStorageWithSync = setLocalStorageWithSync; }

      // Clean up localStorage to free space
      const cleanupLocalStorage = () => {
        const keysToClean = [
          'pantryChef_imagePreview',
          'menuDecoder_imagePreview',
          'pantryChef_ingredients',
          'pantryChef_recipes',
          'menuDecoder_menuItems',
          'menuDecoder_recommendations',
          'dailyQuote',
          'lastQuoteFetchDate'
        ];
        
        // Remove image previews first (largest items)
        keysToClean.forEach(key => {
          try {
            localStorage.removeItem(key);
            console.log(`Cleaned up localStorage key: ${key}`);
          } catch (e) {
            console.warn(`Failed to remove ${key}:`, e);
          }
        });
        
        // Clean up old cache entries
        Object.keys(localStorage).forEach(key => {
          if (key.startsWith('fitmate-slots-') && key !== `fitmate-slots-${new Date().toISOString().split('T')[0]}`) {
            try {
              localStorage.removeItem(key);
              console.log(`Cleaned up old cache: ${key}`);
            } catch (e) {
              console.warn(`Failed to remove cache ${key}:`, e);
            }
          }
        });
      };

      const checkLocalStorageUsage = () => {
        let totalSize = 0;
        const usage = {};
        try {
          for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (!key) continue;
            const size = (localStorage.getItem(key) || '').length;
            totalSize += size;
            usage[key] = size;
          }
        } catch (_) {}
        if (totalSize > 4 * 1024 * 1024) {
          if (!window.__fitmateAutoCleaned) {
            try { cleanupLocalStorage(); } catch (_) {}
            window.__fitmateAutoCleaned = true;
          }
        }
        return { totalSize, usage };
      };

      // Check usage periodically (once) at a lower frequency to reduce console noise
      if (!window.__fitmateLSUsageInterval) {
        window.__fitmateLSUsageInterval = setInterval(checkLocalStorageUsage, 300000); // every 5 minutes
      }

      // Real-time listener for cross-device sync (using Supabase subscriptions)
      React.useEffect(() => {
        if (!user || !supabase || !USERS_REALTIME_ENABLED) return;
        
        console.log('🔗 Setting up real-time sync listener for user:', user.id);
        
        const subscription = db.subscribe('users', (payload) => {
          if (payload.new && payload.new.id === user.id) {
            const remoteData = payload.new;
            const remoteTimestamp = remoteData.updated_at ? new Date(remoteData.updated_at).getTime() : 0;
            const localTimestamp = parseInt(localStorage.getItem('lastSyncTimestamp') || '0');
            
            // Only sync if remote data is newer than local
            if (remoteTimestamp > localTimestamp) {
              console.log('🔄 Real-time sync: Remote data is newer, updating local data');
              
              // Update localStorage silently (without triggering auto-sync)
              if (remoteData.goals) localStorage.setItem('goals', JSON.stringify(remoteData.goals));
              if (remoteData.profile_picture) localStorage.setItem('profilePicture', remoteData.profile_picture);
              if (remoteData.notifications_enabled !== undefined) localStorage.setItem('notificationsEnabled', JSON.stringify(remoteData.notifications_enabled));
              // Subscription status from backend (Stripe/Play)
              if (remoteData.subscription) {
                try { localStorage.setItem('subscriptionActive', JSON.stringify(!!remoteData.subscription.active)); } catch (_) {}
                try { window.dispatchEvent(new CustomEvent('subscription-status-changed', { detail: { active: !!remoteData.subscription.active } })); } catch (_) {}
              }
              // Skip syncing dark_mode from remote - it's a local UI preference
              if (remoteData.daily_intake) {
                try {
                  const todayISO = toLocalISODate(new Date());
                  const remoteUpdateIsToday = !!remoteTimestamp && toLocalISODate(new Date(remoteTimestamp)) === todayISO;
                  if (!remoteUpdateIsToday) {
                    console.log('⏭️ Realtime(sub): skipping remote daily_intake (updated_at not today)');
                  } else {
                    const localIntakeDate = localStorage.getItem('dailyIntakeDate');
                    const lastSaved = localStorage.getItem('lastSavedDate');
                    const rolledToToday = (localIntakeDate === todayISO && lastSaved === todayISO);
                    const currentLocal = (() => { try { return JSON.parse(localStorage.getItem('dailyIntake') || '{}') || {}; } catch { return {}; } })();
                    const localIsZero = ['calories','protein','carbs','fat','activity','water'].every(k => Number(currentLocal[k]||0) === 0);
                    const remoteHasNonZero = ['calories','protein','carbs','fat','activity','water'].some(k => Number(remoteData.daily_intake?.[k]||0) > 0);
                    const localMeals = (() => { try { return JSON.parse(localStorage.getItem('recentMeals') || '[]') || []; } catch { return []; } })();
                    const localHasStarted = !localIsZero || (Array.isArray(localMeals) && localMeals.length > 0);
                    if (rolledToToday && !localHasStarted && remoteHasNonZero) {
                      console.log('⏭️ Realtime(sub): skipping remote daily_intake until local day start');
                    } else {
                      const merged = { ...remoteData.daily_intake, activity: Number(remoteData.daily_intake?.activity || 0) };
                      localStorage.setItem('dailyIntake', JSON.stringify(merged));
                      console.log('✅ Realtime(sub): daily_intake synced (activity remote-only)');
                    }
                  }
                } catch (_) {
                  console.log('⚠️ Realtime(sub): intake merge failed; leaving local untouched');
                }
              }
              if (remoteData.recent_meals) {
                try {
                  const todayISO = toLocalISODate(new Date());
                  const remoteUpdateIsToday = !!remoteTimestamp && toLocalISODate(new Date(remoteTimestamp)) === todayISO;
                  if (!remoteUpdateIsToday) {
                    console.log('⏭️ Realtime(sub): skipping remote recent_meals (updated_at not today)');
                  } else {
                    const localIntakeDate = localStorage.getItem('dailyIntakeDate');
                    const lastSaved = localStorage.getItem('lastSavedDate');
                    const rolledToToday = (localIntakeDate === todayISO && lastSaved === todayISO);
                    const localMeals = (() => { try { return JSON.parse(localStorage.getItem('recentMeals') || '[]') || []; } catch { return []; } })();
                    const localIsEmpty = !Array.isArray(localMeals) || localMeals.length === 0;
                    const remoteHasMeals = Array.isArray(remoteData.recent_meals) && remoteData.recent_meals.length > 0;
                    const resetAt = parseInt(localStorage.getItem('midnightResetAt') || '0');
                    const remoteOlderThanReset = resetAt && remoteTimestamp && (remoteTimestamp <= resetAt);
                    if (rolledToToday && localIsEmpty && remoteHasMeals && remoteOlderThanReset) {
                      console.log('⏭️ Realtime(sub): skipping remote recent_meals to avoid post-rollover flicker');
                    } else {
                      localStorage.setItem('recentMeals', JSON.stringify(remoteData.recent_meals));
                    }
                  }
                } catch (_) {
                  localStorage.setItem('recentMeals', JSON.stringify(remoteData.recent_meals));
                }
              }
              if (remoteData.daily_history) {
                try {
                  const localDH = JSON.parse(localStorage.getItem('dailyHistory') || '{}') || {};
                  const merged = { ...remoteData.daily_history, ...localDH };
                  localStorage.setItem('dailyHistory', JSON.stringify(merged));
                } catch (_) {
                  localStorage.setItem('dailyHistory', JSON.stringify(remoteData.daily_history));
                }
              }
              if (remoteData.coach_messages) localStorage.setItem('coachMessages', JSON.stringify(remoteData.coach_messages));
              if (remoteData.habit_ai_advice) localStorage.setItem('habitAIAdvice', remoteData.habit_ai_advice);
              if (remoteData.habits) localStorage.setItem('habits', JSON.stringify(remoteData.habits));
              if (remoteData.meal_plan) localStorage.setItem('mealPlan', JSON.stringify(remoteData.meal_plan));
              if (remoteData.workout_plan) localStorage.setItem('workoutPlan', JSON.stringify(remoteData.workout_plan));
              // workout_history is handled by separate table, not synced here
              if (remoteData.scan_result) localStorage.setItem('scanResult', JSON.stringify(remoteData.scan_result));
              if (remoteData.form_analysis) localStorage.setItem('formAnalysis', JSON.stringify(remoteData.form_analysis));
              // AI usage: merge remote with local using MAX to prevent overwrites
              if (remoteData.ai_usage) {
                try {
                  const remoteUsage = remoteData.ai_usage || {};
                  const localUsage = JSON.parse(localStorage.getItem('aiUsage') || '{}') || {};
                  const merged = { ...localUsage };
                  Object.keys(remoteUsage).forEach(date => {
                    if (!merged[date]) merged[date] = {};
                    Object.keys(remoteUsage[date]).forEach(uid => {
                      const remoteCount = Number(remoteUsage[date][uid] || 0);
                      const localCount = Number(merged[date][uid] || 0);
                      merged[date][uid] = Math.max(remoteCount, localCount);
                    });
                  });
                  localStorage.setItem('aiUsage', JSON.stringify(merged));
                  window.dispatchEvent(new CustomEvent('userDataSynced'));
                  console.log('✅ Real-time: AI usage merged from remote (MAX)');
                } catch (e) {
                  console.warn('Realtime AI usage merge failed:', e);
                }
              }
              
              // Update local sync timestamp
              localStorage.setItem('lastSyncTimestamp', remoteTimestamp.toString());
              
              // Dispatch event to update React components
              window.dispatchEvent(new CustomEvent('userDataSynced'));
              
              console.log('✅ Real-time sync completed');
            }
          }
        }, { filter: `id=eq.${user.id}` });
        
        // Cleanup subscription on unmount or user change
        return () => {
          console.log('🔌 Removing real-time sync listener');
          subscription.unsubscribe();
        };
      }, [user, supabase]);

      const syncAllDataToSupabase = async () => {
        if (!user || !supabase) return;
        // Prevent bulk push during remote-only sign-in fetch
        if (forceNextRemoteOnlyRef?.current) {
          console.log('🔒 Remote-only mode active: skipping syncAllDataToSupabase during sign-in');
          return;
        }
        // Also block until initial remote applied
        if (!authInitialRemoteAppliedRef?.current) {
          console.log('⏸️ Skipping syncAllDataToSupabase until initial remote sync completes');
          return;
        }
        
        try {
          const currentTimestamp = new Date().toISOString();
          const allLocalData = {
            goals: JSON.parse(localStorage.getItem('goals') || '{}'),
            // profile_picture intentionally excluded in remote-only mode to avoid overwriting remote data,
            notifications_enabled: JSON.parse(localStorage.getItem('notificationsEnabled') || 'true'),
            daily_intake: JSON.parse(localStorage.getItem('dailyIntake') || '{}'),
            recent_meals: JSON.parse(localStorage.getItem('recentMeals') || '[]'),
            daily_history: JSON.parse(localStorage.getItem('dailyHistory') || '{}'),
            coach_messages: JSON.parse(localStorage.getItem('coachMessages') || '[]'),
            habit_ai_advice: localStorage.getItem('habitAIAdvice') || '',
            habits: JSON.parse(localStorage.getItem('habits') || '[]'),
            dark_mode: JSON.parse(localStorage.getItem('fitmate-dark-mode') || 'false'),
            meal_plan: JSON.parse(localStorage.getItem('mealPlan') || 'null'),
            workout_plan: JSON.parse(localStorage.getItem('workoutPlan') || 'null'),
            // workout_history: JSON.parse(localStorage.getItem('workoutHistory') || '[]'), // Removed - using separate table
            scan_result: JSON.parse(localStorage.getItem('scanResult') || 'null'),
            form_analysis: JSON.parse(localStorage.getItem('formAnalysis') || 'null'),
            updated_at: currentTimestamp
          };
          
          await queueUserUpdate(user.id, allLocalData);
          
          // Update local sync timestamp to match what we just sent
          localStorage.setItem('lastSyncTimestamp', Date.now().toString());
          
          console.log('✅ All local data queued for Supabase update with timestamp:', currentTimestamp);
        } catch (error) {
          console.error('Error syncing all data to Supabase Database:', error);
          throw error; // Re-throw to handle in calling function
        }
      };

      // Sync daily intake data
      const syncDailyIntake = async (dailyIntake) => {
        if (user && supabase) {
          try {
            await updateUserData({ 
              daily_intake: dailyIntake
            });
          } catch (error) {
            console.error('Error syncing daily intake:', error);
          }
        }
      };

      // Sync meals data
      const syncMealsData = async (recentMeals) => {
        if (user && supabase) {
          try {
            await updateUserData({ 
              recent_meals: recentMeals
            });
          } catch (error) {
            console.error('Error syncing meals data:', error);
          }
        }
      };

      // Sync daily history
      const syncDailyHistory = async (dailyHistory) => {
        if (user && supabase) {
          try {
            await updateUserData({ 
              daily_history: dailyHistory
            });
          } catch (error) {
            console.error('Error syncing daily history:', error);
          }
        }
      };

      // Sync AI-generated content
      const syncAIContent = async (contentType, content) => {
        if (user && supabase) {
          try {
            // Convert camelCase to snake_case for database storage
            const dbContentType = contentType.replace(/([A-Z])/g, '_$1').toLowerCase();
            await updateUserData({ 
              [dbContentType]: content
              // Removed last_*_update fields as they don't exist in schema
            });
          } catch (error) {
            console.error(`Error syncing ${contentType}:`, error);
          }
        }
      };

      const value = {
        user,
        loading,
        authError,
        signUp,
        signIn,
        signOut,
        resetPassword,
        validatePassword,
        updateUserData,
        syncUserData,
        syncAllDataToSupabase,
        syncDailyIntake,
        syncMealsData,
        syncDailyHistory,
        syncAIContent,
        triggerAutoSync,
        setLocalStorageWithSync,
        setAuthError,
        forceNextRemoteOnlyRef,
        authInitialRemoteAppliedRef
      };

      return (
        <AuthContext.Provider value={value}>
          {children}
        </AuthContext.Provider>
      );
    };

    const useAuth = () => {
      const context = React.useContext(AuthContext);
      if (!context) {
        throw new Error('useAuth must be used within an AuthProvider');
      }
      return context;
    };

    // --- Centralized API Configuration ---
    // Edge function endpoint
    const NETLIFY_API_URL = '/api/myapi';
    
    // Removed deprecated Gemini simple config and GEMINI_API_URL (migrated to OpenRouter)
    
    // Direct OpenRouter API (ChatGPT 4 Mini) with obfuscated key
    const OPENROUTER_QWEN_MODEL = 'google/gemini-2.5-flash'; // text-only
    const OPENROUTER_QWEN_VL_MODEL = "google/gemini-2.5-flash"
    const getDirectGeminiConfig = () => {
      return {
        url: 'https://fitserver-k7r4.onrender.com/api/myapi',
        headers: {
          'Content-Type': 'application/json',
          'X-Title': 'Fitmate',
          'HTTP-Referer': (typeof window !== 'undefined' && window.location ? window.location.origin : 'http://localhost')
        }
      };
    };
    
    // Feature flag: hide manual cloud sync UI (auto-sync is active)
    const SHOW_MANUAL_CLOUD_SYNC = false;
    (function(){const installLimiter=()=>{if(window.__aiLimiterInstalled)return;const aiUrl=getDirectGeminiConfig().url;const orig=window.fetch.bind(window);window.fetch=async (input,init={})=>{try{const reqUrl=typeof input==='string'?input:((input&&input.url)||'');const method=(init&&init.method)?String(init.method).toUpperCase():'GET';const isAI=(reqUrl===aiUrl&&method==='POST');if(!isAI){return orig(input,init);}let hdrs=(init&&init.headers)||null;let ignore=false;try{if(hdrs&&typeof hdrs.get==='function'){ignore=!!hdrs.get('X-Fitmate-Ignore-Quota');}else if(hdrs&&typeof hdrs==='object'){ignore=!!(hdrs['X-Fitmate-Ignore-Quota']||hdrs['x-fitmate-ignore-quota']);}}catch(_){}if(ignore){return orig(input,init);}let uid=null;try{if(auth&&auth.getSession){const { data:{ session } }=await auth.getSession();uid=session&&session.user?session.user.id:null;}}catch(_){}const todayISO=(typeof toLocalISODate==='function'?toLocalISODate(new Date()):new Date().toISOString().slice(0,10));let usage={};try{usage=JSON.parse(localStorage.getItem('aiUsage')||'{}')||{};}catch(_){}if(!usage[todayISO])usage[todayISO]={};const key=uid||'anon';let subscribed=false;try{subscribed=JSON.parse(localStorage.getItem('subscriptionActive')||'false');}catch(_){}const limit=subscribed?10:(uid?5:3);const count=Number(usage[todayISO][key]||0);if(count>=limit){try{if(uid){window.dispatchEvent(new Event('force-open-subscription-modal'));}else{window.dispatchEvent(new CustomEvent('ai-quota-exceeded',{detail:{key,limit}}));}}catch(_){}return new Response(JSON.stringify({error:'quota_exceeded'}),{status:429,headers:{'Content-Type':'application/json'}});}usage[todayISO][key]=count+1;try{localStorage.setItem('aiUsage',JSON.stringify(usage));
            try {
              // Sync AI usage to database immediately after incrementing
              if (uid && typeof supabase !== 'undefined' && typeof db !== 'undefined' && db.updateUser) {
                try {
                  // Debounce updates to avoid hammering the database
                  if (window.__aiUsageSyncTimeout) clearTimeout(window.__aiUsageSyncTimeout);
                  window.__aiUsageSyncTimeout = setTimeout(async () => {
                    try {
                      await db.updateUser(uid, { ai_usage: usage });
                      console.log('✅ AI usage synced to database:', usage[todayISO]);
                    } catch (err) {
                      console.error('Failed to sync AI usage to database:', err);
                    }
                  }, 500);
                } catch(e) { 
                  console.error('AI limiter: Failed to schedule database sync:', e);
                }
              }
            } catch(e) { console.error('AI limiter: Database sync error:', e); }}
            catch(_){}return orig(input,init);}catch(_){return orig(input,init);}};window.__aiLimiterInstalled=true;};installLimiter();})();

    (function(){
      if (window.__iapSetupInstalled) return;
      window.__iapSetupInstalled = true;

      const PRODUCT_ID = 'fitmate_monthly_149'; // configure in Play Console
      const BILLING_METHOD = 'https://play.google.com/billing';

      const setSubActive = (active) => {
        try { localStorage.setItem('subscriptionActive', JSON.stringify(!!active)); } catch(_) {}
        try { window.dispatchEvent(new CustomEvent('subscription-status-changed', { detail: { active: !!active } })); } catch(_) {}
        try { window.dispatchEvent(new CustomEvent('ads-control', { detail: { enabled: !active } })); } catch(_) {}
        (async () => {
          try {
            if (auth && db) {
              const { data: { session } } = await auth.getSession();
              const uid = session && session.user ? session.user.id : null;
              if (uid) {
                // Read current subscription platform; do not overwrite Stripe-managed subscriptions
                let currentPlatform = null;
                try {
                  const existing = await db.getUser(uid);
                  currentPlatform = existing && existing.subscription ? existing.subscription.platform : null;
                } catch(_) {}
                if (currentPlatform && currentPlatform !== 'google_play') {
                  return; // Don't touch Stripe or other platforms
                }
                // Never push a false from Play to the backend; only persist true activations
                if (active) {
                  await db.updateUser(uid, { subscription: { active: true, platform: 'google_play', product_id: PRODUCT_ID, last_updated: new Date().toISOString() } });
                }
              }
            }
          } catch (_) {}
        })();
      };

      const isSupported = () => typeof window.getDigitalGoodsService === 'function';

      const refreshEntitlement = async () => {
        if (!isSupported()) return false;
        try {
          const service = await window.getDigitalGoodsService(BILLING_METHOD);
          const purchases = await service.listPurchases();
          const active = Array.isArray(purchases) && purchases.some(p => (p.productId||p.sku) === PRODUCT_ID && !p.isCanceled && !p.isRefunded && !p.isExpired);
          // Only update state if Play Billing actually returned purchases. This avoids overwriting
          // Stripe-based subscriptions to false on platforms where Digital Goods API is available
          // but the user subscribed via Stripe.
          if (Array.isArray(purchases) && purchases.length > 0) {
            if (active) setSubActive(true); // only set true; avoid overwriting Stripe users to false
          }
          return active;
        } catch (e) {
          return false;
        }
      };

      const subscribe = async (productId = PRODUCT_ID) => {
        if (!('PaymentRequest' in window)) {
          try { if (window.openStripePricingModal) window.openStripePricingModal(); } catch(_) {}
          return false;
        }
        const methodData = [{ supportedMethods: BILLING_METHOD, data: { sku: productId, type: 'subs' } }];
        const details = { total: { label: 'Subscription', amount: { currency: 'EUR', value: '1.49' } } };
        try {
          const request = new PaymentRequest(methodData, details);
          const resp = await request.show();
          await resp.complete('success');
          await refreshEntitlement();
          return true;
        } catch (e) {
          try { console.warn('Subscription failed:', e); } catch(_) { }
          try { if (window.openStripePricingModal) window.openStripePricingModal(); } catch(_) {}
          return false;
        }
      };

      const restore = async () => { return refreshEntitlement(); };
      const isSubscribed = () => { try { return JSON.parse(localStorage.getItem('subscriptionActive')||'false')===true; } catch(_) { return false; } };
      const onStatusChange = (cb) => { if (typeof cb !== 'function') return () => {}; const handler = (e)=>cb(!!(e&&e.detail&&e.detail.active)); window.addEventListener('subscription-status-changed', handler); return () => window.removeEventListener('subscription-status-changed', handler); };

      window.fitmateIAP = { subscribe, restore, refreshEntitlement, isSubscribed, onStatusChange, PRODUCT_ID };

      // Kick off entitlement check on load and when returning to the app
      refreshEntitlement();
      document.addEventListener('visibilitychange', () => { if (!document.hidden) refreshEntitlement(); });
    })();
    
    // PDF Generation Utility
    const generatePDF = (title, content, filename) => {
      const { jsPDF } = window.jspdf;
      const doc = new jsPDF();
      
      // Add title
      doc.setFontSize(18);
      doc.text(title, 20, 20);
      
      // Add content
      doc.setFontSize(12);
      let y = 30;
      
      // Split content into lines to fit page width
      const splitContent = doc.splitTextToSize(content, 170);
      
      // Calculate line height
      const lineHeight = 7;
      
      // Add content with pagination
      for (let i = 0; i < splitContent.length; i++) {
        // Check if we need a new page
        if (y > 280) { // A4 height is about 297mm, leaving margin
          doc.addPage();
          y = 20; // Reset y position for new page
        }
        
        // Add the line
        doc.text(splitContent[i], 20, y);
        y += lineHeight;
      }
      
      // Save the PDF
      doc.save(filename);
    };

    // Enhanced Speech Controller for granular control
    const speechController = {
      isPlaying: false,
      currentUtterance: null,
      activeButton: null,
      currentText: null,
      
      speak: function(text, buttonId) {
        if ('speechSynthesis' in window) {
          // If this button is currently playing, stop it
          if (this.isPlaying && this.activeButton === buttonId) {
            this.stop();
            return 'stop';
          }
          
          // Stop any other playing speech
          if (this.isPlaying) {
            this.stop();
          }
          
          // Start new speech
          this.currentText = text;
          const utterance = new SpeechSynthesisUtterance(text);
          utterance.rate = 0.9;
          
          // Mobile-optimized voice selection
          const voices = window.speechSynthesis.getVoices();
          const preferredVoice = voices.find(voice => 
            voice.lang.startsWith('en') && (voice.name.includes('Google') || voice.name.includes('Microsoft'))
          ) || voices.find(voice => voice.lang.startsWith('en'));
          if (preferredVoice) {
            utterance.voice = preferredVoice;
          }
          
          utterance.onstart = () => {
            this.isPlaying = true;
            this.activeButton = buttonId;
          };
          
          utterance.onend = () => {
            this.isPlaying = false;
            this.currentUtterance = null;
            this.activeButton = null;
            this.currentText = null;
          };
          
          utterance.onerror = (event) => {
            console.error('Speech synthesis error:', event);
            this.stop();
          };
          
          this.currentUtterance = utterance;
          window.speechSynthesis.speak(utterance);
          this.isPlaying = true;
          this.activeButton = buttonId;
          return 'play';
        } else {
          alert('Text-to-speech not supported in this browser');
          return 'error';
        }
      },
      
      stop: function() {
        window.speechSynthesis.cancel();
        this.isPlaying = false;
        this.currentUtterance = null;
        this.activeButton = null;
        this.currentText = null;
      },
      
      isActuallyPlaying: function() {
        return this.isPlaying && window.speechSynthesis.speaking;
      }
    };

    // Simple Text-to-Speech Function (for backward compatibility)
    const speakText = (text) => {
      speechController.speak(text);
    };

    // --- Default Goal Data ---
    const defaultGoals = {
      calories: 2000,
      protein: 120,
      carbs: 250,
      fat: 60,
      activity: 30, // in minutes
      water: 8, // in glasses
    };

    // --- Helper Components ---


    // --- Main App Component ---
    function App() {
      const [screen, setScreen] = useState(() => {
        const urlParams = new URLSearchParams(window.location.search);
        const tab = urlParams.get('tab');
        const view = urlParams.get('view');
        
        // Handle workout detail redirection
        if (view === 'detail') {
          const completedWorkoutIndex = localStorage.getItem('completedWorkoutIndex');
          if (completedWorkoutIndex) {
            localStorage.removeItem('completedWorkoutIndex');
            // Redirect to workout.html detail view immediately
            window.location.replace(`workout.html?workout=${completedWorkoutIndex}&view=detail`);
            return null; // Prevent rendering while redirecting
          }
        }
        
        if (tab) {
          // Clear the URL parameter to prevent it from persisting on refresh
          window.history.replaceState({}, document.title, window.location.pathname);
          return tab;
        }
        const savedScreen = localStorage.getItem('fitmate-current-screen');
        return savedScreen || 'dashboard';
      }); // 'dashboard', 'scan', 'profile', 'planner', 'workout', 'coach', 'progress'

      // --- Clean Theme State Management ---
      const [isDarkMode, setIsDarkMode] = useState(() => {
        const saved = localStorage.getItem('fitmate-dark-mode');
        return saved === 'true';
      });

      // --- Coach and Progress State Management ---
      const [coachMessages, setCoachMessages] = useState(() => {
        // For signed-in users, start with default message and let remote data load via useEffect
        if (user) {
          return [{ text: "Hello! I'm your AI Health Coach. Ask me anything about your nutrition or meals.", sender: 'ai' }];
        }
        const savedMessages = localStorage.getItem('coachMessages');
        return savedMessages ? JSON.parse(savedMessages) : [{ text: "Hello! I'm your AI Health Coach. Ask me anything about your nutrition or meals.", sender: 'ai' }];
      });
      const [habitAIAdvice, setHabitAIAdvice] = useState(() => {
        // For signed-in users, start with empty string and let remote data load via useEffect
        if (user) {
          return '';
        }
        const savedAdvice = localStorage.getItem('habitAIAdvice');
        return savedAdvice || '';
      });
      const [isLoadingAdvice, setIsLoadingAdvice] = useState(false);
      const [showResetModal, setShowResetModal] = useState(false);
      const [showSubscriptionModal, setShowSubscriptionModal] = useState(false);
      const [subActiveGlobal, setSubActiveGlobal] = useState(() => { try { return JSON.parse(localStorage.getItem('subscriptionActive')||'false'); } catch (_) { return false; } });
      const [aiRemainingGlobal, setAiRemainingGlobal] = useState({ count: 0, limit: 0 });

      // Add these new AI states:
      const [scanResult, setScanResult] = useState(() => {
        // For signed-in users, start with null and let remote data load via useEffect
        if (user) {
          return null;
        }
        const saved = localStorage.getItem('scanResult');
        return saved ? JSON.parse(saved) : null;
      });
      const [scanLoading, setScanLoading] = useState(false);
      const [scanError, setScanError] = useState(null);

      const [mealPlan, setMealPlan] = useState(() => {
        // For signed-in users, start with null and let remote data load via useEffect
        if (user) {
          return null;
        }
        const saved = localStorage.getItem('mealPlan');
        return saved ? JSON.parse(saved) : null;
      });
      const [mealPlanLoading, setMealPlanLoading] = useState(false);
      const [mealPlanError, setMealPlanError] = useState(null);

      const [workoutPlan, setWorkoutPlan] = useState(() => {
        // For signed-in users, start with null and let remote data load via useEffect
        if (user) {
          return null;
        }
        const saved = localStorage.getItem('workoutPlan');
        return saved ? JSON.parse(saved) : null;
      });
      const [workoutPlanLoading, setWorkoutPlanLoading] = useState(false);
      const [workoutPlanError, setWorkoutPlanError] = useState(null);

      const [formAnalysis, setFormAnalysis] = useState(() => {
        // For signed-in users, start with null and let remote data load via useEffect
        if (user) {
          return null;
        }
        const saved = localStorage.getItem('formAnalysis');
        return saved ? JSON.parse(saved) : null;
      });
      const [formAnalysisLoading, setFormAnalysisLoading] = useState(false);
      const [formAnalysisError, setFormAnalysisError] = useState(null);

      useEffect(() => {
        if (isDarkMode) {
          document.documentElement.classList.add('dark');
        } else {
          document.documentElement.classList.remove('dark');
        }
        localStorage.setItem('fitmate-dark-mode', isDarkMode.toString());
      }, [isDarkMode]);

      useEffect(() => {
        if ('Notification' in window && Notification.permission === 'default') {
          Notification.requestPermission();
        }
      }, []);

      // Simplified: no periodic rollover. Midnight reset is handled by the scheduled timer,
      // and if the app opens the next day, on-mount archiving will finalize the prior day.
      useEffect(() => { return () => {}; }, []);

      // Open reset modal if Supabase notifies PASSWORD_RECOVERY (fallback to event)
      useEffect(() => {
        const handler = () => setShowResetModal(true);
        window.addEventListener('supabase-password-recovery', handler);
        return () => window.removeEventListener('supabase-password-recovery', handler);
      }, []);

      const computeAiRemainingGlobal = React.useCallback(async () => {
        // Get user from auth session directly to avoid stale React state
        let uid = null;
        try {
          if (auth && auth.getSession) {
            const { data: { session } } = await auth.getSession();
            uid = session && session.user ? session.user.id : null;
          }
        } catch (_) {}
        
        const todayISO = typeof toLocalISODate === 'function' ? toLocalISODate(new Date()) : new Date().toISOString().slice(0,10);
        let usage = {};
        try { usage = JSON.parse(localStorage.getItem('aiUsage') || '{}') || {}; } catch (_) {}
        const key = uid || 'anon';
        const count = Number((usage[todayISO] && usage[todayISO][key]) || 0);
        let subscribed = false;
        try { subscribed = JSON.parse(localStorage.getItem('subscriptionActive') || 'false'); } catch (_) {}
        const limit = subscribed ? 10 : (uid ? 5 : 3);
        setAiRemainingGlobal({ count, limit });
      }, []);

      useEffect(() => {
        computeAiRemainingGlobal();
        const openSub = async () => {
          await computeAiRemainingGlobal();
          if (!user) {
            setShowSubscriptionModal(false);
            setScreen('profile');
            setTimeout(() => { try { window.dispatchEvent(new Event('open-account-modal')); } catch (_) {} }, 50);
          } else {
            try { window.dispatchEvent(new Event('close-account-modal')); } catch (_) {}
            try { setTimeout(() => { window.dispatchEvent(new Event('close-account-modal')); }, 0); } catch (_) {}
            try { setTimeout(() => { window.dispatchEvent(new Event('close-account-modal')); }, 150); } catch (_) {}
            setShowSubscriptionModal(true);
          }
        };
        const openOnQuota = async () => {
          // Same logic as forceOpenSub for consistency
          let uid = null;
          try {
            if (auth && auth.getSession) {
              const { data: { session } } = await auth.getSession();
              uid = session && session.user ? session.user.id : null;
            }
          } catch (_) {}
          
          const todayISO = typeof toLocalISODate === 'function' ? toLocalISODate(new Date()) : new Date().toISOString().slice(0,10);
          let usage = {};
          try { usage = JSON.parse(localStorage.getItem('aiUsage') || '{}') || {}; } catch (_) {}
          const key = uid || 'anon';
          const count = Number((usage[todayISO] && usage[todayISO][key]) || 0);
          let subscribed = false;
          try { subscribed = JSON.parse(localStorage.getItem('subscriptionActive') || 'false'); } catch (_) {}
          const limit = subscribed ? 10 : (uid ? 5 : 3);
          setAiRemainingGlobal({ count, limit });
          
          if (!user) {
            setShowSubscriptionModal(false);
            setScreen('profile');
            setTimeout(() => { try { window.dispatchEvent(new Event('open-account-modal')); } catch (_) {} }, 50);
          } else {
            try { window.dispatchEvent(new Event('close-account-modal')); } catch (_) {}
            setShowSubscriptionModal(true);
          }
        };
        const onVis = () => { if (!document.hidden) computeAiRemainingGlobal().catch(() => {}); };
        const forceOpenSub = async () => { 
          // Force immediate recompute before opening modal - must match AI limiter logic exactly
          let uid = null;
          try {
            if (auth && auth.getSession) {
              const { data: { session } } = await auth.getSession();
              uid = session && session.user ? session.user.id : null;
            }
          } catch (_) {}
          
          const todayISO = typeof toLocalISODate === 'function' ? toLocalISODate(new Date()) : new Date().toISOString().slice(0,10);
          let usage = {};
          try { usage = JSON.parse(localStorage.getItem('aiUsage') || '{}') || {}; } catch (_) {}
          const key = uid || 'anon';
          const count = Number((usage[todayISO] && usage[todayISO][key]) || 0);
          let subscribed = false;
          try { subscribed = JSON.parse(localStorage.getItem('subscriptionActive') || 'false'); } catch (_) {}
          const limit = subscribed ? 10 : (uid ? 5 : 3);
          
          console.log('🔍 Force-open modal debug:', { uid, key, todayISO, count, limit, subscribed, usage: usage[todayISO] });
          
          setAiRemainingGlobal({ count, limit });
          try { window.dispatchEvent(new Event('close-account-modal')); } catch (_) {} try { setTimeout(() => { window.dispatchEvent(new Event('close-account-modal')); }, 0); } catch (_) {} try { setTimeout(() => { window.dispatchEvent(new Event('close-account-modal')); }, 150); } catch (_) {} setShowSubscriptionModal(true); 
        };
        window.addEventListener('open-subscription-modal', openSub);
        window.addEventListener('force-open-subscription-modal', forceOpenSub);
        window.addEventListener('ai-quota-exceeded', openOnQuota);
        document.addEventListener('visibilitychange', onVis);
        let off = null;
        if (window.fitmateIAP && typeof window.fitmateIAP.onStatusChange === 'function') {
          off = window.fitmateIAP.onStatusChange((active) => { 
            setSubActiveGlobal(!!active); 
            // Fire and forget - don't block the event handler
            computeAiRemainingGlobal().catch(() => {}); 
          });
        }
        return () => {
          window.removeEventListener('open-subscription-modal', openSub);
          window.removeEventListener('force-open-subscription-modal', forceOpenSub);
          window.removeEventListener('ai-quota-exceeded', openOnQuota);
          document.removeEventListener('visibilitychange', onVis);
          if (off) off();
        };
      }, [computeAiRemainingGlobal]);

      // Handle Supabase auth links (email confirmation and password recovery)
      useEffect(() => {
        if (!auth) return;
        const url = new URL(window.location.href);
        // Support both query (?code=) and hash (#access_token=) styles
        const hash = window.location.hash.startsWith('#') ? window.location.hash.slice(1) : window.location.hash;
        const hashParams = new URLSearchParams(hash);
        const searchParams = url.searchParams;

        const code = searchParams.get('code') || hashParams.get('code');
        const type = searchParams.get('type') || hashParams.get('type'); // 'recovery' when coming from reset email
        const accessToken = hashParams.get('access_token');
        const refreshToken = hashParams.get('refresh_token');

        (async () => {
          try {
            // For all Supabase auth links, establish a session
            if (code) {
              const { error } = await auth.exchangeCodeForSession({ code });
              if (error) console.error('exchangeCodeForSession error:', error.message);
              searchParams.delete('code');
            } else if (accessToken && refreshToken) {
              // Hash flow: set session directly
              const { error } = await auth.setSession({
                access_token: accessToken,
                refresh_token: refreshToken
              });
              if (error) console.error('setSession error:', error.message);
            }
          } finally {
            // If this was a password recovery link, open Reset modal
            if (type === 'recovery') {
              setShowResetModal(true);
              searchParams.delete('type');
            }
            // Clean URL (remove hash and processed params)
            const clean = url.origin + url.pathname + (searchParams.toString() ? `?${searchParams.toString()}` : '');
            window.history.replaceState({}, document.title, clean);
            if (window.location.hash) {
              window.location.hash = '';
            }
          }
        })();
      }, []);

      // Persist current screen state
      useEffect(() => {
        localStorage.setItem('fitmate-current-screen', screen);
      }, [screen]);

      // Listen for userDataSynced/remoteDataApplied events to refresh React state
      useEffect(() => {
        const handleUserDataSynced = (evt) => {
          console.log('🔄 Refreshing React state after sync...');
          const payload = evt && evt.detail && evt.detail.userData ? evt.detail.userData : null;
          
          // Prefer event payload (freshest). Fallback to localStorage.
          if (payload && payload.goals) {
            setGoals(payload.goals);
            try { localStorage.setItem('goals', JSON.stringify(payload.goals)); } catch (_) {}
            console.log('✅ Goals applied from event payload');
          } else {
            const savedGoals = localStorage.getItem('goals');
            if (savedGoals) {
              const goalsData = JSON.parse(savedGoals);
              setGoals(goalsData);
              console.log('✅ Goals synced:', goalsData);
            }
          }
          
          if (payload && payload.daily_intake) {
            try {
              const todayISO = toLocalISODate(new Date());
              const remoteUpdateIsToday = !!payload.updated_at && toLocalISODate(new Date(payload.updated_at)) === todayISO;
              if (!remoteUpdateIsToday) {
                console.log('⏭️ Skipping remote daily_intake from event payload (updated_at not today)');
              } else {
                const localIntakeDate = localStorage.getItem('dailyIntakeDate');
                const lastSaved = localStorage.getItem('lastSavedDate');
                const rolledToToday = (localIntakeDate === todayISO && lastSaved === todayISO);
                const currentLocal = JSON.parse(localStorage.getItem('dailyIntake') || '{}') || {};
                const localIsZero = ['calories','protein','carbs','fat','activity','water'].every(k => Number(currentLocal[k]||0) === 0);
                const remoteHasNonZero = ['calories','protein','carbs','fat','activity','water'].some(k => Number(payload.daily_intake?.[k]||0) > 0);
                const localMeals = (() => { try { return JSON.parse(localStorage.getItem('recentMeals') || '[]') || []; } catch { return []; } })();
                const localHasStarted = !localIsZero || (Array.isArray(localMeals) && localMeals.length > 0);
                if (rolledToToday && !localHasStarted && remoteHasNonZero) {
                  console.log('⏭️ Skipping remote daily_intake from event payload until local day start');
                } else {
                  const merged = {
                    ...payload.daily_intake,
                    activity: Number(payload.daily_intake?.activity || 0)
                  };
                  setDailyIntake(merged);
                  try { localStorage.setItem('dailyIntake', JSON.stringify(merged)); } catch (_) {}
                  console.log('✅ Daily intake applied from event (activity remote-only):', merged.activity);
                }
              }
            } catch (_) {
              console.log('⚠️ Event payload intake merge failed; leaving local untouched');
            }
          } else {
            const savedIntake = localStorage.getItem('dailyIntake');
            if (savedIntake) {
              const intakeData = JSON.parse(savedIntake);
              setDailyIntake(intakeData);
              console.log('✅ Daily intake synced from localStorage:', intakeData);
            }
          }
          
          if (payload && payload.recent_meals) {
            try {
              const todayISO = toLocalISODate(new Date());
              const remoteUpdateIsToday = !!payload.updated_at && toLocalISODate(new Date(payload.updated_at)) === todayISO;
              if (!remoteUpdateIsToday) {
                console.log('⏭️ Skipping remote recent_meals from event payload (updated_at not today)');
              } else {
                const localIntakeDate = localStorage.getItem('dailyIntakeDate');
                const lastSaved = localStorage.getItem('lastSavedDate');
                const rolledToToday = (localIntakeDate === todayISO && lastSaved === todayISO);
                const localMeals = (() => { try { return JSON.parse(localStorage.getItem('recentMeals') || '[]') || []; } catch { return []; } })();
                const localIsEmpty = !Array.isArray(localMeals) || localMeals.length === 0;
                const remoteHasMeals = Array.isArray(payload.recent_meals) && payload.recent_meals.length > 0;
                const remoteTs = payload && payload.updated_at ? new Date(payload.updated_at).getTime() : 0;
                const resetAt = parseInt(localStorage.getItem('midnightResetAt') || '0');
                const remoteOlderThanReset = resetAt && remoteTs && (remoteTs <= resetAt);
                if (rolledToToday && localIsEmpty && remoteHasMeals && remoteOlderThanReset) {
                  console.log('⏭️ Skipping remote recent_meals from event payload after local reset');
                } else {
                  setRecentMeals(payload.recent_meals);
                  try { localStorage.setItem('recentMeals', JSON.stringify(payload.recent_meals)); } catch (_) {}
                  console.log('✅ Recent meals applied from event payload');
                }
              }
            } catch (_) {
              setRecentMeals(payload.recent_meals);
              try { localStorage.setItem('recentMeals', JSON.stringify(payload.recent_meals)); } catch (__e) {}
              console.log('✅ Recent meals applied from event payload');
            }
          } else {
            const savedMeals = localStorage.getItem('recentMeals');
            if (savedMeals) {
              const mealsData = JSON.parse(savedMeals);
              setRecentMeals(mealsData);
              console.log('✅ Recent meals synced:', mealsData);
            }
          }
          
          const savedHistory = localStorage.getItem('dailyHistory');
          if (savedHistory) {
            let historyData = JSON.parse(savedHistory);
            setDailyHistory(historyData);
            console.log('✅ Daily history synced:', historyData);
          }
          
          // Skip dark mode refresh - it's managed by its own useEffect
          // const savedDarkMode = localStorage.getItem('fitmate-dark-mode');
          // if (savedDarkMode) {
          //   setIsDarkMode(savedDarkMode === 'true');
          //   console.log('✅ Dark mode setting synced');
          // }
          
          console.log('✅ All React state refreshed after sync');
        };
        
        window.addEventListener('userDataSynced', handleUserDataSynced);
        window.addEventListener('remoteDataApplied', handleUserDataSynced);

        // If remote finished applying before this listener mounted, hydrate now
        try {
          if (localStorage.getItem('pendingUserDataSynced') === '1') {
            console.log('🔁 Pending userDataSynced detected on mount; hydrating state now');
            handleUserDataSynced();
          }
          const rawPending = localStorage.getItem('pendingHydratePayload');
          if (rawPending) {
            try {
              const payload = JSON.parse(rawPending);
              console.log('🧩 Found pendingHydratePayload; hydrating state now');
              if (window.fitmateHydrateFromRemote) {
                window.fitmateHydrateFromRemote(payload);
              } else {
                handleUserDataSynced({ detail: { userData: payload } });
              }
            } finally {
              localStorage.removeItem('pendingHydratePayload');
            }
          }
        } catch (_) {}
        
        return () => {
          window.removeEventListener('userDataSynced', handleUserDataSynced);
          window.removeEventListener('remoteDataApplied', handleUserDataSynced);
        };
      }, []);

      // Auth state changes are handled by AuthProvider context

      const toggleDarkMode = () => {
        setIsDarkMode(prev => !prev);
      };

      // --- State Initialization from localStorage ---
      const [goals, setGoals] = useState(() => {
        // For signed-in users, start with defaults and let remote data load via useEffect
        if (user) {
          return defaultGoals;
        }
        const savedGoals = localStorage.getItem('goals');
        return savedGoals ? JSON.parse(savedGoals) : defaultGoals;
      });

      const [dailyIntake, setDailyIntake] = useState(() => {
        try {
          const zero = { calories: 0, protein: 0, carbs: 0, fat: 0, activity: 0, water: 0 };
          const today = toLocalISODate(new Date());
          
          // Rollover disabled: load saved intake directly
          if (user) {
            return zero;
          }
          const savedIntake = localStorage.getItem('dailyIntake');
          return savedIntake ? JSON.parse(savedIntake) : zero;
        } catch (_) {
          return { calories: 0, protein: 0, carbs: 0, fat: 0, activity: 0, water: 0 };
        }
      });

      const [recentMeals, setRecentMeals] = useState(() => {
        // For signed-in users, start with empty array and let remote data load via useEffect
        if (user) {
          return [];
        }
        const savedMeals = localStorage.getItem('recentMeals');
        return savedMeals ? JSON.parse(savedMeals) : [];
      });

      const [dailyHistory, setDailyHistory] = useState(() => {
        // For signed-in users, start with empty object and let remote data load via useEffect
        if (user) {
          return {};
        }
        const savedHistory = localStorage.getItem('dailyHistory');
        return savedHistory ? JSON.parse(savedHistory) : {};
      });

      // Global hydrator: allows AuthProvider to hydrate UI directly from remote payload
      useEffect(() => {
        window.fitmateHydrateFromRemote = (payload) => {
          try {
            if (!payload || typeof payload !== 'object') return;
            if (payload.goals) {
              setGoals(payload.goals);
              try { localStorage.setItem('goals', JSON.stringify(payload.goals)); } catch (_) {}
            }
            if (payload.daily_intake) {
              try {
                const todayISO = toLocalISODate(new Date());
                const remoteUpdateIsToday = !!payload.updated_at && toLocalISODate(new Date(payload.updated_at)) === todayISO;
                if (!remoteUpdateIsToday) {
                  console.log('⏭️ Hydrate: skipping remote intake (updated_at not today)');
                } else {
                  const localIntakeDate = localStorage.getItem('dailyIntakeDate');
                  const lastSaved = localStorage.getItem('lastSavedDate');
                  const rolledToToday = (localIntakeDate === todayISO && lastSaved === todayISO);
                  const localIntake = (() => { try { return JSON.parse(localStorage.getItem('dailyIntake')||'{}'); } catch { return {}; } })();
                  const localIsZero = ['calories','protein','carbs','fat','activity','water'].every(k => Number(localIntake[k]||0) === 0);
                  const remoteHasNonZero = ['calories','protein','carbs','fat','activity','water'].some(k => Number(payload.daily_intake?.[k]||0) > 0);
                  const localMeals = (() => { try { return JSON.parse(localStorage.getItem('recentMeals') || '[]') || []; } catch { return []; } })();
                  const localHasStarted = !localIsZero || (Array.isArray(localMeals) && localMeals.length > 0);
                  if (rolledToToday && !localHasStarted && remoteHasNonZero) {
                    console.log('⏭️ Hydrate: skipping remote intake until local day start');
                  } else {
                    const merged = { 
                      ...payload.daily_intake, 
                      activity: Number(payload.daily_intake?.activity || 0)
                    };
                    setDailyIntake(merged);
                    try { localStorage.setItem('dailyIntake', JSON.stringify(merged)); } catch (_) {}
                    console.log('⏭️ Hydrate: applied intake with activity merged by max:', merged.activity);
                  }
                }
              } catch (_e) {
                console.log('⚠️ Hydrate: intake merge failed; leaving local untouched');
              }
            }
            if (payload.recent_meals) {
              try {
                const todayISO = toLocalISODate(new Date());
                const remoteUpdateIsToday = !!payload.updated_at && toLocalISODate(new Date(payload.updated_at)) === todayISO;
                if (!remoteUpdateIsToday) {
                  console.log('⏭️ Hydrate: skipping recent_meals (updated_at not today)');
                } else {
                  const localIntakeDate = localStorage.getItem('dailyIntakeDate');
                  const lastSaved = localStorage.getItem('lastSavedDate');
                  const rolledToToday = (localIntakeDate === todayISO && lastSaved === todayISO);
                  const localMeals = (() => { try { return JSON.parse(localStorage.getItem('recentMeals') || '[]') || []; } catch { return []; } })();
                  const localIsEmpty = !Array.isArray(localMeals) || localMeals.length === 0;
                  const remoteHasMeals = Array.isArray(payload.recent_meals) && payload.recent_meals.length > 0;
                  if (rolledToToday && localIsEmpty && remoteHasMeals) {
                    console.log('⏭️ Hydrate: skipping recent_meals until local day start');
                  } else {
                    setRecentMeals(payload.recent_meals);
                    try { localStorage.setItem('recentMeals', JSON.stringify(payload.recent_meals)); } catch (_) {}
                  }
                }
              } catch (_) {
                console.log('⚠️ Hydrate: meals merge failed; leaving local untouched');
              }
            }
            if (payload.daily_history) {
              try {
                const localDH = JSON.parse(localStorage.getItem('dailyHistory') || '{}') || {};
                const merged = { ...payload.daily_history, ...localDH }; // prefer local for conflicts
                setDailyHistory(merged);
                try { localStorage.setItem('dailyHistory', JSON.stringify(merged)); } catch (_) {}
              } catch (_) {
                setDailyHistory(payload.daily_history);
                try { localStorage.setItem('dailyHistory', JSON.stringify(payload.daily_history)); } catch (_) {}
              }
            }
            try { window.dispatchEvent(new CustomEvent('userDataSynced', { detail: { userData: payload } })); } catch (_) {}
          } catch (e) {
            console.warn('fitmateHydrateFromRemote failed:', e);
          }
        };
        return () => { try { delete window.fitmateHydrateFromRemote; } catch (_) {} };
      }, []);
      // --- Day-Boundary Watcher: Archive and Reset at Local Midnight ---
      useEffect(() => {
        const finalizeIfDayChanged = () => {
          try {
            const todayISO = toLocalISODate(new Date());
            const lastSaved = localStorage.getItem('lastSavedDate') || '';
            const intakeDate = localStorage.getItem('dailyIntakeDate') || '';
            const dayChanged = (!!intakeDate && intakeDate !== todayISO) || (!!lastSaved && lastSaved !== todayISO);
            if (dayChanged) {
              const prevDate = intakeDate || lastSaved || todayISO;
              const prevIntake = (() => { try { return JSON.parse(localStorage.getItem('dailyIntake') || '{}') || {}; } catch { return {}; } })();
              const prevMeals = (() => { try { return JSON.parse(localStorage.getItem('recentMeals') || '[]') || []; } catch { return []; } })();
              const history = (() => { try { return JSON.parse(localStorage.getItem('dailyHistory') || '{}') || {}; } catch { return {}; } })();
              const scoreObj = computeHealthScoreForDate(prevIntake, goals, prevDate);
              const record = { intake: prevIntake, meals: prevMeals, score: scoreObj?.score, components: scoreObj?.components };
              history[prevDate] = { ...(history[prevDate] || {}), ...record, archivedAt: Date.now() };
              localStorage.setItem('dailyHistory', JSON.stringify(history));

              const zero = { calories:0, protein:0, carbs:0, fat:0, activity:0, water:0 };
              localStorage.setItem('dailyIntake', JSON.stringify(zero));
              localStorage.setItem('recentMeals', JSON.stringify([]));
              localStorage.removeItem('activityTimerState');

              localStorage.setItem('dailyIntakeDate', todayISO);
              localStorage.setItem('lastSavedDate', todayISO);
              localStorage.setItem('midnightResetAt', String(Date.now()));

              // Push reset to Supabase to mark today's zeroed intake/meals
              if (user && supabase && !forceNextRemoteOnlyRef?.current && authInitialRemoteAppliedRef?.current) {
                const currentTimestamp = new Date().toISOString();
                const update = {
                  daily_intake: zero,
                  recent_meals: [],
                  updated_at: currentTimestamp
                };
                queueUserUpdate(user.id, update)
                  .then(() => {
                    try { localStorage.setItem('lastSyncTimestamp', Date.now().toString()); } catch (_) {}
                    console.log('📤 Midnight reset: queued Supabase update with zeros and today timestamp');
                  })
                  .catch((pushErr) => {
                    console.warn('⚠️ Midnight reset: Supabase push failed; will rely on next sync', pushErr);
                  });
              } else {
                console.log('📤 Midnight reset: skipped Supabase push (auth gating active)');
              }

              try { window.dispatchEvent(new CustomEvent('userDataSynced')); } catch (_) {}
              console.log(`🌙 Midnight reset: archived ${prevDate} with score ${scoreObj?.score ?? 'n/a'} and reset to zero`);
            } else {
              if (!intakeDate) localStorage.setItem('dailyIntakeDate', todayISO);
              if (!lastSaved) localStorage.setItem('lastSavedDate', todayISO);
            }
          } catch (e) {
            console.warn('Midnight reset check failed:', e);
          }
        };
        finalizeIfDayChanged();
        const intervalId = setInterval(finalizeIfDayChanged, 60 * 1000);
        const onVis = () => { if (!document.hidden) finalizeIfDayChanged(); };
        document.addEventListener('visibilitychange', onVis, true);
        return () => { clearInterval(intervalId); document.removeEventListener('visibilitychange', onVis, true); };
      }, [user]);

      // --- Enhanced Data Persistence with Supabase Sync ---
      const { user, updateUserData, syncDailyIntake, syncMealsData, syncDailyHistory, syncAIContent, forceNextRemoteOnlyRef, authInitialRemoteAppliedRef } = useAuth();
      const isRemoteSyncRef = useRef(false);
      // Track initial state to avoid overwriting remote with local defaults/stale data
      const hadDailyIntakeAtStartRef = useRef(!!localStorage.getItem('dailyIntake'));
      const hadGoalsAtStartRef = useRef(!!localStorage.getItem('goals'));
      const hadMealsAtStartRef = useRef((() => { try { return (JSON.parse(localStorage.getItem('recentMeals') || '[]') || []).length > 0; } catch { return false; } })());
      const hadHistoryAtStartRef = useRef((() => { try { return Object.keys(JSON.parse(localStorage.getItem('dailyHistory') || '{}') || {}).length > 0; } catch { return false; } })());
      const initialSyncCompletedRef = useRef(false);
const midnightTimerRef = useRef(null);

      // Day-boundary watcher disabled: no automatic resets or archiving
      useEffect(() => {
        // Intentionally do nothing. Keep intake and meals untouched across days.
        return () => {};
      }, [user]);
      const isDefaultIntake = (di) => !di || (
        Number(di.calories) === 0 &&
        Number(di.protein) === 0 &&
        Number(di.carbs) === 0 &&
        Number(di.fat) === 0 &&
        Number(di.activity) === 0 &&
        Number(di.water) === 0
      );

      // Realtime listener to reflect remote changes into UI/localStorage (Supabase)
      useEffect(() => {
        if (!user || !supabase || !USERS_REALTIME_ENABLED) return;
        
        const subscription = db.subscribe('users', (payload) => {
          if (payload.new && payload.new.id === user.id) {
            const userData = payload.new;
            if (!userData) return;

            // Update localStorage from remote (using Supabase column names)
            if (userData.goals) localStorage.setItem('goals', JSON.stringify(userData.goals));
            if (userData.profile_picture) localStorage.setItem('profilePicture', userData.profile_picture);
            if (userData.notifications_enabled !== undefined) localStorage.setItem('notificationsEnabled', JSON.stringify(userData.notifications_enabled));
            // Skip syncing dark_mode from remote - it's a local UI preference
            if (userData.daily_intake) {
              try {
                const todayISO = toLocalISODate(new Date());
                const remoteUpdateIsToday = !!userData.updated_at && toLocalISODate(new Date(userData.updated_at)) === todayISO;
                if (!remoteUpdateIsToday) {
                  console.log('⏭️ Realtime(sub-2): skipping remote daily_intake (updated_at not today)');
                } else {
                  const currentLocal = JSON.parse(localStorage.getItem('dailyIntake') || '{}') || {};
                  const merged = {
                    ...userData.daily_intake,
                    activity: Number(userData.daily_intake?.activity || 0)
                  };
                  localStorage.setItem('dailyIntake', JSON.stringify(merged));
                }
              } catch (_) {
                const merged = { ...userData.daily_intake, activity: Number(userData.daily_intake?.activity || 0) };
                localStorage.setItem('dailyIntake', JSON.stringify(merged));
              }
            }
            if (userData.recent_meals) {
              const todayISO = toLocalISODate(new Date());
              const remoteUpdateIsToday = !!userData.updated_at && toLocalISODate(new Date(userData.updated_at)) === todayISO;
              if (!remoteUpdateIsToday) {
                console.log('⏭️ Realtime(sub-2): skipping remote recent_meals (updated_at not today)');
              } else {
                localStorage.setItem('recentMeals', JSON.stringify(userData.recent_meals));
              }
            }
            if (userData.daily_history) {
              // Merge remote history with local, but PREFER LOCAL for conflicting dates
              // to prevent remote from overwriting freshly archived local data.
              try {
                const localDH = JSON.parse(localStorage.getItem('dailyHistory') || '{}') || {};
                const mergedDH = { ...userData.daily_history, ...localDH };
                localStorage.setItem('dailyHistory', JSON.stringify(mergedDH));
              } catch (_) {
                localStorage.setItem('dailyHistory', JSON.stringify(userData.daily_history));
              }
            }
            // Subscription status from backend (Stripe/Play)
            if (userData.subscription) {
              try { localStorage.setItem('subscriptionActive', JSON.stringify(!!userData.subscription.active)); } catch (_) {}
              try { window.dispatchEvent(new CustomEvent('subscription-status-changed', { detail: { active: !!userData.subscription.active } })); } catch (_) {}
            }
            if (userData.coach_messages) localStorage.setItem('coachMessages', JSON.stringify(userData.coach_messages));
            if (userData.habit_ai_advice) localStorage.setItem('habitAIAdvice', userData.habit_ai_advice);
            if (userData.habits) localStorage.setItem('habits', JSON.stringify(userData.habits));
            if (userData.meal_plan) localStorage.setItem('mealPlan', JSON.stringify(userData.meal_plan));
            if (userData.workout_plan) localStorage.setItem('workoutPlan', JSON.stringify(userData.workout_plan));
            // AI usage: merge remote with local using MAX to prevent overwrites
            if (userData.ai_usage) {
              try {
                const remoteUsage = userData.ai_usage || {};
                const localUsage = JSON.parse(localStorage.getItem('aiUsage') || '{}') || {};
                const merged = { ...localUsage };
                // For each date in remote, take MAX of counts
                Object.keys(remoteUsage).forEach(date => {
                  if (!merged[date]) merged[date] = {};
                  Object.keys(remoteUsage[date]).forEach(uid => {
                    const remoteCount = Number(remoteUsage[date][uid] || 0);
                    const localCount = Number(merged[date][uid] || 0);
                    merged[date][uid] = Math.max(remoteCount, localCount);
                  });
                });
                localStorage.setItem('aiUsage', JSON.stringify(merged));
                console.log('✅ AI usage synced from remote (MAX logic applied)');
              } catch (err) {
                console.error('Error syncing AI usage:', err);
              }
            }
            if (userData.scan_result) localStorage.setItem('scanResult', JSON.stringify(userData.scan_result));
            if (userData.form_analysis) localStorage.setItem('formAnalysis', JSON.stringify(userData.form_analysis));

            // Prevent feedback loop: mark update as remote, then refresh UI
            // Also directly notify UI with latest payload
            try { window.dispatchEvent(new CustomEvent('subscription-status-changed', { detail: { active: !!userData.subscription.active } })); } catch (_) {}
            try {
              localStorage.setItem('pendingHydratePayload', JSON.stringify(remoteData));
              if (window.fitmateHydrateFromRemote) window.fitmateHydrateFromRemote(remoteData);
            } catch (_) {}
            isRemoteSyncRef.current = true;
            try { localStorage.setItem('pendingUserDataSynced', '1'); } catch (_) {}
            window.dispatchEvent(new CustomEvent('userDataSynced', { detail: { userData: remoteData } }));
            // Also signal that remote data has been applied (for initial-sync gating)
            window.dispatchEvent(new CustomEvent('remoteDataApplied', { detail: { userData: remoteData } }));
            // Re-dispatch after short delays to catch listeners that mount slightly later
            setTimeout(() => { try { window.dispatchEvent(new CustomEvent('userDataSynced', { detail: { userData: remoteData } })); } catch (_) {} }, 300);
            setTimeout(() => { try { window.dispatchEvent(new CustomEvent('userDataSynced', { detail: { userData: remoteData } })); } catch (_) {} try { localStorage.removeItem('pendingUserDataSynced'); } catch (_) {} }, 800);
            setTimeout(() => { try { window.dispatchEvent(new CustomEvent('userDataSynced', { detail: { userData: remoteData } })); } catch (_) {} }, 1500);
            setTimeout(() => { isRemoteSyncRef.current = false; }, 300);
          }
        }, { filter: `id=eq.${user.id}` });

        return () => subscription.unsubscribe();
      }, [user]);

      // Real-time listener for workout_history table to sync workouts across devices
      useEffect(() => {
        if (!user || !supabase || !USERS_REALTIME_ENABLED) return;
        
        console.log('🏋️ Setting up real-time workout history listener for user:', user.id);
        
        const workoutSubscription = supabase
          .channel(`workout-history-${user.id}`)
          .on('postgres_changes', {
            event: '*',
            schema: 'public',
            table: 'workout_history',
            filter: `user_id=eq.${user.id}`
          }, async (payload) => {
            console.log('🏋️ Workout history change detected:', payload);
            
            try {
              // Fetch fresh workout history from database
              const { data: workouts, error } = await supabase
                .from('workout_history')
                .select('*')
                .eq('user_id', user.id)
                .order('timestamp', { ascending: false })
                .limit(100);
              
              if (error) throw error;
              
              if (workouts) {
                // Update localStorage with fresh workout data
                localStorage.setItem('workoutHistory', JSON.stringify(workouts));
                console.log(`✅ Workout history synced: ${workouts.length} workouts`);
                
                // Trigger health score recalculation
                window.dispatchEvent(new Event('workout-history-updated'));
              }
            } catch (error) {
              console.error('Error syncing workout history:', error);
            }
          })
          .subscribe();
        
        // Initial fetch of workout history
        (async () => {
          try {
            const { data: workouts, error } = await supabase
              .from('workout_history')
              .select('*')
              .eq('user_id', user.id)
              .order('timestamp', { ascending: false })
              .limit(100);
            
            if (!error && workouts) {
              localStorage.setItem('workoutHistory', JSON.stringify(workouts));
              console.log(`✅ Initial workout history loaded: ${workouts.length} workouts`);
            }
          } catch (error) {
            console.error('Error loading initial workout history:', error);
          }
        })();
        
        return () => {
          workoutSubscription.unsubscribe();
        };
      }, [user]);
      
      useEffect(() => { 
        localStorage.setItem('goals', JSON.stringify(goals));
        // Defer pushing goals until initial remote sync completes AND prevent overwriting remote data
        if (user && !isRemoteSyncRef.current && !forceNextRemoteOnlyRef?.current) {
          if (!initialSyncCompletedRef.current) return;
          // Additional guard: Don't sync if we just loaded remote data
          if (!authInitialRemoteAppliedRef.current) return;
          updateUserData({ goals });
        }
      }, [goals, user, updateUserData]);
      
      useEffect(() => { 
        localStorage.setItem('dailyIntake', JSON.stringify(dailyIntake));
        // DO NOT set dailyIntakeDate here - only finalize logic (on-mount & midnight) should set it.
        // Setting it on every change breaks the "intakeDate !== today" guard in finalize.
        // Defer pushing intake until initial remote sync completes AND prevent overwriting remote data
        if (user && !isRemoteSyncRef.current && !forceNextRemoteOnlyRef?.current) {
          if (!initialSyncCompletedRef.current) return;
          // Additional guard: Don't sync if we just loaded remote data
          if (!authInitialRemoteAppliedRef.current) return;
          syncDailyIntake(dailyIntake);
        }
      }, [dailyIntake, user, syncDailyIntake]);

      // Mark when initial remote sync completes to allow subsequent updates
      useEffect(() => {
        const onRemoteApplied = () => {
          initialSyncCompletedRef.current = true;
          console.log('✅ Initial remote sync completed (flag set)');
        };
        window.addEventListener('remoteDataApplied', onRemoteApplied);
        return () => window.removeEventListener('remoteDataApplied', onRemoteApplied);
      }, []);
      
      useEffect(() => { 
        localStorage.setItem('recentMeals', JSON.stringify(recentMeals));
        // Defer pushing meals until initial remote sync completes AND prevent overwriting remote data
        if (user && !isRemoteSyncRef.current && !forceNextRemoteOnlyRef?.current) {
          if (!initialSyncCompletedRef.current) return;
          // Additional guard: Don't sync if we just loaded remote data
          if (!authInitialRemoteAppliedRef.current) return;
          syncMealsData(recentMeals);
        }
      }, [recentMeals, user, syncMealsData]);
      
      useEffect(() => { 
        localStorage.setItem('dailyHistory', JSON.stringify(dailyHistory));
        // Defer pushing history until initial remote sync completes AND prevent overwriting remote data
        if (user && !isRemoteSyncRef.current && !forceNextRemoteOnlyRef?.current) {
          if (!initialSyncCompletedRef.current) return;
          // Additional guard: Don't sync if we just loaded remote data
          if (!authInitialRemoteAppliedRef.current) return;
          syncDailyHistory(dailyHistory);
        }
      }, [dailyHistory, user, syncDailyHistory]);
      
      useEffect(() => { 
        localStorage.setItem('coachMessages', JSON.stringify(coachMessages));
        // Prevent overwriting remote data during sign-in
        if (user && !forceNextRemoteOnlyRef?.current && authInitialRemoteAppliedRef.current) {
          updateUserData({ coach_messages: coachMessages });
        }
      }, [coachMessages, user, updateUserData]);
      
      useEffect(() => { 
        localStorage.setItem('habitAIAdvice', habitAIAdvice);
        // Prevent overwriting remote data during sign-in
        if (user && !forceNextRemoteOnlyRef?.current && authInitialRemoteAppliedRef.current) {
          updateUserData({ habit_ai_advice: habitAIAdvice });
        }
      }, [habitAIAdvice, user, updateUserData]);
      
      // --- AI State Persistence with Firebase Sync ---
      useEffect(() => {
        if (scanResult) {
          localStorage.setItem('scanResult', JSON.stringify(scanResult));
          // Prevent overwriting remote data during sign-in
          if (user && !forceNextRemoteOnlyRef?.current && authInitialRemoteAppliedRef.current) {
            syncAIContent('scanResult', scanResult);
          }
        }
      }, [scanResult, user, syncAIContent]);
      
      useEffect(() => {
        if (mealPlan) {
          localStorage.setItem('mealPlan', JSON.stringify(mealPlan));
          // Prevent overwriting remote data during sign-in
          if (user && !forceNextRemoteOnlyRef?.current && authInitialRemoteAppliedRef.current) {
            syncAIContent('mealPlan', mealPlan);
          }
        }
      }, [mealPlan, user, syncAIContent]);
      
      useEffect(() => {
        if (workoutPlan) {
          localStorage.setItem('workoutPlan', JSON.stringify(workoutPlan));
          // Prevent overwriting remote data during sign-in
          if (user && !forceNextRemoteOnlyRef?.current && authInitialRemoteAppliedRef.current) {
            syncAIContent('workoutPlan', workoutPlan);
          }
        }
      }, [workoutPlan, user, syncAIContent]);
      
      useEffect(() => {
        if (formAnalysis) {
          localStorage.setItem('formAnalysis', JSON.stringify(formAnalysis));
          // Prevent overwriting remote data during sign-in
          if (user && !forceNextRemoteOnlyRef?.current && authInitialRemoteAppliedRef.current) {
            syncAIContent('formAnalysis', formAnalysis);
          }
        }
      }, [formAnalysis, user, syncAIContent]);

      // Function to compress image to target size (in KB)
      const compressImageToSize = (base64Image, targetKB, quality = 0.7, maxWidth = 400) => {
        return new Promise((resolve) => {
          if (!base64Image || !base64Image.startsWith('data:image/')) {
            resolve(base64Image);
            return;
          }
          
          const img = new Image();
          img.onload = function() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // Calculate dimensions to fit within maxWidth while maintaining aspect ratio
            let width = img.width;
            let height = img.height;
            
            if (width > maxWidth) {
              height = (height * maxWidth) / width;
              width = maxWidth;
            }
            
            canvas.width = width;
            canvas.height = height;
            
            // Draw image with quality settings
            ctx.imageSmoothingQuality = 'medium';
            ctx.drawImage(img, 0, 0, width, height);
            
            // Function to compress with quality adjustment
            const compressWithQuality = (currentQuality) => {
              try {
                const compressed = canvas.toDataURL('image/jpeg', currentQuality);
                const sizeKB = Math.round(compressed.length / 1024);
                
                if (sizeKB <= targetKB || currentQuality <= 0.3) {
                  resolve(compressed);
                } else {
                  // Reduce quality and try again
                  setTimeout(() => compressWithQuality(currentQuality - 0.1), 10);
                }
              } catch (error) {
                console.warn('Compression error, using original:', error);
                resolve(base64Image);
              }
            };
            
            // Start compression with initial quality
            compressWithQuality(quality);
          };
          
          img.onerror = () => {
            console.warn('Image loading failed, using original');
            resolve(base64Image);
          };
          
          img.src = base64Image;
        });
      };

      // Function to add a new meal to the log - Mobile-optimized crash-resistant version
      const handleLogMeal = async (mealData) => {
        console.log('📝 Logging meal data (mobile-safe):', mealData);
        
        try {
          // Extract nutritional values with fallbacks
          const calories = Number(mealData.calories) || Number(mealData.total_calories) || 0;
          const protein = Number(mealData.protein) || Number(mealData.total_protein) || 0;
          const carbs = Number(mealData.carbs) || Number(mealData.total_carbs) || 0;
          const fat = Number(mealData.fat) || Number(mealData.total_fat) || 0;
          
          // Generate unique meal ID
          const mealId = Date.now();
          
          // Universal image handling - always use original image for both desktop and mobile
          let processedImage = mealData.image || 'https://placehold.co/100x100/cccccc/333333?text=Meal';
          
          if (mealData.image && mealData.image.startsWith('data:image/')) {
            // Client-side compression: Compress image to ~100KB before processing
            try {
              const compressedImage = await compressImageToSize(mealData.image, 100); // Target 100KB
              processedImage = compressedImage;
              console.log('✅ Image compressed for mobile:', Math.round(compressedImage.length / 1024) + 'KB');
            } catch (error) {
              console.warn('Image compression failed, using original:', error);
              processedImage = mealData.image; // Fallback to original
            }
          }
          
          const newMeal = {
            id: mealId,
            name: mealData.name || mealData.food_name || 'Scanned Meal',
            calories: calories,
            image: processedImage,
            mood: mealData.mood || 'Neutral',
          };
          
          // Batch state updates with proper error boundaries
          setTimeout(() => {
            try {
              // Update daily intake
              setDailyIntake(prevIntake => ({
                ...prevIntake,
                calories: prevIntake.calories + calories,
                protein: prevIntake.protein + protein,
                carbs: prevIntake.carbs + carbs,
                fat: prevIntake.fat + fat,
              }));
              
              // Add to recent meals
              setRecentMeals(prevMeals => [newMeal, ...prevMeals.slice(0, 9)]); // Limit to 10 items
              
              console.log('💾 Meal saved successfully:', newMeal);
              
              // Navigate to dashboard with safety delay
              setTimeout(() => {
                try {
                  setScreen('dashboard');
                } catch (navError) {
                  console.error('Navigation error:', navError);
                  // Fallback: reload the page if navigation fails
                  window.location.reload();
                }
              }, 200);
              
            } catch (stateError) {
              console.error('State update error:', stateError);
              // Emergency fallback: reload to recover from state corruption
              window.location.reload();
            }
          }, 50);
          
        } catch (mainError) {
          console.error('Critical error in handleLogMeal:', mainError);
          // Ultimate fallback: reload the entire application
          window.location.reload();
        }
      };

      // Function to log daily activity
      const handleLogActivity = (activity) => {
        const updatedIntake = {
          ...dailyIntake,
          activity: dailyIntake.activity + (activity.minutes || 0),
        };
        setDailyIntake(updatedIntake);
        
        // Sync to server only after initial remote fetch completes AND prevent overwriting remote data
        if (user && initialSyncCompletedRef.current && !isRemoteSyncRef.current && !forceNextRemoteOnlyRef?.current && authInitialRemoteAppliedRef.current) {
          syncDailyIntake(updatedIntake);
        }
      };

      const handleLogWater = () => {
        const updatedIntake = {
          ...dailyIntake,
          water: dailyIntake.water + 1,
        };
        setDailyIntake(updatedIntake);
        
        // Sync to server only after initial remote fetch completes AND prevent overwriting remote data
        if (user && initialSyncCompletedRef.current && !isRemoteSyncRef.current && !forceNextRemoteOnlyRef?.current && authInitialRemoteAppliedRef.current) {
          syncDailyIntake(updatedIntake);
        }
      };

      // Function to render the current screen based on state
      const renderScreen = () => {
        // Handle redirect state - don't render anything while redirecting
        if (screen === null) {
          return <div className="flex items-center justify-center min-h-screen">
            <div className="text-center">
              <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-pink-500 mx-auto"></div>
              <p className="mt-2 text-gray-600 dark:text-gray-400">Redirecting...</p>
            </div>
          </div>;
        }
        
        switch (screen) {
          case 'dashboard': return <Dashboard dailyIntake={dailyIntake} goals={goals} recentMeals={recentMeals} onLogActivity={handleLogActivity} onLogWater={handleLogWater} />;
          case 'scan': return <Scan 
            onLogMeal={handleLogMeal}
          />;
          case 'profile': return <Profile isDarkMode={isDarkMode} toggleDarkMode={toggleDarkMode} goals={goals} setGoals={setGoals} setDailyIntake={setDailyIntake} setRecentMeals={setRecentMeals} setDailyHistory={setDailyHistory} setScreen={setScreen} />;
          case 'workout': return <WorkoutPlanner 
            workoutPlan={workoutPlan}
            setWorkoutPlan={setWorkoutPlan}
            isLoading={workoutPlanLoading}
            setIsLoading={setWorkoutPlanLoading}
            error={workoutPlanError}
            setError={setWorkoutPlanError}
          />;
          case 'coach': return <Coach 
            dailyIntake={dailyIntake} 
            recentMeals={recentMeals} 
            goals={goals}
            messages={coachMessages}
            setMessages={setCoachMessages}
            isDarkMode={isDarkMode}
          />;
          case 'progress': return <Progress 
            dailyHistory={dailyHistory} 
            goals={goals} 
            dailyIntake={dailyIntake}
            habitAIAdvice={habitAIAdvice}
            setHabitAIAdvice={setHabitAIAdvice}
            isLoadingAdvice={isLoadingAdvice}
            setIsLoadingAdvice={setIsLoadingAdvice}
          />;
          case 'planner': return <MealPlanner goals={goals} mealPlan={mealPlan} setMealPlan={setMealPlan} isLoading={mealPlanLoading} setIsLoading={setMealPlanLoading} error={mealPlanError} setError={setMealPlanError} />;

          default: return <Dashboard dailyIntake={dailyIntake} goals={goals} recentMeals={recentMeals} onLogActivity={handleLogActivity} onLogWater={handleLogWater} />;
        }
      };

      return (
        <div className="bg-gray-50 dark:bg-gray-900 min-h-screen font-sans flex flex-col">
          <main className="flex-grow">
            {renderScreen()}
          </main>
          {screen !== null && <BottomNavBar screen={screen} setScreen={setScreen} />}
          {showSubscriptionModal && (
            <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
              <div className="bg-white dark:bg-gray-800 rounded-2xl shadow-2xl max-w-md w-full">
                <div className="flex justify-between items-center p-6 border-b border-gray-200 dark:border-gray-700">
                  <h2 className="text-2xl font-bold text-gray-800 dark:text-gray-200">{subActiveGlobal ? 'Subscribed' : 'Upgrade'}</h2>
                  <button onClick={() => setShowSubscriptionModal(false)} className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 text-2xl font-bold">×</button>
                </div>
                <div className="p-6 space-y-3">
                  <div className="text-gray-800 dark:text-gray-200">AI quota: {aiRemainingGlobal.count}/{aiRemainingGlobal.limit} today</div>
                  {subActiveGlobal ? (
                    <div className="text-sm text-gray-600 dark:text-gray-400">You've used your daily AI quota. It resets at midnight.</div>
                  ) : (
                    <div className="text-sm text-gray-600 dark:text-gray-400">Subscribed users get 10 prompts per day and ads are removed.</div>
                  )}
                </div>
                <div className="p-6 pt-0 flex items-center justify-between">
                  {subActiveGlobal ? (
                    <div className="flex items-center gap-3">
                      <button
                        onClick={async ()=>{ const openPlay=()=>{ const sku=(window.fitmateIAP&&window.fitmateIAP.PRODUCT_ID)?window.fitmateIAP.PRODUCT_ID:'fitmate_monthly_149'; const manageUrl=`https://play.google.com/store/account/subscriptions?sku=${encodeURIComponent(sku)}`; try{window.open(manageUrl,'_blank');}catch(_){} }; const openStripeLogin=()=>{ try{ window.open('https://billing.stripe.com/p/login/28E14o3tE3dP9Uhfnc3sI00','_blank'); }catch(_){} }; try { if (supabase && supabase.functions) { const { data, error } = await supabase.functions.invoke('stripe-webhook', { body: { action: 'create_portal_session' } }); if (!error && data && data.url) { window.location.assign(data.url); return; } } } catch(_){} if (typeof window.getDigitalGoodsService === 'function' || /Android/i.test(navigator.userAgent)) { openPlay(); } else { openStripeLogin(); } }}
                        className="bg-gray-800 hover:bg-gray-900 text-white text-sm px-4 py-2 rounded-lg shadow"
                      >
                        Manage
                      </button>
                      <span className="text-xs bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-200 px-2 py-1 rounded-full">Subscribed</span>
                    </div>
                  ) : (
                    <div className="flex items-center gap-3">
                      <button onClick={async ()=>{ try { if (!user) { setShowSubscriptionModal(false); setScreen('profile'); setTimeout(()=>{ try { window.dispatchEvent(new Event('open-account-modal')); } catch(_) {} }, 50); return; } const ok = await (window.fitmateIAP && window.fitmateIAP.subscribe ? window.fitmateIAP.subscribe() : Promise.resolve(false)); if (ok) { setShowSubscriptionModal(false); computeAiRemainingGlobal(); } } catch(_){} }} className="bg-blue-500 hover:bg-blue-600 text-white text-sm px-4 py-2 rounded-lg shadow">Subscribe · €1.49</button>
                      <button onClick={async ()=>{ try { await (window.fitmateIAP && window.fitmateIAP.restore ? window.fitmateIAP.restore() : Promise.resolve(false)); computeAiRemainingGlobal(); } catch(_){} }} className="text-xs text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 underline">Restore</button>
                    </div>
                  )}
                  <button onClick={()=> setShowSubscriptionModal(false)} className="text-sm text-gray-600 dark:text-gray-300">Not now</button>
                </div>
              </div>
            </div>
          )}
          {showResetModal && (
            <ResetPasswordModal onClose={() => setShowResetModal(false)} />
          )}
        </div>
      );
    }

    // Shared utilities for health score and dates (hoisted function declarations)
    function toLocalISODate(date) {
      // Timezone-aware local date string (YYYY-MM-DD) for archiving and day grouping
      // Priority: user-selected timezone in localStorage ('userTimeZone') > device timezone
      try {
        const tz = localStorage.getItem('userTimeZone') || Intl.DateTimeFormat().resolvedOptions().timeZone;
        const parts = new Intl.DateTimeFormat('en-CA', {
          timeZone: tz,
          year: 'numeric',
          month: '2-digit',
          day: '2-digit'
        }).formatToParts(date);
        const year = parts.find(p => p.type === 'year')?.value || String(date.getFullYear());
        const month = parts.find(p => p.type === 'month')?.value || String(date.getMonth() + 1).padStart(2, '0');
        const day = parts.find(p => p.type === 'day')?.value || String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
      } catch (e) {
        // Fallback: original local computation
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
      }
    }

    // Compute health score for a specific date using unified weights:
    // Nutrition 40% = Calories 25% + Protein 5% + Carbs 5% + Fat 5% (±10% tolerance earns full points; calories beyond ±10% apply 25% penalty)
    // Activity up to 15 pts: 10m=5, 20m=10, 30m+=15 (capped). Workouts do NOT add activity minutes.
    // Workouts up to 30 pts: 1 pt per 10% completion (max 10 per workout), cap at 30 total per day
    // Hydration 15 pts
    function computeHealthScoreForDate(intake, goals, dateString, workoutHistoryOpt) {
      const safeNum = (v) => (Number.isFinite(Number(v)) ? Number(v) : 0);
      const gCalories = safeNum(goals?.calories);
      const gProtein  = safeNum(goals?.protein);
      const gCarbs    = safeNum(goals?.carbs);
      const gFat      = safeNum(goals?.fat);
      const gActivity = safeNum(goals?.activity);
      const gWater    = safeNum(goals?.water);

      const cals  = safeNum(intake?.calories);
      const prot  = safeNum(intake?.protein);
      const crbs  = safeNum(intake?.carbs);
      const ft    = safeNum(intake?.fat);
      const act   = safeNum(intake?.activity);
      const water = safeNum(intake?.water);

      // Tolerance-based accuracy: within ±10% of goal earns full 100%;
      // beyond that, linearly decreases toward 0 up to extreme deviations.
      const toleranceScorePct = (actual, goal, tol = 0.10) => {
        if (!goal || goal <= 0) return 0;
        const deviation = Math.abs((actual / goal) - 1); // relative deviation
        if (deviation <= tol) return 100;
        // Scale remaining deviation portion (beyond tol) to 0..100 using (1 - tol) span
        const pct = 100 - Math.min(100, ((deviation - tol) / (1 - tol)) * 100);
        return Math.max(0, pct);
      };

      const caloriesPct  = toleranceScorePct(cals, gCalories); // up to 100
      const proteinPct   = toleranceScorePct(prot, gProtein);
      const carbsPct     = toleranceScorePct(crbs, gCarbs);
      const fatPct       = toleranceScorePct(ft, gFat);
      const activityScore = gActivity > 0 ? Math.min(100, (act / gActivity) * 100) : 0; // kept for legacy display if needed
      const waterScore    = gWater > 0 ? Math.min(100, (water / gWater) * 100) : 0;

      let workoutHistory = workoutHistoryOpt;
      if (!Array.isArray(workoutHistory)) {
        try {
          workoutHistory = JSON.parse(localStorage.getItem('workoutHistory') || '[]');
          if (!Array.isArray(workoutHistory)) workoutHistory = [];
        } catch (e) { workoutHistory = []; }
      }
      // For today's date, only include workouts if an explicit flag is set (prevents accidental carry-ins)
      let allowTodayWorkouts = false;
      try {
        const todayISO = toLocalISODate(new Date());
        if (dateString === todayISO) {
          allowTodayWorkouts = (localStorage.getItem(`workoutScoreEnabled:${todayISO}`) === '1');
        }
      } catch (_) {}

      const workouts = workoutHistory.filter(w => {
        try { return toLocalISODate(new Date(w.timestamp)) === dateString; } catch { return false; }
      });
      const effectiveWorkouts = (dateString && allowTodayWorkouts) ? workouts : (dateString === toLocalISODate(new Date()) ? [] : workouts);

      // Legacy workout quality no longer used for scoring; retained for potential analytics
      let workoutQualityScore = 0;

      // Activity points: 10m=5, 20m=10, 30m+=15 (capped at 15)
      const activityPoints = Math.min(15, Math.floor(act / 10) * 5);

      // Workout points: 1 point per 10% completion (max 10 per workout), cap at 30 total
      const workoutPoints = Math.min(30, effectiveWorkouts.reduce((sum, w) => {
        const completion = safeNum(w.completionRate);
        return sum + Math.min(10, Math.floor(completion / 10));
      }, 0));
      // Nutrition = 25% calories + 5% protein + 5% carbs + 5% fat
      let nutritionPoints = (caloriesPct * 0.25) + (proteinPct * 0.05) + (carbsPct * 0.05) + (fatPct * 0.05); // max 40
      // Penalty: if calories deviate beyond ±10%, reduce nutrition total by 25%
      const calTolExceeded = gCalories > 0 ? Math.abs((cals / gCalories) - 1) > 0.10 : false;
      if (calTolExceeded) nutritionPoints *= 0.75;
      const hydrationPoints = waterScore * 0.15; // max 15

      const total = Math.round(Math.min(100, nutritionPoints + activityPoints + workoutPoints + hydrationPoints));
      return {
        score: total,
        components: {
          nutrition: Math.round(nutritionPoints),
          activity: Math.round(activityPoints),
          workout: Math.round(workoutPoints),
          hydration: Math.round(hydrationPoints),
        }
      };
    }

    // --- Screens ---

    // Dashboard Screen Component
    const Dashboard = ({ dailyIntake, recentMeals, goals, onLogActivity, onLogWater }) => {
      const rawCalorieProgress = goals.calories > 0 ? (Number(dailyIntake.calories) / Number(goals.calories)) * 100 : 0;
      const calorieProgress = Math.min(100, Math.max(0, isFinite(rawCalorieProgress) ? rawCalorieProgress : 0));
      const [quote, setQuote] = useState('');
      const { setLocalStorageWithSync } = useAuth();

      // Fetch daily motivational quote
      useEffect(() => {
        const today = new Date().toISOString().split('T')[0];
        const lastFetchDate = localStorage.getItem('lastQuoteFetchDate');
        const cachedQuote = localStorage.getItem('dailyQuote');

        if (lastFetchDate === today && cachedQuote) {
          setQuote(cachedQuote);
          return;
        }

        const fetchQuote = async () => {
          try {
            const prompt = "Generate a short, motivational fitness quote (max 15 words). Just return the quote, nothing else.";
            
            const payload = {
              model: OPENROUTER_QWEN_MODEL,
              messages: [
                { role: 'user', content: prompt }
              ]
            };

            const response = await fetch(getDirectGeminiConfig().url, {
              method: 'POST',
              headers: { ...getDirectGeminiConfig().headers, 'X-Fitmate-Ignore-Quota': 'true' },
              body: JSON.stringify(payload),
              signal: AbortSignal.timeout(10000)
            });

            if (!response.ok) {
              throw new Error('API request failed');
            }

            const contentType = response.headers.get('content-type');
            if (!contentType || !contentType.includes('application/json')) {
              throw new Error('Invalid response format');
            }

            const result = await response.json();
            const newQuote = (result.choices?.[0]?.message?.content || '').trim();
            if (newQuote) {
              setQuote(newQuote);
              setLocalStorageWithSync('dailyQuote', newQuote);
              setLocalStorageWithSync('lastQuoteFetchDate', today);
            } else {
              throw new Error('Empty quote received');
            }
          } catch (error) {
            // Silently use fallback quote - don't spam console with CORS/network errors
            const fallbackQuotes = [
              "The only bad workout is the one that didn't happen.",
              "Progress, not perfection.",
              "Your body can do it. It's your mind you need to convince.",
              "Stronger every day.",
              "Fitness is not about being better than someone else. It's about being better than you used to be."
            ];
            const randomQuote = fallbackQuotes[Math.floor(Math.random() * fallbackQuotes.length)];
            setQuote(randomQuote);
          }
        };

        fetchQuote();
      }, []);

      // On mount: enable workout scoring if today already has workouts
      useEffect(() => {
        try {
          const todayISO = toLocalISODate(new Date());
          const wh = JSON.parse(localStorage.getItem('workoutHistory') || '[]');
          if (Array.isArray(wh)) {
            const todayWorkouts = wh.filter(w => {
              try {
                const wDate = toLocalISODate(new Date(w.timestamp));
                return wDate === todayISO;
              } catch { return false; }
            });
            if (todayWorkouts.length > 0) {
              localStorage.setItem(`workoutScoreEnabled:${todayISO}`, '1');
              console.log('✅ Workout scoring enabled on mount (found', todayWorkouts.length, 'workouts for today)');
            }
          }
        } catch (_) {}
      }, []);

      // Calculate Health Score using shared utility (for today)
      const [healthScore, setHealthScore] = useState(() => {
        const todayStr = toLocalISODate(new Date());
        return computeHealthScoreForDate(dailyIntake, goals, todayStr).score;
      });

      // Recalculate health score when dailyIntake or goals change
      useEffect(() => {
        const todayStr = toLocalISODate(new Date());
        const newScore = computeHealthScoreForDate(dailyIntake, goals, todayStr).score;
        setHealthScore(newScore);
      }, [dailyIntake, goals]);

      // Listen for workout history updates from real-time sync
      useEffect(() => {
        const handleWorkoutUpdate = () => {
          const todayStr = toLocalISODate(new Date());
          const newScore = computeHealthScoreForDate(dailyIntake, goals, todayStr).score;
          setHealthScore(newScore);
          console.log('🏋️ Health score recalculated after workout update:', newScore);
        };

        window.addEventListener('workout-history-updated', handleWorkoutUpdate);
        return () => window.removeEventListener('workout-history-updated', handleWorkoutUpdate);
      }, [dailyIntake, goals]);

      // Recalculate score when returning from background/screen lock
      useEffect(() => {
        const handleVisibilityChange = () => {
          if (!document.hidden) {
            const todayStr = toLocalISODate(new Date());
            const newScore = computeHealthScoreForDate(dailyIntake, goals, todayStr).score;
            setHealthScore(newScore);
            console.log('👁️ Health score recalculated after returning from background:', newScore);
          }
        };

        document.addEventListener('visibilitychange', handleVisibilityChange);
        return () => document.removeEventListener('visibilitychange', handleVisibilityChange);
      }, [dailyIntake, goals]);

      return (
        <div className="p-6 pb-24">
          <header className="mb-6 bg-white dark:bg-gray-800 p-4 rounded-2xl shadow-md">
            <div className="flex flex-col sm:flex-row sm:items-center justify-between gap-3">
              <div className="flex items-center flex-shrink-0">
              <svg className="w-8 h-8 sm:w-9 sm:h-9 md:w-10 md:h-10 mr-3 text-pink-500" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M4 9h2V7a2 2 0 1 1 4 0v10a2 2 0 1 1-4 0v-2H4V9zm14 0h2v6h-2v2a2 2 0 1 1-4 0V7a2 2 0 1 1 4 0v2zM9 11h6v2H9v-2z" fill="currentColor"/>
              </svg>
              <div>
                <h1 className="truncate text-lg sm:text-2xl md:text-3xl font-bold leading-tight text-gray-800 dark:text-gray-200">FitnessMate - AI Workout Hub</h1>
                <p className="truncate text-xs sm:text-base text-gray-500 dark:text-gray-400">Personalized AI workout plans for home and gym</p>
              </div>
              </div>
              <div className="merch-teaser starry blink text-gray-900 dark:text-white text-xs sm:text-sm md:text-base text-center sm:text-right w-full sm:w-auto sm:max-w-[60%] md:max-w-[50%] whitespace-normal md:whitespace-nowrap leading-tight mt-1 sm:mt-0 mx-auto sm:mx-0 self-center sm:self-auto">
                Look sharp. Merch drops soon
              </div>
            </div>
            {quote && <p className="text-gray-600 dark:text-gray-300 italic mt-2 text-center bg-gray-100 dark:bg-gray-700 p-2 rounded-lg">"{quote}"</p>}
          </header>

          <div className="grid md:grid-cols-2 gap-6 mb-6">
            {/* Health Score Card - Fixed light gradient */}
            <div className="bg-white dark:bg-gray-800 p-6 rounded-2xl shadow-md text-center h-full flex flex-col">
              <h2 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-4">Health Score</h2>
              <div className="flex-grow flex flex-col justify-center">
                <div className="relative w-32 h-32 mx-auto">
                  <svg className="w-full h-full" viewBox="0 0 36 36">
                    <path className="text-gray-200 dark:text-gray-700" strokeWidth="3" fill="none" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831" />
                    <path className="text-green-500" strokeWidth="3" strokeLinecap="round" fill="none" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831" strokeDasharray={`${healthScore}, 100`} />
                  </svg>
                  <div className="absolute inset-0 flex items-center justify-center">
                    <span className="text-3xl font-bold text-green-500">{healthScore}</span>
                  </div>
                </div>
                <p className="text-gray-600 dark:text-gray-400 mt-2">Today's Score / 100</p>
                <div className="text-xs text-gray-500 dark:text-gray-400 mt-2 space-y-1">
                  <p><span className="font-bold text-pink-500">40%</span> Nutrition</p>
                  <p><span className="font-bold text-purple-500">15%</span> Activity</p>
                  <p><span className="font-bold text-purple-500">30%</span> Workout</p>
                  <p><span className="font-bold text-blue-500">15%</span> Hydration</p>
                  <p className="opacity-75">Calories beyond ±10% tolerance applies a 25% penalty to total Nutrition points</p>
                </div>
              </div>
            </div>

            {/* Activity & Water Tracker Card - Fixed light gradient */}
            <div className="bg-white dark:bg-gray-800 p-4 sm:p-6 rounded-2xl shadow-md h-full flex flex-col">
              <h2 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-2 text-center">Activity & Hydration</h2>
              <p className="text-xs text-gray-500 dark:text-gray-400 text-center mb-2">
                <span className="font-semibold">Activity</span> = general movement like walking, brisk walk, cardio, steps (logged with this timer). 
                 <span className="font-semibold"> Workouts</span> are separate.
              </p>
              <div className="flex-grow flex flex-col justify-center space-y-4">
                <ActivityTimer onLogActivity={onLogActivity} />
                <WaterTracker onLogWater={onLogWater} dailyIntake={dailyIntake} goals={goals} />
              </div>
            </div>
          </div>

          <div className="bg-gradient-to-br from-cyan-400 to-pink-500 rounded-2xl p-6 mb-6 text-white shadow-lg">
            <p className="font-semibold">Calories</p>
            <div className="flex items-end my-2">
              <p className="text-5xl font-bold">{Math.round(dailyIntake.calories)}</p>
              <p className="ml-2 mb-1">/ {goals.calories} kcal</p>
            </div>
            <div className="w-full bg-white/30 rounded-full h-2.5 overflow-hidden">
              <div className="bg-white h-2.5 rounded-full max-w-full" style={{ width: `${calorieProgress}%` }}></div>
            </div>
          </div>

          <div className="grid grid-cols-3 gap-4 mb-6">
            <MacroCard title="Protein" value={dailyIntake.protein} goal={goals.protein} unit="g" color="text-blue-500" />
            <MacroCard title="Carbs" value={dailyIntake.carbs} goal={goals.carbs} unit="g" color="text-yellow-500" />
            <MacroCard title="Fat" value={dailyIntake.fat} goal={goals.fat} unit="g" color="text-red-500" />
          </div>

          <div>
            <h2 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-4">Recent Meals</h2>
            {recentMeals.length > 0 ? (
              <div className="space-y-3">
                {recentMeals.map((meal) => (
                  <MealCard key={meal.id} meal={meal} />
                ))}
              </div>
            ) : (
              <div className="text-center text-gray-500 dark:text-gray-400 bg-white dark:bg-gray-800 p-6 rounded-2xl shadow-md">
                <p>No meals logged yet.</p>
                <p>Tap the 'Cal' button to scan your first meal!</p>
              </div>
            )}
          </div>
        </div>
      );
    };

    // Profile Screen Component
    const Profile = ({ isDarkMode, toggleDarkMode, goals, setGoals, setDailyIntake, setRecentMeals, setDailyHistory, setScreen }) => {
      const { user, signOut, updateUserData } = useAuth();
      const [profilePicture, setProfilePicture] = useState(() => {
        // Initialize from localStorage for both signed-in and guest users to avoid placeholder flicker
        const saved = localStorage.getItem('profilePicture');
        return saved || "https://placehold.co/100x100/EAB543/ffffff?text=User";
      });
      const [isGeneratingAvatar, setIsGeneratingAvatar] = useState(false);
      const [notificationsEnabled, setNotificationsEnabled] = useState(() => {
        // For signed-in users, start with default and let remote data load via useEffect
        if (user) {
          return true;
        }
        const saved = localStorage.getItem('notificationsEnabled');
        return saved ? JSON.parse(saved) : true;
      });
      const [backgroundMusicEnabled, setBackgroundMusicEnabled] = useState(() => {
        // For signed-in users, start with default and let remote data load via useEffect
        if (user) {
          return false;
        }
        const saved = localStorage.getItem('backgroundMusicEnabled');
        return saved ? JSON.parse(saved) : false;
      });
      const [showPrivacyModal, setShowPrivacyModal] = useState(false);
      const [showSupportModal, setShowSupportModal] = useState(false);
      const [showAccountModal, setShowAccountModal] = useState(false);
      const [subActive, setSubActive] = useState(() => { try { return JSON.parse(localStorage.getItem('subscriptionActive')||'false'); } catch (_) { return false; } });
      const [aiRemaining, setAiRemaining] = useState({ count: 0, limit: 0 });
      const [supportForm, setSupportForm] = useState({
        fullName: '',
        email: '',
        subject: '',
        message: ''
      });
      const [isSubmittingSupport, setIsSubmittingSupport] = useState(false);
      const [supportSubmissionStatus, setSupportSubmissionStatus] = useState(null);
      const [showBookingModal, setShowBookingModal] = useState(false);
  const [bookingStep, setBookingStep] = useState(1);
  const [selectedDate, setSelectedDate] = useState(null);
  const [selectedTimeSlot, setSelectedTimeSlot] = useState(null);
  const [selectedPackage, setSelectedPackage] = useState(null);
  const [currentMonth, setCurrentMonth] = useState('');
  const [currentYear, setCurrentYear] = useState(2023);
  const [calendarDays, setCalendarDays] = useState([]);
  const [availableTimeSlots, setAvailableTimeSlots] = useState([]);
  
  // Booking History State
  const [bookingHistory, setBookingHistory] = useState([]);
  const [isLoadingBookings, setIsLoadingBookings] = useState(false);
  const [showBookingHistory, setShowBookingHistory] = useState(false);
  const [showMeetingModal, setShowMeetingModal] = useState(false);
  const [currentMeetingLink, setCurrentMeetingLink] = useState('');
  const [bookedSlots, setBookedSlots] = useState([]);
  const [slotsCache, setSlotsCache] = useState({});
  const [isLoadingSlots, setIsLoadingSlots] = useState(false);
  const [confirmationMessage, setConfirmationMessage] = useState(null);
  const [debounceTimer, setDebounceTimer] = useState(null);
  const [abortController, setAbortController] = useState(null);

  // Track if we've already fetched remote AI usage for today in this session
  const aiUsageFetchedForDateRef = useRef(null);

      const computeAiRemaining = React.useCallback(async () => {
        // Get user from auth session directly to avoid stale React state
        let uid = null;
        try {
          if (auth && auth.getSession) {
            const { data: { session } } = await auth.getSession();
            uid = session && session.user ? session.user.id : null;
          }
        } catch (_) {}
        
        const todayISO = typeof toLocalISODate === 'function' ? toLocalISODate(new Date()) : new Date().toISOString().slice(0,10);
        
        // Start from localStorage
        let usage = {};
        try { usage = JSON.parse(localStorage.getItem('aiUsage') || '{}') || {}; } catch (_) {}
        if (!usage[todayISO]) usage[todayISO] = {};
        
        const key = uid || 'anon';
        let count = Number(usage[todayISO][key] || 0);

        // If signed in and we have an 'anon' entry, re-key it to the user and persist (MAX logic)
        if (uid) {
          const anonCount = Number(usage[todayISO]['anon'] || 0);
          const userCount = Number(usage[todayISO][uid] || 0);
          const maxLocal = Math.max(userCount, anonCount);
          if (anonCount > 0 && maxLocal !== userCount) {
            usage[todayISO][uid] = maxLocal;
            try { localStorage.setItem('aiUsage', JSON.stringify(usage)); } catch (_) {}
            // Persist this reconciliation to the backend once
            try { if (typeof db !== 'undefined' && db.updateUser) await db.updateUser(uid, { ai_usage: usage }); } catch (_) {}
            count = maxLocal;
          }
        }

        // Remote fetch once per day when signed in (remote-first; uses MAX with local)
        if (uid && supabase && aiUsageFetchedForDateRef.current !== todayISO) {
          try {
            const { data, error } = await supabase
              .from('users')
              .select('ai_usage')
              .eq('id', uid)
              .single();
            if (!error && data && data.ai_usage) {
              const remote = data.ai_usage || {};
              const dayObj = remote[todayISO] || {};
              let remoteCount = 0;
              if (dayObj && typeof dayObj === 'object') {
                remoteCount = Number(dayObj[uid] || 0);
                if (!remoteCount) {
                  // Fallback to max across keys (handles older 'anon' writes)
                  remoteCount = Math.max(0, ...Object.values(dayObj).map(v => Number(v || 0)));
                }
              }
              const maxCount = Math.max(count, remoteCount);
              if (maxCount !== count) {
                usage[todayISO][uid] = maxCount;
                try { localStorage.setItem('aiUsage', JSON.stringify(usage)); } catch (_) {}
                // Persist authoritative merged value back to DB
                try { if (uid && typeof db !== 'undefined' && db.updateUser) await db.updateUser(uid, { ai_usage: usage }); } catch (_) {}
                count = maxCount;
              }
            }
          } catch (_) { /* ignore network errors */ }
          aiUsageFetchedForDateRef.current = todayISO;
        }

        let isSub = false;
        try { isSub = !!uid && JSON.parse(localStorage.getItem('subscriptionActive') || 'false') === true; } catch (_) { isSub = false; }
        const limit = isSub ? 10 : (uid ? 5 : 3);
        setAiRemaining({ count, limit });
      }, []);

      useEffect(() => {
        computeAiRemaining();
        let off = null;
        if (window.fitmateIAP && typeof window.fitmateIAP.onStatusChange === 'function') {
          off = window.fitmateIAP.onStatusChange((active) => { setSubActive(!!active); computeAiRemaining().catch(() => {}); });
        }
        const onQuota = () => computeAiRemaining().catch(() => {});
        window.addEventListener('ai-quota-exceeded', onQuota);
        const onRemoteSync = () => {
          console.log('🔄 AI quota: userDataSynced event received, recomputing...');
          computeAiRemaining().catch(() => {});
        };
        window.addEventListener('userDataSynced', onRemoteSync);
        // AI usage now syncs via database (realtime listener handles remote updates)
        const onVis = () => { if (!document.hidden) computeAiRemaining().catch(() => {}); };
        document.addEventListener('visibilitychange', onVis);
        const onOpenAccount = () => { try { setShowAccountModal(true); } catch (_) {} };
        const onCloseAccount = () => { try { setShowAccountModal(false); } catch (_) {} };
        window.addEventListener('open-account-modal', onOpenAccount);
        window.addEventListener('close-account-modal', onCloseAccount);
        return () => {
          if (off) off();
          window.removeEventListener('ai-quota-exceeded', onQuota);
          window.removeEventListener('userDataSynced', onRemoteSync);
          document.removeEventListener('visibilitychange', onVis);
          window.removeEventListener('open-account-modal', onOpenAccount);
          window.removeEventListener('close-account-modal', onCloseAccount);
        };
      }, [computeAiRemaining]);

      const fileInputRef = useRef(null);

      // Save profile picture to localStorage whenever it changes (with quota handling)
      useEffect(() => {
        // Only save to localStorage for non-signed-in users
        if (profilePicture && !user) {
          try {
            setLocalStorageWithSync('profilePicture', profilePicture);
          } catch (error) {
            if (error.name === 'QuotaExceededError') {
              console.warn('Profile picture too large for localStorage, skipping storage');
            }
          }
        }
      }, [profilePicture, user]);

      // Sync profile picture only on explicit user actions (upload/generate avatar)
      // Removed automatic syncing effect to prevent overwriting remote data with placeholders
      // useEffect(() => {
      //   if (user && profilePicture) {
      //     updateUserData({ profile_picture: profilePicture });
      //   }
      // }, [profilePicture, user]);

      // Listen for remote data sync and update profile picture
      useEffect(() => {
        const handleUserDataSync = (event) => {
          // For signed-in users, only use remote data from the event payload
          if (user && event?.detail?.userData?.profile_picture) {
            const remoteProfilePicture = event.detail.userData.profile_picture;
            if (remoteProfilePicture !== profilePicture) {
              setProfilePicture(remoteProfilePicture);
              console.log('✅ Profile picture synced from remote data');
            }
          } else if (!user) {
            // For non-signed-in users, use localStorage as before
            const syncedProfilePicture = localStorage.getItem('profilePicture');
            if (syncedProfilePicture && syncedProfilePicture !== profilePicture) {
              setProfilePicture(syncedProfilePicture);
              console.log('✅ Profile picture synced from localStorage');
            }
          }
        };

        window.addEventListener('userDataSynced', handleUserDataSync);
        return () => window.removeEventListener('userDataSynced', handleUserDataSync);
      }, [profilePicture, user]);

      // Listen for remote data sync and update notifications setting
      useEffect(() => {
        const handleUserDataSync = () => {
          const syncedNotifications = localStorage.getItem('notificationsEnabled');
          if (syncedNotifications) {
            const notificationsData = JSON.parse(syncedNotifications);
            if (notificationsData !== notificationsEnabled) {
              setNotificationsEnabled(notificationsData);
              console.log('✅ Notifications setting synced in Profile component');
            }
          }
        };

        window.addEventListener('userDataSynced', handleUserDataSync);
        return () => window.removeEventListener('userDataSynced', handleUserDataSync);
      }, [notificationsEnabled]);

      // Listen for remote data sync and update background music setting
      useEffect(() => {
        const handleUserDataSync = () => {
          const syncedBackgroundMusic = localStorage.getItem('backgroundMusicEnabled');
          if (syncedBackgroundMusic) {
            const backgroundMusicData = JSON.parse(syncedBackgroundMusic);
            if (backgroundMusicData !== backgroundMusicEnabled) {
              setBackgroundMusicEnabled(backgroundMusicData);
              console.log('✅ Background music setting synced in Profile component');
            }
          }
        };

        window.addEventListener('userDataSynced', handleUserDataSync);
        return () => window.removeEventListener('userDataSynced', handleUserDataSync);
      }, [backgroundMusicEnabled]);

      // Load profile picture from localStorage only for non-signed-in users
      useEffect(() => {
        if (!user) {
          const savedProfilePicture = localStorage.getItem('profilePicture');
          if (savedProfilePicture && savedProfilePicture !== profilePicture) {
            setProfilePicture(savedProfilePicture);
          }
        }
      }, [user, profilePicture]);

      // Save notifications setting to localStorage
      useEffect(() => {
        localStorage.setItem('notificationsEnabled', JSON.stringify(notificationsEnabled));
      }, [notificationsEnabled]);

      // Save background music setting to localStorage
      useEffect(() => {
        localStorage.setItem('backgroundMusicEnabled', JSON.stringify(backgroundMusicEnabled));
      }, [backgroundMusicEnabled]);

      // Initialize background music on component mount
      useEffect(() => {
        const audio = document.getElementById('background-music');
        if (audio && backgroundMusicEnabled) {
          // Set volume to a reasonable level
          audio.volume = 0.3;
          audio.play().catch(e => console.log('Audio autoplay failed:', e));
        }
      }, []);

      // Control background music when setting changes
      useEffect(() => {
        const audio = document.getElementById('background-music');
        if (audio) {
          audio.volume = 0.3;
          if (backgroundMusicEnabled) {
            // Try to play, but don't force it on mobile without user interaction
            audio.play().catch(e => {
              console.log('Audio autoplay prevented:', e);
              // On mobile, we'll wait for user interaction instead of showing alert here
            });
          } else {
            audio.pause();
          }
        }
      }, [backgroundMusicEnabled]);

      const toggleNotifications = () => {
        setNotificationsEnabled(prev => {
          const newValue = !prev;
          // Update Firebase if user is authenticated
          if (user) {
            updateUserData({ notificationsEnabled: newValue });
          }
          // Show user feedback
          if (newValue) {
            alert('✅ Notifications enabled! You\'ll receive fitness reminders and updates.');
          } else {
            alert('🔕 Notifications disabled. You won\'t receive any alerts.');
          }
          return newValue;
        });      };

      const toggleBackgroundMusic = () => {
        setBackgroundMusicEnabled(prev => {
          const newValue = !prev;
          // Background music setting is stored locally only (no database sync needed)
          // Control background music
          const audio = document.getElementById('background-music');
          if (audio) {
            if (newValue) {
              // For mobile browsers, we need user interaction to play audio
              audio.play().catch(e => {
                console.log('Audio play failed (likely due to autoplay policy):', e);
                // Show user-friendly message for mobile
                if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
                  alert('🎵 Tap anywhere on the screen to start background music!');
                  // Add click listener to start music on next user interaction
                  const startMusicOnClick = () => {
                    audio.play().catch(e => console.log('Audio play still failed:', e));
                    document.removeEventListener('click', startMusicOnClick);
                    document.removeEventListener('touchstart', startMusicOnClick);
                  };
                  document.addEventListener('click', startMusicOnClick, { once: true });
                  document.addEventListener('touchstart', startMusicOnClick, { once: true });
                }
              });
            } else {
              audio.pause();
            }
          }
          return newValue;
        });
      };

      const handleGoalChange = (key, value) => {
        const newGoals = { ...goals, [key]: Number(value) };
        setGoals(newGoals);
        // Update Firebase if user is authenticated
        if (user) {
          updateUserData({ goals: newGoals });
        }
      };

      const handleImageUpload = (event) => {
        const file = event.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (e) => {
            // Compress image before storing
            const img = new Image();
            img.onload = () => {
              // Create canvas for compression
              const canvas = document.createElement('canvas');
              // Set max dimensions (reduce size)
              const MAX_WIDTH = 400;
              const MAX_HEIGHT = 400;
              let width = img.width;
              let height = img.height;
              
              // Calculate new dimensions while maintaining aspect ratio
              if (width > height) {
                if (width > MAX_WIDTH) {
                  height *= MAX_WIDTH / width;
                  width = MAX_WIDTH;
                }
              } else {
                if (height > MAX_HEIGHT) {
                  width *= MAX_HEIGHT / height;
                  height = MAX_HEIGHT;
                }
              }
              
              // Set canvas dimensions and draw resized image
              canvas.width = width;
              canvas.height = height;
              const ctx = canvas.getContext('2d');
              ctx.drawImage(img, 0, 0, width, height);
              
              // Convert to compressed data URL (0.7 quality)
              const compressedDataUrl = canvas.toDataURL('image/jpeg', 0.7);
              setProfilePicture(compressedDataUrl);
              
              // Sync to remote if user is signed in
              if (user) {
                updateUserData({ profile_picture: compressedDataUrl });
              }
            };
            img.src = e.target.result;
          };
          reader.readAsDataURL(file);
        }
      };

      const handleSignOut = async () => {
        try {
          await signOut();
          // Close modal - user state will be cleared by AuthProvider's auth listener
          setShowAccountModal(false);
          // Clear any additional local storage data if needed
          localStorage.removeItem('userPreferences');
          localStorage.removeItem('recentMeals');
          localStorage.removeItem('dailyIntake');
          localStorage.removeItem('fitmate_user');
          localStorage.removeItem('fitmate_user_data');
          alert('✅ Successfully signed out!');
        } catch (error) {
          alert('❌ Error signing out: ' + error.message);
        }
      };

      // Booking History Functions
      // Check if a time slot is available across all users
      const checkSlotAvailability = async (date, timeSlot) => {
        if (!supabase) {
          console.log('Database not available');
          return false;
        }
        
        try {
          // Use Supabase to get global bookings for the date
          const globalBookings = await db.getGlobalBookings(date);
          
          if (!globalBookings || globalBookings.length === 0) {
            return true; // No bookings exist, slot is available
          }
          
          // Check if the time slot is already booked
          const isBooked = globalBookings.some(booking => 
            booking.time === timeSlot && booking.status !== 'cancelled'
          );
          
          return !isBooked; // Return true if not booked, false if booked
        } catch (error) {
          console.error('Error checking slot availability:', error);
          return false; // Assume unavailable on error for safety
        }
      };

      // Fetch booked slots for a specific date
      // Memoization cache for Supabase requests
      const requestCache = new Map();
      const CACHE_DURATION = 30000; // 30 seconds
      
      const fetchBookedSlotsForDate = async (date, signal = null) => {
        if (!db) {
          console.log('Database not available, using fallback');
          // Return mock data for testing when Firebase is unavailable
          return [];
        }
        
        // Check cache first
        const cacheKey = `booked-slots-${date}`;
        const cached = requestCache.get(cacheKey);
        if (cached && Date.now() - cached.timestamp < CACHE_DURATION) {
          return cached.data;
        }
        
        try {
          // Check if request was cancelled
          if (signal && signal.aborted) {
            throw new Error('Request cancelled');
          }
          
          // Use Supabase to get global bookings for the date
          const bookedTimes = [];
          
          try {
            // Add timeout to prevent infinite loading
            const timeoutPromise = new Promise((_, reject) => {
              setTimeout(() => reject(new Error('Supabase query timeout')), 10000);
            });
            
            const bookingsPromise = db.getGlobalBookings(date);
            
            const globalBookings = await Promise.race([
              bookingsPromise,
              timeoutPromise
            ]);
            
            // Check again after async operation
            if (signal && signal.aborted) {
              throw new Error('Request cancelled');
            }
            
            if (globalBookings && globalBookings.length > 0) {
              // Use global bookings for faster lookup
              globalBookings.forEach(booking => {
                if (booking.status !== 'cancelled') {
                  bookedTimes.push(booking.time);
                }
              });
            }
          } catch (queryError) {
            console.warn('Error querying global bookings:', queryError);
            // Continue with empty booked times if query fails
          }
          
          // Cache the result
          requestCache.set(cacheKey, {
            data: bookedTimes,
            timestamp: Date.now()
          });
          
          return bookedTimes;
        } catch (error) {
          if (error.message.includes('timeout')) {
            console.warn('Supabase query timed out, using empty slots');
          } else {
            console.error('Error fetching booked slots:', error);
          }
          return [];
        }
      };

      const fetchBookingHistory = async (retryCount = 0) => {
        if (!user || !db) {
          console.log('User not authenticated or database not available');
          return;
        }
        
        setIsLoadingBookings(true);
        try {
          const bookingsData = await db.getBookings(user.id);
          
          if (bookingsData && bookingsData.length > 0) {
            // Process bookings and sort by creation date (newest first)
            const bookingsArray = bookingsData.map(booking => {
              // Replace old Jitsi or Daily.co links with new Whereby URL
              if (booking.meeting_link && (booking.meeting_link.includes('jit.si') || booking.meeting_link.includes('daily.co'))) {
                booking.meeting_link = 'https://fitness-mate.whereby.com/meeting410ee91d-38a8-4636-bcc8-5b9b86035b45';
              }
              
              return booking;
            }).sort((a, b) => new Date(b.created_at || 0) - new Date(a.created_at || 0));
            
            setBookingHistory(bookingsArray);
          } else {
            setBookingHistory([]);
          }
        } catch (error) {
          console.error('Error fetching booking history:', error);
          
          // Retry logic for network errors
          if (retryCount < 2 && (error.message?.includes('NetworkError') || error.message?.includes('fetch'))) {
            console.log(`🔄 Retrying booking history fetch (attempt ${retryCount + 1}/3)...`);
            setTimeout(() => {
              fetchBookingHistory(retryCount + 1);
            }, 1000 * (retryCount + 1)); // Exponential backoff
            return;
          }
          
          // Only show error alert if all retries failed
          if (retryCount >= 2) {
            alert('❌ Error loading booking history. Please try again.');
          }
        } finally {
          // Always stop loading, regardless of retry count
          setIsLoadingBookings(false);
        }
      };
      
      // Load booking history when user changes or component mounts
      useEffect(() => {
        if (user) {
          fetchBookingHistory();
        } else {
          setBookingHistory([]);
        }
      }, [user]);
      
      const toggleBookingHistory = () => {
        setShowBookingHistory(prev => !prev);
        if (!showBookingHistory && bookingHistory.length === 0) {
          fetchBookingHistory();
        }
      };


      const openAccountModal = () => setShowAccountModal(true);
      const closeAccountModal = () => setShowAccountModal(false);

      const openPrivacyModal = () => {
        setShowPrivacyModal(true);
      };

      const closePrivacyModal = () => {
        setShowPrivacyModal(false);
      };

      const openSupportModal = () => {
        setShowSupportModal(true);
        setSupportSubmissionStatus(null);
      };

      const closeSupportModal = () => {
        setShowSupportModal(false);
        setSupportForm({ fullName: '', email: '', subject: '', message: '' });
        setSupportSubmissionStatus(null);
      };

      const handleSupportFormChange = (field, value) => {
        setSupportForm(prev => ({ ...prev, [field]: value }));
      };

      const openBookingModal = () => {
    setBookingStep(1);
    setSelectedDate(null);
    setSelectedTimeSlot(null);
    setSelectedPackage(null);
    initializeCalendar();
    setShowBookingModal(true);
  };
  
  const closeBookingModal = () => {
    setShowBookingModal(false);
    setBookingStep(1);
    setSelectedDate(null);
    setSelectedTimeSlot(null);
    setSelectedPackage(null);
  };
  
  const initializeCalendar = () => {
    const today = new Date();
    const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
    
    setCurrentMonth(monthNames[today.getMonth()]);
    setCurrentYear(today.getFullYear());
    
    generateCalendarDays(today.getMonth(), today.getFullYear());
  };
  
  const generateCalendarDays = (month, year) => {
    const firstDay = new Date(year, month, 1).getDay();
    const daysInMonth = new Date(year, month + 1, 0).getDate();
    const daysInPrevMonth = new Date(year, month, 0).getDate();
    
    const days = [];
    
    // Previous month days
    for (let i = firstDay - 1; i >= 0; i--) {
      days.push({
        dayOfMonth: daysInPrevMonth - i,
        isCurrentMonth: false,
        isAvailable: false,
        date: new Date(year, month - 1, daysInPrevMonth - i)
      });
    }
    
    // Current month days
    for (let i = 1; i <= daysInMonth; i++) {
      const date = new Date(year, month, i);
      const isAvailable = date >= new Date(); // Available if not in the past (including Sundays)
      
      days.push({
        dayOfMonth: i,
        isCurrentMonth: true,
        isAvailable,
        date,
        dayName: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][date.getDay()],
        monthName: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'][date.getMonth()],
        year: date.getFullYear()
      });
    }
    
    // Next month days
    const remainingDays = 42 - days.length; // 6 rows of 7 days
    for (let i = 1; i <= remainingDays; i++) {
      days.push({
        dayOfMonth: i,
        isCurrentMonth: false,
        isAvailable: false,
        date: new Date(year, month + 1, i)
      });
    }
    
    setCalendarDays(days);
  };
  
  const changeMonth = (direction) => {
    const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
    let newMonthIndex = monthNames.indexOf(currentMonth) + direction;
    let newYear = currentYear;
    
    if (newMonthIndex < 0) {
      newMonthIndex = 11;
      newYear--;
    } else if (newMonthIndex > 11) {
      newMonthIndex = 0;
      newYear++;
    }
    
    setCurrentMonth(monthNames[newMonthIndex]);
    setCurrentYear(newYear);
    generateCalendarDays(newMonthIndex, newYear);
    
    // Preload data for adjacent months
    preloadAdjacentMonths(newMonthIndex, newYear, monthNames);
  };
  
  const preloadAdjacentMonths = async (monthIndex, year, monthNames) => {
    // Preload previous month
    let prevMonthIndex = monthIndex - 1;
    let prevYear = year;
    if (prevMonthIndex < 0) {
      prevMonthIndex = 11;
      prevYear--;
    }
    
    // Preload next month
    let nextMonthIndex = monthIndex + 1;
    let nextYear = year;
    if (nextMonthIndex > 11) {
      nextMonthIndex = 0;
      nextYear++;
    }
    
    // Preload first few days of each adjacent month
    const preloadDays = [1, 2, 3, 15]; // Sample key dates
    
    for (const day of preloadDays) {
      // Previous month
      const prevDateString = `${monthNames[prevMonthIndex]} ${day}, ${prevYear}`;
      if (!slotsCache[prevDateString]) {
        try {
          await fetchBookedSlotsForDate(prevDateString);
        } catch (e) {
          // Silently fail preloading
        }
      }
      
      // Next month
      const nextDateString = `${monthNames[nextMonthIndex]} ${day}, ${nextYear}`;
      if (!slotsCache[nextDateString]) {
        try {
          await fetchBookedSlotsForDate(nextDateString);
        } catch (e) {
          // Silently fail preloading
        }
      }
    }
  };
  
  const selectDate = async (day) => {
    setSelectedDate(day);
    
    // Cancel any ongoing request
    if (abortController) {
      abortController.abort();
    }
    
    // Clear existing timer
    if (debounceTimer) {
      clearTimeout(debounceTimer);
    }
    
    // Set new timer for debounced slot generation
    const timer = setTimeout(async () => {
      await generateTimeSlots(day);
    }, 300);
    
    setDebounceTimer(timer);
  };
  
  const generateTimeSlots = async (day) => {
    const dateString = `${day.monthName} ${day.dayOfMonth}, ${day.year}`;
    
    // Create new AbortController for this request
    const controller = new AbortController();
    setAbortController(controller);
    
    // Clear ALL cached slots to ensure changes apply to all dates
    Object.keys(localStorage).forEach(key => {
      if (key.startsWith('fitmate-slots-')) {
        localStorage.removeItem(key);
      }
    });
    
    // Check localStorage cache first
    const localCacheKey = `fitmate-slots-${dateString}`;
    const localCache = localStorage.getItem(localCacheKey);
    
    if (localCache) {
      try {
        const cached = JSON.parse(localCache);
        // Check if cache is still valid (1 hour expiration)
        if (Date.now() - cached.timestamp < 3600000) {
          setAvailableTimeSlots(cached.slots);
          setBookedSlots(cached.bookedTimes);
          // Update memory cache too
          setSlotsCache(prev => ({
            ...prev,
            [dateString]: { slots: cached.slots, bookedTimes: cached.bookedTimes }
          }));
          return;
        } else {
          // Remove expired cache
          localStorage.removeItem(localCacheKey);
        }
      } catch (e) {
        localStorage.removeItem(localCacheKey);
      }
    }
    
    // Check memory cache
    if (slotsCache[dateString]) {
      setAvailableTimeSlots(slotsCache[dateString].slots);
      setBookedSlots(slotsCache[dateString].bookedTimes);
      return;
    }
    
    setIsLoadingSlots(true);
    
    try {
      // Generate rolling 45-minute slots from 6:00 to before 21:00
      const slots = [];
      const startHour = 6;
      const endHour = 21; // end boundary (exclusive)
      let minutes = startHour * 60;
      const endMinutes = endHour * 60;
      while (minutes < endMinutes) {
        const hour24 = Math.floor(minutes / 60);
        const mins = minutes % 60;
        const period = hour24 >= 12 ? 'PM' : 'AM';
        const hour12 = hour24 % 12 === 0 ? 12 : hour24 % 12;
        const minsStr = String(mins).padStart(2, '0');
        slots.push(`${hour12}:${minsStr} ${period} EST/EDT`);
        minutes += 45;
      }
      
      // Fetch booked slots for this date
      const bookedTimes = await fetchBookedSlotsForDate(dateString, controller.signal);
      
      // Cache the results in memory and localStorage
      const cacheData = { slots, bookedTimes, timestamp: Date.now() };
      
      setSlotsCache(prev => ({
        ...prev,
        [dateString]: { slots, bookedTimes }
      }));
      
      // Save to localStorage with expiration
      try {
        setLocalStorageWithSync(`fitmate-slots-${dateString}`, JSON.stringify(cacheData));
      } catch (e) {
        console.warn('Failed to save to localStorage:', e);
      }
      
      setBookedSlots(bookedTimes);
      setAvailableTimeSlots(slots);
    } catch (error) {
      // Don't log errors for cancelled requests
      if (error.message !== 'Request cancelled') {
        console.error('Error generating time slots:', error);
      }
    } finally {
      // Only update loading state if request wasn't cancelled
      if (!controller.signal.aborted) {
        setIsLoadingSlots(false);
      }
    }
  };
  
  const selectTimeSlot = (slot) => {
    setSelectedTimeSlot(slot);
  };
  
  const selectPackage = (packageType) => {
    setSelectedPackage(packageType);
  };
  
  const handleBookingSubmit = async () => {
    if (!selectedDate || !selectedTimeSlot || !selectedPackage) {
      alert('Please complete all booking steps');
      return;
    }
    
    // Check slot availability before proceeding
    const dateString = `${selectedDate.monthName} ${selectedDate.dayOfMonth}, ${selectedDate.year}`;
    const isAvailable = await checkSlotAvailability(dateString, selectedTimeSlot);
    
    if (!isAvailable) {
      alert('❌ Sorry, this time slot is already booked. Please select a different time.');
      return;
    }
    
    if (selectedPackage === 'free') {
      // Handle free session booking
      handleFreeSessionBooking();
    } else {
      // Handle paid session booking
      handlePaidSessionBooking();
    }
  };
  
  const handleFreeSessionBooking = () => {
    // Prepare booking details
    const bookingDetails = {
      date: `${selectedDate.monthName} ${selectedDate.dayOfMonth}, ${selectedDate.year}`,
      time: selectedTimeSlot,
      package: 'Free Trial Session',
      email: user?.email || prompt('Please enter your email address:') || 'user@example.com',
      type: 'free',
      sessions: 1,
      price: 0
    };
    
    console.log('Free session booking:', bookingDetails);
    
    // Use the single Whereby meeting room for all sessions
       const meetingId = `FitmateFree${Date.now()}${Math.random().toString(36).substr(2, 9)}`;
       const wherebyLink = `https://fitness-mate.whereby.com/meeting410ee91d-38a8-4636-bcc8-5b9b86035b45`;
    
    // Store booking in Supabase
    if (user && db) {
      const bookingData = {
        date: bookingDetails.date,
        time: bookingDetails.time,
        service: bookingDetails.package,
        duration: 45, // 45-minute sessions
        price: bookingDetails.price,
        status: 'confirmed',
        meeting_link: wherebyLink
      };
      
      // Save to user's bookings in Supabase
      db.addBooking(user.id, bookingData)
        .then(() => {
          console.log('Free booking saved to Supabase successfully');
          // Clear slots cache to ensure fresh data on next load
          setSlotsCache({});
        })
        .catch((error) => {
          console.error('Error saving free booking to Supabase:', error);
        });
    }
    
    // Send confirmation email using EmailJS
    const templateParams = {
      to_email: bookingDetails.email,
      to_name: user?.displayName || 'Fitness Enthusiast',
      session_date: bookingDetails.date,
      session_time: bookingDetails.time,
      session_type: bookingDetails.package,
      meeting_link: wherebyLink
    };
    
    // Show immediate confirmation while email is being sent
    setConfirmationMessage({
      type: 'success',
      title: 'Booking Confirmed!',
      message: `Your free session has been booked for ${bookingDetails.date} at ${bookingDetails.time}. Confirmation email is being sent...`
    });
    closeBookingModal();
    
    // Send the email using EmailJS with timeout
    const emailTimeout = new Promise((_, reject) => {
      setTimeout(() => reject(new Error('Email timeout')), 15000);
    });
    
    Promise.race([
      emailjs.send(
        'service_94q9wl7', // Replace with your EmailJS service ID
        'template_3oqo92k', // Replace with your EmailJS template ID
        templateParams
      ),
      emailTimeout
    ]).then(function(response) {
      console.log('Invoice email sent successfully:', response);
      // Update confirmation message to show email was sent
      setConfirmationMessage({
        type: 'success',
        title: 'Booking Confirmed!',
        message: `Your free session has been booked for ${bookingDetails.date} at ${bookingDetails.time}. Confirmation email sent successfully!`
      });
    }).catch(function(error) {
      console.error('Email sending failed or timed out:', error);
      // Update confirmation message to show email issue
      setConfirmationMessage({
        type: 'warning',
        title: 'Booking Confirmed',
        message: 'Your session was booked successfully, but there was an issue sending the confirmation email. Please contact support if needed.'
      });
    });
    
    // Log what is being sent
    console.log('Email being sent with session details:', {
      to: bookingDetails.email,
      subject: 'Your Free Fitness Session is Confirmed!',
      body: `
        Hi there,
        
        Your free fitness session is confirmed for ${bookingDetails.date} at ${bookingDetails.time}.
        
        Join link: ${wherebyLink}
        
        We look forward to seeing you!
        
        The Fitmate Team
      `
    });
  };
  
  const handlePaidSessionBooking = () => {
    // Set up the bundle based on the selected package
    const bundle = selectedPackage === 'basic' ? 
      { sessions: 5, price: 100 } : 
      { sessions: 10, price: 150 };
    
    // Prepare booking details
    const bookingDetails = {
      date: `${selectedDate.monthName} ${selectedDate.dayOfMonth}, ${selectedDate.year}`,
      time: selectedTimeSlot,
      package: selectedPackage === 'basic' ? 'Basic Package' : 'Premium Package',
      sessions: bundle.sessions,
      price: bundle.price,
      email: user?.email || prompt('Please enter your email address:') || 'user@example.com',
      type: 'paid'
    };
    
    // Use the single Whereby meeting room for all sessions
       const meetingId = `FitmatePaid${Date.now()}${Math.random().toString(36).substr(2, 9)}`;
       const wherebyLink = `https://fitness-mate.whereby.com/meeting410ee91d-38a8-4636-bcc8-5b9b86035b45`;
    
    // Store booking in Firebase
    if (user && db) {
      const bookingData = {
        date: bookingDetails.date,
        time: bookingDetails.time,
        service: bookingDetails.package,
        duration: 45, // 45-minute sessions
        price: bookingDetails.price,
        status: 'Reserved',
        meeting_link: wherebyLink
      };
      
      // Save to user's bookings in Supabase
      db.addBooking(user.id, bookingData)
        .then(() => {
          console.log('Paid booking saved to Supabase successfully');
          // Clear slots cache to ensure fresh data on next load
          setSlotsCache({});
        })
        .catch((error) => {
          console.error('Error saving paid booking to Supabase:', error);
        });
    }
    
    // Prepare email template parameters with invoice details
    const invoiceNumber = `INV-${Date.now()}`;
    const dueDate = new Date();
    dueDate.setDate(dueDate.getDate() + 7); // 7 days from now
    
    const templateParams = {
      to_email: bookingDetails.email,
      to_name: user?.displayName || 'Fitness Enthusiast',
      session_date: bookingDetails.date,
      session_time: bookingDetails.time,
      session_type: bookingDetails.package,
      sessions_count: bookingDetails.sessions,
      amount_due: bookingDetails.price,
      invoice_number: invoiceNumber,
      due_date: dueDate.toLocaleDateString(),
      meeting_link: wherebyLink,
      payment_instructions: 'Please send payment via bank transfer (SEPA domestic or international Swift transfer), PayPal, or contact us for other payment methods. Your session will be confirmed once payment is received.',
      bank_details: 'Name: Rahim Dhannani | IBAN: BE45 9670 9853 5289 | Swift/BIC: TRWIBEB1XXX | Bank: Wise, Rue du Trône 100, 3rd floor, Brussels, 1050, Belgium',
      paypal_email: 'payments@fitmate.com'
    };
    
    // Show immediate confirmation while email is being sent
    setConfirmationMessage({
      type: 'success',
      title: 'Invoice Generated!',
      message: `Booking reserved! You've selected ${bookingDetails.sessions} sessions for $${bookingDetails.price}. Invoice and payment instructions are being sent...`
    });
    closeBookingModal();
    
    // Send the email using EmailJS with timeout
    const paidEmailTimeout = new Promise((_, reject) => {
      setTimeout(() => reject(new Error('Email timeout')), 15000);
    });
    
    Promise.race([
      emailjs.send(
        'service_94q9wl7', // Replace with your EmailJS service ID
        'template_3oqo92k', // Replace with your EmailJS template ID
        templateParams
      ),
      paidEmailTimeout
    ]).then(function(response) {
      console.log('Invoice email sent successfully:', response);
      // Update confirmation message to show email was sent
      setConfirmationMessage({
        type: 'success',
        title: 'Invoice Sent!',
        message: `Booking reserved! You've selected ${bookingDetails.sessions} sessions for $${bookingDetails.price}. Invoice and payment instructions sent successfully!`,
        paymentDetails: {
          amount: bookingDetails.price,
          sessions: bookingDetails.sessions,
          invoiceNumber: invoiceNumber,
          bankDetails: 'Name: Rahim Dhannani | IBAN: BE45 9670 9853 5289 | Swift/BIC: TRWIBEB1XXX',
          bankAddress: 'Bank: Wise, Rue du Trône 100, 3rd floor, Brussels, 1050, Belgium',
          paypalEmail: 'payments@fitmate.com'
        }
      });
    }).catch(function(error) {
      console.error('Email sending failed or timed out:', error);
      // Update confirmation message to show email issue
      setConfirmationMessage({
        type: 'warning',
        title: 'Booking Reserved',
        message: 'Your booking was reserved successfully, but there was an issue sending the invoice email. Please contact support for payment instructions.'
      });
    });
  };
      

      


      const validateEmail = (email) => {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
      };

      const handleSupportSubmit = async (e) => {
        e.preventDefault();
        
        // Validation
        if (!supportForm.fullName.trim()) {
          alert('Please enter your full name.');
          return;
        }
        
        if (!supportForm.email.trim() || !validateEmail(supportForm.email)) {
          alert('Please enter a valid email address.');
          return;
        }
        
        if (!supportForm.subject.trim()) {
          alert('Please enter a subject.');
          return;
        }
        
        if (!supportForm.message.trim()) {
          alert('Please enter your message.');
          return;
        }

        setIsSubmittingSupport(true);
        
        try {
          // Create URLSearchParams directly for Netlify form submission
          const formData = new URLSearchParams();
          formData.append('form-name', 'support-form');
          formData.append('full-name', supportForm.fullName);
          formData.append('email', supportForm.email);
          formData.append('subject', supportForm.subject);
          formData.append('message', supportForm.message);
          
          const response = await fetch('/', {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: formData.toString()
          });
          
          if (response.ok) {
            setSupportSubmissionStatus('success');
            setSupportForm({ fullName: '', email: '', subject: '', message: '' });
          } else {
            throw new Error('Form submission failed');
          }
        } catch (error) {
          console.error('Support form submission error:', error);
          setSupportSubmissionStatus('error');
        } finally {
          setIsSubmittingSupport(false);
        }
      };

      const generateAIAvatar = async () => {
        // Show prompt to collect user preferences
        const gender = prompt("What gender would you like for your avatar? (male/female/non-binary)", "male");
        if (!gender) return; // User cancelled
        
        const style = prompt("What style do you prefer? (professional/casual/sporty/artistic)", "sporty");
        if (!style) return; // User cancelled
        
        const hairColor = prompt("Preferred hair color? (brown/black/blonde/red/gray/other)", "brown");
        if (!hairColor) return; // User cancelled
        
        setIsGeneratingAvatar(true);
        try {
          const prompt = `Create a professional, friendly avatar for a fitness app user with these specifications:
          - Gender: ${gender}
          - Style: ${style} 
          - Hair color: ${hairColor}
          - Clean, modern design
          - Suitable for a health and fitness application
          - Colorful but professional
          - Square format, suitable for profile picture
          - Cartoon or illustrated style, not photorealistic
          - Should look healthy, fit, and approachable
          - Age range: 25-35 years old
          
          Generate a detailed description for an avatar that represents health, fitness, and wellness with the specified characteristics.`;

            const response = await fetch(getDirectGeminiConfig().url, {
            method: 'POST',
            headers: getDirectGeminiConfig().headers,
            body: JSON.stringify({
              model: OPENROUTER_QWEN_MODEL,
              messages: [{ role: 'user', content: prompt }]
            })
          });

          if (!response.ok) {
            throw new Error(`API Error: ${response.status}`);
          }

          const result = await response.json();
          const description = (result.choices?.[0]?.message?.content || '');
          
          // Use the AI description with user preferences as seed for avatar generation
          const seed = `${gender}-${style}-${hairColor}-${description.substring(0, 30)}`;
          const avatarUrl = `https://api.dicebear.com/7.x/avataaars/svg?seed=${encodeURIComponent(seed)}&backgroundColor=b6e3f4,c0aede,d1d4f9,ffd5dc,ffdfbf&hair=${hairColor === 'blonde' ? 'blonde' : hairColor === 'red' ? 'red' : 'brown'}`;
          
          setProfilePicture(avatarUrl);
          
          // Sync to remote if user is signed in
          if (user) {
            updateUserData({ profile_picture: avatarUrl });
          }
        } catch (error) {
          console.error('Avatar generation error:', error);
          alert('Failed to generate avatar. Please try again.');
        } finally {
          setIsGeneratingAvatar(false);
        }
      };

      return (
        <div className="p-6 pb-24">
          {showBookingModal && (
            <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4">
              <div className="bg-white dark:bg-gray-900 rounded-2xl shadow-2xl w-full max-w-4xl max-h-[90vh] flex flex-col transform transition-all opacity-100 scale-100">
                <div className="flex justify-between items-center p-4 border-b border-gray-200 dark:border-gray-700 flex-shrink-0">
                  <h3 className="text-2xl font-bold text-gray-800 dark:text-gray-200">Book Your Session</h3>
                  <button onClick={closeBookingModal} className="text-gray-500 hover:text-gray-800 dark:text-gray-400 dark:hover:text-gray-200 p-2 rounded-full bg-gray-100 dark:bg-gray-800">
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" /></svg>
                  </button>
                </div>
                <div className="p-2 md:p-6 flex-1 overflow-y-auto">
                  {/* Custom Booking Calendar */}
                  <div className="booking-calendar-container">
                    {/* Step 1: Date Selection */}
                    {bookingStep === 1 && (
                      <div className="booking-step">
                        <h3 className="text-xl font-semibold text-gray-800 dark:text-gray-200 mb-4">Select a Date</h3>
                        <div className="calendar-container">
                          <div className="calendar-header flex justify-between items-center mb-4">
                            <button 
                              onClick={() => changeMonth(-1)} 
                              className="p-2 rounded-full bg-gray-100 dark:bg-gray-800 text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-700"
                            >
                              <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fillRule="evenodd" d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z" clipRule="evenodd" />
                              </svg>
                            </button>
                            <h4 className="text-lg font-medium text-gray-800 dark:text-gray-200">{currentMonth} {currentYear}</h4>
                            <button 
                              onClick={() => changeMonth(1)} 
                              className="p-2 rounded-full bg-gray-100 dark:bg-gray-800 text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-700"
                            >
                              <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fillRule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clipRule="evenodd" />
                              </svg>
                            </button>
                          </div>
                          
                          <div className="calendar-grid grid grid-cols-7 gap-1 mb-6">
                            {['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].map((day, index) => (
                              <div key={index} className="calendar-day-header text-center text-sm font-medium text-gray-500 dark:text-gray-400 py-2">
                                {day}
                              </div>
                            ))}
                            
                            {calendarDays.map((day, index) => (
                              <div 
                                key={index} 
                                className={`
                                  calendar-day text-center py-2 rounded-lg cursor-pointer
                                  ${day.isCurrentMonth ? 'text-gray-800 dark:text-gray-200' : 'text-gray-400 dark:text-gray-600'} 
                                  ${day.isAvailable ? 'hover:bg-pink-100 dark:hover:bg-pink-900' : 'opacity-50 cursor-not-allowed'}
                                  ${selectedDate && day.date.toDateString() === selectedDate.date.toDateString() ? 'bg-pink-500 text-white' : ''}
                                `}
                                onClick={() => day.isAvailable ? selectDate(day) : null}
                              >
                                {day.dayOfMonth}
                              </div>
                            ))}
                          </div>
                          
                          <button 
                            className={`
                              w-full py-3 rounded-lg font-medium text-white
                              ${selectedDate ? 'bg-pink-500 hover:bg-pink-600' : 'bg-gray-300 dark:bg-gray-700 cursor-not-allowed'}
                            `}
                            disabled={!selectedDate} 
                            onClick={() => setBookingStep(2)}
                          >
                            Next: Select Time
                          </button>
                        </div>
                      </div>
                    )}
                    
                    {/* Step 2: Time Selection */}
                    {bookingStep === 2 && (
                      <div className="booking-step">
                        <h3 className="text-xl font-semibold text-gray-800 dark:text-gray-200 mb-2">Select a Time</h3>
                        <p className="text-gray-600 dark:text-gray-400 mb-4">
                          {selectedDate ? `${selectedDate.dayName}, ${selectedDate.monthName} ${selectedDate.dayOfMonth}, ${selectedDate.year}` : ''}
                        </p>
                        
                        <div className="time-slots-container grid grid-cols-3 gap-3 mb-6">
                          {isLoadingSlots ? (
                            // Skeleton loading for time slots
                            Array.from({ length: 12 }).map((_, index) => (
                              <div key={index} className="animate-pulse">
                                <div className="bg-gray-200 dark:bg-gray-700 rounded-lg h-12 w-full"></div>
                              </div>
                            ))
                          ) : availableTimeSlots.map((slot, index) => {
                            const isBooked = bookedSlots.includes(slot);
                            const isSelected = selectedTimeSlot === slot;
                            
                            return (
                              <div 
                                key={index} 
                                className={`
                                  time-slot text-center py-3 rounded-lg border relative
                                  ${isBooked 
                                    ? 'bg-red-100 dark:bg-red-900 text-red-600 dark:text-red-300 border-red-300 dark:border-red-700 cursor-not-allowed opacity-60' 
                                    : isSelected 
                                      ? 'bg-pink-500 text-white border-pink-500 cursor-pointer' 
                                      : 'bg-white dark:bg-gray-800 text-gray-800 dark:text-gray-200 border-gray-200 dark:border-gray-700 hover:border-pink-500 dark:hover:border-pink-500 cursor-pointer'
                                  }
                                `}
                                onClick={() => !isBooked && selectTimeSlot(slot)}
                              >
                                {slot}
                                {isBooked && (
                                  <div className="absolute inset-0 flex items-center justify-center">
                                    <span className="text-xs font-semibold bg-red-500 text-white px-2 py-1 rounded-full">Booked</span>
                                  </div>
                                )}
                              </div>
                            );
                          })}
                        
                        </div>
                        
                        <div className="flex space-x-3">
                          <button 
                            className="flex-1 py-3 rounded-lg font-medium text-gray-700 dark:text-gray-300 bg-gray-100 dark:bg-gray-800 hover:bg-gray-200 dark:hover:bg-gray-700"
                            onClick={() => setBookingStep(1)}
                          >
                            Back
                          </button>
                          <button 
                            className={`
                              flex-1 py-3 rounded-lg font-medium text-white
                              ${selectedTimeSlot ? 'bg-pink-500 hover:bg-pink-600' : 'bg-gray-300 dark:bg-gray-700 cursor-not-allowed'}
                            `}
                            disabled={!selectedTimeSlot} 
                            onClick={() => setBookingStep(3)}
                          >
                            Next: Select Package
                          </button>
                        </div>
                      </div>
                    )}
                    
                    {/* Step 3: Package Selection */}
                    {bookingStep === 3 && (
                      <div className="booking-step">
                        <h3 className="text-xl font-semibold text-gray-800 dark:text-gray-200 mb-2">Select a Package</h3>
                        <p className="text-gray-600 dark:text-gray-400 mb-4">
                          {selectedDate ? `${selectedDate.dayName}, ${selectedDate.monthName} ${selectedDate.dayOfMonth}, ${selectedDate.year} at ${selectedTimeSlot}` : ''}
                        </p>
                        
                        <div className="package-options grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                          <div 
                            className={`
                              package-card p-4 rounded-lg border cursor-pointer
                              ${selectedPackage === 'free' ? 'bg-pink-50 dark:bg-pink-900/20 border-pink-500' : 'bg-white dark:bg-gray-800 border-gray-200 dark:border-gray-700 hover:border-pink-500 dark:hover:border-pink-500'}
                            `}
                            onClick={() => selectPackage('free')}
                          >
                            <h4 className="text-lg font-semibold text-gray-800 dark:text-gray-200 mb-2">Free Trial Session</h4>
                            <p className="text-2xl font-bold text-pink-500 mb-3">$0</p>
                            <ul className="text-sm text-gray-600 dark:text-gray-400 space-y-2">
                              <li>✓ 25-minute introduction session</li>
                              <li>✓ Fitness assessment</li>
                              <li>✓ Goal setting consultation</li>
                            </ul>
                          </div>
                          
                          <div 
                            className={`
                              package-card p-4 rounded-lg border cursor-pointer
                              ${selectedPackage === 'basic' ? 'bg-pink-50 dark:bg-pink-900/20 border-pink-500' : 'bg-white dark:bg-gray-800 border-gray-200 dark:border-gray-700 hover:border-pink-500 dark:hover:border-pink-500'}
                            `}
                            onClick={() => selectPackage('basic')}
                          >
                            <h4 className="text-lg font-semibold text-gray-800 dark:text-gray-200 mb-2">Basic Package</h4>
                            <p className="text-2xl font-bold text-pink-500 mb-3">$100</p>
                            <ul className="text-sm text-gray-600 dark:text-gray-400 space-y-2">
                              <li>✓ 5 training sessions</li>
                              <li>✓ Personalized workout plan</li>
                              <li>✓ Nutrition guidance</li>
                            </ul>
                          </div>
                          
                          <div 
                            className={`
                              package-card p-4 rounded-lg border cursor-pointer
                              ${selectedPackage === 'premium' ? 'bg-pink-50 dark:bg-pink-900/20 border-pink-500' : 'bg-white dark:bg-gray-800 border-gray-200 dark:border-gray-700 hover:border-pink-500 dark:hover:border-pink-500'}
                            `}
                            onClick={() => selectPackage('premium')}
                          >
                            <h4 className="text-lg font-semibold text-gray-800 dark:text-gray-200 mb-2">Premium Package</h4>
                            <p className="text-2xl font-bold text-pink-500 mb-3">$150</p>
                            <ul className="text-sm text-gray-600 dark:text-gray-400 space-y-2">
                              <li>✓ 10 training sessions</li>
                              <li>✓ Comprehensive fitness plan</li>
                              <li>✓ Detailed nutrition program</li>
                              <li>✓ 24/7 support</li>
                            </ul>
                          </div>
                        </div>
                        
                        <div className="flex space-x-3">
                          <button 
                            className="flex-1 py-3 rounded-lg font-medium text-gray-700 dark:text-gray-300 bg-gray-100 dark:bg-gray-800 hover:bg-gray-200 dark:hover:bg-gray-700"
                            onClick={() => setBookingStep(2)}
                          >
                            Back
                          </button>
                          <button 
                            className={`
                              flex-1 py-3 rounded-lg font-medium text-white text-sm sm:text-base
                              ${selectedPackage ? 'bg-pink-500 hover:bg-pink-600' : 'bg-gray-300 dark:bg-gray-700 cursor-not-allowed'}
                            `}
                            disabled={!selectedPackage} 
                            onClick={handleBookingSubmit}
                          >
                            {selectedPackage === 'free' ? 'Book Free Session' : 'Generate Invoice & Book'}
                          </button>
                        </div>
                      </div>
                    )}
                  </div>
                </div>
              </div>
            </div>
           )}
           
           {/* Optimized Confirmation Message Modal */}
           {confirmationMessage && (
             <div className="fixed inset-0 bg-black/75 flex items-center justify-center z-50 p-4 will-change-transform">
               <div className="bg-white dark:bg-gray-900 rounded-2xl shadow-2xl w-full max-w-md mx-auto transform transition-transform duration-200 scale-100 will-change-transform">
                 <div className="p-6 text-center">
                   <div className={`mx-auto mb-4 w-12 h-12 rounded-full flex items-center justify-center will-change-transform ${
                     confirmationMessage.type === 'success' ? 'bg-green-100 dark:bg-green-900/20' : 'bg-yellow-100 dark:bg-yellow-900/20'
                   }`}>
                     {confirmationMessage.type === 'success' ? (
                       <svg className="w-6 h-6 text-green-600 dark:text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" style={{willChange: 'transform'}}>
                         <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
                       </svg>
                     ) : (
                       <svg className="w-6 h-6 text-yellow-600 dark:text-yellow-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" style={{willChange: 'transform'}}>
                         <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z" />
                       </svg>
                     )}
                   </div>
                   <h3 className="text-lg font-semibold text-gray-800 dark:text-gray-200 mb-2 will-change-contents">
                     {confirmationMessage.title}
                   </h3>
                   <p className="text-gray-600 dark:text-gray-400 mb-4 will-change-contents">
                     {confirmationMessage.message}
                   </p>
                   
                   {/* Payment Details Section */}
                   {confirmationMessage.paymentDetails && (
                     <div className="bg-gray-50 dark:bg-gray-800 rounded-lg p-4 mb-4 text-left">
                       <h4 className="font-semibold text-gray-800 dark:text-gray-200 mb-3 text-center">💳 Payment Details</h4>
                       <div className="space-y-2 text-sm">
                         <div className="flex justify-between">
                           <span className="text-gray-600 dark:text-gray-400">Amount:</span>
                           <span className="font-medium text-gray-800 dark:text-gray-200">${confirmationMessage.paymentDetails.amount}</span>
                         </div>
                         <div className="flex justify-between">
                           <span className="text-gray-600 dark:text-gray-400">Sessions:</span>
                           <span className="font-medium text-gray-800 dark:text-gray-200">{confirmationMessage.paymentDetails.sessions}</span>
                         </div>
                         <div className="flex justify-between">
                           <span className="text-gray-600 dark:text-gray-400">Invoice #:</span>
                           <span className="font-medium text-gray-800 dark:text-gray-200">{confirmationMessage.paymentDetails.invoiceNumber}</span>
                         </div>
                         <hr className="border-gray-200 dark:border-gray-700 my-3" />
                         <div className="mb-2">
                           <span className="text-gray-600 dark:text-gray-400 block mb-1">🏦 Bank Transfer:</span>
                           <div className="text-xs text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-700 p-2 rounded border">
                             <div>{confirmationMessage.paymentDetails.bankDetails}</div>
                             <div className="mt-1">{confirmationMessage.paymentDetails.bankAddress}</div>
                           </div>
                         </div>
                         <div>
                           <span className="text-gray-600 dark:text-gray-400 block mb-1">💰 PayPal:</span>
                           <div className="text-xs text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-700 p-2 rounded border">
                             {confirmationMessage.paymentDetails.paypalEmail}
                           </div>
                         </div>
                       </div>
                     </div>
                   )}
                   <button
                     onClick={() => setConfirmationMessage(null)}
                     className="w-full bg-pink-500 active:bg-pink-600 text-white font-medium py-3 px-4 rounded-lg transition-colors duration-150 will-change-transform touch-manipulation"
                   >
                     OK
                   </button>
                 </div>
               </div>
             </div>
           )}

           <header className="mb-6 flex justify-between items-center">
            <h1 className="text-3xl font-bold text-gray-800 dark:text-gray-200">My Profile</h1>
            {user && (
              <button 
                onClick={() => document.getElementById('virtual-trainer-card')?.scrollIntoView({ behavior: 'smooth' })}
                className="flex items-center gap-2 bg-gradient-to-r from-purple-500 to-pink-500 text-white px-3 py-2 rounded-full shadow-lg hover:scale-105 transition-transform text-sm md:text-base md:px-4"
              >
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M2 5a2 2 0 012-2h7a2 2 0 012 2v4a2 2 0 01-2 2H9l-3 3v-3H4a2 2 0 01-2-2V5z"/><path d="M15 7v2a2 2 0 012 2v5a2 2 0 01-2 2H9a2 2 0 01-2-2v-2h6V7z"/></svg>
                <span>Virtual Trainer</span>
              </button>
            )}
          </header>

          <div className="flex flex-col items-center mb-6 bg-white dark:bg-gray-800 p-6 rounded-2xl shadow-md">
            <div className="relative mb-4">
              <img 
                src={profilePicture} 
                alt="User profile" 
                className="w-24 h-24 rounded-full object-cover border-4 border-pink-200 dark:border-pink-400" 
              />
              <button
                onClick={() => fileInputRef.current?.click()}
                className="absolute -bottom-2 -right-2 bg-pink-500 text-white p-2 rounded-full shadow-lg hover:bg-pink-600 transition-colors"
                title="Upload Photo"
              >
                📷
              </button>
            </div>
            
            <div className="flex gap-2 mb-4">
              <button
                onClick={() => fileInputRef.current?.click()}
                className="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-lg text-sm font-medium transition-colors"
              >
                📁 Upload Photo
              </button>
              <button
                onClick={generateAIAvatar}
                disabled={isGeneratingAvatar}
                className="bg-purple-500 hover:bg-purple-600 disabled:bg-gray-400 text-white px-4 py-2 rounded-lg text-sm font-medium transition-colors flex items-center gap-1"
              >
                {isGeneratingAvatar ? '⏳ Generating...' : '🤖 AI Avatar'}
              </button>
            </div>

            <input
              type="file"
              ref={fileInputRef}
              onChange={handleImageUpload}
              accept="image/*"
              className="hidden"
            />
            
            <h2 className="text-2xl font-bold text-gray-800 dark:text-gray-200">
              {user ? (user.user_metadata?.display_name || 'User') : 'John Doe'}
            </h2>
            <p className="text-gray-500 dark:text-gray-400">
              {user ? user.email : 'john.doe@example.com'}
            </p>
          </div>

          <div className="mb-6">
            <h3 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-4">My Goals</h3>
            <div className="bg-white dark:bg-gray-800 rounded-2xl shadow-md p-4 space-y-3">
              <div className="p-2">
                <label className="font-semibold mb-2 block text-gray-800 dark:text-gray-200">Daily Calories: {goals.calories} kcal</label>
                <input type="range" min="1200" max="4000" step="50" value={goals.calories} onChange={e => handleGoalChange('calories', e.target.value)} className="w-full" />
              </div>
              <div className="flex justify-between items-center p-2">
                <p className="text-gray-600 dark:text-gray-300">Protein</p>
                <p className="font-bold text-gray-800 dark:text-gray-200">{goals.protein} g</p>
              </div>
              <div className="flex justify-between items-center p-2">
                <p className="text-gray-600 dark:text-gray-300">Carbs</p>
                <p className="font-bold text-gray-800 dark:text-gray-200">{goals.carbs} g</p>
              </div>
              <div className="flex justify-between items-center p-2">
                <p className="text-gray-600 dark:text-gray-300">Fat</p>
                <p className="font-bold text-gray-800 dark:text-gray-200">{goals.fat} g</p>
              </div>
            </div>
          </div>

          {/* Virtual Trainer Section */}
          <div id="virtual-trainer-card" className="mb-6">
            <h3 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-4">Virtual Trainer</h3>
            <div className="bg-white dark:bg-gray-800 rounded-2xl shadow-md p-6">
              <div className="flex flex-col md:flex-row items-center gap-6">
                <div className="flex-shrink-0">
                  <img src={user ? "naim.png" : "icon-512.png"} alt="Virtual Trainer" className="w-32 h-32 rounded-full object-cover object-center border-4 border-pink-200 dark:border-pink-400"/>
                </div>
                <div className="flex-grow">
                  <h4 className="text-2xl font-bold text-gray-800 dark:text-gray-200">Book a Personal Session</h4>
                  <p className="text-gray-600 dark:text-gray-400 mt-2">
                    Get one-on-one guidance from a certified trainer. Your first 25-minute session is <strong>FREE</strong>!
                  </p>
                  <div className="mt-4 space-y-3">
                    <div className="flex justify-between items-center p-3 bg-gray-50 dark:bg-gray-700 rounded-lg">
                      <div>
                        <p className="text-gray-700 dark:text-gray-300"><span className="font-bold text-pink-500">5 Sessions:</span> $100</p>
                        <p className="text-xs text-gray-500 dark:text-gray-400">Save $25 compared to individual sessions</p>
                      </div>
                      {user && (
                        <button 
                          onClick={() => {
                            setSelectedPackage('basic');
                            openBookingModal();
                          }}
                          className="bg-pink-500 hover:bg-pink-600 text-white px-4 py-2 rounded-lg text-sm font-medium transition-colors"
                        >
                          Buy Now
                        </button>
                      )}
                    </div>
                    <div className="flex justify-between items-center p-3 bg-gray-50 dark:bg-gray-700 rounded-lg">
                      <div>
                        <p className="text-gray-700 dark:text-gray-300"><span className="font-bold text-pink-500">10 Sessions:</span> $150</p>
                        <p className="text-xs text-gray-500 dark:text-gray-400">Best value - Save $50!</p>
                      </div>
                      {user && (
                        <button 
                          onClick={() => {
                            setSelectedPackage('premium');
                            openBookingModal();
                          }}
                          className="bg-pink-500 hover:bg-pink-600 text-white px-4 py-2 rounded-lg text-sm font-medium transition-colors"
                        >
                          Buy Now
                        </button>
                      )}
                    </div>
                  </div>
                  <div className="mt-6 flex flex-col md:flex-row gap-3">
                    {user ? (
                      <>
                        <button 
                          onClick={openBookingModal}
                          className="w-full md:w-auto bg-gradient-to-r from-green-500 to-blue-500 text-white px-6 py-3 rounded-lg shadow-lg hover:scale-105 transition-transform font-semibold"
                        >
                          Book a Session
                        </button>
                      </>
                    ) : (
                      <button 
                        onClick={openAccountModal}
                        className="w-full md:w-auto bg-gradient-to-r from-purple-500 to-pink-500 text-white px-6 py-3 rounded-lg shadow-lg hover:scale-105 transition-transform font-semibold"
                      >
                        Sign In to Book
                      </button>
                    )}
                  </div>
                </div>
              </div>
            </div>
          </div>

          <div>
            <h3 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-4">Settings</h3>
            <div className="bg-white dark:bg-gray-800 rounded-2xl shadow-md p-4 space-y-1">
              <button 
                onClick={openAccountModal}
                className="w-full text-left p-3 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-300 transition-colors flex justify-between items-center"
              >
                <span>Account</span>
                {user && (
                  <span className="text-xs bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-200 px-2 py-1 rounded-full">
                    Signed In
                  </span>
                )}
              </button>

              <div className="w-full p-3 rounded-lg border border-gray-200 dark:border-gray-700">
                <div className="flex justify-between items-start mb-2">
                  <div>
                    <div className="text-gray-700 dark:text-gray-300 font-medium">Subscription</div>
                    <div className="text-xs text-gray-500 dark:text-gray-400 mt-0.5">
                      {aiRemaining.count}/{aiRemaining.limit} prompts today
                    </div>
                  </div>
                  {subActive && (
                    <span className="text-xs bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-200 px-2 py-1 rounded-full whitespace-nowrap">
                      ✓ Active
                    </span>
                  )}
                </div>
                {subActive ? (
                  <div className="flex flex-col gap-2 mt-3 pt-3 border-t border-gray-100 dark:border-gray-700">
                    <button
                      onClick={async ()=>{ const openPlay=()=>{ const sku=(window.fitmateIAP&&window.fitmateIAP.PRODUCT_ID)?window.fitmateIAP.PRODUCT_ID:'fitmate_monthly_149'; const manageUrl=`https://play.google.com/store/account/subscriptions?sku=${encodeURIComponent(sku)}`; try{window.open(manageUrl,'_blank');}catch(_){} }; const openStripeLogin=()=>{ try{ window.open('https://billing.stripe.com/p/login/28E14o3tE3dP9Uhfnc3sI00','_blank'); }catch(_){} }; try { if (supabase && supabase.functions) { const { data, error } = await supabase.functions.invoke('stripe-webhook', { body: { action: 'create_portal_session' } }); if (!error && data && data.url) { window.location.assign(data.url); return; } } } catch(_){} if (typeof window.getDigitalGoodsService === 'function' || /Android/i.test(navigator.userAgent)) { openPlay(); } else { openStripeLogin(); } }}
                      className="w-full bg-gray-800 hover:bg-gray-900 text-white text-sm font-medium px-4 py-2.5 rounded-lg shadow-sm transition-colors"
                    >
                      Manage subscription
                    </button>
                  </div>
                ) : (
                  <div className="flex flex-col gap-2 mt-3 pt-3 border-t border-gray-100 dark:border-gray-700">
                    <button
                      onClick={()=>{ try { if (!user) { openAccountModal(); return; } window.dispatchEvent(new CustomEvent('force-open-subscription-modal')); } catch(_){} }}
                      className="w-full bg-blue-500 hover:bg-blue-600 text-white text-sm font-medium px-4 py-2.5 rounded-lg shadow-sm transition-colors"
                    >
                      Subscribe · €1.49/mo
                    </button>
                    <button
                      onClick={async ()=>{ try { await (window.fitmateIAP && window.fitmateIAP.restore ? window.fitmateIAP.restore() : Promise.resolve(false)); } catch(_){} }}
                      className="text-xs text-center text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200"
                    >
                      Already subscribed? Restore
                    </button>
                  </div>
                )}
              </div>
              
              {/* Booking History Button - Only show when user is signed in */}
              {user && (
                <button 
                  onClick={toggleBookingHistory}
                  className="w-full text-left p-3 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-300 transition-colors flex justify-between items-center"
                >
                  <span className="flex items-center gap-2">
                    <span>📅</span>
                    <span>Booking History</span>
                  </span>
                  {bookingHistory.length > 0 && (
                    <span className="text-xs bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200 px-2 py-1 rounded-full">
                      {bookingHistory.length}
                    </span>
                  )}
                </button>
              )}
              
              
              {/* Manual Cloud Sync (hidden by default; auto-sync is active) */}
              {user && SHOW_MANUAL_CLOUD_SYNC && (
                <div className="space-y-2">
                  <div className="space-y-2">
                    <button 
                      onClick={async () => {
                        console.log('🧪 Testing manual upload...');
                        try {
                          // Force sync all current data to Supabase
                          const allLocalData = {
                            goals: JSON.parse(localStorage.getItem('goals') || '{}'),
                            // profile_picture intentionally excluded to avoid overwriting remote value during remote-only mode,
                            notifications_enabled: JSON.parse(localStorage.getItem('notificationsEnabled') || 'true'),
                            daily_intake: JSON.parse(localStorage.getItem('dailyIntake') || '{}'),
                            recent_meals: JSON.parse(localStorage.getItem('recentMeals') || '[]'),
                            daily_history: JSON.parse(localStorage.getItem('dailyHistory') || '{}'),
                            coach_messages: JSON.parse(localStorage.getItem('coachMessages') || '[]'),
                            habit_ai_advice: localStorage.getItem('habitAIAdvice') || '',
                            habits: JSON.parse(localStorage.getItem('habits') || '[]'),
                            dark_mode: JSON.parse(localStorage.getItem('fitmate-dark-mode') || 'false'),
                            meal_plan: JSON.parse(localStorage.getItem('mealPlan') || 'null'),
                            workout_plan: JSON.parse(localStorage.getItem('workoutPlan') || 'null'),
                            scan_result: JSON.parse(localStorage.getItem('scanResult') || 'null'),
                            form_analysis: JSON.parse(localStorage.getItem('formAnalysis') || 'null'),
                            updated_at: new Date().toISOString()
                          };
                          
                          await queueUserUpdate(user.id, allLocalData);
                          console.log('✅ Manual upload queued and will be sent shortly!');
                          alert('✅ Data uploaded successfully! Check another device to see if it appears.');
                        } catch (error) {
                          console.error('❌ Manual upload failed:', error);
                          alert('❌ Upload failed: ' + error.message);
                        }
                      }}
                      className="w-full text-left p-3 rounded-lg hover:bg-blue-100 dark:hover:bg-blue-900 text-blue-700 dark:text-blue-300 transition-colors flex items-center gap-2"
                    >
                      <span>📤</span>
                      <span>Upload Data to Cloud</span>
                    </button>
                    
                    <button 
                      onClick={async () => {
                        console.log('🧪 Testing manual download...');
                        try {
                          // Force download data from Supabase
                          const userData = await db.getUser(user.id);
                          if (userData) {
                            // Update localStorage with remote data
                            if (userData.goals) localStorage.setItem('goals', JSON.stringify(userData.goals));
                            if (userData.profile_picture) localStorage.setItem('profilePicture', userData.profile_picture);
                            if (userData.notifications_enabled !== undefined) localStorage.setItem('notificationsEnabled', JSON.stringify(userData.notifications_enabled));
                            if (userData.daily_intake) {
                              try {
                                const localIntake = (() => { try { return JSON.parse(localStorage.getItem('dailyIntake') || '{}') || {}; } catch { return {}; } })();
                                const merged = { ...userData.daily_intake, activity: Number(userData.daily_intake?.activity || 0) };
                                localStorage.setItem('dailyIntake', JSON.stringify(merged));
                                console.log('✅ Manual download: synced daily_intake (activity remote-only)');
                              } catch (_) {
                                const merged = { ...userData.daily_intake, activity: Number(userData.daily_intake?.activity || 0) };
                                localStorage.setItem('dailyIntake', JSON.stringify(merged));
                                console.log('✅ Manual download: synced daily_intake (remote activity used)');
                              }
                            }
                            if (userData.recent_meals) localStorage.setItem('recentMeals', JSON.stringify(userData.recent_meals));
                            if (userData.daily_history) {
                              try {
                                const localDH = JSON.parse(localStorage.getItem('dailyHistory') || '{}') || {};
                                const mergedDH = { ...userData.daily_history, ...localDH };
                                localStorage.setItem('dailyHistory', JSON.stringify(mergedDH));
                                console.log('✅ Manual download: merged daily_history (prefer local)');
                              } catch (_) {
                                localStorage.setItem('dailyHistory', JSON.stringify(userData.daily_history));
                                console.log('✅ Manual download: set daily_history from remote');
                              }
                            }
                            if (userData.coach_messages) localStorage.setItem('coachMessages', JSON.stringify(userData.coach_messages));
                            if (userData.habit_ai_advice) localStorage.setItem('habitAIAdvice', userData.habit_ai_advice);
                            if (userData.habits) localStorage.setItem('habits', JSON.stringify(userData.habits));
                            // Skip syncing dark_mode from remote - it's a local UI preference
                            if (userData.meal_plan) localStorage.setItem('mealPlan', JSON.stringify(userData.meal_plan));
                            if (userData.workout_plan) localStorage.setItem('workoutPlan', JSON.stringify(userData.workout_plan));
                            if (userData.scan_result) localStorage.setItem('scanResult', JSON.stringify(userData.scan_result));
                            if (userData.form_analysis) localStorage.setItem('formAnalysis', JSON.stringify(userData.form_analysis));
                            
                            // Trigger React state update
                            window.dispatchEvent(new CustomEvent('userDataSynced'));
                            
                            console.log('✅ Manual download completed successfully!');
                            alert('✅ Data downloaded successfully! Check if your data updated.');
                          } else {
                            alert('❌ No data found in cloud.');
                          }
                        } catch (error) {
                          console.error('❌ Manual download failed:', error);
                          alert('❌ Download failed: ' + error.message);
                        }
                      }}
                      className="w-full text-left p-3 rounded-lg hover:bg-green-100 dark:hover:bg-green-900 text-green-700 dark:text-green-300 transition-colors flex items-center gap-2"
                    >
                      <span>📥</span>
                      <span>Download Data from Cloud</span>
                    </button>
                  </div>
                </div>
              )}

              {/* Updated Notifications with toggle */}
              <div className="flex justify-between items-center p-3">
                <span className="text-gray-700 dark:text-gray-300">Notifications</span>
                <button 
                  onClick={toggleNotifications}
                  className={`relative w-14 h-7 rounded-full p-1 transition-colors duration-200 focus:outline-none ${
                    notificationsEnabled ? 'bg-green-500' : 'bg-gray-300'
                  }`}
                  title={notificationsEnabled ? 'Notifications ON' : 'Notifications OFF'}
                >
                  <div className={`w-5 h-5 bg-white rounded-full shadow-md transform transition-transform duration-200 ${
                    notificationsEnabled ? 'translate-x-7' : 'translate-x-0'
                  }`}></div>
                </button>
              </div>
              
              {/* Background Music toggle */}
              <div className="p-3">
                <div className="flex justify-between items-center">
                  <span className="text-gray-700 dark:text-gray-300">Background Music</span>
                  <button 
                    onClick={toggleBackgroundMusic}
                    className={`relative w-14 h-7 rounded-full p-1 transition-colors duration-200 focus:outline-none ${
                      backgroundMusicEnabled ? 'bg-pink-500' : 'bg-gray-300'
                    }`}
                    title={backgroundMusicEnabled ? 'Background Music ON' : 'Background Music OFF'}
                  >
                    <div className={`w-5 h-5 bg-white rounded-full shadow-md transform transition-transform duration-200 ${
                      backgroundMusicEnabled ? 'translate-x-7' : 'translate-x-0'
                    }`}></div>
                  </button>
                </div>
                {backgroundMusicEnabled && (
                  <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">
                    📱 On mobile: Tap anywhere to start music
                  </p>
                )}
              </div>
              
              <button 
                onClick={openPrivacyModal}
                className="w-full text-left p-3 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-300 transition-colors"
              >
                Privacy
              </button>
              
              {/* New Support Button */}
              <button 
                onClick={openSupportModal}
                className="w-full text-left p-3 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-300 transition-colors"
              >
                Support
              </button>
              
              {/* Existing Dark Mode toggle */}
              <div className="flex justify-between items-center p-3">
                <span className="text-gray-700 dark:text-gray-300">Dark Mode</span>
                <button 
                  onClick={toggleDarkMode} 
                  className={`relative w-14 h-7 rounded-full p-1 transition-colors duration-200 focus:outline-none ${
                    isDarkMode ? 'bg-pink-500' : 'bg-gray-300'
                  }`}
                >
                  <div className={`w-5 h-5 bg-white rounded-full shadow-md transform transition-transform duration-200 ${
                    isDarkMode ? 'translate-x-7' : 'translate-x-0'
                  }`}></div>
                </button>
              </div>
            </div>
          </div>

          {/* Privacy Modal */}
          {showPrivacyModal && (
            <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
              <div className="bg-white dark:bg-gray-800 rounded-2xl shadow-2xl max-w-md w-full max-h-[80vh] overflow-y-auto">
                {/* Modal Header */}
                <div className="flex justify-between items-center p-6 border-b border-gray-200 dark:border-gray-700">
                  <h2 className="text-2xl font-bold text-gray-800 dark:text-gray-200 flex items-center">
                    🔒 Privacy Policy
                  </h2>
                  <button 
                    onClick={closePrivacyModal}
                    className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 text-2xl font-bold transition-colors"
                  >
                    ×
                  </button>
                </div>
                
                {/* Modal Content */}
                <div className="p-6 space-y-4">
                  <div className="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-4">
                    <h3 className="font-semibold text-blue-800 dark:text-blue-200 mb-2 flex items-center">
                      📱 Local Storage & Minimal Cloud Sync
                    </h3>
                    <p className="text-blue-700 dark:text-blue-300 text-sm">
                      By default, your data is stored locally on your device. When you sign in, FitnessMate uses Supabase to securely sync a minimal set of data required for core functionality (for example: profile, goals, workout/activity history). We do not sell or share your data with third parties.
                    </p>
                  </div>
                  
                  <div className="space-y-3 text-gray-700 dark:text-gray-300">
                    <div>
                      <h4 className="font-semibold mb-1">🛡️ Data Security</h4>
                      <p className="text-sm">
                        Your information remains on your device and, if signed in, in Supabase where it is transmitted over HTTPS and stored securely. Access is restricted to your account, and we only keep what is needed to make the app work.
                      </p>
                    </div>
                    
                    <div>
                      <h4 className="font-semibold mb-1">🔄 Data Control</h4>
                      <p className="text-sm">
                        You control your data. Clearing your browser data removes local information. If signed in, you can stop sync by signing out, and you may request deletion of synced data associated with your account at any time.
                      </p>
                    </div>
                    
                    <div>
                      <h4 className="font-semibold mb-1">🤖 AI Interactions</h4>
                      <p className="text-sm">
                        AI coaching features may send anonymized queries to external services for responses, but no personal data is retained.
                      </p>
                    </div>
                    
                    <div>
                      <h4 className="font-semibold mb-1">📸 Image Processing</h4>
                      <p className="text-sm">
                        Food scanning and image analysis are processed temporarily and not stored permanently.
                      </p>
                    </div>
                  </div>
                  
                  <div className="bg-green-50 dark:bg-green-900/20 border border-green-200 dark:border-green-800 rounded-lg p-4">
                    <p className="text-green-800 dark:text-green-200 text-sm font-medium">
                      ✅ Your privacy is our priority. This app is designed with privacy-first principles.
                    </p>
                  </div>

                  <div className="text-center pt-1">
                    <a href="/privacy.html" className="text-blue-600 dark:text-blue-400 hover:underline text-sm font-medium">
                      View full Privacy Policy / Terms of Service →
                    </a>
                  </div>
                </div>
                
                {/* Modal Footer */}
                <div className="p-6 border-t border-gray-200 dark:border-gray-700">
                  <button 
                    onClick={closePrivacyModal}
                    className="w-full bg-gradient-to-r from-purple-500 to-pink-500 text-white py-3 px-4 rounded-xl font-semibold hover:from-purple-600 hover:to-pink-600 transition-all duration-200 shadow-lg"
                  >
                    Got it!
                  </button>
                </div>
              </div>
            </div>
          )}

          {/* Account Modal */}
          {showAccountModal && (
            <AccountModal 
              user={user}
              onClose={closeAccountModal}
              onSignOut={handleSignOut}
            />
          )}

          {/* Booking History Modal */}
          {showBookingHistory && (
            <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
              <div className="bg-white dark:bg-gray-800 rounded-2xl shadow-2xl max-w-2xl w-full max-h-[80vh] overflow-y-auto">
                {/* Modal Header */}
                <div className="flex justify-between items-center p-6 border-b border-gray-200 dark:border-gray-700">
                  <h2 className="text-2xl font-bold text-gray-800 dark:text-gray-200 flex items-center">
                    📅 Booking History
                  </h2>
                  <button 
                    onClick={toggleBookingHistory}
                    className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 text-2xl font-bold transition-colors"
                  >
                    ×
                  </button>
                </div>
                
                {/* Modal Content */}
                <div className="p-6">
                  {isLoadingBookings ? (
                    <div className="text-center py-8">
                      <div className="animate-spin text-4xl mb-4">⏳</div>
                      <p className="text-gray-600 dark:text-gray-400">Loading your booking history...</p>
                    </div>
                  ) : bookingHistory.length === 0 ? (
                    <div className="text-center py-8">
                      <div className="text-6xl mb-4">📅</div>
                      <h3 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-2">No Bookings Yet</h3>
                      <p className="text-gray-600 dark:text-gray-400 mb-4">
                        You haven't made any bookings yet. Book your first session to get started!
                      </p>
                      <button 
                         onClick={() => {
                           toggleBookingHistory();
                           openBookingModal();
                         }}
                         className="bg-gradient-to-r from-pink-500 to-purple-600 text-white py-2 px-6 rounded-xl font-semibold hover:from-pink-600 hover:to-purple-700 transition-all duration-200 shadow-lg"
                       >
                         Book Now
                       </button>
                    </div>
                  ) : (
                    <div className="space-y-4">
                      <div className="flex justify-between items-center mb-4">
                        <p className="text-gray-600 dark:text-gray-400">
                          Total bookings: <span className="font-semibold text-gray-800 dark:text-gray-200">{bookingHistory.length}</span>
                        </p>
                        <button 
                          onClick={fetchBookingHistory}
                          className="text-blue-600 dark:text-blue-400 hover:text-blue-700 dark:hover:text-blue-300 text-sm font-medium"
                        >
                          🔄 Refresh
                        </button>
                      </div>
                      
                      {bookingHistory.map((booking) => (
                        <div key={booking.id} className="bg-gray-50 dark:bg-gray-700 rounded-xl p-4 border border-gray-200 dark:border-gray-600">
                          <div className="flex justify-between items-start mb-3">
                            <div>
                              <h4 className="font-semibold text-gray-800 dark:text-gray-200">
                                {booking.package || 'Session'}
                              </h4>
                              <p className="text-sm text-gray-600 dark:text-gray-400">
                                {booking.date} at {booking.time}
                              </p>
                            </div>
                            <div className="text-right">
                              <span className={`inline-block px-2 py-1 rounded-full text-xs font-medium ${
                                booking.type === 'free' 
                                  ? 'bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-200'
                                  : 'bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200'
                              }`}>
                                {booking.type === 'free' ? 'Free Trial' : `$${booking.price}`}
                              </span>
                            </div>
                          </div>
                          
                          <div className="grid grid-cols-2 gap-4 text-sm">
                            <div>
                              <span className="text-gray-500 dark:text-gray-400">Sessions:</span>
                              <span className="ml-2 font-medium text-gray-800 dark:text-gray-200">{booking.sessions || 1}</span>
                            </div>
                            <div>
                              <span className="text-gray-500 dark:text-gray-400">Status:</span>
                              <span className="ml-2 font-medium text-green-600 dark:text-green-400">{booking.status || 'Confirmed'}</span>
                            </div>
                          </div>
                          
                          {booking.createdAt && (
                            <div className="mt-2 text-xs text-gray-500 dark:text-gray-400">
                              Booked: {new Date(booking.createdAt).toLocaleDateString()} at {new Date(booking.createdAt).toLocaleTimeString()}
                            </div>
                          )}
                          
                          {(booking.meeting_link || booking.meetingLink) && (
                            <div className="mt-3">
                              <button 
                                onClick={() => {
                                  const meetingUrl = booking.meeting_link || booking.meetingLink;
                                  setCurrentMeetingLink(meetingUrl);
                                  setShowMeetingModal(true);
                                }}
                                className="inline-flex items-center gap-2 text-blue-600 dark:text-blue-400 hover:text-blue-700 dark:hover:text-blue-300 text-sm font-medium bg-transparent border-none cursor-pointer"
                              >
                                🎥 Join Session
                              </button>
                            </div>
                          )}
                        </div>
                      ))}
                    </div>
                  )}
                </div>
              </div>
            </div>
          )}

          {/* Support Modal */}
          {showSupportModal && (
            <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
              <div className="bg-white dark:bg-gray-800 rounded-2xl shadow-2xl max-w-md w-full max-h-[80vh] overflow-y-auto">
                {/* Modal Header */}
                <div className="flex justify-between items-center p-6 border-b border-gray-200 dark:border-gray-700">
                  <h2 className="text-2xl font-bold text-gray-800 dark:text-gray-200 flex items-center">
                    🎧 Support
                  </h2>
                  <button 
                    onClick={closeSupportModal}
                    className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 text-2xl font-bold transition-colors"
                  >
                    ×
                  </button>
                </div>
                
                {/* Modal Content */}
                <div className="p-6">
                  {supportSubmissionStatus === 'success' ? (
                    <div className="text-center space-y-4">
                      <div className="text-6xl">✅</div>
                      <h3 className="text-xl font-bold text-green-600 dark:text-green-400">Message Sent!</h3>
                      <p className="text-gray-600 dark:text-gray-400">
                        Thank you for contacting us. We'll get back to you within 24 hours.
                      </p>
                      <button 
                        onClick={closeSupportModal}
                        className="w-full bg-gradient-to-r from-green-500 to-green-600 text-white py-3 px-4 rounded-xl font-semibold hover:from-green-600 hover:to-green-700 transition-all duration-200 shadow-lg"
                      >
                        Close
                      </button>
                    </div>
                  ) : (
                    <form onSubmit={handleSupportSubmit} className="space-y-4">
                      {/* Hidden Netlify form field */}
                      <input type="hidden" name="form-name" value="support-form" />
                      
                      {/* Full Name */}
                      <div>
                        <label className="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-2">
                          Full Name *
                        </label>
                        <input
                          type="text"
                          name="full-name"
                          value={supportForm.fullName}
                          onChange={(e) => handleSupportFormChange('fullName', e.target.value)}
                          className="w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-xl focus:ring-2 focus:ring-pink-500 focus:border-transparent bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 transition-all"
                          placeholder="Enter your full name"
                          required
                        />
                      </div>
                      
                      {/* Email */}
                      <div>
                        <label className="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-2">
                          Email Address *
                        </label>
                        <input
                          type="email"
                          name="email"
                          value={supportForm.email}
                          onChange={(e) => handleSupportFormChange('email', e.target.value)}
                          className="w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-xl focus:ring-2 focus:ring-pink-500 focus:border-transparent bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 transition-all"
                          placeholder="Enter your email address"
                          required
                        />
                      </div>
                      
                      {/* Subject */}
                      <div>
                        <label className="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-2">
                          Subject *
                        </label>
                        <input
                          type="text"
                          name="subject"
                          value={supportForm.subject}
                          onChange={(e) => handleSupportFormChange('subject', e.target.value)}
                          className="w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-xl focus:ring-2 focus:ring-pink-500 focus:border-transparent bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 transition-all"
                          placeholder="Brief description of your issue"
                          required
                        />
                      </div>
                      
                      {/* Message */}
                      <div>
                        <label className="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-2">
                          Message *
                        </label>
                        <textarea
                          name="message"
                          value={supportForm.message}
                          onChange={(e) => handleSupportFormChange('message', e.target.value)}
                          rows={4}
                          className="w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-xl focus:ring-2 focus:ring-pink-500 focus:border-transparent bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 transition-all resize-none"
                          placeholder="Please describe your issue or question in detail..."
                          required
                        ></textarea>
                      </div>
                      
                      {supportSubmissionStatus === 'error' && (
                        <div className="bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg p-4">
                          <p className="text-red-800 dark:text-red-200 text-sm font-medium">
                            ❌ Failed to send message. Please try again or contact us directly.
                          </p>
                        </div>
                      )}
                      
                      {/* Submit Button */}
                      <button 
                        type="submit"
                        disabled={isSubmittingSupport}
                        className="w-full bg-gradient-to-r from-purple-500 to-pink-500 text-white py-3 px-4 rounded-xl font-semibold hover:from-purple-600 hover:to-pink-600 disabled:from-gray-400 disabled:to-gray-500 disabled:cursor-not-allowed transition-all duration-200 shadow-lg"
                      >
                        {isSubmittingSupport ? '📤 Sending...' : '📤 Send Message'}
                      </button>
                    </form>
                  )}
                </div>
              </div>
            </div>
          )}

          {/* Meeting Modal */}
          {showMeetingModal && (
            <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
              <div className="bg-white dark:bg-gray-800 rounded-2xl shadow-2xl max-w-6xl w-full max-h-[90vh] overflow-hidden">
                {/* Modal Header with FitnessMate Branding */}
                <div className="flex justify-between items-center p-4 border-b border-gray-200 dark:border-gray-700 bg-gradient-to-r from-purple-500 to-pink-500">
                  <div className="flex items-center space-x-3">
                    <div className="text-2xl">💪</div>
                    <div>
                      <h2 className="text-xl font-bold text-white">FitnessMate Meeting</h2>
                      <p className="text-purple-100 text-sm">Your personal fitness session</p>
                    </div>
                  </div>
                  <button 
                    onClick={() => {
                      setShowMeetingModal(false);
                      setCurrentMeetingLink('');
                    }}
                    className="text-white hover:text-purple-200 text-2xl font-bold transition-colors bg-white bg-opacity-20 rounded-full w-8 h-8 flex items-center justify-center"
                  >
                    ×
                  </button>
                </div>
                
                {/* Modal Content - Embedded Whereby Meeting */}
                <div className="relative h-[70vh]">
                  {currentMeetingLink && (
                    <iframe 
                      src={currentMeetingLink}
                      className="w-full h-full border-0"
                      title="FitnessMate Meeting Session"
                      allow="camera; microphone; fullscreen; display-capture; autoplay; clipboard-write"
                      allowFullScreen
                      sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-popups-to-escape-sandbox allow-presentation"
                      referrerPolicy="no-referrer-when-downgrade"
                    />
                  )}
                  

                </div>
                

              </div>
            </div>
          )}
        </div>
      );
    };



    // Reset Password Modal Component
    const ResetPasswordModal = ({ onClose }) => {
      const [password, setPassword] = React.useState('');
      const [confirm, setConfirm] = React.useState('');
      const [error, setError] = React.useState('');
      const [loading, setLoading] = React.useState(false);
      const [done, setDone] = React.useState(false);

      // Dynamic password rules status
      const rules = React.useMemo(() => {
        const length = password.length >= 8;
        const upper = /[A-Z]/.test(password);
        const lower = /[a-z]/.test(password);
        const number = /[0-9]/.test(password);
        const special = /[^A-Za-z0-9]/.test(password);
        return { length, upper, lower, number, special, valid: length && upper && lower && number && special };
      }, [password]);

      // Proactively verify we have a valid recovery session
      React.useEffect(() => {
        (async () => {
          try {
            const { data: { session } } = await auth.getSession();
            if (!session) {
              setError('Auth session missing! Please open the password reset link from your email again.');
            }
          } catch (_) {
            // ignore
          }
        })();
      }, []);

      const handleSubmit = async (e) => {
        e.preventDefault();
        setError('');
        if (!rules.valid) {
          setError('Password must include at least 8 characters, one uppercase letter, one lowercase letter, one number, and one special character.');
          return;
        }
        if (password !== confirm) {
          setError('Passwords do not match.');
          return;
        }
        setLoading(true);
        try {
          // Ensure we have a valid session from the recovery link
          const { data: { session } } = await auth.getSession();
          if (!session) throw new Error('Auth session missing! Please open the password reset link from your email again.');
          const { error } = await auth.updateUser({ password });
          if (error) throw error;
          setDone(true);
          setTimeout(onClose, 1500);
        } catch (err) {
          setError(err?.message || 'Failed to update password.');
        } finally {
          setLoading(false);
        }
      };

      return (
        <div className="fixed inset-0 bg-black/60 flex items-center justify-center z-50 p-4">
          <div className="bg-white dark:bg-gray-800 rounded-2xl shadow-2xl w-full max-w-md p-6">
            <div className="flex justify-between items-center mb-4">
              <h3 className="text-xl font-bold text-gray-800 dark:text-gray-200">Reset Password</h3>
              <button onClick={onClose} className="text-gray-500 hover:text-gray-800 dark:text-gray-400 dark:hover:text-gray-200 text-2xl font-bold">×</button>
            </div>

            {done ? (
              <div className="text-center">
                <div className="text-4xl mb-2">✅</div>
                <p className="text-gray-700 dark:text-gray-300">Password updated. You're signed in.</p>
              </div>
            ) : (
              <form onSubmit={handleSubmit} className="space-y-4">
                <div>
                  <label className="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-1">New password</label>
                  <input
                    type="password"
                    className="w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-xl bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200"
                    value={password}
                    onChange={(e) => setPassword(e.target.value)}
                    placeholder="At least 8 characters"
                    required
                  />
                </div>
                {/* Password rules prompt */}
                <div className="text-xs text-gray-600 dark:text-gray-400 -mt-1">
                  <p className="font-medium">Password must contain:</p>
                  <ul className="mt-1 space-y-0.5">
                    <li className={rules.length ? 'text-green-600' : ''}>{rules.length ? '✓' : '•'} At least 8 characters</li>
                    <li className={rules.upper ? 'text-green-600' : ''}>{rules.upper ? '✓' : '•'} One uppercase letter</li>
                    <li className={rules.lower ? 'text-green-600' : ''}>{rules.lower ? '✓' : '•'} One lowercase letter</li>
                    <li className={rules.number ? 'text-green-600' : ''}>{rules.number ? '✓' : '•'} One number</li>
                    <li className={rules.special ? 'text-green-600' : ''}>{rules.special ? '✓' : '•'} One special character</li>
                  </ul>
                </div>
                <div>
                  <label className="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-1">Confirm password</label>
                  <input
                    type="password"
                    className="w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-xl bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200"
                    value={confirm}
                    onChange={(e) => setConfirm(e.target.value)}
                    required
                  />
                </div>
                {error && (
                  <div className="bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg p-3 text-sm text-red-700 dark:text-red-300">
                    {error}
                  </div>
                )}
                <button
                  type="submit"
                  disabled={loading}
                  className="w-full bg-pink-500 hover:bg-pink-600 disabled:bg-gray-400 text-white font-semibold py-3 rounded-xl"
                >
                  {loading ? 'Updating...' : 'Update Password'}
                </button>
              </form>
            )}
          </div>
        </div>
      );
    };

    // Account Modal Component
    const AccountModal = ({ user, onClose, onSignOut }) => {
      const { signIn, signUp, authError, setAuthError, validatePassword, resetPassword } = useAuth();
      const [isSignUp, setIsSignUp] = useState(false);
      const [formData, setFormData] = useState({
        email: '',
        password: '',
        confirmPassword: '',
        displayName: ''
      });
      const [isLoading, setIsLoading] = useState(false);

      const handleInputChange = (field, value) => {
        setFormData(prev => ({ ...prev, [field]: value }));
        if (authError) setAuthError(null);
      };

      const handleSubmit = async (e) => {
        e.preventDefault();
        setIsLoading(true);

        try {
          if (isSignUp) {
            if (formData.password !== formData.confirmPassword) {
              throw new Error('Passwords do not match');
            }
            if (formData.password.length < 6) {
              throw new Error('Password must be at least 6 characters');
            }
            await signUp(formData.email, formData.password, formData.displayName);
            alert('✅ Account created successfully!');
          } else {
            await signIn(formData.email, formData.password);
            alert('✅ Successfully signed in!');
          }
          onClose();
        } catch (error) {
          console.error('Auth error:', error);
        } finally {
          setIsLoading(false);
        }
      };

      if (user) {
        // Authenticated user view
        return (
          <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
            <div className="bg-white dark:bg-gray-800 rounded-2xl shadow-2xl max-w-md w-full">
              {/* Modal Header */}
              <div className="flex justify-between items-center p-6 border-b border-gray-200 dark:border-gray-700">
                <h2 className="text-2xl font-bold text-gray-800 dark:text-gray-200 flex items-center">
                  👤 Account
                </h2>
                <button 
                  onClick={onClose}
                  className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 text-2xl font-bold transition-colors"
                >
                  ×
                </button>
              </div>
              
              {/* User Info */}
              <div className="p-6 space-y-4">
                <div className="text-center">
                  <div className="w-20 h-20 bg-gradient-to-r from-pink-500 to-purple-600 rounded-full flex items-center justify-center text-white text-2xl font-bold mx-auto mb-4">
                    {user.user_metadata?.display_name ? user.user_metadata.display_name.charAt(0).toUpperCase() : user.email.charAt(0).toUpperCase()}
                  </div>
                  <h3 className="text-xl font-semibold text-gray-800 dark:text-gray-200">
                    {user.user_metadata?.display_name || 'User'}
                  </h3>
                  <p className="text-gray-600 dark:text-gray-400">{user.email}</p>
                </div>
                
                <div className="bg-green-50 dark:bg-green-900/20 border border-green-200 dark:border-green-800 rounded-lg p-4">
                  <p className="text-green-800 dark:text-green-200 text-sm font-medium flex items-center">
                    ✅ Account verified
                  </p>
                </div>
                
                <div className="space-y-2 text-sm text-gray-600 dark:text-gray-400">
                  <p><strong>Account created:</strong> {user.created_at ? new Date(user.created_at).toLocaleDateString() : 'Unknown'}</p>
                  <p><strong>Last sign in:</strong> {user.last_sign_in_at ? new Date(user.last_sign_in_at).toLocaleDateString() : 'Unknown'}</p>
                </div>
                
                <button 
                  onClick={onSignOut}
                  className="w-full bg-red-500 hover:bg-red-600 text-white py-3 px-4 rounded-xl font-semibold transition-colors"
                >
                  Sign Out
                </button>
              </div>
            </div>
          </div>
        );
      }

      // Sign in/up form
      return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
          <div className="bg-white dark:bg-gray-800 rounded-2xl shadow-2xl max-w-md w-full">
            {/* Modal Header */}
            <div className="flex justify-between items-center p-6 border-b border-gray-200 dark:border-gray-700">
              <h2 className="text-2xl font-bold text-gray-800 dark:text-gray-200 flex items-center">
                🔐 {isSignUp ? 'Create Account' : 'Sign In'}
              </h2>
              <button 
                onClick={onClose}
                className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 text-2xl font-bold transition-colors"
              >
                ×
              </button>
            </div>
            
            {/* Form */}
            <form onSubmit={handleSubmit} className="p-6 space-y-4">
              {isSignUp && (
                <div>
                  <label className="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-2">
                    Full Name
                  </label>
                  <input
                    type="text"
                    value={formData.displayName}
                    onChange={(e) => handleInputChange('displayName', e.target.value)}
                    className="w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-xl focus:ring-2 focus:ring-pink-500 focus:border-transparent bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 transition-all"
                    placeholder="Enter your full name"
                    required
                  />
                </div>
              )}
              
              <div>
                <label className="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-2">
                  Email Address
                </label>
                <input
                  type="email"
                  value={formData.email}
                  onChange={(e) => handleInputChange('email', e.target.value)}
                  className="w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-xl focus:ring-2 focus:ring-pink-500 focus:border-transparent bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 transition-all"
                  placeholder="Enter your email"
                  required
                />
              </div>
              
              <div>
                <label className="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-2">
                  Password
                </label>
                <input
                  type="password"
                  value={formData.password}
                  onChange={(e) => handleInputChange('password', e.target.value)}
                  className="w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-xl focus:ring-2 focus:ring-pink-500 focus:border-transparent bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 transition-all"
                  placeholder="Enter your password"
                  required
                />
                {isSignUp && formData.password && (
                  <div className="mt-2 text-xs space-y-1">
                    {(() => {
                      const validation = validatePassword(formData.password);
                      return (
                        <div className="space-y-1">
                          <div className={`flex items-center ${formData.password.length >= 8 ? 'text-green-600' : 'text-red-500'}`}>
                            <span className="mr-1">{formData.password.length >= 8 ? '✓' : '✗'}</span>
                            At least 8 characters
                          </div>
                          <div className={`flex items-center ${/[A-Z]/.test(formData.password) ? 'text-green-600' : 'text-red-500'}`}>
                            <span className="mr-1">{/[A-Z]/.test(formData.password) ? '✓' : '✗'}</span>
                            One uppercase letter
                          </div>
                          <div className={`flex items-center ${/[a-z]/.test(formData.password) ? 'text-green-600' : 'text-red-500'}`}>
                            <span className="mr-1">{/[a-z]/.test(formData.password) ? '✓' : '✗'}</span>
                            One lowercase letter
                          </div>
                          <div className={`flex items-center ${/[0-9]/.test(formData.password) ? 'text-green-600' : 'text-red-500'}`}>
                            <span className="mr-1">{/[0-9]/.test(formData.password) ? '✓' : '✗'}</span>
                            One number
                          </div>
                          <div className={`flex items-center ${/[!@#$%^&*(),.?":{}|<>]/.test(formData.password) ? 'text-green-600' : 'text-red-500'}`}>
                            <span className="mr-1">{/[!@#$%^&*(),.?":{}|<>]/.test(formData.password) ? '✓' : '✗'}</span>
                            One special character
                          </div>
                        </div>
                      );
                    })()
                    }
                  </div>
                )}
              </div>
              
              {isSignUp && (
                <div>
                  <label className="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-2">
                    Confirm Password
                  </label>
                  <input
                    type="password"
                    value={formData.confirmPassword}
                    onChange={(e) => handleInputChange('confirmPassword', e.target.value)}
                    className={`w-full px-4 py-3 border rounded-xl focus:ring-2 focus:ring-pink-500 focus:border-transparent bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 transition-all ${
                      formData.confirmPassword && formData.password !== formData.confirmPassword 
                        ? 'border-red-500 dark:border-red-500' 
                        : 'border-gray-300 dark:border-gray-600'
                    }`}
                    placeholder="Confirm your password"
                    required
                  />
                  {formData.confirmPassword && formData.password !== formData.confirmPassword && (
                    <div className="mt-2 text-xs text-red-500 flex items-center">
                      <span className="mr-1">✗</span>
                      Passwords do not match
                    </div>
                  )}
                  {formData.confirmPassword && formData.password === formData.confirmPassword && formData.confirmPassword.length > 0 && (
                    <div className="mt-2 text-xs text-green-600 flex items-center">
                      <span className="mr-1">✓</span>
                      Passwords match
                    </div>
                  )}
                </div>
              )}
              
              {authError && (
                <div className="bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg p-4">
                  <p className="text-red-800 dark:text-red-200 text-sm font-medium">
                    ❌ {authError}
                  </p>
                </div>
              )}
              
              <button 
                type="submit"
                disabled={isLoading}
                className="w-full bg-gradient-to-r from-pink-500 to-purple-600 text-white py-3 px-4 rounded-xl font-semibold hover:from-pink-600 hover:to-purple-700 transition-all duration-200 shadow-lg disabled:opacity-50 disabled:cursor-not-allowed"
              >
                {isLoading ? '⏳ Processing...' : (isSignUp ? 'Create Account' : 'Sign In')}
              </button>
              
              {!isSignUp && (
                <div className="text-center">
                  <button 
                    type="button"
                    onClick={async () => {
                      if (!formData.email) {
                        setAuthError('Please enter your email address first.');
                        return;
                      }
                      try {
                        await resetPassword(formData.email);
                        setAuthError('');
                        alert('Password reset email sent! Check your inbox.');
                      } catch (error) {
                        // Error is already handled in resetPassword function
                      }
                    }}
                    className="text-sm text-gray-600 dark:text-gray-400 hover:text-pink-500 transition-colors"
                  >
                    Forgot your password?
                  </button>
                </div>
              )}
              
              <div className="text-center">
                <button 
                  type="button"
                  onClick={() => setIsSignUp(!isSignUp)}
                  className="text-pink-500 hover:text-pink-600 font-medium transition-colors"
                >
                  {isSignUp ? 'Already have an account? Sign In' : 'Need an account? Sign Up'}
                </button>
              </div>
              
              <div className="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-4">
                <p className="text-blue-800 dark:text-blue-200 text-sm">
                  💡 <strong>Benefits of creating an account:</strong><br/>
                  • Sync data across all devices<br/>
                  • Never lose your progress<br/>
                  • Access from any browser
                </p>
              </div>
            </form>
          </div>
        </div>
      );
    };

    // Scan Screen Component with OpenRouter (Qwen VL) Integration
    const Scan = ({ onLogMeal }) => {
      const [isLoading, setIsLoading] = useState(false);
      const [scanResult, setScanResult] = useState(() => {
        try {
          const saved = localStorage.getItem('foodScanner_scanResult');
          return saved ? JSON.parse(saved) : null;
        } catch {
          return null;
        }
      });
      const [error, setError] = useState(null);
      const [imagePreview, setImagePreview] = useState(() => {
        try {
          return localStorage.getItem('foodScanner_imagePreview') || null;
        } catch {
          return null;
        }
      });
      const [selectedMood, setSelectedMood] = useState(() => {
        try {
          return localStorage.getItem('foodScanner_selectedMood') || null;
        } catch {
          return null;
        }
      });
      const [portionSize, setPortionSize] = useState(() => {
        try {
          return localStorage.getItem('foodScanner_portionSize') || '';
        } catch {
          return '';
        }
      });
      const [portionUnit, setPortionUnit] = useState(() => {
        try {
          return localStorage.getItem('foodScanner_portionUnit') || 'grams';
        } catch {
          return 'grams';
        }
      });
      const fileInputRef = useRef(null);

      const fileToBase64 = (file) => new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = () => resolve(reader.result.split(',')[1]);
        reader.onerror = error => reject(error);
      });


      const handleImageChange = (event) => {
        const file = event.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = async (e) => {
            const dataUrl = e.target.result;
            setImagePreview(dataUrl);
            
            // Store compressed image in localStorage like Menu Decoder does
            try {
              const compress = (dataUrl) => new Promise(resolve => {
                try {
                  const img = new Image();
                  img.onload = () => {
                    try {
                      const canvas = document.createElement('canvas');
                      const ctx = canvas.getContext('2d');
                      const maxWidth = 800;
                      const maxHeight = 600;
                      let { width, height } = img;
                      if (width > height) {
                        if (width > maxWidth) { height *= maxWidth / width; width = maxWidth; }
                      } else {
                        if (height > maxHeight) { width *= maxHeight / height; height = maxHeight; }
                      }
                      canvas.width = width; canvas.height = height;
                      ctx.drawImage(img, 0, 0, width, height);
                      resolve(canvas.toDataURL('image/jpeg', 0.6));
                    } catch (e) { resolve(dataUrl); }
                  };
                  img.onerror = () => resolve(dataUrl);
                  img.src = dataUrl;
                } catch (e) { resolve(dataUrl); }
              });
              const compressedImage = await compress(dataUrl);
              localStorage.setItem('foodScanner_imagePreview', compressedImage);
            } catch (error) {
              console.warn('Failed to store compressed image:', error);
            }
          };
          reader.readAsDataURL(file);
          setScanResult(null);
          setError(null);
          setSelectedMood(null);
          handleScan(file);
        }
      };

      const handleScan = async (file) => {
        setIsLoading(true);
        setError(null);
        try {
          const base64ImageData = await fileToBase64(file);
          
          // Build the prompt with portion information if provided
          let prompt = `Analyze the food in this image.
1. Identify the main dish.
2. Break it down into primary ingredients and estimate calories for each.
3. Provide a total nutritional summary (calories, protein, carbs, fat).`;

          // Add portion size information to the prompt if provided
          if (portionSize && portionSize.trim() !== '') {
            prompt += `
4. IMPORTANT: The user has specified that this portion weighs ${portionSize} ${portionUnit}. Please adjust ALL nutritional values (calories, protein, carbs, fat) based on this specific portion size.`;
          }

          prompt += `
5. Offer a single, actionable, and encouraging "health_tip" to make this meal healthier next time.
Respond ONLY with a valid JSON object in this format:
{
  "name": "Overall Dish Name",
  "total_calories": 550,
  "total_protein": 30.5,
  "total_carbs": 45.2,
  "total_fat": 25.8,
  "ingredients": [
    {"name": "Ingredient 1", "calories": 200},
    {"name": "Ingredient 2", "calories": 150}
  ],
  "health_tip": "A short, encouraging tip to improve the meal."
}`;

          const payload = {
            model: OPENROUTER_QWEN_VL_MODEL,
            messages: [
              {
                role: 'user',
                content: [
                  { type: 'text', text: prompt },
                  { type: 'image_url', image_url: `data:${file.type};base64,${base64ImageData}` }
                ]
              }
            ]
          };

          const response = await fetch(getDirectGeminiConfig().url, {
            method: 'POST',
            headers: getDirectGeminiConfig().headers,
            body: JSON.stringify(payload)
          });

          if (!response.ok) {
            throw new Error(`API Error: ${response.status} ${response.statusText}`);
          }

          const result = await response.json();
          const textResponse = (result.choices?.[0]?.message?.content || '');
          const jsonString = textResponse.replace(/```json|```/g, '').trim();
          const data = JSON.parse(jsonString);
          data.image = `data:${file.type};base64,${base64ImageData}`;
          setScanResult(data);
          
          // Save to localStorage for persistence
          try {
            localStorage.setItem('foodScanner_scanResult', JSON.stringify(data));
            // imagePreview is already saved in handleImageChange
            if (portionSize) localStorage.setItem('foodScanner_portionSize', portionSize);
            if (portionUnit) localStorage.setItem('foodScanner_portionUnit', portionUnit);
          } catch (err) {
            console.warn('Failed to save scan result to localStorage:', err);
          }
        } catch (err) {
          console.error("OpenRouter API call failed:", err);
          setError('Could not analyze the image. Please try again.');
        } finally {
          setIsLoading(false);
        }
      };

      const resetScan = () => {
        setImagePreview(null);
        setScanResult(null);
        setError(null);
        setSelectedMood(null);
        setPortionSize('');
        setPortionUnit('grams');
        
        // Clear localStorage when resetting
        try {
          localStorage.removeItem('foodScanner_scanResult');
          localStorage.removeItem('foodScanner_imagePreview');
          localStorage.removeItem('foodScanner_selectedMood');
          localStorage.removeItem('foodScanner_portionSize');
          localStorage.removeItem('foodScanner_portionUnit');
        } catch (err) {
          console.warn('Failed to clear localStorage:', err);
        }
        
        if (fileInputRef.current) {
          fileInputRef.current.value = '';
        }
        console.log('Scan reset');
      };



      return (
        <div className="p-6 pb-24 flex flex-col items-center">
          <header className="mb-6 text-center">
            <h1 className="text-3xl font-bold text-gray-800 dark:text-gray-200">AI Food Scanner</h1>
            <p className="text-gray-500 dark:text-gray-400">Get instant nutritional info and health tips</p>
          </header>

          <div className="w-full max-w-md mx-auto">
            {/* Portion Input Section */}
            <div className="bg-white dark:bg-gray-800 p-4 rounded-2xl shadow-md mb-4">
              <h3 className="text-lg font-semibold text-gray-800 dark:text-gray-200 mb-3 text-center">Portion Size (Optional)</h3>
              <div className="flex items-center space-x-2 sm:space-x-3">
                <input
                  type="number"
                  placeholder="Enter quantity"
                  value={portionSize}
                  onChange={(e) => {
                    setPortionSize(e.target.value);
                    try {
                      localStorage.setItem('foodScanner_portionSize', e.target.value);
                    } catch (err) {
                      console.warn('Failed to save portion size to localStorage:', err);
                    }
                  }}
                  className="flex-1 p-3 border border-gray-300 dark:border-gray-600 rounded-xl bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 focus:outline-none focus:ring-2 focus:ring-purple-500"
                />
                <div className="flex bg-gray-100 dark:bg-gray-700 rounded-xl p-1 flex-shrink-0">
                  <button
                    onClick={() => {
                      setPortionUnit('grams');
                      try {
                        localStorage.setItem('foodScanner_portionUnit', 'grams');
                      } catch (err) {
                        console.warn('Failed to save portion unit to localStorage:', err);
                      }
                    }}
                    className={`px-2 sm:px-3 py-2 rounded-lg text-xs sm:text-sm font-medium transition-colors ${
                      portionUnit === 'grams' 
                        ? 'bg-purple-500 text-white' 
                        : 'text-gray-600 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-600'
                    }`}
                  >
                    g
                  </button>
                  <button
                    onClick={() => {
                      setPortionUnit('ml');
                      try {
                        localStorage.setItem('foodScanner_portionUnit', 'ml');
                      } catch (err) {
                        console.warn('Failed to save portion unit to localStorage:', err);
                      }
                    }}
                    className={`px-2 sm:px-3 py-2 rounded-lg text-xs sm:text-sm font-medium transition-colors ${
                      portionUnit === 'ml' 
                        ? 'bg-purple-500 text-white' 
                        : 'text-gray-600 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-600'
                    }`}
                  >
                    ml
                  </button>
                </div>
              </div>
              <p className="text-xs text-gray-500 dark:text-gray-400 mt-2 text-center">
                Add portion size for more accurate nutritional values
              </p>
            </div>

            {!imagePreview && (
              <div className="bg-white dark:bg-gray-800 p-8 rounded-2xl shadow-md text-center">
                <div className="mb-6">
                  <div className="w-24 h-24 mx-auto mb-4 bg-gradient-to-br from-purple-400 to-pink-500 rounded-full flex items-center justify-center">
                    <span className="text-4xl">📷</span>
                  </div>
                  <h3 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-2">Scan Your Food</h3>
                  <p className="text-gray-600 dark:text-gray-400 mb-6">Take a photo of your meal and get instant nutritional analysis with personalized health tips!</p>
                </div>
                
                <button
                  onClick={() => fileInputRef.current.click()}
                  className="w-full bg-gradient-to-r from-purple-500 to-pink-500 text-white font-bold py-4 rounded-2xl shadow-lg hover:from-purple-600 hover:to-pink-600 transition-all transform hover:scale-105"
                >
                  📷 Scan Your Meal
                </button>
                
                <div className="mt-6 p-4 bg-purple-50 dark:bg-purple-900/20 rounded-xl">
                  <h4 className="font-semibold text-purple-800 dark:text-purple-200 mb-2">💡 Pro Tips:</h4>
                  <ul className="text-sm text-purple-700 dark:text-purple-300 space-y-1">
                    <li>• Ensure good lighting for best results</li>
                    <li>• Include labels and packaging when visible</li>
                    <li>• Multiple ingredients in one photo work great!</li>
                  </ul>
                </div>
              </div>
            )}

            {imagePreview && !scanResult && (
              <div className="bg-white dark:bg-gray-800 rounded-2xl shadow-md overflow-hidden">
                <img src={imagePreview} alt="Meal preview" className="w-full h-64 object-cover" />
                
                {!isLoading && (
                  <div className="p-6">
                    <div className="mb-4 p-4 bg-purple-50 dark:bg-purple-900/20 rounded-xl">
                      <h4 className="font-semibold text-purple-800 dark:text-purple-200 mb-2">💡 Pro Tips:</h4>
                      <ul className="text-sm text-purple-700 dark:text-purple-300 space-y-1">
                        <li>• Ensure good lighting for best results</li>
                        <li>• Include labels and packaging when visible</li>
                        <li>• Multiple ingredients in one photo work great!</li>
                      </ul>
                    </div>
                    
                    <p className="text-gray-600 dark:text-gray-400 mb-4 text-center">Image loaded. Ready to analyze.</p>
                    <div className="flex gap-3 justify-center">
                      <button 
                        onClick={() => {
                          const storedImage = localStorage.getItem('foodScanner_imagePreview');
                          if (storedImage) {
                            fetch(storedImage)
                              .then(res => res.blob())
                              .then(blob => {
                                const file = new File([blob], 'image.jpg', { type: 'image/jpeg' });
                                handleScan(file);
                              })
                              .catch(err => {
                                console.error('Failed to analyze:', err);
                                setError('Could not analyze the image. Please try scanning again.');
                              });
                          }
                        }}
                        className="bg-purple-500 hover:bg-purple-600 text-white px-6 py-3 rounded-xl font-semibold transition-colors"
                      >
                        Analyse
                      </button>
                      <button 
                        onClick={resetScan}
                        className="bg-gray-500 hover:bg-gray-600 text-white px-6 py-3 rounded-xl font-semibold transition-colors"
                      >
                        Scan New
                      </button>
                    </div>
                  </div>
                )}
                
                {isLoading && (
                  <div className="p-6 text-center">
                    <div className="animate-spin w-8 h-8 border-4 border-purple-500 border-t-transparent rounded-full mx-auto mb-4"></div>
                    <p className="text-gray-600 dark:text-gray-400">Analyzing your meal...</p>
                  </div>
                )}
              </div>
            )}
            
            <input
              type="file"
              accept="image/*"
              capture="environment"
              ref={fileInputRef}
              onChange={handleImageChange}
              className="hidden"
            />

            {error && <div className="my-4 text-center text-red-500 bg-red-100 p-3 rounded-lg">{error}</div>}

            {scanResult && (
              <div className="mt-6 bg-white dark:bg-gray-800 p-6 rounded-2xl shadow-md animate-fade-in">
                <div className="flex justify-between items-center mb-4">
                  <div>
                    <h2 className="text-2xl font-bold text-gray-800 dark:text-gray-200">{scanResult.name}</h2>
                    <p className="text-lg font-semibold text-gray-600 dark:text-gray-300">{scanResult.total_calories} kcal</p>
                  </div>
                  <button
                    onClick={resetScan}
                    className="text-purple-500 font-semibold text-sm hover:text-purple-600 transition-colors"
                  >
                    ← Scan New
                  </button>
                </div>

                {scanResult.health_tip && (
                  <div className="mb-4 p-4 bg-yellow-100 text-yellow-800 rounded-lg flex items-start">
                    <span className="text-2xl mr-3">💡</span>
                    <div>
                      <h3 className="font-bold">Plate Perfecter Tip</h3>
                      <p>{scanResult.health_tip}</p>
                    </div>
                  </div>
                )}

                {/* Mindful Journal Section */}
                <div className="my-4">
                  <h3 className="font-bold text-gray-700 dark:text-gray-300 mb-2 text-center">How do you feel after this meal?</h3>
                  <div className="flex justify-around">
                    {['Energized', 'Happy', 'Sluggish', 'Bloated'].map(mood => (
                      <button
                        key={mood}
                        onClick={() => {
                          setSelectedMood(mood);
                          try {
                            localStorage.setItem('foodScanner_selectedMood', mood);
                          } catch (err) {
                            console.warn('Failed to save mood to localStorage:', err);
                          }
                        }}
                        className={`p-2 rounded-lg border-2 ${selectedMood === mood ? 'border-pink-500' : 'border-transparent'}`}
                      >
                        <span className="text-3xl">{{ Energized: '⚡️', Happy: '😊', Sluggish: '😴', Bloated: '🤢' }[mood]}</span>
                      </button>
                    ))}
                  </div>
                </div>

                <div className="space-y-3 mb-4 text-gray-800 dark:text-gray-200">
                  <h3 className="font-bold text-gray-700 dark:text-gray-300">Nutritional Summary:</h3>
                  <p><strong>Protein:</strong> {scanResult.total_protein} g</p>
                  <p><strong>Carbs:</strong> {scanResult.total_carbs} g</p>
                  <p><strong>Fat:</strong> {scanResult.total_fat} g</p>
                </div>

                {scanResult.ingredients && scanResult.ingredients.length > 0 && (
                  <div className="space-y-3 mb-4 text-gray-800 dark:text-gray-200">
                    <h3 className="font-bold text-gray-700 dark:text-gray-300">Ingredient Breakdown:</h3>
                    {scanResult.ingredients.map((item, index) => (
                      <div key={index} className="flex justify-between">
                        <span>{item.name}</span>
                        <span>{item.calories} kcal</span>
                      </div>
                    ))}
                  </div>
                )}

                <button
                  onClick={() => onLogMeal({
                    ...scanResult,
                    calories: scanResult.total_calories,
                    protein: scanResult.total_protein,
                    carbs: scanResult.total_carbs,
                    fat: scanResult.total_fat,
                    image: scanResult.image,
                    mood: selectedMood
                  })}
                  className="w-full mt-4 bg-green-500 text-white font-bold py-3 rounded-xl hover:bg-green-600 transition-colors"
                >
                  Log this Meal
                </button>
              </div>
            )}
          </div>
        </div>
      );

    };

    // Menu Decoder Component
    const MenuDecoder = ({ goals, menuState, setMenuState }) => {
      const { imagePreview, isLoading, menuItems, recommendations, error, userGoals } = menuState;
      
      const setIsLoading = (value) => setMenuState(prev => ({ ...prev, isLoading: value }));
      const setImagePreview = (value) => {
        setMenuState(prev => ({ ...prev, imagePreview: value }));
        // Do not store raw image here; compressed version will be stored after processing
      };
      const setMenuItems = (value) => {
        setMenuState(prev => ({ ...prev, menuItems: value }));
        localStorage.setItem('menuDecoder_menuItems', JSON.stringify(value));
      };
      const setRecommendations = (value) => {
        setMenuState(prev => ({ ...prev, recommendations: value }));
        localStorage.setItem('menuDecoder_recommendations', JSON.stringify(value));
      };
      const setError = (value) => setMenuState(prev => ({ ...prev, error: value }));
      const setUserGoals = (value) => {
        setMenuState(prev => ({ ...prev, userGoals: value }));
        localStorage.setItem('menuDecoder_userGoals', value);
      };
      const fileInputRef = useRef(null);

      const fileToBase64 = (file) => new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = () => resolve(reader.result.split(',')[1]);
        reader.onerror = error => reject(error);
      });

      // Rebuild a File from stored data URL to resume analysis after a stale preview in Menu Decoder
      const dataURLtoFile = (dataUrl, fileName = 'menu.jpg') => {
        try {
          const [meta, base64] = dataUrl.split(',');
          const match = /data:(.*?);/i.exec(meta);
          const mime = match ? match[1] : 'image/jpeg';
          const binary = atob(base64);
          const len = binary.length;
          const bytes = new Uint8Array(len);
          for (let i = 0; i < len; i++) bytes[i] = binary.charCodeAt(i);
          return new File([bytes], fileName, { type: mime });
        } catch (e) { return null; }
      };

      const resumeMenuScanFromSaved = async () => {
        try {
          let dataUrl = localStorage.getItem('menuDecoder_imagePreview');
          if (!dataUrl && typeof imagePreview === 'string' && imagePreview.startsWith('data:')) {
            dataUrl = imagePreview;
          }
          if (dataUrl) {
            const file = dataURLtoFile(dataUrl, 'menu.jpg');
            if (file) { await handleScan(file); return; }
          }
          if (fileInputRef.current) fileInputRef.current.click();
        } catch (err) { setError('Could not resume analysis. Please try again.'); }
      };

      const resetScan = () => {
        setImagePreview(null);
        localStorage.removeItem('menuDecoder_imagePreview');
        setMenuItems(null);
        localStorage.removeItem('menuDecoder_menuItems');
        setRecommendations(null);
        localStorage.removeItem('menuDecoder_recommendations');
        setError(null);
      };

      const handleImageChange = (e) => {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = async (e) => {
            setImagePreview(e.target.result);
            try {
              const compress = async (dataUrl) => {
                if (typeof compressImageForMobile !== 'undefined') return await compressImageForMobile(dataUrl, 300, 0.6);
                if (typeof window !== 'undefined' && window.compressImageForMobile) return await window.compressImageForMobile(dataUrl, 300, 0.6);
                return await new Promise((resolve) => {
                  try {
                    const img = new Image();
                    img.onload = () => {
                      try {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        let width = img.width, height = img.height;
                        const maxWidth = 300;
                        if (width > maxWidth) { height = height * (maxWidth / width); width = maxWidth; }
                        canvas.width = width; canvas.height = height;
                        ctx.drawImage(img, 0, 0, width, height);
                        resolve(canvas.toDataURL('image/jpeg', 0.6));
                      } catch (e) { resolve(dataUrl); }
                    };
                    img.onerror = () => resolve(dataUrl);
                    img.src = dataUrl;
                  } catch (e) { resolve(dataUrl); }
                });
              };
              const compressedImage = await compress(e.target.result);
              setLocalStorageWithSync('menuDecoder_imagePreview', compressedImage);
            } catch (error) {
              console.warn('Failed to store compressed image:', error);
            }
          };
          reader.readAsDataURL(file);
          setMenuItems(null);
          localStorage.removeItem('menuDecoder_menuItems');
          setRecommendations(null);
          localStorage.removeItem('menuDecoder_recommendations');
          setError(null);
          handleScan(file);
        }
      };

      const handleScan = async (file) => {
        setIsLoading(true);
        setError(null);
        try {
          const base64ImageData = await fileToBase64(file);
          const prompt = `Analyze this restaurant menu image and provide personalized recommendations.

1. Extract all visible menu items with their names, descriptions, and prices (if visible).
2. Based on the user's dietary goals: "${userGoals}" and daily calorie target of ${goals.calories} calories, analyze each item.
3. Provide specific recommendations with explanations.

Respond ONLY with a valid JSON object in this format:
{
  "menu_items": [
    {
      "name": "Item Name",
      "description": "Item description from menu",
      "price": "$X.XX or null if not visible",
      "estimated_calories": 000,
      "health_score": 1-10,
      "recommendation_reason": "Why this fits or doesn't fit user goals"
    }
  ],
  "top_recommendations": [
    {
      "item_name": "Best Item Name",
      "why_recommended": "Detailed explanation",
      "modification_tip": "Optional suggestion to make it healthier"
    }
  ],
  "items_to_avoid": [
    {
      "item_name": "Item to avoid",
      "why_avoid": "Reason why it doesn't fit goals"
    }
  ]
}`;

          const payload = {
            contents: [
              {
                parts: [
                  { text: prompt },
                  { inlineData: { mimeType: file.type, data: base64ImageData } }
                ]
              }
            ],
          };

          // Use Direct OpenRouter (Qwen)
          const response = await fetch(getDirectGeminiConfig().url, {
            method: 'POST',
            headers: getDirectGeminiConfig().headers,
            body: JSON.stringify({
              model: OPENROUTER_QWEN_VL_MODEL,
              messages: [{
                role: 'user',
                content: [
                  { type: 'text', text: prompt },
                  { type: 'image_url', image_url: `data:${file.type};base64,${base64ImageData}` }
                ]
              }]
            })
          });

          if (!response.ok) {
            throw new Error(`API Error: ${response.status} ${response.statusText}`);
          }

          const result = await response.json();
          const textResponse = (result.choices?.[0]?.message?.content || '');
          const jsonString = textResponse.replace(/```json|```/g, '').trim();
          const data = JSON.parse(jsonString);
          setMenuItems(data.menu_items);
          localStorage.setItem('menuDecoder_menuItems', JSON.stringify(data.menu_items));
          setRecommendations({
            top: data.top_recommendations,
            avoid: data.items_to_avoid
          });
          localStorage.setItem('menuDecoder_recommendations', JSON.stringify({
            top: data.top_recommendations,
            avoid: data.items_to_avoid
          }));
        } catch (err) {
          console.error("Menu analysis failed:", err);
          setError('Could not analyze menu. Please try again with a clearer image.');
        } finally {
          setIsLoading(false);
        }
      };

      return (
        <div className="p-6 pb-24">
          <header className="mb-6 text-center">
            <h1 className="text-3xl font-bold text-gray-800 dark:text-gray-200">🍽️ Menu Decoder</h1>
            <p className="text-gray-500 dark:text-gray-400">Smart dining choices made easy!</p>
          </header>

          {!imagePreview && (
            <div className="max-w-md mx-auto">
              {/* Goals Input */}
              <div className="bg-white dark:bg-gray-800 p-4 rounded-2xl shadow-md mb-4">
                <h3 className="font-semibold text-gray-800 dark:text-gray-200 mb-2">Your Dining Goals:</h3>
                <input
                  type="text"
                  value={userGoals}
                  onChange={(e) => {
                    setUserGoals(e.target.value);
                    localStorage.setItem('menuDecoder_userGoals', e.target.value);
                  }}
                  placeholder="e.g., high protein, low carb, heart healthy"
                  className="w-full p-3 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200"
                />
              </div>

              <div className="bg-white dark:bg-gray-800 p-8 rounded-2xl shadow-md text-center">
                <div className="mb-6">
                  <div className="w-24 h-24 mx-auto mb-4 bg-gradient-to-br from-orange-400 to-red-500 rounded-full flex items-center justify-center">
                    <span className="text-4xl">🍽️</span>
                  </div>
                  <h3 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-2">Scan Restaurant Menu</h3>
                  <p className="text-gray-600 dark:text-gray-400 mb-6">Take a photo of any restaurant menu and I'll highlight the healthiest options for your goals!</p>
                </div>
                
                <input
                  type="file"
                  accept="image/*"
                  capture="environment"
                  onChange={handleImageChange}
                  ref={fileInputRef}
                  className="hidden"
                />
                
                <button
                  onClick={() => fileInputRef.current?.click()}
                  className="w-full bg-gradient-to-r from-orange-500 to-red-500 text-white font-bold py-4 rounded-2xl shadow-lg hover:from-orange-600 hover:to-red-600 transition-all transform hover:scale-105"
                >
                  📷 Scan Menu
                </button>
                
                <div className="mt-6 p-4 bg-orange-50 dark:bg-orange-900/20 rounded-xl">
                  <h4 className="font-semibold text-orange-800 dark:text-orange-200 mb-2">💡 Pro Tips:</h4>
                  <ul className="text-sm text-orange-700 dark:text-orange-300 space-y-1">
                    <li>• Ensure menu text is clearly visible</li>
                    <li>• Include item descriptions when possible</li>
                    <li>• Works with any restaurant menu!</li>
                  </ul>
                </div>
              </div>
            </div>
          )}

          {imagePreview && (
            <div className="max-w-md mx-auto">
              <div className="bg-white dark:bg-gray-800 rounded-2xl shadow-md overflow-hidden">
                <img src={imagePreview} alt="Restaurant menu" className="w-full h-64 object-cover" />
                
                {!isLoading && !error && !recommendations && !menuItems && (
                  <div className="p-6 text-center">
                    <p className="text-gray-600 dark:text-gray-400 mb-4">Image loaded. Ready to analyze.</p>
                    <div className="flex gap-3 justify-center">
                      <button onClick={resumeMenuScanFromSaved} className="bg-orange-500 hover:bg-orange-600 text-white px-4 py-2 rounded-lg">Analyze Now</button>
                      <button onClick={resetScan} className="bg-gray-500 hover:bg-gray-600 text-white px-4 py-2 rounded-lg">Choose Different Image</button>
                    </div>
                  </div>
                )}
                
                {isLoading && (
                  <div className="p-6 text-center">
                    <div className="animate-spin w-8 h-8 border-4 border-orange-500 border-t-transparent rounded-full mx-auto mb-4"></div>
                    <p className="text-gray-600 dark:text-gray-400">Analyzing menu options...</p>
                  </div>
                )}

                {error && (
                  <div className="p-6 text-center">
                    <p className="text-red-500 mb-4">{error}</p>
                    <button onClick={resetScan} className="bg-gray-500 text-white px-4 py-2 rounded-lg">
                      Try Again
                    </button>
                  </div>
                )}

                {recommendations && (
                  <div className="p-6">
                    <div className="flex justify-between items-center mb-4">
                      <h3 className="font-bold text-gray-800 dark:text-gray-200">🎯 Smart Recommendations</h3>
                      <button onClick={resetScan} className="text-orange-500 font-semibold text-sm">
                        ← New Menu
                      </button>
                    </div>
                    
                    {/* Top Recommendations */}
                    {recommendations.top && recommendations.top.length > 0 && (
                      <div className="mb-6">
                        <h4 className="font-semibold text-green-600 dark:text-green-400 mb-3">✅ Best Choices for You:</h4>
                        <div className="space-y-3">
                          {recommendations.top.map((rec, index) => (
                            <div key={index} className="bg-green-50 dark:bg-green-900/20 p-4 rounded-lg border-l-4 border-green-500">
                              <h5 className="font-bold text-gray-800 dark:text-gray-200">{rec.item_name}</h5>
                              <p className="text-sm text-gray-600 dark:text-gray-400 mt-1">{rec.why_recommended}</p>
                              {rec.modification_tip && (
                                <p className="text-sm text-green-700 dark:text-green-300 mt-2 font-medium">
                                  💡 Tip: {rec.modification_tip}
                                </p>
                              )}
                            </div>
                          ))}
                        </div>
                      </div>
                    )}

                    {/* Items to Avoid */}
                    {recommendations.avoid && recommendations.avoid.length > 0 && (
                      <div className="mb-6">
                        <h4 className="font-semibold text-red-600 dark:text-red-400 mb-3">⚠️ Consider Avoiding:</h4>
                        <div className="space-y-3">
                          {recommendations.avoid.map((avoid, index) => (
                            <div key={index} className="bg-red-50 dark:bg-red-900/20 p-4 rounded-lg border-l-4 border-red-500">
                              <h5 className="font-bold text-gray-800 dark:text-gray-200">{avoid.item_name}</h5>
                              <p className="text-sm text-gray-600 dark:text-gray-400 mt-1">{avoid.why_avoid}</p>
                            </div>
                          ))}
                        </div>
                      </div>
                    )}

                    {/* All Menu Items */}
                    {menuItems && menuItems.length > 0 && (
                      <div>
                        <h4 className="font-semibold text-gray-800 dark:text-gray-200 mb-3">📋 All Menu Items:</h4>
                        <div className="space-y-2">
                          {menuItems.map((item, index) => (
                            <div key={index} className="bg-gray-50 dark:bg-gray-700 p-3 rounded-lg">
                              <div className="flex justify-between items-start">
                                <div className="flex-1">
                                  <h5 className="font-semibold text-gray-800 dark:text-gray-200">{item.name}</h5>
                                  {item.description && (
                                    <p className="text-sm text-gray-600 dark:text-gray-400 mt-1">{item.description}</p>
                                  )}
                                  <p className="text-xs text-gray-500 dark:text-gray-500 mt-1">{item.recommendation_reason}</p>
                                </div>
                                <div className="text-right ml-3">
                                  {item.price && (
                                    <p className="font-semibold text-gray-800 dark:text-gray-200">{item.price}</p>
                                  )}
                                  <div className="flex items-center mt-1">
                                    <span className={`text-xs px-2 py-1 rounded-full ${
                                      item.health_score >= 8 ? 'bg-green-200 text-green-800 dark:bg-green-800 dark:text-green-200' :
                                      item.health_score >= 6 ? 'bg-yellow-200 text-yellow-800 dark:bg-yellow-800 dark:text-yellow-200' :
                                      'bg-red-200 text-red-800 dark:bg-red-800 dark:text-red-200'
                                    }`}>
                                      {item.health_score}/10
                                    </span>
                                  </div>
                                  <p className="text-xs text-gray-500 dark:text-gray-500 mt-1">~{item.estimated_calories} cal</p>
                                </div>
                              </div>
                            </div>
                          ))}
                        </div>
                      </div>
                    )}
                  </div>
                )}
              </div>
            </div>
          )}
        </div>
      );
    };

    // Smart Pantry Chef Component
    const SmartPantryChef = ({ goals, pantryState, setPantryState }) => {
      const { isLoading, ingredients, recipes, error, imagePreview } = pantryState;
      
      const setIsLoading = (value) => setPantryState(prev => ({ ...prev, isLoading: value }));
      const setIngredients = (value) => {
        setPantryState(prev => ({ ...prev, ingredients: value }));
        localStorage.setItem('pantryChef_ingredients', JSON.stringify(value));
      };
      const setRecipes = (value) => {
        setPantryState(prev => ({ ...prev, recipes: value }));
        localStorage.setItem('pantryChef_recipes', JSON.stringify(value));
      };
      const setError = (value) => setPantryState(prev => ({ ...prev, error: value }));
      const setImagePreview = (value) => {
        setPantryState(prev => ({ ...prev, imagePreview: value }));
        // Do not store raw image here; compressed version will be stored after processing
      };
      const fileInputRef = useRef(null);

      const fileToBase64 = (file) => new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = () => resolve(reader.result.split(',')[1]);
        reader.onerror = error => reject(error);
      });

      // Rebuild a File from stored data URL to resume analysis after a stale preview
      const dataURLtoFile = (dataUrl, fileName = 'pantry.jpg') => {
        try {
          const [meta, base64] = dataUrl.split(',');
          const match = /data:(.*?);/i.exec(meta);
          const mime = match ? match[1] : 'image/jpeg';
          const binary = atob(base64);
          const len = binary.length;
          const bytes = new Uint8Array(len);
          for (let i = 0; i < len; i++) bytes[i] = binary.charCodeAt(i);
          return new File([bytes], fileName, { type: mime });
        } catch (e) { return null; }
      };

      const resumePantryScanFromSaved = async () => {
        try {
          let dataUrl = localStorage.getItem('pantryChef_imagePreview');
          if (!dataUrl && typeof imagePreview === 'string' && imagePreview.startsWith('data:')) {
            dataUrl = imagePreview;
          }
          if (dataUrl) {
            const file = dataURLtoFile(dataUrl, 'pantry.jpg');
            if (file) { await handleScan(file); return; }
          }
          if (fileInputRef.current) fileInputRef.current.click();
        } catch (err) { setError('Could not resume analysis. Please try again.'); }
      };

      const handleImageChange = (event) => {
        const file = event.target.files[0];
        if (file) {
          const previewUrl = URL.createObjectURL(file);
          setImagePreview(previewUrl);
          
          // Store compressed image data for persistence across refreshes
          const reader = new FileReader();
          reader.onload = async (e) => {
            try {
              const compress = async (dataUrl) => {
                if (typeof compressImageForMobile !== 'undefined') return await compressImageForMobile(dataUrl, 300, 0.6);
                if (typeof window !== 'undefined' && window.compressImageForMobile) return await window.compressImageForMobile(dataUrl, 300, 0.6);
                return await new Promise((resolve) => {
                  try {
                    const img = new Image();
                    img.onload = () => {
                      try {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        let width = img.width, height = img.height;
                        const maxWidth = 300;
                        if (width > maxWidth) { height = height * (maxWidth / width); width = maxWidth; }
                        canvas.width = width; canvas.height = height;
                        ctx.drawImage(img, 0, 0, width, height);
                        resolve(canvas.toDataURL('image/jpeg', 0.6));
                      } catch (e) { resolve(dataUrl); }
                    };
                    img.onerror = () => resolve(dataUrl);
                    img.src = dataUrl;
                  } catch (e) { resolve(dataUrl); }
                });
              };
              const compressedImage = await compress(e.target.result);
              setLocalStorageWithSync('pantryChef_imagePreview', compressedImage);
            } catch (error) {
              console.warn('Failed to store compressed image:', error);
            }
          };
          reader.readAsDataURL(file);
          
          setIngredients(null);
          localStorage.removeItem('pantryChef_ingredients');
          setRecipes(null);
          localStorage.removeItem('pantryChef_recipes');
          setError(null);
          handleScan(file);
        }
      };

      const handleScan = async (file) => {
        // Safety check - if already loading, don't start again
        if (isLoading) return;
        
        setIsLoading(true);
        setError(null);
        
        // Add manual timeout to prevent freezing
        const timeoutId = setTimeout(() => {
          console.warn('Scan timeout triggered - resetting component');
          setIsLoading(false);
          setError('Request timed out. Please try scanning again.');
          // Force clear any stuck state
          localStorage.removeItem('pantryChef_ingredients');
          localStorage.removeItem('pantryChef_recipes');
        }, 30000); // 30 second backup timeout
        
        try {
          const base64ImageData = await fileToBase64(file);
          const prompt = `Analyze this image of pantry/fridge ingredients.
1. Identify all visible food items and ingredients.
2. List them clearly with estimated quantities if visible.
3. Respond ONLY with a valid JSON object in this format:
{
  "ingredients": [
    {"name": "Ingredient Name", "quantity": "estimated amount or 'available'"},
    {"name": "Another Ingredient", "quantity": "estimated amount or 'available'"}
  ]
}`;

          const payload = {
            contents: [
              {
                parts: [
                  { text: prompt },
                  { inlineData: { mimeType: file.type, data: base64ImageData } }
                ]
              }
            ],
          };

          const response = await fetch(getDirectGeminiConfig().url, {
            method: 'POST',
            headers: getDirectGeminiConfig().headers,
            body: JSON.stringify({
              model: OPENROUTER_QWEN_VL_MODEL,
              messages: [{
                role: 'user',
                content: [
                  { type: 'text', text: prompt },
                  { type: 'image_url', image_url: `data:${file.type};base64,${base64ImageData}` }
                ]
              }]
            }),
            signal: AbortSignal.timeout(25000) // 25 second timeout
          });

          if (!response.ok) {
            throw new Error(`API Error: ${response.status} ${response.statusText}`);
          }

          const result = await response.json();
          const textResponse = (result.choices?.[0]?.message?.content || '');
          const jsonString = textResponse.replace(/```json|```/g, '').trim();
          const data = JSON.parse(jsonString);
          setIngredients(data.ingredients);
          localStorage.setItem('pantryChef_ingredients', JSON.stringify(data.ingredients));
          clearTimeout(timeoutId); // Clear timeout on success
        } catch (err) {
          console.error("Ingredient recognition failed:", err);
          setError('Could not identify ingredients. Please try again.');
          clearTimeout(timeoutId); // Clear timeout on error
        } finally {
          setIsLoading(false);
        }
      };

      const generateRecipes = async () => {
        if (!ingredients || ingredients.length === 0) return;
        
        // Safety check - if already loading, don't start again
        if (isLoading) return;
        
        setIsLoading(true);
        setError(null);
        
        // Add manual timeout to prevent freezing
        const timeoutId = setTimeout(() => {
          console.warn('Recipe generation timeout triggered - resetting component');
          setIsLoading(false);
          setError('Recipe generation timed out. Please try again.');
          // Force clear any stuck state
          localStorage.removeItem('pantryChef_recipes');
        }, 30000); // 30 second backup timeout
        
        try {
          const ingredientList = ingredients.map(ing => ing.name).join(', ');
          const prompt = `Create 3 quick recipes using: ${ingredientList}. Keep under ${goals.calories} calories. JSON only: {"recipes":[{"name":"Recipe","prep_time":"15 min","cook_time":"20 min","servings":2,"calories_per_serving":350,"ingredients_used":["ingredient1"],"instructions":["Step 1"],"nutrition":{"protein":25,"carbs":30,"fat":15}}]}`;

          const response = await fetch(getDirectGeminiConfig().url, {
            method: 'POST',
            headers: getDirectGeminiConfig().headers,
            body: JSON.stringify({
              model: OPENROUTER_QWEN_MODEL,
              messages: [{ role: 'user', content: prompt }]
            })
          });

          if (!response.ok) {
            throw new Error(`API Error: ${response.status} ${response.statusText}`);
          }

          const result = await response.json();
          const textResponse = (result.choices?.[0]?.message?.content || '');
          const jsonString = textResponse.replace(/```json|```/g, '').trim();
          const data = JSON.parse(jsonString);
          setRecipes(data.recipes);
          localStorage.setItem('pantryChef_recipes', JSON.stringify(data.recipes));
          clearTimeout(timeoutId); // Clear timeout on success
        } catch (err) {
          console.error("Recipe generation failed:", err);
          setError('Could not generate recipes. Please try again.');
          clearTimeout(timeoutId); // Clear timeout on error
        } finally {
          setIsLoading(false);
        }
      };

      const resetScan = () => {
        setImagePreview(null);
        localStorage.removeItem('pantryChef_imagePreview');
        setIngredients(null);
        localStorage.removeItem('pantryChef_ingredients');
        setRecipes(null);
        localStorage.removeItem('pantryChef_recipes');
        setError(null);
        if (fileInputRef.current) {
          fileInputRef.current.value = '';
        }
      };

      return (
        <div className="p-6 pb-24">
          <header className="mb-6 text-center">
            <h1 className="text-3xl font-bold text-gray-800 dark:text-gray-200">🧑‍🍳 Smart Pantry Chef</h1>
            <p className="text-gray-500 dark:text-gray-400">Snap your ingredients, get instant recipes!</p>
          </header>

          {!imagePreview && (
            <div className="max-w-md mx-auto">
              <div className="bg-white dark:bg-gray-800 p-8 rounded-2xl shadow-md text-center">
                <div className="mb-6">
                  <div className="w-24 h-24 mx-auto mb-4 bg-gradient-to-br from-green-400 to-blue-500 rounded-full flex items-center justify-center">
                    <span className="text-4xl">📸</span>
                  </div>
                  <h3 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-2">Scan Your Pantry</h3>
                  <p className="text-gray-600 dark:text-gray-400 mb-6">Take a photo of your fridge or pantry ingredients and I'll suggest recipes you can make right now!</p>
                </div>
                
                <input
                  type="file"
                  accept="image/*"
                  capture="environment"
                  onChange={handleImageChange}
                  ref={fileInputRef}
                  className="hidden"
                />
                
                <button
                  onClick={() => fileInputRef.current?.click()}
                  className="w-full bg-gradient-to-r from-green-500 to-blue-500 text-white font-bold py-4 rounded-2xl shadow-lg hover:from-green-600 hover:to-blue-600 transition-all transform hover:scale-105"
                >
                  📷 Scan Ingredients
                </button>
                
                <div className="mt-6 p-4 bg-blue-50 dark:bg-blue-900/20 rounded-xl">
                  <h4 className="font-semibold text-blue-800 dark:text-blue-200 mb-2">💡 Pro Tips:</h4>
                  <ul className="text-sm text-blue-700 dark:text-blue-300 space-y-1">
                    <li>• Ensure good lighting for best results</li>
                    <li>• Include labels and packaging when visible</li>
                    <li>• Multiple ingredients in one photo work great!</li>
                  </ul>
                </div>
              </div>
            </div>
          )}

          {imagePreview && (
            <div className="max-w-md mx-auto">
              <div className="bg-white dark:bg-gray-800 rounded-2xl shadow-md overflow-hidden">
                <img src={imagePreview} alt="Scanned ingredients" className="w-full h-64 object-cover" />
                
                {!isLoading && !error && !ingredients && !recipes && (
                  <div className="p-6 text-center">
                    <p className="text-gray-600 dark:text-gray-400 mb-4">Image loaded. Ready to analyze.</p>
                    <div className="flex gap-3 justify-center">
                      <button onClick={resumePantryScanFromSaved} className="bg-pink-500 hover:bg-pink-600 text-white px-4 py-2 rounded-lg">Analyze Now</button>
                      <button onClick={resetScan} className="bg-gray-500 hover:bg-gray-600 text-white px-4 py-2 rounded-lg">Choose Different Image</button>
                    </div>
                  </div>
                )}
                
                {isLoading && (
                  <div className="p-6 text-center">
                    <div className="animate-spin w-8 h-8 border-4 border-pink-500 border-t-transparent rounded-full mx-auto mb-4"></div>
                    <p className="text-gray-600 dark:text-gray-400 mb-4">
                      {!ingredients ? 'Identifying ingredients...' : 'Generating recipes...'}
                    </p>
                    <button 
                      onClick={() => {
                        setIsLoading(false);
                        setError('Process cancelled. You can try again.');
                      }}
                      className="text-sm bg-red-500 text-white px-4 py-2 rounded-lg hover:bg-red-600 transition-colors"
                    >
                      Cancel & Reset
                    </button>
                  </div>
                )}

                {error && (
                  <div className="p-6 text-center">
                    <p className="text-red-500 mb-4">{error}</p>
                    <button onClick={resetScan} className="bg-gray-500 text-white px-4 py-2 rounded-lg">
                      Try Again
                    </button>
                  </div>
                )}

                {ingredients && !recipes && !isLoading && (
                  <div className="p-6">
                    <h3 className="font-bold text-gray-800 dark:text-gray-200 mb-4">🥘 Ingredients Found:</h3>
                    <div className="space-y-2 mb-6">
                      {ingredients.map((ingredient, index) => (
                        <div key={index} className="flex justify-between items-center p-2 bg-gray-50 dark:bg-gray-700 rounded-lg">
                          <span className="text-gray-800 dark:text-gray-200">{ingredient.name}</span>
                          <span className="text-sm text-gray-500 dark:text-gray-400">{ingredient.quantity}</span>
                        </div>
                      ))}
                    </div>
                    
                    <div className="space-y-3">
                      <button
                        onClick={generateRecipes}
                        className="w-full bg-green-500 text-white font-bold py-3 rounded-xl hover:bg-green-600 transition-colors"
                      >
                        🍳 Get Recipe Ideas
                      </button>
                      
                      <button
                        onClick={resetScan}
                        className="w-full bg-gray-500 text-white font-bold py-2 rounded-xl hover:bg-gray-600 transition-colors"
                      >
                        📸 Scan Different Ingredients
                      </button>
                    </div>
                  </div>
                )}

                {recipes && (
                  <div className="p-6">
                    <div className="flex justify-between items-center mb-4">
                      <h3 className="font-bold text-gray-800 dark:text-gray-200">🍽️ Recipe Suggestions</h3>
                      <button onClick={resetScan} className="text-pink-500 font-semibold text-sm">
                        ← New Scan
                      </button>
                    </div>
                    
                    <div className="space-y-4">
                      {recipes.map((recipe, index) => (
                        <RecipeCard key={index} recipe={recipe} />
                      ))}
                    </div>
                  </div>
                )}
              </div>
            </div>
          )}
        </div>
      );
    };

    // Recipe Card Component for Smart Pantry Chef
    const RecipeCard = ({ recipe }) => {
      const [isExpanded, setIsExpanded] = useState(false);
      
      return (
        <div className="border border-gray-200 dark:border-gray-700 rounded-xl overflow-hidden">
          <div className="p-4 bg-gradient-to-r from-green-50 to-blue-50 dark:from-green-900/20 dark:to-blue-900/20">
            <div className="flex justify-between items-start mb-2">
              <h4 className="font-bold text-gray-800 dark:text-gray-200">{recipe.name}</h4>
              <span className="text-sm bg-green-100 dark:bg-green-800 text-green-800 dark:text-green-200 px-2 py-1 rounded-full">
                {recipe.calories_per_serving} cal
              </span>
            </div>
            
            <div className="flex gap-4 text-sm text-gray-600 dark:text-gray-400 mb-3">
              <span>⏱️ Prep: {recipe.prep_time}</span>
              <span>🔥 Cook: {recipe.cook_time}</span>
              <span>🍽️ Serves: {recipe.servings}</span>
            </div>
            
            <div className="mb-3">
              <p className="text-sm font-semibold text-gray-700 dark:text-gray-300 mb-1">Using your ingredients:</p>
              <div className="flex flex-wrap gap-1">
                {recipe.ingredients_used.map((ing, i) => (
                  <span key={i} className="text-xs bg-green-200 dark:bg-green-700 text-green-800 dark:text-green-200 px-2 py-1 rounded-full">
                    {ing}
                  </span>
                ))}
              </div>
            </div>
            
            {recipe.additional_needed && recipe.additional_needed.length > 0 && (
              <div className="mb-3">
                <p className="text-sm font-semibold text-gray-700 dark:text-gray-300 mb-1">You might need:</p>
                <div className="flex flex-wrap gap-1">
                  {recipe.additional_needed.map((item, i) => (
                    <span key={i} className="text-xs bg-yellow-200 dark:bg-yellow-700 text-yellow-800 dark:text-yellow-200 px-2 py-1 rounded-full">
                      {item}
                    </span>
                  ))}
                </div>
              </div>
            )}
            
            <button
              onClick={() => setIsExpanded(!isExpanded)}
              className="w-full bg-white dark:bg-gray-800 text-gray-800 dark:text-gray-200 font-semibold py-2 rounded-lg border border-gray-200 dark:border-gray-600 hover:bg-gray-50 dark:hover:bg-gray-700 transition-colors"
            >
              {isExpanded ? '▲ Hide Details' : '▼ View Recipe'}
            </button>
          </div>
          
          {isExpanded && (
            <div className="p-4 border-t border-gray-200 dark:border-gray-700">
              <div className="grid md:grid-cols-2 gap-4 mb-4">
                <div>
                  <h5 className="font-semibold text-gray-800 dark:text-gray-200 mb-2">Instructions:</h5>
                  <ol className="list-decimal list-inside text-sm text-gray-600 dark:text-gray-400 space-y-1">
                    {recipe.instructions.map((step, i) => (
                      <li key={i}>{step}</li>
                    ))}
                  </ol>
                </div>
                
                <div>
                  <h5 className="font-semibold text-gray-800 dark:text-gray-200 mb-2">Nutrition per serving:</h5>
                  <div className="text-sm text-gray-600 dark:text-gray-400 space-y-1">
                    <p>🥩 Protein: {recipe.nutrition.protein}g</p>
                    <p>🍞 Carbs: {recipe.nutrition.carbs}g</p>
                    <p>🥑 Fat: {recipe.nutrition.fat}g</p>
                  </div>
                </div>
              </div>
              
              {recipe.health_tip && (
                <div className="bg-blue-50 dark:bg-blue-900/20 p-3 rounded-lg">
                  <h5 className="font-semibold text-blue-800 dark:text-blue-200 mb-1">💡 Health Tip:</h5>
                  <p className="text-sm text-blue-700 dark:text-blue-300">{recipe.health_tip}</p>
                </div>
              )}
            </div>
          )}
        </div>
      );
    };

    // Reusable Voice Button Component
    const VoiceButton = ({ text, buttonId, label, className = "" }) => {
      const [isPlaying, setIsPlaying] = useState(false);
      
      const handleVoiceControl = () => {
        const action = speechController.speak(text, buttonId);
        setIsPlaying(action === 'play');
        
        // Monitor speech end
        const checkEnd = setInterval(() => {
          if (!speechController.isActuallyPlaying() || speechController.activeButton !== buttonId) {
            setIsPlaying(false);
            clearInterval(checkEnd);
          }
        }, 500);
        
        // Cleanup after 2 minutes
        setTimeout(() => clearInterval(checkEnd), 120000);
      };
      
      return (
        <button
          onClick={handleVoiceControl}
          className={`inline-flex items-center px-3 py-2 text-sm font-medium rounded-md transition-colors ${
            isPlaying 
              ? 'bg-red-500 hover:bg-red-600 text-white' 
              : 'bg-blue-500 hover:bg-blue-600 text-white'
          } ${className}`}
        >
          {isPlaying ? '⏹️ Stop' : '🔊'} {label}
        </button>
      );
    };

    // Individual Meal Voice Button Component
    const MealVoiceButton = ({ meal, mealType, buttonId }) => {
      const [isPlaying, setIsPlaying] = useState(false);
      
      useEffect(() => {
        const checkStatus = () => {
          const actuallyPlaying = speechController.activeButton === buttonId && speechController.isActuallyPlaying();
          if (isPlaying !== actuallyPlaying) {
            setIsPlaying(actuallyPlaying);
          }
        };
        
        const interval = setInterval(checkStatus, 500);
        return () => clearInterval(interval);
      }, [buttonId, isPlaying]);
      
      const handleVoiceControl = () => {
        let text = `${mealType}: ${meal.name}. `;
        text += "Ingredients: " + meal.ingredients.join(", ") + ". ";
        text += "Instructions: " + meal.instructions.join(". ") + ".";
        
        const action = speechController.speak(text, buttonId);
        setIsPlaying(action === 'play');
      };
      
      return (
        <button
          onClick={handleVoiceControl}
          className={`w-full mb-3 py-2 px-4 rounded-lg font-medium transition-all duration-200 ${
            isPlaying 
              ? 'bg-red-500 hover:bg-red-600 text-white' 
              : 'bg-blue-500 hover:bg-blue-600 text-white'
          }`}
        >
          {isPlaying ? '⏹️ Stop Reading' : `🔊 Read ${mealType}`}
        </button>
      );
    };

    // Full Meal Plan Voice Button Component
    const MealPlanVoiceButton = ({ mealPlan }) => {
      const [isPlaying, setIsPlaying] = useState(false);
      const buttonId = 'full-meal-plan';
      
      useEffect(() => {
        const checkStatus = () => {
          const actuallyPlaying = speechController.activeButton === buttonId && speechController.isActuallyPlaying();
          if (isPlaying !== actuallyPlaying) {
            setIsPlaying(actuallyPlaying);
          }
        };
        
        const interval = setInterval(checkStatus, 500);
        return () => clearInterval(interval);
      }, [isPlaying]);
      
      const handleVoiceControl = () => {
        let text = "Here is your complete meal plan. ";
        
        // Breakfast
        text += `For breakfast, you will have ${mealPlan.breakfast.name}. `;
        text += "Ingredients needed: " + mealPlan.breakfast.ingredients.join(", ") + ". ";
        text += "Instructions: " + mealPlan.breakfast.instructions.join(". ") + ". ";
        
        // Lunch
        text += `For lunch, you will have ${mealPlan.lunch.name}. `;
        text += "Ingredients needed: " + mealPlan.lunch.ingredients.join(", ") + ". ";
        text += "Instructions: " + mealPlan.lunch.instructions.join(". ") + ". ";
        
        // Dinner
        text += `For dinner, you will have ${mealPlan.dinner.name}. `;
        text += "Ingredients needed: " + mealPlan.dinner.ingredients.join(", ") + ". ";
        text += "Instructions: " + mealPlan.dinner.instructions.join(". ") + ". ";
        
        text += "Enjoy your healthy meals!";
        
        const action = speechController.speak(text, buttonId);
        setIsPlaying(action === 'play');
      };
      
      return (
        <button
          onClick={handleVoiceControl}
          className={`mb-4 mx-auto block py-3 px-6 rounded-xl font-semibold transition-all duration-200 ${
            isPlaying 
              ? 'bg-red-500 hover:bg-red-600 text-white' 
              : 'bg-gradient-to-r from-blue-500 to-purple-500 hover:from-blue-600 hover:to-purple-600 text-white'
          }`}
        >
          {isPlaying ? '⏹️ Stop Reading Full Plan' : '🔊 Read Complete Meal Plan'}
        </button>
      );
    };

    // Individual Exercise Voice Button Component
    const ExerciseVoiceButton = ({ exercise, index }) => {
      const [isPlaying, setIsPlaying] = useState(false);
      const buttonId = `exercise-${index}`;
      
      useEffect(() => {
        const checkStatus = () => {
          const actuallyPlaying = speechController.activeButton === buttonId && speechController.isActuallyPlaying();
          if (isPlaying !== actuallyPlaying) {
            setIsPlaying(actuallyPlaying);
          }
        };
        
        const interval = setInterval(checkStatus, 500);
        return () => clearInterval(interval);
      }, [buttonId, isPlaying]);
      
      const handleVoiceControl = () => {
        let text = `Exercise ${index + 1}: ${exercise.name}. `;
        text += `You will do ${exercise.sets} sets of ${exercise.reps} repetitions. `;
        text += `Instructions: ${exercise.instructions}.`;
        
        const action = speechController.speak(text, buttonId);
        setIsPlaying(action === 'play');
      };
      
      return (
        <button
          onClick={handleVoiceControl}
          className={`w-full mb-2 py-2 px-3 rounded-lg text-sm font-medium transition-all duration-200 ${
            isPlaying 
              ? 'bg-red-500 hover:bg-red-600 text-white' 
              : 'bg-blue-500 hover:bg-blue-600 text-white'
          }`}
        >
          {isPlaying ? '⏹️ Stop' : `🔊 Read Exercise ${index + 1}`}
        </button>
      );
    };

    // Full Workout Plan Voice Button Component
    const WorkoutPlanVoiceButton = ({ workoutPlan }) => {
      const [isPlaying, setIsPlaying] = useState(false);
      const buttonId = 'full-workout-plan';
      
      useEffect(() => {
        const checkStatus = () => {
          const actuallyPlaying = speechController.activeButton === buttonId && speechController.isActuallyPlaying();
          if (isPlaying !== actuallyPlaying) {
            setIsPlaying(actuallyPlaying);
          }
        };
        
        const interval = setInterval(checkStatus, 500);
        return () => clearInterval(interval);
      }, [isPlaying]);
      
      const handleVoiceControl = () => {
        let text = "Here is your complete workout plan. ";
        
        workoutPlan.exercises.forEach((exercise, index) => {
          text += `Exercise ${index + 1}: ${exercise.name}. `;
          text += `You will do ${exercise.sets} sets of ${exercise.reps} repetitions. `;
          text += `Instructions: ${exercise.instructions}. `;
        });
        
        text += "Great job on your workout plan!";
        
        const action = speechController.speak(text, buttonId);
        setIsPlaying(action === 'play');
      };
      
      return (
        <button
          onClick={handleVoiceControl}
          className={`mb-4 mx-auto block py-3 px-6 rounded-xl font-semibold transition-all duration-200 ${
            isPlaying 
              ? 'bg-red-500 hover:bg-red-600 text-white' 
              : 'bg-gradient-to-r from-blue-500 to-purple-500 hover:from-blue-600 hover:to-purple-600 text-white'
          }`}
        >
          {isPlaying ? '⏹️ Stop Reading Full Plan' : '🔊 Read Complete Workout'}
        </button>
      );
    };

    // Meal Planner Screen Component
    const MealPlanner = ({ goals, mealPlan, setMealPlan, isLoading, setIsLoading, error, setError }) => {
      const [activeTab, setActiveTab] = useState(() => localStorage.getItem('mealPlanner_activeTab') || 'planner'); // 'planner', 'pantry', or 'menu'
      const [preferences, setPreferences] = useState({ cuisine: '', diet: '', calories: goals.calories, allergies: [] });
      
      // Persist active tab to localStorage so we remember last selected tab
      useEffect(() => {
        try {
          if (typeof setLocalStorageWithSync === 'function') {
            setLocalStorageWithSync('mealPlanner_activeTab', activeTab);
          } else {
            localStorage.setItem('mealPlanner_activeTab', activeTab);
          }
        } catch (e) {
          // ignore storage errors
        }
      }, [activeTab]);
      
      // State to persist Smart Pantry Chef and Menu Decoder data
      const [pantryState, setPantryState] = useState(() => {
        const savedIngredients = localStorage.getItem('pantryChef_ingredients');
        const savedRecipes = localStorage.getItem('pantryChef_recipes');
        const savedImagePreview = localStorage.getItem('pantryChef_imagePreview');
        return {
          isLoading: false,
          ingredients: savedIngredients ? JSON.parse(savedIngredients) : null,
          recipes: savedRecipes ? JSON.parse(savedRecipes) : null,
          error: null,
          imagePreview: savedImagePreview || null
        };
      });
      
      const [menuState, setMenuState] = useState(() => {
        const savedMenuItems = localStorage.getItem('menuDecoder_menuItems');
        const savedRecommendations = localStorage.getItem('menuDecoder_recommendations');
        const savedImagePreview = localStorage.getItem('menuDecoder_imagePreview');
        const savedUserGoals = localStorage.getItem('menuDecoder_userGoals');
        return {
          isLoading: false,
          menuItems: savedMenuItems ? JSON.parse(savedMenuItems) : null,
          recommendations: savedRecommendations ? JSON.parse(savedRecommendations) : null,
          error: null,
          imagePreview: savedImagePreview || null,
          userGoals: savedUserGoals || 'high protein, low carb'
        };
      });

      const handlePreferenceChange = (key, value) => {
        setPreferences(prev => ({ ...prev, [key]: value }));
      };

      const handleAllergyChange = (allergy) => {
        setPreferences(prev => {
          const newAllergies = prev.allergies.includes(allergy)
            ? prev.allergies.filter(a => a !== allergy)
            : [...prev.allergies, allergy];
          return { ...prev, allergies: newAllergies };
        });
      };

      const generateMealPlan = async () => {
        setIsLoading(true);
        setError(null);
        setMealPlan(null);
        try {
          const prompt = `Create a ${preferences.diet || 'Standard'} ${preferences.cuisine || 'Any'} meal plan for ${preferences.calories} calories.
Allergies: ${preferences.allergies.join(', ') || 'None'}

Respond ONLY with a valid JSON object in this exact format:
{
  "breakfast": {"name": "Meal Name", "ingredients": ["ingredient1", "ingredient2"], "instructions": ["step1", "step2"]},
  "lunch": {"name": "Meal Name", "ingredients": ["ingredient1", "ingredient2"], "instructions": ["step1", "step2"]},
  "dinner": {"name": "Meal Name", "ingredients": ["ingredient1", "ingredient2"], "instructions": ["step1", "step2"]}
}`;

          const response = await fetch(getDirectGeminiConfig().url, {
            method: 'POST',
            headers: getDirectGeminiConfig().headers,
            body: JSON.stringify({
              model: OPENROUTER_QWEN_MODEL,
              messages: [{ role: 'user', content: prompt }]
            }),
            signal: AbortSignal.timeout(25000) // 25 second timeout
          });

          if (!response.ok) {
            throw new Error(`API Error: ${response.status} ${response.statusText}`);
          }

          const result = await response.json();
          const textResponse = (result.choices?.[0]?.message?.content || '');
          
          // Better JSON extraction and validation
          let jsonString = textResponse.replace(/```json|```/g, '').trim();
          
          // Remove any text before the first { and after the last }
          const firstBrace = jsonString.indexOf('{');
          const lastBrace = jsonString.lastIndexOf('}');
          
          if (firstBrace !== -1 && lastBrace !== -1) {
            jsonString = jsonString.substring(firstBrace, lastBrace + 1);
          }
          
          const data = JSON.parse(jsonString);
          
          // Validate the structure
          if (!data.breakfast || !data.lunch || !data.dinner) {
            throw new Error('Invalid meal plan structure');
          }
          
          setMealPlan(data);
        } catch (err) {
          console.error("Meal plan generation failed:", err);
          setError("Could not generate a meal plan. Please try again.");
        } finally {
          setIsLoading(false);
        }
      };

      return (
        <div className="p-6 pb-24">
          <header className="mb-6 text-center">
            <h1 className="text-3xl font-bold text-gray-800 dark:text-gray-200">Meal Planning</h1>
            <p className="text-gray-500 dark:text-gray-400">Plan meals, use ingredients, or decode menus</p>
          </header>

          {/* Tab Navigation */}
          <div className="flex mb-6 bg-gray-100 dark:bg-gray-800 rounded-2xl p-1 max-w-lg mx-auto">
            <button
              onClick={() => setActiveTab('planner')}
              className={`flex-1 py-3 px-2 rounded-xl font-semibold transition-all text-sm ${
                activeTab === 'planner'
                  ? 'bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 shadow-md'
                  : 'text-gray-600 dark:text-gray-400'
              }`}
            >
              📋 Planner
            </button>
            <button
              onClick={() => setActiveTab('pantry')}
              className={`flex-1 py-3 px-2 rounded-xl font-semibold transition-all text-sm ${
                activeTab === 'pantry'
                  ? 'bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 shadow-md'
                  : 'text-gray-600 dark:text-gray-400'
              }`}
            >
              🧑‍🍳 Pantry
            </button>
            <button
              onClick={() => setActiveTab('menu')}
              className={`flex-1 py-3 px-2 rounded-xl font-semibold transition-all text-sm ${
                activeTab === 'menu'
                  ? 'bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 shadow-md'
                  : 'text-gray-600 dark:text-gray-400'
              }`}
            >
              🍽️ Menu
            </button>
          </div>

          {/* Tab Content */}
          {activeTab === 'planner' && (
            <div>
              {!mealPlan && (
                <div className="max-w-md mx-auto">
                  <div className="bg-white dark:bg-gray-800 p-6 rounded-2xl shadow-md space-y-4">
                    <div>
                      <h3 className="font-semibold mb-2 text-gray-800 dark:text-gray-200">Cuisine Type</h3>
                      <div className="grid grid-cols-2 sm:grid-cols-3 gap-2">
                        {['International', 'Indian', 'Mediterranean', 'Asian', 'Mexican', 'Italian'].map(c => (
                          <button
                            key={c}
                            onClick={() => handlePreferenceChange('cuisine', c)}
                            className={`p-2 rounded-lg border dark:border-gray-700 text-xs sm:text-sm font-medium min-h-[2.5rem] flex items-center justify-center ${
                              preferences.cuisine === c ? 'bg-pink-500 text-white' : 'bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200'
                            }`}
                          >
                            <span className="text-center leading-tight">{c}</span>
                          </button>
                        ))}
                      </div>
                    </div>

                    <div>
                      <h3 className="font-semibold mb-2 text-gray-800 dark:text-gray-200">Diet Type</h3>
                      <div className="grid grid-cols-3 gap-2">
                        {['Veg', 'Non-Veg', 'Vegan'].map(d => (
                          <button
                            key={d}
                            onClick={() => handlePreferenceChange('diet', d)}
                            className={`p-2 rounded-lg border dark:border-gray-700 ${preferences.diet === d ? 'bg-pink-500 text-white' : 'bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200'}`}
                          >
                            {d}
                          </button>
                        ))}
                      </div>
                    </div>

                    <div>
                      <h3 className="font-semibold mb-2 text-gray-800 dark:text-gray-200">Daily Calorie Target: {preferences.calories} kcal</h3>
                      <input type="range" min="1200" max="4000" step="50" value={preferences.calories} onChange={e => handlePreferenceChange('calories', e.target.value)} className="w-full" />
                    </div>

                    <div>
                      <h3 className="font-semibold mb-2 text-gray-800 dark:text-gray-200">Allergies & Restrictions</h3>
                      <div className="grid grid-cols-3 gap-2">
                        {['Nuts', 'Dairy', 'Gluten', 'Eggs', 'Seafood', 'Soy'].map(a => (
                          <button
                            key={a}
                            onClick={() => handleAllergyChange(a)}
                            className={`p-2 rounded-lg border dark:border-gray-700 ${preferences.allergies.includes(a) ? 'bg-pink-500 text-white' : 'bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200'}`}
                          >
                            {a}
                          </button>
                        ))}
                      </div>
                    </div>
                  </div>

                  <button
                    onClick={generateMealPlan}
                    disabled={isLoading}
                    className="w-full mt-6 bg-green-500 text-white font-bold py-4 rounded-2xl shadow-lg hover:bg-green-600 transition-colors disabled:bg-gray-400"
                  >
                    {isLoading ? 'Generating...' : 'Generate Meal Plan'}
                  </button>

                  {error && <div className="mt-4 text-center text-red-500">{error}</div>}
                </div>
              )}

              {mealPlan && (
                <div className="animate-fade-in">
                  <button onClick={() => setMealPlan(null)} className="mb-4 text-pink-500 font-semibold">&larr; Back to Preferences</button>
                  
                  {/* Voice Button with Pause/Resume - REMOVED */}
                  
                  <MealPlanDisplay mealPlan={mealPlan} />
                  
                  {/* Download Button */}
                  <button
                    onClick={() => {
                      // Format meal plan for PDF
                      const title = "Your Personalized Meal Plan";
                      let content = "";
                      
                      // Add meal plan details
                      content += "BREAKFAST\n";
                      content += `${mealPlan.breakfast.name}\n\n`;
                      content += "Ingredients:\n";
                      mealPlan.breakfast.ingredients.forEach(ing => {
                        content += `- ${ing}\n`;
                      });
                      content += "\nInstructions:\n";
                      mealPlan.breakfast.instructions.forEach((inst, i) => {
                        content += `${i+1}. ${inst}\n`;
                      });
                      
                      content += "\n\nLUNCH\n";
                      content += `${mealPlan.lunch.name}\n\n`;
                      content += "Ingredients:\n";
                      mealPlan.lunch.ingredients.forEach(ing => {
                        content += `- ${ing}\n`;
                      });
                      content += "\nInstructions:\n";
                      mealPlan.lunch.instructions.forEach((inst, i) => {
                        content += `${i+1}. ${inst}\n`;
                      });
                      
                      content += "\n\nDINNER\n";
                      content += `${mealPlan.dinner.name}\n\n`;
                      content += "Ingredients:\n";
                      mealPlan.dinner.ingredients.forEach(ing => {
                        content += `- ${ing}\n`;
                      });
                      content += "\nInstructions:\n";
                      mealPlan.dinner.instructions.forEach((inst, i) => {
                        content += `${i+1}. ${inst}\n`;
                      });
                      
                      // Generate and download PDF
                      generatePDF(title, content, "meal-plan.pdf");
                    }}
                    className="mt-6 mx-auto block bg-pink-500 text-white font-bold py-3 px-6 rounded-xl shadow-lg hover:bg-pink-600 transition-colors"
                  >
                    📥 Download Meal Plan PDF
                  </button>
                </div>
              )}
            </div>
          )}

          {activeTab === 'pantry' && (
            <SmartPantryChef 
              goals={goals} 
              pantryState={pantryState}
              setPantryState={setPantryState}
            />
          )}

          {activeTab === 'menu' && (
            <MenuDecoder 
              goals={goals}
              menuState={menuState}
              setMenuState={setMenuState}
            />
          )}
        </div>
      );
    };

    // AI Workout Form Coach Component
    const WorkoutFormCoach = () => {
      const [videoPreview, setVideoPreview] = useState(null);
      const [isRecording, setIsRecording] = useState(false);
      const [isLoading, setIsLoading] = useState(false);
      const [formAnalysis, setFormAnalysis] = useState(() => {
        const saved = localStorage.getItem('formAnalysis');
        return saved ? JSON.parse(saved) : null;
      });
      const [error, setError] = useState(null);
      const [selectedExercise, setSelectedExercise] = useState('squat');
      const [mediaRecorder, setMediaRecorder] = useState(null);
      const [recordedChunks, setRecordedChunks] = useState([]);
      const [recordingTime, setRecordingTime] = useState(0);
      const videoRef = useRef(null);
      const fileInputRef = useRef(null);
      const recordingTimerRef = useRef(null);
      // Access auth helpers to sync latest analysis to remote immediately
      const { user, syncAIContent } = useAuth();

      // Keep formAnalysis in sync with localStorage/remote updates across navigation/refresh
      useEffect(() => {
        const hydrate = () => {
          try {
            const saved = localStorage.getItem('formAnalysis');
            if (saved) {
              const parsed = JSON.parse(saved);
              // Avoid unnecessary rerenders if identical
              const prev = formAnalysis ? JSON.stringify(formAnalysis) : null;
              const next = parsed ? JSON.stringify(parsed) : null;
              if (prev !== next) setFormAnalysis(parsed);
            } else if (formAnalysis) {
              // If storage cleared, mirror it in state
              setFormAnalysis(null);
            }
          } catch (_) {}
        };
        const handleStorage = (e) => {
          if (!e || e.key === 'formAnalysis') hydrate();
        };
        window.addEventListener('userDataSynced', hydrate);
        window.addEventListener('remoteDataApplied', hydrate);
        window.addEventListener('storage', handleStorage);
        // Hydrate immediately on mount
        hydrate();
        return () => {
          window.removeEventListener('userDataSynced', hydrate);
          window.removeEventListener('remoteDataApplied', hydrate);
          window.removeEventListener('storage', handleStorage);
        };
      }, []);

      const exercises = [
      // Strength Training - Upper Body
      { id: 'pushup', name: '💪 Push-up', tips: 'Maintain straight line from head to heels, lower chest to ground' },
      { id: 'pullup', name: '🔥 Pull-up', tips: 'Full range of motion, control the movement, engage lats' },
      { id: 'dips', name: '💺 Dips', tips: 'Lower until shoulders below elbows, push up with control' },
      { id: 'overhead_press', name: '🏋️ Overhead Press', tips: 'Press straight up, keep core tight, full lockout' },
      { id: 'bench_press', name: '🏋️‍♂️ Bench Press', tips: 'Lower bar to chest, press up explosively, maintain arch' },
      { id: 'rows', name: '🚣 Bent-Over Row', tips: 'Hinge at hips, pull to lower chest, squeeze shoulder blades' },
      
      // Strength Training - Lower Body
      { id: 'squat', name: '🏋️ Squat', tips: 'Keep back straight, knees track over toes, hip hinge' },
      { id: 'deadlift', name: '🏋️‍♀️ Deadlift', tips: 'Hinge at hips, keep bar close to body, drive through heels' },
      { id: 'lunge', name: '🦵 Lunge', tips: 'Step forward, lower back knee toward ground, push back up' },
      { id: 'bulgarian_split_squat', name: '🦵 Bulgarian Split Squat', tips: 'Rear foot elevated, lower into lunge, drive through front heel' },
      { id: 'hip_thrust', name: '🍑 Hip Thrust', tips: 'Squeeze glutes at top, maintain neutral spine, full hip extension' },
      { id: 'calf_raise', name: '🦵 Calf Raise', tips: 'Rise onto toes, pause at top, control the descent' },
      
      // Core & Stability
      { id: 'plank', name: '🤸 Plank', tips: 'Engage core, avoid sagging or arching, breathe normally' },
      { id: 'side_plank', name: '🤸‍♀️ Side Plank', tips: 'Stack shoulders and hips, lift hips up, hold straight line' },
      { id: 'mountain_climbers', name: '⛰️ Mountain Climbers', tips: 'Keep hips level, drive knees to chest, maintain plank position' },
      { id: 'russian_twists', name: '🌪️ Russian Twists', tips: 'Lean back slightly, rotate torso, keep feet off ground' },
      { id: 'bicycle_crunches', name: '🚴 Bicycle Crunches', tips: 'Bring opposite elbow to knee, extend other leg, control movement' },
      { id: 'dead_bug', name: '🐛 Dead Bug', tips: 'Keep lower back pressed down, move opposite arm and leg' },
      
      // Cardio & Conditioning
      { id: 'burpees', name: '💥 Burpees', tips: 'Jump back to plank, push-up, jump forward, jump up with arms overhead' },
      { id: 'jumping_jacks', name: '🤸‍♂️ Jumping Jacks', tips: 'Jump feet apart while raising arms, return to start position' },
      { id: 'high_knees', name: '🏃‍♀️ High Knees', tips: 'Drive knees up to waist level, pump arms, stay on balls of feet' },
      { id: 'butt_kicks', name: '🦵 Butt Kicks', tips: 'Kick heels to glutes, keep knees pointing down, quick tempo' },
      { id: 'jump_squats', name: '🦘 Jump Squats', tips: 'Squat down, explode up into jump, land softly, repeat' },
      
      // Functional Movement
      { id: 'bear_crawl', name: '🐻 Bear Crawl', tips: 'Keep knees just off ground, move opposite hand and foot together' },
      { id: 'crab_walk', name: '🦀 Crab Walk', tips: 'Keep hips up, move opposite hand and foot, face up' },
      { id: 'turkish_getup', name: '🇹🇷 Turkish Get-up', tips: 'Slow controlled movement, keep weight overhead, step by step' },
      { id: 'farmers_walk', name: '🚜 Farmer\'s Walk', tips: 'Keep shoulders back, core tight, walk with heavy weights' },
      
      // Flexibility & Mobility
      { id: 'downward_dog', name: '🧘‍♀️ Downward Dog', tips: 'Form inverted V, press hands down, lengthen spine' },
      { id: 'cat_cow', name: '🐱🐄 Cat-Cow Stretch', tips: 'Arch and round spine slowly, coordinate with breathing' },
      { id: 'pigeon_pose', name: '🕊️ Pigeon Pose', tips: 'Hip opener, keep front knee at 90 degrees, square hips' },
      { id: 'child_pose', name: '🧘 Child\'s Pose', tips: 'Sit back on heels, reach arms forward, relax and breathe' },
      
      // Olympic Lifts (Advanced)
      { id: 'clean_and_press', name: '🏋️‍♀️ Clean & Press', tips: 'Explosive hip drive, catch in front rack, press overhead' },
      { id: 'snatch', name: '🏋️ Snatch', tips: 'Wide grip, explosive pull, catch overhead in squat position' },
      { id: 'clean_and_jerk', name: '🏋️‍♂️ Clean & Jerk', tips: 'Clean to front rack, dip and drive, split or squat jerk' }
    ];

      // Persist formAnalysis to localStorage
      useEffect(() => {
        if (formAnalysis) {
          localStorage.setItem('formAnalysis', JSON.stringify(formAnalysis));
        }
      }, [formAnalysis]);

      const resetAnalysis = () => {
        setVideoPreview(null);
        setFormAnalysis(null);
        setError(null);
        setRecordedChunks([]);
        setRecordingTime(0);
        localStorage.removeItem('formAnalysis');
        if (recordingTimerRef.current) {
          clearInterval(recordingTimerRef.current);
        }
      };

      const startCamera = async () => {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ 
            video: { facingMode: 'user' }, 
            audio: false 
          });
          if (videoRef.current) {
            videoRef.current.srcObject = stream;
          }
        } catch (err) {
          console.error('Camera access failed:', err);
          setError('Camera access denied. Please use file upload instead.');
        }
      };

      const startRecording = async () => {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ 
            video: { facingMode: 'user' }, 
            audio: false 
          });
          
          setIsRecording(true);
          
          // Wait for the video element to be rendered, then set the stream
          setTimeout(async () => {
            if (videoRef.current) {
              videoRef.current.srcObject = stream;
              try {
                await videoRef.current.play();
                console.log('Video preview started successfully');
              } catch (playError) {
                console.error('Video play failed:', playError);
              }
            }
          }, 100);
          
          const recorder = new MediaRecorder(stream);
          const chunks = [];
          
          recorder.ondataavailable = (event) => {
            if (event.data.size > 0) {
              chunks.push(event.data);
            }
          };
          
          recorder.onstop = () => {
            const blob = new Blob(chunks, { type: 'video/webm' });
            const videoUrl = URL.createObjectURL(blob);
            setVideoPreview(videoUrl);
            setRecordedChunks(chunks);
            stream.getTracks().forEach(track => track.stop());
            // Clear live preview
            if (videoRef.current) {
              videoRef.current.srcObject = null;
            }
            clearInterval(recordingTimerRef.current);
            analyzeForm(blob);
          };
          
          setMediaRecorder(recorder);
          recorder.start();
          
          // Start 10-second timer
          let timeLeft = 10;
          setRecordingTime(timeLeft);
          recordingTimerRef.current = setInterval(() => {
            timeLeft--;
            setRecordingTime(timeLeft);
            if (timeLeft <= 0) {
              stopRecording();
            }
          }, 1000);
          
        } catch (err) {
          console.error('Recording failed:', err);
          setError('Recording failed. Please try file upload instead.');
          setIsRecording(false);
        }
      };

      const stopRecording = () => {
        if (mediaRecorder && mediaRecorder.state === 'recording') {
          mediaRecorder.stop();
          setIsRecording(false);
          clearInterval(recordingTimerRef.current);
        }
      };

      // Enhanced multi-frame analysis defined within component scope
      const enhancedAnalyzeForm = async (videoBlob) => {
        setIsLoading(true);
        setError(null);
        try {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d', { willReadFrequently: true });
          const video = document.createElement('video');
          video.src = URL.createObjectURL(videoBlob);
          video.muted = true;
          video.playsInline = true;

          const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error('Video processing timeout')), 30000));

          const loadMeta = new Promise((resolve, reject) => {
            video.onloadedmetadata = () => resolve(true);
            video.onerror = () => reject(new Error('Failed to load video metadata'));
            try { video.load(); } catch (_) {}
          });

          await Promise.race([loadMeta, timeoutPromise]);
          if (!video.videoWidth || !video.videoHeight) throw new Error('Invalid video dimensions');

          const duration = Math.max(0.5, isFinite(video.duration) ? video.duration : 3);
          const times = Array.from({ length: 4 }, (_, i) => Math.min(duration - 0.1, Math.max(0.1, ((i + 1) / 5) * duration)));

          const seekTo = (t) => new Promise((resolve, reject) => {
            const onSeeked = () => { video.removeEventListener('seeked', onSeeked); resolve(true); };
            const onError = () => { video.removeEventListener('error', onError); reject(new Error('Failed to seek video')); };
            video.addEventListener('seeked', onSeeked, { once: true });
            video.addEventListener('error', onError, { once: true });
            try { video.currentTime = t; } catch (_) { reject(new Error('Seek failed')); }
          });

          const computeMetrics = (imageData, w, h) => {
            const data = imageData.data;
            const step = Math.max(1, Math.floor(Math.min(w, h) / 160));
            let sumL = 0, count = 0;
            const gray = new Float32Array(w * h);
            for (let y = 0; y < h; y += step) {
              for (let x = 0; x < w; x += step) {
                const idx = (y * w + x) * 4;
                const r = data[idx], g = data[idx + 1], b = data[idx + 2];
                const l = 0.299 * r + 0.587 * g + 0.114 * b;
                gray[y * w + x] = l;
                sumL += l; count++;
              }
            }
            const meanL = sumL / Math.max(1, count) / 255;
            let sharpSum = 0, sCount = 0;
            for (let y = step; y < h - step; y += step) {
              for (let x = step; x < w - step; x += step) {
                const rx = gray[y * w + (x + step)] - gray[y * w + (x - step)];
                const ry = gray[(y + step) * w + x] - gray[(y - step) * w + x];
                const mag = Math.abs(rx) + Math.abs(ry);
                sharpSum += mag; sCount++;
              }
            }
            const sharpness = (sharpSum / Math.max(1, sCount)) / 255;
            return { brightness: meanL, sharpness };
          };

          const captureFrame = () => {
            const maxSide = 640;
            const scale = Math.min(1, maxSide / Math.max(video.videoWidth, video.videoHeight));
            const w = Math.max(1, Math.floor(video.videoWidth * scale));
            const h = Math.max(1, Math.floor(video.videoHeight * scale));
            canvas.width = w; canvas.height = h;
            ctx.drawImage(video, 0, 0, w, h);
            const imgData = ctx.getImageData(0, 0, w, h);
            const { brightness, sharpness } = computeMetrics(imgData, w, h);
            const base64 = canvas.toDataURL('image/jpeg', 0.7).split(',')[1];
            return { base64, brightness, sharpness, w, h };
          };

          const frames = [];
          for (const t of times) {
            try {
              await Promise.race([seekTo(t), timeoutPromise]);
              frames.push({ t, ...captureFrame() });
            } catch (e) { console.warn('Frame capture failed at', t, e); }
          }
          if (frames.length === 0) {
            await Promise.race([seekTo(Math.min(duration / 2, duration - 0.1)), timeoutPromise]);
            frames.push({ t: duration / 2, ...captureFrame() });
          }

          const scored = frames.map(f => ({
            ...f,
            quality: f.sharpness * 0.8 + (1 - Math.abs(f.brightness - 0.55)) * 0.2
          }))
          .sort((a, b) => b.quality - a.quality)
          .slice(0, Math.min(3, frames.length));

          const selectedExerciseData = exercises.find(ex => ex.id === selectedExercise);
          if (!selectedExerciseData) throw new Error('No exercise selected');

          const prompt = `You will analyze multiple frames from a video of a ${selectedExerciseData.name} exercise.\n\nUse the sequence to judge posture, joint angles, and safety across the movement. Do not penalize for limited visible motion per frame; consider consistency across frames. If visibility is partial or lighting is poor, avoid overly low scores—provide constructive feedback instead.\n\nFocus on:\n1. Body alignment and posture\n2. Joint positioning and angles\n3. Common mistakes to avoid\n4. Specific improvements for better form\n5. Safety considerations\n6. Reference relevant FitMate features (e.g., Workout Planner videos for ${selectedExerciseData.name})\n\nRespond ONLY with a valid JSON object in this exact format:\n{\n  "exercise_detected": "${selectedExerciseData.name}",\n  "overall_score": 1-10,\n  "form_analysis": {\n    "posture": "...",\n    "technique": "...",\n    "safety": "..."\n  },\n  "feedback": {\n    "positive_points": ["..."],\n    "improvements": ["..."],\n    "tips": ["..."]\n  },\n  "next_steps": "..."\n}`;

          const contentImages = scored.map(s => ({ type: 'image_url', image_url: `data:image/jpeg;base64,${s.base64}` }));

          const response = await fetch(getDirectGeminiConfig().url, {
            method: 'POST',
            headers: getDirectGeminiConfig().headers,
            body: JSON.stringify({
              model: OPENROUTER_QWEN_VL_MODEL,
              messages: [{
                role: 'user',
                content: [
                  { type: 'text', text: prompt },
                  ...contentImages
                ]
              }]
            })
          });
          if (!response.ok) {
            const errorText = await response.text();
            console.error('API Error Response:', errorText);
            throw new Error(`API Error: ${response.status} ${response.statusText}`);
          }
          const result = await response.json();
          const textResponse = (result.choices?.[0]?.message?.content || '');
          if (!textResponse) throw new Error('Invalid API response format');

          let jsonString = textResponse.replace(/```json|```/g, '').trim();
          if (jsonString.includes('```')) {
            const jsonMatchMd = jsonString.match(/```(?:json)?\s*({[\s\S]*?})\s*```/);
            if (jsonMatchMd) jsonString = jsonMatchMd[1];
          }
          const jsonMatch = jsonString.match(/{[\s\S]*}/);
          if (jsonMatch) jsonString = jsonMatch[0];
          const data = JSON.parse(jsonString);

          if (!data.overall_score && data.overall_score !== 0) data.overall_score = 3;
          if (!data.form_analysis) {
            data.form_analysis = {
              posture: data.posture || 'Unable to analyze posture from this video.',
              technique: data.technique || 'Unable to assess technique from this video.',
              safety: data.safety || 'Please ensure proper form and safety when exercising.'
            };
          }
          if (!data.feedback) {
            data.feedback = {
              positive_points: data.positive_points || [],
              improvements: data.improvements || ['Please upload a clearer video showing the full exercise movement'],
              tips: data.tips || ['Ensure good lighting and clear view of your full body', 'Upload from a side or slightly angled perspective']
            };
          }
          if (data.exercise_detected && data.exercise_detected.toLowerCase().includes('no ') && data.exercise_detected.toLowerCase().includes('detected')) {
            const sel = exercises.find(ex => ex.id === selectedExercise);
            data.exercise_detected = sel ? sel.name : 'Exercise';
            data.overall_score = 2;
            data.feedback.improvements = [
              'The selected exercise was not clearly visible in the video',
              'Please ensure your full body is visible in the frame',
              'Use a side angle for clearer joint visibility',
              'Ensure adequate lighting and a clear background'
            ];
            data.feedback.tips = [
              'Place camera 6-8 feet away to capture full body',
              'Avoid backlighting; face the light source',
              'Perform the movement slowly with full range of motion',
              'Keep the camera stable at chest height'
            ];
            data.next_steps = 'Please upload another video with better positioning and lighting for accurate form analysis.';
          }
          if (!data.next_steps) data.next_steps = 'Continue practicing with proper form and consider uploading from different angles for comprehensive analysis.';
          setFormAnalysis(data);
          try { localStorage.setItem('formAnalysis', JSON.stringify(data)); } catch (_) {}
          try { if (user && syncAIContent) await syncAIContent('formAnalysis', data); } catch (e) { console.warn('Sync formAnalysis failed:', e); }
        } catch (err) {
          console.error('Enhanced form analysis failed, falling back to single-frame:', err);
          try {
            await analyzeForm(videoBlob);
            return;
          } catch (fallbackErr) {
            console.error('Fallback analyzeForm also failed:', fallbackErr);
            setError('Could not analyze form. Please upload a clearer video.');
          }
        } finally {
          setIsLoading(false);
        }
      };

      const handleVideoUpload = (e) => {
        const file = e.target.files[0];
        if (file) {
          const videoUrl = URL.createObjectURL(file);
          setVideoPreview(videoUrl);
          setFormAnalysis(null);
          setError(null);
          enhancedAnalyzeForm(file);
        }
      };

      const analyzeForm = async (videoBlob) => {
        setIsLoading(true);
        setError(null);
        
        try {
          // For video analysis, we'll extract a frame and analyze it
          const canvas = document.createElement('canvas');
          const video = document.createElement('video');
          
          // Add timeout promise to prevent hanging
          const timeoutPromise = new Promise((_, reject) => {
            setTimeout(() => reject(new Error('Video processing timeout')), 30000);
          });
          
          const processVideo = new Promise((resolve, reject) => {
            video.src = URL.createObjectURL(videoBlob);
            video.muted = true; // Ensure video can play
            
            video.onloadedmetadata = async () => {
              try {
                console.log('Video metadata loaded:', {
                  duration: video.duration,
                  width: video.videoWidth,
                  height: video.videoHeight
                });
                
                // Validate video dimensions
                if (!video.videoWidth || !video.videoHeight) {
                  throw new Error('Invalid video dimensions');
                }
                
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                
                // Seek to middle of video for analysis
                const seekTime = Math.min(video.duration / 2, 5); // Max 5 seconds in
                video.currentTime = seekTime;
                
                video.onseeked = async () => {
                  try {
                    const ctx = canvas.getContext('2d', { willReadFrequently: true });
                    ctx.drawImage(video, 0, 0);
                    
                    // Validate canvas has content
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const hasContent = imageData.data.some(pixel => pixel !== 0);
                    
                    if (!hasContent) {
                      throw new Error('Failed to capture video frame');
                    }
                    
                    // Convert canvas to base64
                    const base64ImageData = canvas.toDataURL('image/jpeg', 0.8).split(',')[1];
                    
                    if (!base64ImageData) {
                      throw new Error('Failed to convert image to base64');
                    }
                    
                    const selectedExerciseData = exercises.find(ex => ex.id === selectedExercise);
                    
                    if (!selectedExerciseData) {
                      throw new Error('No exercise selected');
                    }
                    
                    console.log('Sending analysis request for:', selectedExerciseData.name);
                    
                    const prompt = `Analyze this image of someone performing a ${selectedExerciseData.name} exercise. You are an AI Form Coach with comprehensive knowledge of the FitMate app and all its features.

Even if the exercise is not clearly visible or the person is not performing the expected exercise, provide constructive feedback and guide them to relevant app features.

**APP CONTEXT AWARENESS:**
📊 Dashboard: Users can track workout progress and health scores
🏋️ Workout Planner: 15+ exercises with video guides (Burpee, Inchworm, Jumping Jack, Military Push Ups, Reverse Crunches, etc.)
🎥 Exercise Videos: Reference specific exercises from the workout database for comparison
🤖 AI Health Coach: Available for additional fitness guidance and motivation
👤 Profile: Users can adjust fitness goals and track improvements

Provide detailed form analysis and feedback. Focus on:
1. Body alignment and posture (if visible)
2. Joint positioning and angles (if visible) 
3. Common mistakes to avoid
4. Specific improvements for better form
5. Safety considerations
6. **Reference relevant app features** (e.g., "Check the ${selectedExerciseData.name} video in Workout Planner")

If the exercise is not clearly visible, focus on video recording tips and guide them to the Workout Planner for proper exercise demonstrations.

Respond ONLY with a valid JSON object in this format:
{
  "exercise_detected": "${selectedExerciseData.name}",
  "overall_score": 1-10,
  "form_analysis": {
    "posture": "Analysis of overall posture and alignment or recording feedback with app feature references",
    "technique": "Assessment of exercise technique with references to Workout Planner videos",
    "safety": "Safety considerations and injury prevention tips"
  },
  "feedback": {
    "positive_points": ["What they're doing well or encouraging notes"],
    "improvements": ["Specific areas to improve with app feature suggestions"],
    "tips": ["Actionable tips referencing app features like exercise videos or AI Coach"]
  },
  "next_steps": "Recommendations for progression, modification, or app feature usage (Dashboard tracking, Workout Planner, etc.)"
}`;

                    const payload = {
                      contents: [
                        {
                          parts: [
                            { text: prompt },
                            { inlineData: { mimeType: 'image/jpeg', data: base64ImageData } }
                          ]
                        }
                      ],
                    };

                    const response = await fetch(getDirectGeminiConfig().url, {
                      method: 'POST',
                      headers: getDirectGeminiConfig().headers,
                      body: JSON.stringify({
                        model: OPENROUTER_QWEN_VL_MODEL,
                        messages: [{
                          role: 'user',
                          content: [
                            { type: 'text', text: prompt },
                            { type: 'image_url', image_url: `data:image/jpeg;base64,${base64ImageData}` }
                          ]
                        }]
                      })
                    });

                    if (!response.ok) {
                      const errorText = await response.text();
                      console.error('API Error Response:', errorText);
                      throw new Error(`API Error: ${response.status} ${response.statusText}`);
                    }

                    const result = await response.json();
                    console.log('API Response:', result);
                    
                    const textResponse = (result.choices?.[0]?.message?.content || '');
                    if (!textResponse) {
                      throw new Error('Invalid API response format');
                    }
                    
                    console.log('Raw AI Response:', textResponse);
                    
                    // Clean and parse JSON response
                    let jsonString = textResponse.replace(/```json|```/g, '').trim();
                    
                    // Handle potential markdown formatting
                    if (jsonString.includes('```')) {
                      const jsonMatch = jsonString.match(/```(?:json)?\s*({[\s\S]*?})\s*```/);
                      if (jsonMatch) {
                        jsonString = jsonMatch[1];
                      }
                    }
                    
                    // Find JSON object if wrapped in text
                    const jsonMatch = jsonString.match(/{[\s\S]*}/);
                    if (jsonMatch) {
                      jsonString = jsonMatch[0];
                    }
                    
                    console.log('Parsed JSON String:', jsonString);
                    
                    const data = JSON.parse(jsonString);
                    
                    // Updated validation - more flexible for "no exercise detected" cases
                    if (!data.overall_score && data.overall_score !== 0) {
                      // If no score provided, set a default low score
                      data.overall_score = 3;
                    }

                    // Ensure form_analysis exists with defaults
                    if (!data.form_analysis) {
                      data.form_analysis = {
                        posture: data.posture || "Unable to analyze posture from this video.",
                        technique: data.technique || "Unable to assess technique from this video.", 
                        safety: data.safety || "Please ensure proper form and safety when exercising."
                      };
                    }

                    // Ensure feedback exists with defaults
                    if (!data.feedback) {
                      data.feedback = {
                        positive_points: data.positive_points || [],
                        improvements: data.improvements || ["Please record a clearer video showing the full exercise movement"],
                        tips: data.tips || ["Ensure good lighting and clear view of your full body", "Record from a side or slightly angled perspective"]
                      };
                    }

                    // Handle "No [Exercise] Detected" cases
                    if (data.exercise_detected && data.exercise_detected.toLowerCase().includes('no ') && data.exercise_detected.toLowerCase().includes('detected')) {
                      const selectedExerciseData = exercises.find(ex => ex.id === selectedExercise);
                      data.exercise_detected = selectedExerciseData ? selectedExerciseData.name : 'Exercise';
                      data.overall_score = 2; // Low score for undetected exercise
                      
                      // Provide helpful feedback for undetected exercises
                      data.feedback.improvements = [
                        "The selected exercise was not clearly visible in the video",
                        "Please ensure your full body is visible in the frame", 
                        "Record from a side angle for better form analysis",
                        "Make sure lighting is adequate and background is clear"
                      ];
                      
                      data.feedback.tips = [
                        "Position camera 6-8 feet away to capture full body",
                        "Use good lighting - avoid backlighting",
                        "Perform the exercise slowly and with full range of motion",
                        "Ensure the camera is stable and at chest height"
                      ];
                      
                      data.next_steps = "Please re-record the video with better positioning and lighting for accurate form analysis.";
                    }

                    // Ensure next_steps exists
                    if (!data.next_steps) {
                      data.next_steps = "Continue practicing with proper form and consider recording from different angles for comprehensive analysis.";
                    }
                    
                    console.log('Analysis completed successfully:', data);
                    setFormAnalysis(data);
                    try { localStorage.setItem('formAnalysis', JSON.stringify(data)); } catch (_) {}
                    try { if (user && syncAIContent) await syncAIContent('formAnalysis', data); } catch (e) { console.warn('Sync formAnalysis failed:', e); }
                    resolve(data);
                    
                  } catch (seekError) {
                    console.error('Seek error:', seekError);
                    reject(seekError);
                  }
                };
                
                video.onerror = (e) => {
                  console.error('Video seek error:', e);
                  reject(new Error('Failed to seek video'));
                };
                
              } catch (metadataError) {
                console.error('Metadata error:', metadataError);
                reject(metadataError);
              }
            };
            
            video.onerror = (e) => {
              console.error('Video load error:', e);
              reject(new Error('Failed to load video'));
            };
            
            // Ensure video loads
            video.load();
          });
          
          // Race between processing and timeout
          await Promise.race([processVideo, timeoutPromise]);
          
        } catch (err) {
          console.error('Form analysis failed:', err);
          
          // Provide specific error messages
          let errorMessage = 'Could not analyze form. ';
          
          if (err.message.includes('timeout')) {
            errorMessage += 'Video processing timed out. Please try a shorter video.';
          } else if (err.message.includes('dimensions')) {
            errorMessage += 'Invalid video format. Please upload a new video.';
          } else if (err.message.includes('API Error')) {
            errorMessage += 'Analysis service unavailable. Please try again later.';
          } else if (err.message.includes('JSON')) {
            errorMessage += 'Analysis failed to complete. Please try again.';
          } else {
            errorMessage += 'Please try again with a clearer video.';
          }
          
          setError(errorMessage);
        } finally {
          setIsLoading(false);
        }
      };

      return (
        <div className="p-6 pb-24">
          <header className="mb-6 text-center">
            <h1 className="text-3xl font-bold text-gray-800 dark:text-gray-200">🏋️ AI Form Coach</h1>
            <p className="text-gray-500 dark:text-gray-400">Perfect your technique with AI feedback</p>
          </header>

          {!videoPreview && (
            <div className="max-w-md mx-auto">
              {/* Exercise Selection */}
              <div className="bg-white dark:bg-gray-800 p-4 rounded-2xl shadow-md mb-4">
                <h3 className="font-semibold text-gray-800 dark:text-gray-200 mb-3">Select Exercise:</h3>
                <div className="grid grid-cols-2 gap-2">
                  {exercises.map(exercise => (
                    <button
                      key={exercise.id}
                      onClick={() => setSelectedExercise(exercise.id)}
                      className={`p-3 rounded-lg border text-sm ${
                        selectedExercise === exercise.id
                          ? 'bg-purple-500 text-white border-purple-500'
                          : 'bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200 border-gray-300 dark:border-gray-600'
                      }`}
                    >
                      {exercise.name}
                    </button>
                  ))}
                </div>
                {selectedExercise && (
                  <div className="mt-3 p-3 bg-purple-50 dark:bg-purple-900/20 rounded-lg">
                    <p className="text-sm text-purple-700 dark:text-purple-300">
                      💡 {exercises.find(ex => ex.id === selectedExercise)?.tips}
                    </p>
                  </div>
                )}
              </div>

              <div className="bg-white dark:bg-gray-800 p-8 rounded-2xl shadow-md text-center">
                <div className="mb-6">
                  <div className="w-24 h-24 mx-auto mb-4 bg-gradient-to-br from-purple-400 to-pink-500 rounded-full flex items-center justify-center">
                    <span className="text-4xl">🎥</span>
                  </div>
                  <h3 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-2">Upload Your Form</h3>
                 <p className="text-gray-600 dark:text-gray-400 mb-6">Upload a short video of your exercise and get instant AI feedback on your form!</p>
                </div>
                
                {/* Upload Controls (Recording temporarily disabled) */}
                <div className="space-y-4">
                  <input
                    type="file"
                    accept="video/*"
                    onChange={handleVideoUpload}
                    ref={fileInputRef}
                    className="hidden"
                  />
                  <button
                    onClick={() => fileInputRef.current?.click()}
                    className="w-full bg-gray-500 text-white font-bold py-3 rounded-2xl shadow-lg hover:bg-gray-600 transition-all"
                  >
                    📁 Upload Video
                  </button>
                </div>
                
                <div className="mt-6 p-4 bg-purple-50 dark:bg-purple-900/20 rounded-xl">
                  <h4 className="font-semibold text-purple-800 dark:text-purple-200 mb-2">📋 Uploading Tips:</h4>
                  <ul className="text-sm text-purple-700 dark:text-purple-300 space-y-1">
                    <li>• Position camera to show full body</li>
                    <li>• Perform 2-3 reps of the exercise</li>
                    <li>• Ensure good lighting and clear view</li>
                    <li>• Keep movements slow and controlled</li>
                  </ul>
                </div>
              </div>
            </div>
          )}

          {!videoPreview && formAnalysis && (
            <div className="max-w-md mx-auto mt-6">
              <div className="bg-white dark:bg-gray-800 rounded-2xl shadow-md overflow-hidden">
                <div className="p-6">
                  <div className="flex justify-between items-center mb-4">
                    <h3 className="font-bold text-gray-800 dark:text-gray-200">🎯 Last Form Analysis</h3>
                    <button onClick={resetAnalysis} className="text-purple-500 font-semibold text-sm">Clear</button>
                  </div>

                  <div className="mb-6 text-center">
                    <div className={`inline-flex items-center justify-center w-20 h-20 rounded-full text-2xl font-bold ${
                      formAnalysis.overall_score >= 8
                        ? 'bg-green-100 text-green-600 dark:bg-green-900/20 dark:text-green-400'
                        : formAnalysis.overall_score >= 6
                        ? 'bg-yellow-100 text-yellow-600 dark:bg-yellow-900/20 dark:text-yellow-400'
                        : 'bg-red-100 text-red-600 dark:bg-red-900/20 dark:text-red-400'
                    }`}>
                      {formAnalysis.overall_score}/10
                    </div>
                    <p className="text-sm text-gray-600 dark:text-gray-400 mt-2">Form Score</p>
                  </div>

                  <div className="space-y-4 mb-6">
                    <div className="bg-blue-50 dark:bg-blue-900/20 p-4 rounded-lg">
                      <h4 className="font-semibold text-blue-800 dark:text-blue-200 mb-2">📐 Posture Analysis</h4>
                      <p className="text-sm text-blue-700 dark:text-blue-300">{formAnalysis.form_analysis.posture}</p>
                    </div>

                    <div className="bg-purple-50 dark:bg-purple-900/20 p-4 rounded-lg">
                      <h4 className="font-semibold text-purple-800 dark:text-purple-200 mb-2">⚡ Technique</h4>
                      <p className="text-sm text-purple-700 dark:text-purple-300">{formAnalysis.form_analysis.technique}</p>
                    </div>

                    <div className="bg-orange-50 dark:bg-orange-900/20 p-4 rounded-lg">
                      <h4 className="font-semibold text-orange-800 dark:text-orange-200 mb-2">🛡️ Safety</h4>
                      <p className="text-sm text-orange-700 dark:text-orange-300">{formAnalysis.form_analysis.safety}</p>
                    </div>
                  </div>

                  {formAnalysis.feedback?.positive_points?.length > 0 && (
                    <div className="mb-4">
                      <h4 className="font-semibold text-green-600 dark:text-green-400 mb-2">✅ What You're Doing Well:</h4>
                      <ul className="space-y-1">
                        {formAnalysis.feedback.positive_points.map((point, index) => (
                          <li key={index} className="text-sm text-gray-600 dark:text-gray-400 flex items-start">
                            <span className="text-green-500 mr-2">•</span>
                            {point}
                          </li>
                        ))}
                      </ul>
                    </div>
                  )}

                  {formAnalysis.feedback?.improvements?.length > 0 && (
                    <div className="mb-4">
                      <h4 className="font-semibold text-yellow-600 dark:text-yellow-400 mb-2">🎯 Areas to Improve:</h4>
                      <ul className="space-y-1">
                        {formAnalysis.feedback.improvements.map((improvement, index) => (
                          <li key={index} className="text-sm text-gray-600 dark:text-gray-400 flex items-start">
                            <span className="text-yellow-500 mr-2">•</span>
                            {improvement}
                          </li>
                        ))}
                      </ul>
                    </div>
                  )}

                  {formAnalysis.feedback?.tips?.length > 0 && (
                    <div className="mb-4">
                      <h4 className="font-semibold text-purple-600 dark:text-purple-400 mb-2">💡 Pro Tips:</h4>
                      <ul className="space-y-1">
                        {formAnalysis.feedback.tips.map((tip, index) => (
                          <li key={index} className="text-sm text-gray-600 dark:text-gray-400 flex items-start">
                            <span className="text-purple-500 mr-2">•</span>
                            {tip}
                          </li>
                        ))}
                      </ul>
                    </div>
                  )}

                  {formAnalysis.next_steps && (
                    <div className="bg-gray-50 dark:bg-gray-700 p-4 rounded-lg">
                      <h4 className="font-semibold text-gray-800 dark:text-gray-200 mb-2">🚀 Next Steps:</h4>
                      <p className="text-sm text-gray-600 dark:text-gray-400">{formAnalysis.next_steps}</p>
                    </div>
                  )}
                </div>
              </div>
            </div>
          )}

          {videoPreview && (
            <div className="max-w-md mx-auto">
              <div className="bg-white dark:bg-gray-800 rounded-2xl shadow-md overflow-hidden">
                <video 
                  src={videoPreview} 
                  controls 
                  className="w-full h-64 object-cover"
                  poster="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='100' height='100'%3E%3Crect width='100' height='100' fill='%23f3f4f6'/%3E%3Ctext x='50%25' y='50%25' text-anchor='middle' dy='.3em' fill='%236b7280'%3EVideo%3C/text%3E%3C/svg%3E"
                />
                
                {isLoading && (
                  <div className="p-6 text-center">
                    <div className="animate-spin w-8 h-8 border-4 border-purple-500 border-t-transparent rounded-full mx-auto mb-4"></div>
                    <p className="text-gray-600 dark:text-gray-400">Analyzing your form...</p>
                  </div>
                )}

                {error && (
                  <div className="p-6 text-center">
                    <p className="text-red-500 mb-4">{error}</p>
                    <button onClick={resetAnalysis} className="bg-gray-500 text-white px-4 py-2 rounded-lg">
                      Try Again
                    </button>
                  </div>
                )}

                {formAnalysis && (
                  <div className="p-6">
                    <div className="flex justify-between items-center mb-4">
                      <h3 className="font-bold text-gray-800 dark:text-gray-200">🎯 Form Analysis</h3>
                      <button onClick={resetAnalysis} className="text-purple-500 font-semibold text-sm">
                        ← New Video
                      </button>
                    </div>
                    
                    {/* Overall Score */}
                    <div className="mb-6 text-center">
                      <div className={`inline-flex items-center justify-center w-20 h-20 rounded-full text-2xl font-bold ${
                        formAnalysis.overall_score >= 8 ? 'bg-green-100 text-green-600 dark:bg-green-900/20 dark:text-green-400' :
                        formAnalysis.overall_score >= 6 ? 'bg-yellow-100 text-yellow-600 dark:bg-yellow-900/20 dark:text-yellow-400' :
                        'bg-red-100 text-red-600 dark:bg-red-900/20 dark:text-red-400'
                      }`}>
                        {formAnalysis.overall_score}/10
                      </div>
                      <p className="text-sm text-gray-600 dark:text-gray-400 mt-2">Form Score</p>
                    </div>

                    {/* Form Analysis */}
                    <div className="space-y-4 mb-6">
                      <div className="bg-blue-50 dark:bg-blue-900/20 p-4 rounded-lg">
                        <h4 className="font-semibold text-blue-800 dark:text-blue-200 mb-2">📐 Posture Analysis</h4>
                        <p className="text-sm text-blue-700 dark:text-blue-300">{formAnalysis.form_analysis.posture}</p>
                      </div>
                      
                      <div className="bg-purple-50 dark:bg-purple-900/20 p-4 rounded-lg">
                        <h4 className="font-semibold text-purple-800 dark:text-purple-200 mb-2">⚡ Technique</h4>
                        <p className="text-sm text-purple-700 dark:text-purple-300">{formAnalysis.form_analysis.technique}</p>
                      </div>
                      
                      <div className="bg-orange-50 dark:bg-orange-900/20 p-4 rounded-lg">
                        <h4 className="font-semibold text-orange-800 dark:text-orange-200 mb-2">🛡️ Safety</h4>
                        <p className="text-sm text-orange-700 dark:text-orange-300">{formAnalysis.form_analysis.safety}</p>
                      </div>
                    </div>

                    {/* Positive Feedback */}
                    {formAnalysis.feedback.positive_points && formAnalysis.feedback.positive_points.length > 0 && (
                      <div className="mb-4">
                        <h4 className="font-semibold text-green-600 dark:text-green-400 mb-2">✅ What You're Doing Well:</h4>
                        <ul className="space-y-1">
                          {formAnalysis.feedback.positive_points.map((point, index) => (
                            <li key={index} className="text-sm text-gray-600 dark:text-gray-400 flex items-start">
                              <span className="text-green-500 mr-2">•</span>
                              {point}
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}

                    {/* Improvements */}
                    {formAnalysis.feedback.improvements && formAnalysis.feedback.improvements.length > 0 && (
                      <div className="mb-4">
                        <h4 className="font-semibold text-yellow-600 dark:text-yellow-400 mb-2">🎯 Areas to Improve:</h4>
                        <ul className="space-y-1">
                          {formAnalysis.feedback.improvements.map((improvement, index) => (
                            <li key={index} className="text-sm text-gray-600 dark:text-gray-400 flex items-start">
                              <span className="text-yellow-500 mr-2">•</span>
                              {improvement}
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}

                    {/* Tips */}
                    {formAnalysis.feedback.tips && formAnalysis.feedback.tips.length > 0 && (
                      <div className="mb-4">
                        <h4 className="font-semibold text-purple-600 dark:text-purple-400 mb-2">💡 Pro Tips:</h4>
                        <ul className="space-y-1">
                          {formAnalysis.feedback.tips.map((tip, index) => (
                            <li key={index} className="text-sm text-gray-600 dark:text-gray-400 flex items-start">
                              <span className="text-purple-500 mr-2">•</span>
                              {tip}
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}

                    {/* Next Steps */}
                    {formAnalysis.next_steps && (
                      <div className="bg-gray-50 dark:bg-gray-700 p-4 rounded-lg">
                        <h4 className="font-semibold text-gray-800 dark:text-gray-200 mb-2">🚀 Next Steps:</h4>
                        <p className="text-sm text-gray-600 dark:text-gray-400">{formAnalysis.next_steps}</p>
                      </div>
                    )}
                  </div>
                )}
              </div>
            </div>
          )}
        </div>
      );
    };

    // Workout Planner Screen Component
    const WorkoutPlanner = ({ workoutPlan, setWorkoutPlan, isLoading, setIsLoading, error, setError }) => {
      const [activeTab, setActiveTab] = useState(() => localStorage.getItem('workoutPlanner_activeTab') || 'planner'); // 'planner', 'coach', or 'exercises'
      // Persist active tab to localStorage so we remember last selected tab
      useEffect(() => {
        try {
          if (typeof setLocalStorageWithSync === 'function') {
            setLocalStorageWithSync('workoutPlanner_activeTab', activeTab);
          } else {
            localStorage.setItem('workoutPlanner_activeTab', activeTab);
          }
        } catch (e) {
          // ignore storage errors
        }
      }, [activeTab]);
      const [preferences, setPreferences] = useState({ goal: '', type: '', level: '', equipment: [] });
      const [selectedExercise, setSelectedExercise] = useState(null);
      const [currentSet, setCurrentSet] = useState(1);
      const [completedSets, setCompletedSets] = useState({});
      
      // Workout Session State Management
      const [workoutSession, setWorkoutSession] = useState({
        isActive: false,
        isPaused: false,
        currentExerciseIndex: 0,
        currentSet: 1,
        exerciseTime: 0,
        restTime: 0,
        totalTime: 0,
        isResting: false,
        completedExercises: [],
        sessionExercises: []
      });
      const [workoutTimer, setWorkoutTimer] = useState(null);
      const [audioEnabled, setAudioEnabled] = useState(true);
      const [voiceInstructions, setVoiceInstructions] = useState(true);
      const videoRef = useRef(null);
      const speechSynthesis = window.speechSynthesis;

      // Exercise database with video files from animations folder
      const exerciseDatabase = [
        {
          id: 1,
          name: 'Burpee and Jump',
          category: 'Full Body',
          difficulty: 'Advanced',
          sets: 3,
          reps: '8-12',
          duration: '45s',
          video: './animations/Burpee and Jump Exercise (1).mp4',
          muscles: ['Full Body', 'Cardio'],
          instructions: 'Start in standing position, drop to squat, kick back to plank, do push-up, jump feet back to squat, then jump up with arms overhead.'
        },
        {
          id: 2,
          name: 'Inchworm',
          category: 'Core',
          difficulty: 'Intermediate',
          sets: 3,
          reps: '10-15',
          duration: '30s',
          video: './animations/Inchworm.mp4',
          muscles: ['Core', 'Shoulders', 'Hamstrings'],
          instructions: 'Stand with feet hip-width apart, bend forward and walk hands out to plank position, then walk feet toward hands.'
        },
        {
          id: 3,
          name: 'Jumping Jack',
          category: 'Cardio',
          difficulty: 'Beginner',
          sets: 3,
          reps: '20-30',
          duration: '30s',
          video: './animations/Jumping Jack.mp4',
          muscles: ['Full Body', 'Cardio'],
          instructions: 'Jump feet apart while raising arms overhead, then jump back to starting position with arms at sides.'
        },
        {
          id: 4,
          name: 'Military Push Ups',
          category: 'Upper Body',
          difficulty: 'Intermediate',
          sets: 3,
          reps: '8-15',
          duration: '45s',
          video: './animations/Military Push Ups.mp4',
          muscles: ['Chest', 'Triceps', 'Shoulders'],
          instructions: 'Start in plank position with hands shoulder-width apart, lower body until chest nearly touches ground, push back up.'
        },
        {
          id: 5,
          name: 'Reverse Crunches',
          category: 'Core',
          difficulty: 'Beginner',
          sets: 3,
          reps: '12-20',
          duration: '30s',
          video: './animations/Reverse Crunches.mp4',
          muscles: ['Lower Abs', 'Core'],
          instructions: 'Lie on back with knees bent, lift hips off ground by contracting abs, slowly lower back down.'
        },
        {
          id: 6,
          name: 'Seated Abs Circles',
          category: 'Core',
          difficulty: 'Beginner',
          sets: 3,
          reps: '10 each direction',
          duration: '30s',
          video: './animations/Seated abs circles.mp4',
          muscles: ['Core', 'Obliques'],
          instructions: 'Sit with knees bent, lean back slightly, make circular motions with your torso while keeping core engaged.'
        },
        {
          id: 7,
          name: 'Single Leg Hip Rotation',
          category: 'Lower Body',
          difficulty: 'Beginner',
          sets: 3,
          reps: '10 each leg',
          duration: '30s',
          video: './animations/Single Leg Hip Rotation.mp4',
          muscles: ['Hips', 'Glutes', 'Balance'],
          instructions: 'Stand on one leg, rotate the other leg in circular motions, focusing on hip mobility and balance.'
        },
        {
          id: 8,
          name: 'Split Jump',
          category: 'Lower Body',
          difficulty: 'Advanced',
          sets: 3,
          reps: '10-15',
          duration: '45s',
          video: './animations/Split Jump Exercise.mp4',
          muscles: ['Legs', 'Glutes', 'Cardio'],
          instructions: 'Start in lunge position, jump up and switch leg positions in mid-air, land softly in opposite lunge.'
        },
        {
          id: 9,
          name: 'Squat Reach',
          category: 'Lower Body',
          difficulty: 'Beginner',
          sets: 3,
          reps: '12-20',
          duration: '30s',
          video: './animations/Squat Reach.mp4',
          muscles: ['Quads', 'Glutes', 'Core'],
          instructions: 'Perform a squat while reaching arms forward for balance, return to standing with arms at sides.'
        },
        {
          id: 10,
          name: 'Squat Kicks',
          category: 'Lower Body',
          difficulty: 'Intermediate',
          sets: 3,
          reps: '10-15',
          duration: '45s',
          video: './animations/Squat kicks.mp4',
          muscles: ['Quads', 'Glutes', 'Core'],
          instructions: 'Perform a squat, then as you stand up, kick one leg forward, alternate legs with each rep.'
        }
      ];

      // Workout Session Management Functions
      const speakInstruction = (text) => {
        if (voiceInstructions && speechSynthesis) {
          speechSynthesis.cancel();
          const utterance = new SpeechSynthesisUtterance(text);
          utterance.rate = 0.9;
          utterance.pitch = 1;
          utterance.volume = 0.8;
          speechSynthesis.speak(utterance);
        }
      };

      const startWorkoutSession = (exercises) => {
        const sessionExercises = exercises.length > 0 ? exercises : exerciseDatabase.slice(0, 5);
        setWorkoutSession({
          isActive: true,
          isPaused: false,
          currentExerciseIndex: 0,
          currentSet: 1,
          exerciseTime: 0,
          restTime: 0,
          totalTime: 0,
          isResting: false,
          completedExercises: [],
          sessionExercises
        });
        speakInstruction(`Starting workout with ${sessionExercises.length} exercises. First exercise: ${sessionExercises[0].name}`);
        startTimer();
      };

      const pauseWorkoutSession = () => {
        setWorkoutSession(prev => {
          const newPaused = !prev.isPaused;
          
          // Handle video controls
          if (videoRef.current) {
            if (newPaused) {
              videoRef.current.pause();
            } else {
              videoRef.current.play();
            }
          }
          
          if (newPaused) {
            clearInterval(workoutTimer);
            speakInstruction('Workout paused');
          } else {
            startTimer();
            speakInstruction('Workout resumed');
          }
          
          return { ...prev, isPaused: newPaused };
        });
      };

      const nextExercise = () => {
        const { currentExerciseIndex, sessionExercises, currentSet } = workoutSession;
        const currentExercise = sessionExercises[currentExerciseIndex];
        
        if (currentSet < currentExercise.sets) {
          // Next set of current exercise
          setWorkoutSession(prev => ({
            ...prev,
            currentSet: prev.currentSet + 1,
            isResting: true,
            restTime: 0
          }));
          speakInstruction(`Set ${currentSet + 1} of ${currentExercise.sets}. Rest for 30 seconds`);
        } else if (currentExerciseIndex < sessionExercises.length - 1) {
          // Next exercise
          const nextExerciseIndex = currentExerciseIndex + 1;
          const nextExercise = sessionExercises[nextExerciseIndex];
          setWorkoutSession(prev => ({
            ...prev,
            currentExerciseIndex: nextExerciseIndex,
            currentSet: 1,
            exerciseTime: 0,
            isResting: false,
            completedExercises: [...prev.completedExercises, currentExerciseIndex]
          }));
          speakInstruction(`Next exercise: ${nextExercise.name}. ${nextExercise.instructions}`);
        } else {
          // Workout complete
          endWorkoutSession();
        }
      };

      const previousExercise = () => {
        const { currentExerciseIndex, sessionExercises, currentSet } = workoutSession;
        
        if (currentSet > 1) {
          // Previous set of current exercise
          setWorkoutSession(prev => ({
            ...prev,
            currentSet: prev.currentSet - 1,
            isResting: false
          }));
        } else if (currentExerciseIndex > 0) {
          // Previous exercise
          const prevExerciseIndex = currentExerciseIndex - 1;
          const prevExercise = sessionExercises[prevExerciseIndex];
          setWorkoutSession(prev => ({
            ...prev,
            currentExerciseIndex: prevExerciseIndex,
            currentSet: prevExercise.sets,
            exerciseTime: 0,
            isResting: false,
            completedExercises: prev.completedExercises.filter(i => i !== prevExerciseIndex)
          }));
          speakInstruction(`Previous exercise: ${prevExercise.name}`);
        }
      };

      const endWorkoutSession = async () => {
        clearInterval(workoutTimer);
        
        // Calculate workout metrics for health score integration
        const workoutData = {
          duration: Math.round(workoutSession.totalTime / 60), // Convert to minutes
          exercisesCompleted: workoutSession.completedExercises.length,
          totalExercises: workoutSession.sessionExercises.length,
          completionRate: (workoutSession.completedExercises.length / workoutSession.sessionExercises.length) * 100,
          timestamp: new Date().toISOString(),
          type: 'structured_workout'
        };
        
        // Log workout as activity minutes
        if (workoutData.duration > 0) {
          // handleLogActivity({ minutes: workoutData.duration }); // removed: workouts do not add activity points
          
          // Add timestamp to workout data
          const workoutWithTimestamp = {
            ...workoutData,
            timestamp: new Date().toISOString(),
            workout_title: workoutData.workoutTitle || 'Custom Workout',
            calories_burned: workoutData.caloriesBurned || 0,
            completion_rate: Math.round((workoutData.exercisesCompleted / workoutData.totalExercises) * 100) || 0
          };
          
          // Store workout history in local storage
          let workoutHistory;
          try {
            workoutHistory = JSON.parse(localStorage.getItem('workoutHistory') || '[]');
            if (!Array.isArray(workoutHistory)) {
              workoutHistory = [];
            }
          } catch (error) {
            console.warn('Error parsing workoutHistory in workout completion, resetting to empty array:', error);
            workoutHistory = [];
          }
          
          // Add new workout to the beginning of the array (most recent first)
          workoutHistory.unshift(workoutWithTimestamp);
          
          // Keep only last 100 workouts
          if (workoutHistory.length > 100) {
            workoutHistory = workoutHistory.slice(0, 100);
          }
          
          // Update local storage and state
          localStorage.setItem('workoutHistory', JSON.stringify(workoutHistory));
          if (setWorkoutHistory) {
            setWorkoutHistory(workoutHistory);
          }
          
          // Enable workout points for today's health score
          try {
            const todayISO = toLocalISODate(new Date());
            localStorage.setItem(`workoutScoreEnabled:${todayISO}`, '1');
            console.log('✅ Workout points enabled for today:', todayISO);
          } catch (_) {}
          
          // Trigger health score recalculation
          window.dispatchEvent(new Event('workout-history-updated'));
          
          // Sync workout data to Supabase if user is logged in
          if (user && supabase) {
            try {
              const { error } = await supabase
                .from('workout_history')
                .upsert([{
                  ...workoutWithTimestamp,
                  user_id: user.id,
                  created_at: workoutWithTimestamp.timestamp
                }], { onConflict: 'user_id,timestamp' });
                
              if (error) throw error;
              console.log('✅ Workout synced to Supabase');
            } catch (error) {
              console.error('Error syncing workout to Supabase:', error);
              // If sync fails, we'll try again on next sync
            }
          }
        }
        
        setWorkoutSession({
          isActive: false,
          isPaused: false,
          currentExerciseIndex: 0,
          currentSet: 1,
          exerciseTime: 0,
          restTime: 0,
          totalTime: 0,
          isResting: false,
          completedExercises: [],
          sessionExercises: []
        });
        
        const completionMessage = workoutData.completionRate === 100 
          ? `Workout completed! Great job! You completed all ${workoutData.totalExercises} exercises in ${workoutData.duration} minutes.`
          : `Workout session ended. You completed ${workoutData.exercisesCompleted} out of ${workoutData.totalExercises} exercises in ${workoutData.duration} minutes.`;
        
        speakInstruction(completionMessage);
      };

      const startTimer = () => {
        const timer = setInterval(() => {
          setWorkoutSession(prev => {
            if (prev.isPaused) return prev;
            
            const newState = { ...prev, totalTime: prev.totalTime + 1 };
            
            if (prev.isResting) {
              newState.restTime = prev.restTime + 1;
              const restDuration = 30; // 30 second rest between sets
              
              // Countdown for last 5 seconds of rest
              const restTimeLeft = restDuration - prev.restTime;
              if (restTimeLeft <= 5 && restTimeLeft > 0 && prev.restTime > 0) {
                speakInstruction(`${restTimeLeft}`);
              }
              
              if (prev.restTime >= restDuration) {
                newState.isResting = false;
                newState.restTime = 0;
                const currentExercise = prev.sessionExercises[prev.currentExerciseIndex];
                speakInstruction(`Set ${prev.currentSet} of ${currentExercise.sets}. Begin!`);
                // Resume video after rest
                if (videoRef.current) {
                  videoRef.current.currentTime = 0;
                  videoRef.current.play();
                }
              }
            } else {
              newState.exerciseTime = prev.exerciseTime + 1;
              const currentExercise = prev.sessionExercises[prev.currentExerciseIndex];
              const exerciseDuration = parseInt(currentExercise.duration) || 45;
              
              // Voice counting every 5 seconds during exercise
              if (prev.exerciseTime > 0 && prev.exerciseTime % 5 === 0 && prev.exerciseTime <= exerciseDuration - 10) {
                const count = Math.floor(prev.exerciseTime / 5);
                speakInstruction(`${count * 5}`);
              }
              
              // Countdown for last 10 seconds
              const timeLeft = exerciseDuration - prev.exerciseTime;
              if (timeLeft <= 10 && timeLeft > 0) {
                speakInstruction(`${timeLeft}`);
              }
              
              // Ensure video is playing during exercise
              if (videoRef.current && videoRef.current.paused && !prev.isPaused) {
                videoRef.current.play();
              }
              
              if (prev.exerciseTime >= exerciseDuration) {
                // Auto-advance to next set/exercise
                if (prev.currentSet < currentExercise.sets) {
                  newState.currentSet = prev.currentSet + 1;
                  newState.isResting = true;
                  newState.exerciseTime = 0;
                  newState.restTime = 0;
                  speakInstruction(`Set complete. Rest for 30 seconds`);
                  // Pause video during rest
                  if (videoRef.current) {
                    videoRef.current.pause();
                  }
                } else {
                  // Move to next exercise
                  if (prev.currentExerciseIndex < prev.sessionExercises.length - 1) {
                    const nextIndex = prev.currentExerciseIndex + 1;
                    const nextExercise = prev.sessionExercises[nextIndex];
                    newState.currentExerciseIndex = nextIndex;
                    newState.currentSet = 1;
                    newState.exerciseTime = 0;
                    newState.isResting = true;
                    newState.restTime = 0;
                    newState.completedExercises = [...prev.completedExercises, prev.currentExerciseIndex];
                    speakInstruction(`Exercise complete. Next: ${nextExercise.name}. Get ready in 10 seconds`);
                    // Pause video during transition
                    if (videoRef.current) {
                      videoRef.current.pause();
                    }
                    // Set shorter transition time (10 seconds instead of 30)
                    setTimeout(() => {
                      setWorkoutSession(current => ({
                        ...current,
                        isResting: false,
                        restTime: 0
                      }));
                      speakInstruction(`Begin ${nextExercise.name}`);
                      if (videoRef.current) {
                        videoRef.current.currentTime = 0;
                        videoRef.current.play();
                      }
                    }, 10000);
                  } else {
                    // Workout completed
                    newState.isActive = false;
                    newState.completedExercises = [...prev.completedExercises, prev.currentExerciseIndex];
                    clearInterval(timer);
                    speakInstruction('Workout completed! Excellent work!');
                    if (videoRef.current) {
                      videoRef.current.pause();
                    }
                    return newState; // Exit early to prevent further timer execution
                  }
                }
              }
            }
            
            return newState;
          });
        }, 1000);
        
        setWorkoutTimer(timer);
      };

      useEffect(() => {
        return () => {
          if (workoutTimer) {
            clearInterval(workoutTimer);
          }
        };
      }, [workoutTimer]);

      const handlePreferenceChange = (key, value) => {
        setPreferences(prev => ({ ...prev, [key]: value }));
      };

      const handleEquipmentChange = (item) => {
        setPreferences(prev => {
          const newEquipment = prev.equipment.includes(item)
            ? prev.equipment.filter(e => e !== item)
            : [...prev.equipment, item];
          return { ...prev, equipment: newEquipment };
        });
      };

      const generateWorkoutPlan = async () => {
        setIsLoading(true);
        setError(null);
        setWorkoutPlan(null);
        try {
          const prompt = `Create a ${preferences.type || 'Full Body'} workout for ${preferences.goal || 'General Fitness'}.
Level: ${preferences.level || 'Beginner'}
Equipment: ${preferences.equipment.join(', ') || 'Bodyweight'}

Respond ONLY with a valid JSON object in this exact format:
{
  "plan_name": "Workout Plan Name",
  "exercises": [
    {"name": "Exercise Name", "sets": "3", "reps": "10-12", "instructions": "How to perform this exercise"}
  ]
}`;

          // Use OpenRouter API (Qwen) with obfuscated key
          const geminiConfig = getDirectGeminiConfig();
          const response = await fetch(geminiConfig.url, {
            method: 'POST',
            headers: geminiConfig.headers,
            body: JSON.stringify({
              model: OPENROUTER_QWEN_MODEL,
              messages: [{ role: 'user', content: prompt }]
            }),
            signal: AbortSignal.timeout(25000) // 25 second timeout
          });

          if (!response.ok) {
            throw new Error(`API Error: ${response.status} ${response.statusText}`);
          }

          const result = await response.json();
          const textResponse = (result.choices?.[0]?.message?.content || '');
          
          // Better JSON extraction and validation
          let jsonString = textResponse.replace(/```json|```/g, '').trim();
          
          // Remove any text before the first { and after the last }
          const firstBrace = jsonString.indexOf('{');
          const lastBrace = jsonString.lastIndexOf('}');
          
          if (firstBrace !== -1 && lastBrace !== -1) {
            jsonString = jsonString.substring(firstBrace, lastBrace + 1);
          }
          
          const data = JSON.parse(jsonString);
          
          // Validate the structure
          if (!data.plan_name || !data.exercises || !Array.isArray(data.exercises)) {
            throw new Error('Invalid workout plan structure');
          }
          
          setWorkoutPlan(data);
        } catch (err) {
          console.error("Workout plan generation failed:", err);
          setError("Could not generate a workout plan. Please try again.");
        } finally {
          setIsLoading(false);
        }
      };

      return (
        <div className="p-4 sm:p-6 pb-24 mb-20">
          <header className="mb-4 sm:mb-6 text-center px-2">
            <h1 className="text-2xl sm:text-3xl font-bold text-gray-800 dark:text-gray-200">Workout Hub</h1>
            <p className="text-sm sm:text-base text-gray-500 dark:text-gray-400">Plan workouts or perfect your form</p>
          </header>

          {/* Tab Navigation - Mobile Optimized */}
          <div className="flex mb-6 bg-gray-100 dark:bg-gray-800 rounded-2xl p-1 max-w-lg mx-auto mx-4 sm:mx-auto">
            <button
              onClick={() => setActiveTab('planner')}
              className={`flex-1 py-3 px-2 sm:px-4 rounded-xl font-semibold transition-all text-xs sm:text-sm ${
                activeTab === 'planner'
                  ? 'bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 shadow-md'
                  : 'text-gray-600 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-200'
              }`}
            >
              📋 Planner
            </button>
            <button
              onClick={() => setActiveTab('coach')}
              className={`flex-1 py-3 px-2 sm:px-4 rounded-xl font-semibold transition-all text-xs sm:text-sm ${
                activeTab === 'coach'
                  ? 'bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 shadow-md'
                  : 'text-gray-600 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-200'
              }`}
            >
              🏋️ Form Coach
            </button>
            <button
              onClick={() => setActiveTab('exercises')}
              className={`flex-1 py-3 px-2 sm:px-4 rounded-xl font-semibold transition-all text-xs sm:text-sm ${
                activeTab === 'exercises'
                  ? 'bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 shadow-md'
                  : 'text-gray-600 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-200'
              }`}
            >
              💪 Exercises
            </button>
          </div>

          {/* Tab Content */}
          {activeTab === 'planner' && (
            <div>
              {!workoutPlan && (
                <div className="max-w-md mx-auto px-4 sm:px-0">
                  <div className="bg-white dark:bg-gray-800 p-4 sm:p-6 rounded-2xl shadow-md space-y-4 sm:space-y-6">
                    {/* Fitness Goal */}
                    <div>
                      <h3 className="font-semibold mb-2 text-gray-800 dark:text-gray-200 text-sm sm:text-base">Fitness Goal</h3>
                      <div className="grid grid-cols-1 sm:grid-cols-3 gap-2">
                        {['Weight Loss', 'Muscle Gain', 'Endurance'].map(g => (
                          <button
                            key={g}
                            onClick={() => handlePreferenceChange('goal', g)}
                            className={`p-3 sm:p-2 rounded-lg border dark:border-gray-700 text-sm sm:text-base font-medium transition-colors ${preferences.goal === g ? 'bg-pink-500 text-white' : 'bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200 hover:bg-gray-200 dark:hover:bg-gray-600'}`}
                          >
                            {g}
                          </button>
                        ))}
                      </div>
                    </div>

                    {/* Workout Type */}
                    <div>
                      <h3 className="font-semibold mb-2 text-gray-800 dark:text-gray-200 text-sm sm:text-base">Workout Type</h3>
                      <div className="grid grid-cols-1 sm:grid-cols-3 gap-2">
                        {['Full Body', 'Upper Body', 'Lower Body'].map(t => (
                          <button
                            key={t}
                            onClick={() => handlePreferenceChange('type', t)}
                            className={`p-3 sm:p-2 rounded-lg border dark:border-gray-700 text-sm sm:text-base font-medium transition-colors ${preferences.type === t ? 'bg-pink-500 text-white' : 'bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200 hover:bg-gray-200 dark:hover:bg-gray-600'}`}
                          >
                            {t}
                          </button>
                        ))}
                      </div>
                    </div>

                    {/* Experience Level */}
                    <div>
                      <h3 className="font-semibold mb-2 text-gray-800 dark:text-gray-200 text-sm sm:text-base">Experience Level</h3>
                      <div className="grid grid-cols-1 sm:grid-cols-3 gap-2">
                        {['Beginner', 'Intermediate', 'Advanced'].map(l => (
                          <button
                            key={l}
                            onClick={() => handlePreferenceChange('level', l)}
                            className={`p-3 sm:p-2 rounded-lg border dark:border-gray-700 text-sm sm:text-base font-medium transition-colors ${preferences.level === l ? 'bg-pink-500 text-white' : 'bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200 hover:bg-gray-200 dark:hover:bg-gray-600'}`}
                          >
                            {l}
                          </button>
                        ))}
                      </div>
                    </div>

                    {/* Equipment */}
                    <div>
                      <h3 className="font-semibold mb-2 text-gray-800 dark:text-gray-200 text-sm sm:text-base">Available Equipment</h3>
                      <div className="grid grid-cols-2 sm:grid-cols-3 gap-2">
                        {['Bodyweight', 'Dumbbells', 'Barbell', 'Kettlebell', 'Bands', 'Machine'].map(e => (
                          <button
                            key={e}
                            onClick={() => handleEquipmentChange(e)}
                            className={`p-3 sm:p-2 rounded-lg border dark:border-gray-700 text-xs sm:text-sm font-medium transition-colors ${preferences.equipment.includes(e) ? 'bg-pink-500 text-white' : 'bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200 hover:bg-gray-200 dark:hover:bg-gray-600'}`}
                          >
                            {e}
                          </button>
                        ))}
                      </div>
                    </div>
                  </div>

                  <button
                    onClick={generateWorkoutPlan}
                    disabled={isLoading}
                    className="w-full mt-4 sm:mt-6 bg-green-500 text-white font-bold py-4 px-6 rounded-2xl shadow-lg hover:bg-green-600 transition-colors disabled:bg-gray-400 text-base sm:text-lg"
                  >
                    {isLoading ? 'Generating...' : 'Generate Workout Plan'}
                  </button>

                  {error && <div className="mt-4 text-center text-red-500">{error}</div>}
                </div>
              )}

              {workoutPlan && (
                <div className="animate-fade-in">
                  <button onClick={() => setWorkoutPlan(null)} className="mb-4 text-pink-500 font-semibold">&larr; Back to Preferences</button>
                  
                  {/* Voice Button with Pause/Resume - REMOVED */}
                  
                  <div className="bg-white dark:bg-gray-800 p-6 rounded-2xl shadow-md">
                    <h2 className="text-2xl font-bold text-gray-800 dark:text-gray-200 mb-4">{workoutPlan.plan_name}</h2>
                    <WorkoutPlanDisplay workoutPlan={workoutPlan} />
                  </div>
                  
                  {/* Download Button */}
                  <button
                    onClick={() => {
                      // Format workout plan for PDF
                      const title = workoutPlan.plan_name;
                      let content = "";
                      
                      // Add workout details
                      workoutPlan.exercises.forEach((ex, i) => {
                        content += `${i+1}. ${ex.name}\n`;
                        content += `Sets: ${ex.sets} | Reps: ${ex.reps}\n`;
                        content += `Instructions: ${ex.instructions}\n\n`;
                      });
                      
                      // Generate and download PDF
                      generatePDF(title, content, "workout-plan.pdf");
                    }}
                    className="mt-6 mx-auto block bg-pink-500 text-white font-bold py-3 px-6 rounded-xl shadow-lg hover:bg-pink-600 transition-colors"
                  >
                    📥 Download Workout Plan PDF
                  </button>
                </div>
              )}
            </div>
          )}

          {activeTab === 'coach' && (
            <WorkoutFormCoach />
          )}

          <div className={`w-full h-screen ${activeTab === 'exercises' ? '' : 'hidden'}`}>
            <iframe 
              src="./workout.html" 
              loading="eager"
              className="w-full h-full border-0 rounded-lg"
              title="Workout Application"
            />
          </div>
        </div>
      );
    };

  </script>
  <script type="text/babel">
    // AI Coach Screen Component
    const Coach = ({ dailyIntake, recentMeals, goals, messages, setMessages, isDarkMode }) => {
      const [input, setInput] = useState('');
      const [isLoading, setIsLoading] = useState(false);
      const chatEndRef = useRef(null);
      const [attachment, setAttachment] = useState(null);
      const [attachmentPreview, setAttachmentPreview] = useState(null);
      const fileInputRef = useRef(null);

      // Function to start a new conversation
      const startNewConversation = () => {
        setMessages([{ text: "Hello! I'm your AI Health Coach. Ask me anything about your nutrition or meals.", sender: 'ai' }]);
        setInput('');
        setAttachment(null);
        setAttachmentPreview(null);
      };

      useEffect(() => {
        chatEndRef.current?.scrollIntoView({ behavior: "smooth" });
      }, [messages]);

      const fileToBase64 = (file) => new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = () => resolve(reader.result.split(',')[1]);
        reader.onerror = error => reject(error);
      });

      const handleAttachmentChange = (event) => {
        const file = event.target.files[0];
        if (file) {
          setAttachment(file);
          setAttachmentPreview(URL.createObjectURL(file));
        }
      };

      const handleSend = async () => {
        if (!input.trim() && !attachment) return;

        const userMessage = { text: input, sender: 'user', attachment: attachmentPreview };
        setMessages(prev => [...prev, userMessage]);
        setInput('');
        setAttachment(null);
        setAttachmentPreview(null);
        setIsLoading(true);

        try {
          const mealContext = recentMeals.map(m => `${m.name} (Felt: ${m.mood || 'Not specified'})`).join(', ');
          
          // Calculate progress percentages
          const calorieProgress = ((dailyIntake.calories / goals.calories) * 100).toFixed(0);
          const proteinProgress = ((dailyIntake.protein / goals.protein) * 100).toFixed(0);
          const carbProgress = ((dailyIntake.carbs / goals.carbs) * 100).toFixed(0);
          const fatProgress = ((dailyIntake.fat / goals.fat) * 100).toFixed(0);
          // Read habits safely from localStorage (chat context doesn't receive habits prop)
          const habitsLS = (() => { try { return JSON.parse(localStorage.getItem('habits') || '[]'); } catch (e) { return []; } })();

          // Consolidate activity: combine dashboard activity with completed activity habit for today
          const todayStrAct = new Date().toISOString().split('T')[0];
          const activityHabitMinutesCtx = habitsLS.reduce((max, h) => {
            const isActivity = /(cardio|exercise|workout|run|walk|gym)/i.test(h.name || '');
            const done = h.completed && h.completed[todayStrAct];
            if (!isActivity || !done) return max;
            const m = (h.name || '').match(/(\d+)\s*(min|mins|minutes)/i) || (h.name || '').match(/(\d+)/);
            const mins = m ? parseInt(m[1], 10) : 30;
            return Math.max(max, mins);
          }, 0);
          const effectiveActivityCtx = Math.max(dailyIntake.activity || 0, activityHabitMinutesCtx || 0);
          const activityProgress = ((effectiveActivityCtx / goals.activity) * 100).toFixed(0);
          
          // Consolidate hydration: combine dashboard water with completed water habit for today
          const todayStr = new Date().toISOString().split('T')[0];
          const waterHabitGlassesCtx = habitsLS.reduce((max, h) => {
            const isWater = /\b(drink)?\s*\d+\s*(glass|glasses)\s*of\s*water\b|\bwater\b|\bhydrate\b/i.test(h.name || '');
            const doneToday = h.completed && h.completed[todayStr];
            if (!isWater || !doneToday) return max;
            const m = (h.name || '').match(/(\d+)\s*(glass|glasses)/i);
            const g = m ? parseInt(m[1], 10) : 0;
            return Math.max(max, g);
          }, 0);
          const effectiveWaterCtx = Math.max(dailyIntake.water || 0, waterHabitGlassesCtx || 0);
          const waterProgress = ((effectiveWaterCtx / goals.water) * 100).toFixed(0);
          
          // Identify areas needing attention
          const lowAreas = [];
          const highAreas = [];
          if (calorieProgress < 80) lowAreas.push('calories');
          if (proteinProgress < 80) lowAreas.push('protein');
          if (activityProgress < 80) lowAreas.push('activity');
          if (waterProgress < 80) lowAreas.push('water');
          if (calorieProgress > 120) highAreas.push('calories');
          if (carbProgress > 120) highAreas.push('carbs');
          if (fatProgress > 120) highAreas.push('fat');
          
          // Get workout history for enhanced coaching
          let workoutHistory;
          try {
            workoutHistory = JSON.parse(localStorage.getItem('workoutHistory') || '[]');
            if (!Array.isArray(workoutHistory)) {
              workoutHistory = [];
            }
          } catch (error) {
            console.warn('Error parsing workoutHistory in coaching, resetting to empty array:', error);
            workoutHistory = [];
          }
          const recentWorkouts = workoutHistory.slice(-5); // Last 5 workouts
          const workoutContext = recentWorkouts.map(w => 
            `${w.workoutTitle} (${w.workoutLevel || 'Unknown'} level) - ${w.completionRate}% completed on ${new Date(w.timestamp).toLocaleDateString()}`
          ).join('; ');
          
          // Calculate current health score
          const calculateHealthScore = () => {
            const todayStr = toLocalISODate(new Date());
            return computeHealthScoreForDate(dailyIntake, goals, todayStr).score;
          };
          
          const currentHealthScore = calculateHealthScore();
          
          let prompt = `You are an AI Health Coach specializing in FITNESS, WORKOUTS, and NUTRITION. You have comprehensive knowledge of the FitnessMate app's features and can provide expert guidance on ALL app screens and functionality.

📊 USER'S CURRENT STATUS:
🎯 OVERALL HEALTH SCORE: ${currentHealthScore}/100
Daily Intake vs Goals:
- Calories: ${dailyIntake.calories}/${goals.calories} (${calorieProgress}%)
- Protein: ${dailyIntake.protein}g/${goals.protein}g (${proteinProgress}%)
- Carbs: ${dailyIntake.carbs}g/${goals.carbs}g (${carbProgress}%)
- Fat: ${dailyIntake.fat}g/${goals.fat}g (${fatProgress}%)
- Activity: ${Math.min(effectiveActivityCtx, goals.activity)}/${goals.activity} mins (${Math.min(100, Number(activityProgress))}%)
- Water: ${dailyIntake.water}/${goals.water} glasses (${waterProgress}%)

🏋️ WORKOUT DATA:
- Recent workouts: ${workoutContext || 'No recent workouts'}
- Available workout types: Upper Body, Lower Body, Full Body, Core & Abs, Cardio HIIT
- Difficulty levels: Beginner, Intermediate, Advanced
- Features: AI Form Coach, Workout Planner, Progress Tracking

🎯 HEALTH SCORING SYSTEM:
- Nutrition: 40% (25% Calories, 5% Protein, 5% Carbs, 5% Fat; ±10% tolerance; calories beyond ±10% apply 25% penalty to total Nutrition)
- Activity: up to 15 pts — 10m=5, 20m=10, 30m=15 (capped). Workouts do NOT add activity minutes.
- Workouts: 1 pt per 10% completion (max 10 per workout), cap at 30 total per day
- Hydration: 15 pts (water intake vs goals)
- Activity covers general movement (walking, cardio, steps logged via timer). Workouts are structured sessions scored separately.

📱 COMPLETE APP KNOWLEDGE:
DASHBOARD SCREEN: Health score visualization, daily intake tracking (calories/protein/carbs/fat/water), progress bars, recent meals display, motivational quotes, activity logging
FOOD SCANNER: AI nutritional analysis, portion size input (grams/ml), ingredient breakdown, health tips generation, meal logging with photos, instant calorie calculation
WORKOUT PLANNER: 15+ exercises with video guides (Burpee, Inchworm, Jumping Jack, Military Push Ups, Reverse Crunches, etc.), session tracking, timer, voice instructions, difficulty progression
MEAL PLANNER: Recipe generation, pantry scanning, menu decoder for restaurants, dietary goal integration, ingredient analysis
PROFILE SCREEN: Goal setting, notification preferences, dark mode toggle, consultation booking, data sync, account management
AI COACHES: Form Coach (exercise technique), Habit Coach (behavior change), personalized recommendations based on user data

Recent meals: ${mealContext || 'None logged'}
${lowAreas.length > 0 ? `\n⚠️ LOW AREAS: ${lowAreas.join(', ')}` : ''}
${highAreas.length > 0 ? `\n🔴 HIGH AREAS: ${highAreas.join(', ')}` : ''}

🎯 ENHANCED RESPONSE RULES:
1. IDENTIFY QUESTION TYPE & DIRECT TO APPROPRIATE SCREEN:
   - WORKOUT PLANNING → Guide to Workout Planner, recommend specific exercises
   - EXERCISE FORM → Reference AI Form Coach feature for technique help
   - NUTRITION TRACKING → Direct to Food Scanner for accurate logging
   - MEAL PLANNING → Suggest Meal Planner for recipes and pantry management
   - GOAL SETTING → Guide to Profile screen for goal adjustments
   - PROGRESS TRACKING → Reference Dashboard for comprehensive health overview
   - APP NAVIGATION → Explain which screen to use for specific needs

2. RESPONSE FORMAT (MAX 120 WORDS):
   - Direct answer with specific app feature recommendations
   - 2-3 actionable bullet points with screen references
   - Reference their actual data when applicable
   - Guide users to relevant app sections (e.g., "Check your Dashboard", "Use the Food Scanner")
   - Use emojis for readability and engagement

3. COMPREHENSIVE APP GUIDANCE:
   - Explain how different screens work together for complete health management
   - Reference specific features like portion size input, exercise videos, health scoring
   - Encourage cross-feature usage (e.g., scan food → track on dashboard → plan workouts)
   - Mention specific exercises from database when recommending fitness routines

User's question: "${userMessage.text}"`;

          const parts = [{ text: prompt }];

          if (attachment) {
            const base64ImageData = await fileToBase64(attachment);
            parts.push({ inlineData: { mimeType: attachment.type, data: base64ImageData } });
            prompt += "\n\nPlease also consider the attached document in your analysis.";
          }

          const orMessages = [
            attachment ? {
              role: 'user',
              content: [
                { type: 'text', text: prompt },
                { type: 'image_url', image_url: `data:${attachment.type};base64,${await fileToBase64(attachment)}` }
              ]
            } : { role: 'user', content: prompt }
          ];

          const response = await fetch(getDirectGeminiConfig().url, {
            method: 'POST',
            headers: getDirectGeminiConfig().headers,
            body: JSON.stringify({
              model: attachment ? OPENROUTER_QWEN_VL_MODEL : OPENROUTER_QWEN_MODEL,
              messages: orMessages
            })
          });

          if (!response.ok) {
            throw new Error(`API Error: ${response.status} ${response.statusText}`);
          }

          const result = await response.json();
          const aiResponse = (result.choices?.[0]?.message?.content || '');
          setMessages(prev => [...prev, { text: aiResponse, sender: 'ai' }]);
        } catch (err) {
          console.error("Chatbot error:", err);
          setMessages(prev => [...prev, { text: "Sorry, I'm having trouble connecting. Please try again.", sender: 'ai' }]);
        } finally {
          setIsLoading(false);
        }
      };

      return (
        <div className="p-6 pb-24 h-screen flex flex-col">
          <header className="mb-6 text-center">
            <div className="flex items-center justify-between mb-2">
              <div></div> {/* Spacer for centering */}
              <h1 className="text-3xl font-bold text-gray-800 dark:text-gray-200">AI Health Coach</h1>
              <button
                onClick={startNewConversation}
                className="bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded-lg text-sm font-medium transition-colors flex items-center gap-1"
                title="Start New Conversation"
              >
                🔄 New
              </button>
            </div>
            <p className="text-gray-500 dark:text-gray-400">Your personal health assistant</p>
          </header>

          <div className="flex-grow overflow-y-auto p-4 rounded-2xl shadow-md relative" 
               style={{
                 backgroundColor: isDarkMode ? '#1f2937' : '#f8fafc',
                 backgroundImage: `
                   radial-gradient(circle at 25px 25px, rgba(59, 130, 246, 0.15) 6px, transparent 6px),
                   radial-gradient(circle at 75px 75px, rgba(168, 85, 247, 0.12) 8px, transparent 8px),
                   radial-gradient(circle at 50px 100px, rgba(236, 72, 153, 0.08) 4px, transparent 4px)
                 `,
                 backgroundSize: '100px 100px'
               }}>
            
            {/* Bigger dots pattern for dark mode */}
            <div className="absolute inset-0 rounded-2xl dark:bg-gray-800" 
                 style={{
                   backgroundImage: `
                     radial-gradient(circle at 25px 25px, rgba(59, 130, 246, 0.2) 5px, transparent 5px),
                     radial-gradient(circle at 75px 75px, rgba(168, 85, 247, 0.15) 7px, transparent 7px)
                   `,
                   backgroundSize: '100px 100px'
                 }}></div>
            
            {/* Content container */}
            <div className="relative z-10">
              <div className="text-center text-xs text-gray-600 dark:text-gray-400 p-2 mb-2 bg-white dark:bg-gray-700 rounded-lg shadow-sm">
                Disclaimer: This AI is for informational purposes only and is not a substitute for professional medical advice. Always consult a doctor for health concerns.
              </div>

              {messages.map((msg, i) => (
                <div key={i} className={`flex mb-3 ${msg.sender === 'user' ? 'justify-end' : 'justify-start'}`}>
                  <div className={`p-3 rounded-2xl max-w-xs shadow-lg ${
                    msg.sender === 'user' 
                      ? 'bg-pink-500 text-white' 
                      : 'bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200'
                  }`}>
                    {msg.attachment && <img src={msg.attachment} alt="attachment" className="rounded-lg mb-2 max-w-full h-auto" />}
                    {msg.text}
                  </div>
                </div>
              ))}
              <div ref={chatEndRef} />
            </div>
          </div>

          {attachmentPreview && (
            <div className="mt-2 p-2 bg-gray-200 dark:bg-gray-700 rounded-lg flex items-center justify-between">
              <img src={attachmentPreview} alt="preview" className="w-12 h-12 rounded-md object-cover" />
              <button onClick={() => { setAttachment(null); setAttachmentPreview(null); }} className="text-red-500 font-bold">Remove</button>
            </div>
          )}

          <div className="mt-4 flex">
            <input type="file" accept="image/*" ref={fileInputRef} onChange={handleAttachmentChange} className="hidden" />
            <button onClick={() => fileInputRef.current.click()} className="p-3 border dark:border-gray-700 rounded-l-lg bg-gray-100 dark:bg-gray-700">📎</button>
            <input
              type="text"
              value={input}
              onChange={e => setInput(e.target.value)}
              onKeyDown={e => e.key === 'Enter' && handleSend()}
              placeholder="Ask a question..."
              className="flex-grow p-3 border-t border-b dark:border-gray-700 focus:outline-none focus:ring-2 focus:ring-pink-500 bg-white dark:bg-gray-800 text-gray-800 dark:text-gray-200"
              disabled={isLoading}
            />
            <button onClick={handleSend} disabled={isLoading} className="bg-pink-500 text-white p-3 rounded-r-lg font-bold">
              {isLoading ? '...' : 'Send'}
            </button>
          </div>
        </div>
      );
    };

    // Progress Screen Component
    const Progress = ({ dailyHistory, goals, dailyIntake, habitAIAdvice, setHabitAIAdvice, isLoadingAdvice, setIsLoadingAdvice }) => {
      const { updateUserData, user } = useAuth();
      const [currentDate, setCurrentDate] = useState(new Date());
      const [selectedDay, setSelectedDay] = useState(null);
      const [viewMode, setViewMode] = useState('month'); // 'month' or 'year'
      const [activeTab, setActiveTab] = useState(() => localStorage.getItem('progress_activeTab') || 'progress'); // 'progress' or 'habits'
    useEffect(() => {
      try {
        if (typeof setLocalStorageWithSync === 'function') {
          setLocalStorageWithSync('progress_activeTab', activeTab);
        } else {
          localStorage.setItem('progress_activeTab', activeTab);
        }
      } catch (e) {
        // ignore storage errors
      }
    }, [activeTab]);
    const [habits, setHabits] = useState(() => {
        const savedHabits = localStorage.getItem('habits');
        return savedHabits ? JSON.parse(savedHabits) : [];
      });
      const [newHabit, setNewHabit] = useState('');
      const [workoutHistory, setWorkoutHistory] = useState(() => {
        try {
          const saved = localStorage.getItem('workoutHistory');
          return saved ? JSON.parse(saved) : [];
        } catch (e) {
          return [];
        }
      });

      const [stressForm, setStressForm] = useState(() => {
        try {
          const raw = localStorage.getItem('stressForm');
          const parsed = raw ? JSON.parse(raw) : {};
          return {
            sleepHours: parsed.sleepHours ?? '',
            workHours: parsed.workHours ?? '',
            stressRating: parsed.stressRating ?? 5,
            stressEpisodes: parsed.stressEpisodes ?? '',
            exerciseMins: parsed.exerciseMins ?? '',
            meditationMins: parsed.meditationMins ?? '',
            socialMins: parsed.socialMins ?? '',
            screenHours: parsed.screenHours ?? '',
            lifeEvent: parsed.lifeEvent ?? 'none',
            notes: parsed.notes ?? ''
          };
        } catch (_) {
          return { sleepHours:'', workHours:'', stressRating:5, stressEpisodes:'', exerciseMins:'', meditationMins:'', socialMins:'', screenHours:'', lifeEvent:'none', notes:'' };
        }
      });
      const [stressResult, setStressResult] = useState(null);
      const [stressInsight, setStressInsight] = useState('');

      useEffect(() => {
        try { localStorage.setItem('stressForm', JSON.stringify(stressForm)); } catch (_) {}
      }, [stressForm]);

      const computeStressScore = (inp) => {
        const v = {
          sleepHours: Number(inp.sleepHours || 0),
          workHours: Number(inp.workHours || 0),
          stressRating: Number(inp.stressRating || 0),
          stressEpisodes: Number(inp.stressEpisodes || 0),
          exerciseMins: Number(inp.exerciseMins || 0),
          meditationMins: Number(inp.meditationMins || 0),
          socialMins: Number(inp.socialMins || 0),
          screenHours: Number(inp.screenHours || 0),
          lifeEvent: inp.lifeEvent || 'none'
        };
        const clamp01 = (x) => Math.max(0, Math.min(1, x));
        // Normalize inputs to 0-1
        const sleep = clamp01(Math.abs((v.sleepHours || 0) - 8) / 4);
        const work = clamp01((v.workHours || 0) / 12);
        const rating = clamp01((v.stressRating - 1) / 9);
        const episodes = clamp01((v.stressEpisodes || 0) / 6);
        const screen = clamp01((v.screenHours || 0) / 8);
        const exerciseRelief = clamp01((v.exerciseMins || 0) / 45);
        const meditationRelief = clamp01((v.meditationMins || 0) / 15);
        const socialRelief = clamp01((v.socialMins || 0) / 60);

        // New weight distribution (total: 100%)
        // Self-rating+Episodes=20%, Exercise+Meditation=20%, Screen=10%
        const w = { sleep:25, work:20, rating:12, episodes:8, screen:10, exercise:15, meditation:5, social:5 };
        const stressors = sleep*w.sleep + work*w.work + rating*w.rating + episodes*w.episodes + screen*w.screen;
        const bufferSum = exerciseRelief*w.exercise + meditationRelief*w.meditation + socialRelief*w.social;
        let rawIndex = stressors - bufferSum; // Range: [-25, 75]
        
        // Map to 0-100 base score
        let baseScore = Math.max(0, Math.min(100, rawIndex + 25));
        
        // Life event multiplier (amplifies stress)
        let multiplier = 1.0;
        if (v.lifeEvent === 'minor') multiplier = 1.5;
        else if (v.lifeEvent === 'major') multiplier = 2.0;
        
        let stressScore = Math.round(Math.min(100, baseScore * multiplier));

        let category = 'Low';
        if (stressScore >= 70) category = 'High';
        else if (stressScore >= 35) category = 'Moderate';

        // Confidence: weighted completeness matching new distribution
        const pw = { sleepHours:.25, workHours:.20, stressRating:.12, stressEpisodes:.08, screenHours:.10, exerciseMins:.15, meditationMins:.05, socialMins:.05 };
        const filled = (k) => {
          const val = inp[k];
          return val !== '' && val !== null && val !== undefined;
        };
        let coverage = 0;
        Object.keys(pw).forEach(k => { if (filled(k)) coverage += pw[k]; });
        const confidence = Math.max(30, Math.min(100, Math.round(coverage * 100)));

        const drivers = {
          sleep: Math.round(sleep * w.sleep),
          work: Math.round(work * w.work),
          selfRating: Math.round(rating * w.rating),
          episodes: Math.round(episodes * w.episodes),
          screen: Math.round(screen * w.screen)
        };
        const buffers = {
          exercise: Math.round(exerciseRelief * w.exercise),
          meditation: Math.round(meditationRelief * w.meditation),
          social: Math.round(socialRelief * w.social)
        };

        return { stressScore, category, confidence, breakdown: { drivers, buffers }, lifeEventMultiplier: multiplier };
      };

      const generateStressInsight = (res, inp) => {
        const d = res.breakdown?.drivers || {};
        const entries = [
          ['work', d.work],
          ['self rating', d.selfRating],
          ['sleep', d.sleep],
          ['screen time', d.screen],
          ['episodes', d.episodes]
        ];
        entries.sort((a, b) => (b[1]||0) - (a[1]||0));
        const top = entries.filter(e => (e[1]||0) > 0).slice(0, 2).map(e => e[0]);

        const b = res.breakdown?.buffers || {};
        const reliefs = [
          ['exercise', b.exercise],
          ['meditation', b.meditation],
          ['social time', b.social]
        ].filter(e => (e[1]||0) > 0).sort((a,b)=> (b[1]||0) - (a[1]||0));

        const act = [];
        if (top.includes('sleep') || Number(inp.sleepHours || 0) < 7) act.push('aim for 7.5–8h sleep tonight and keep screens away 1h before bed');
        if (top.includes('work') || Number(inp.workHours || 0) > 9) act.push('add two 5‑min breaks every 90 minutes and end work at a firm time');
        if (top.includes('screen time') || Number(inp.screenHours || 0) > 6) act.push('set a 30‑min app limit after 9pm');
        if (top.includes('self rating') || Number(inp.stressRating || 0) >= 7) act.push('do 4‑7‑8 breathing for 3 cycles when stress spikes');
        if (top.includes('episodes') || Number(inp.stressEpisodes || 0) >= 3) act.push('log triggers and use a quick walk to reset when one appears');

        let s1 = `Stress is ${res.category} (score ${res.stressScore}). Top drivers: ${top.join(' and ') || 'balanced factors'}.`;
        let s2 = `Action: ${act.slice(0,2).join('; ')}.`;
        let s3 = '';
        if (reliefs.length > 0) s3 = `Good job: ${reliefs[0][0]} helped buffer stress. Keep it up.`;
        const text = [s1, s2, s3].filter(Boolean).join(' ');
        return text;
      };

      // Helper: use shared timezone-aware formatter so calendar keys match archive keys
      const getLocalDateString = (date) => toLocalISODate(date);

      // Save habits to localStorage and sync with Firebase whenever they change
      useEffect(() => {
        localStorage.setItem('habits', JSON.stringify(habits));
        // Sync with Firebase if user is authenticated
        if (user && updateUserData) {
          updateUserData({ habits });
        }
      }, [habits, user, updateUserData]);

      useEffect(() => {
        const handleStorageChange = (e) => {
          if (e.key === 'workoutHistory') {
            try {
              const updatedHistory = JSON.parse(e.newValue || '[]');
              if (Array.isArray(updatedHistory)) {
                setWorkoutHistory(updatedHistory);
              }
            } catch (error) {
              console.warn('Error parsing workoutHistory from storage event:', error);
            }
          }
        };

        window.addEventListener('storage', handleStorageChange);
        return () => window.removeEventListener('storage', handleStorageChange);
      }, []);

      const startOfMonth = new Date(currentDate.getFullYear(), currentDate.getMonth(), 1);
      const endOfMonth = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 0);
      // Adjust start day for Monday-first calendar (0=Sunday becomes 6, 1=Monday becomes 0)
      const startDay = (startOfMonth.getDay() + 6) % 7;
      const daysInMonth = endOfMonth.getDate();

      const getScoreColor = (score) => {
        if (score >= 90) return 'from-emerald-400 to-emerald-600';
        if (score >= 80) return 'from-green-400 to-green-600';
        if (score >= 70) return 'from-lime-400 to-lime-600';
        if (score >= 60) return 'from-yellow-400 to-yellow-600';
        if (score >= 50) return 'from-orange-400 to-orange-600';
        return 'from-red-400 to-red-600';
      };

      const getScoreGlow = (score) => {
        if (score >= 90) return 'shadow-emerald-500/50';
        if (score >= 80) return 'shadow-green-500/50';
        if (score >= 70) return 'shadow-lime-500/50';
        if (score >= 60) return 'shadow-yellow-500/50';
        if (score >= 50) return 'shadow-orange-500/50';
        return 'shadow-red-500/50';
      };

      // Calculate current streak without breaking mid-day: if today's score < 70 or not yet available, start from yesterday
      const calculateStreak = () => {
        const today = new Date();
        let streak = 0;
        let currentDay = new Date(today);

        const todayISO = toLocalISODate(today);
        let todayScore = dailyHistory[todayISO]?.score;
        if (todayScore === undefined) {
          // Compute on the fly if not archived yet
          const computed = computeHealthScoreForDate(dailyIntake, goals, todayISO).score;
          todayScore = typeof computed === 'number' ? computed : undefined;
        }

        // If today's score isn't >= 70, begin counting from yesterday so the streak doesn't drop to 0 mid-day
        if (!(typeof todayScore === 'number' && todayScore >= 70)) {
          currentDay.setDate(currentDay.getDate() - 1);
        }

        const oneYearAgo = new Date(today.getTime() - 365 * 24 * 60 * 60 * 1000);
        while (currentDay >= oneYearAgo) {
          const dateString = toLocalISODate(currentDay);
          let dayScore = dailyHistory[dateString]?.score;

          if (typeof dayScore === 'number' && dayScore >= 70) {
            streak++;
          } else {
            break;
          }

          currentDay.setDate(currentDay.getDate() - 1);
        }

        return streak;
      };

      // Calculate monthly stats (includes today's computed score if in current month)
      const getMonthlyStats = () => {
        let monthData = Object.entries(dailyHistory)
          .filter(([date]) => {
            // Parse YYYY-MM-DD as local time to avoid UTC shift issues
            const [y, m, d] = (date || '').split('-').map(Number);
            if (!y || !m || !d) return false;
            const local = new Date(y, m - 1, d);
            return local.getMonth() === currentDate.getMonth() && local.getFullYear() === currentDate.getFullYear();
          })
          .map(([_, data]) => data);

        const today = new Date();
        const todayISO = toLocalISODate(today);
        const inCurrentMonth = today.getMonth() === currentDate.getMonth() && today.getFullYear() === currentDate.getFullYear();
        if (inCurrentMonth && !dailyHistory[todayISO]) {
          const computed = computeHealthScoreForDate(dailyIntake, goals, todayISO).score;
          monthData = monthData.concat([{ score: computed }]);
        }

        if (monthData.length === 0) return { avg: 0, best: 0, days: 0 };

        const scores = monthData.map(d => d.score).filter(s => typeof s === 'number');
        if (scores.length === 0) return { avg: 0, best: 0, days: 0 };

        const avg = scores.reduce((sum, s) => sum + s, 0) / scores.length;
        const best = Math.max(...scores);
        return { avg: Math.round(avg), best, days: scores.length };
      };

      const currentStreak = calculateStreak();
      const monthlyStats = getMonthlyStats();

      return (
        <div className="p-6 pb-24 bg-gradient-to-br from-purple-50 via-pink-50 to-blue-50 dark:from-gray-900 dark:via-purple-900/20 dark:to-blue-900/20 min-h-screen">
          {/* Header */}
          <header className="mb-8 text-center">
            <div className="inline-flex items-center justify-center w-16 h-16 bg-gradient-to-r from-purple-500 to-pink-500 rounded-2xl mb-4 shadow-lg">
              <span className="text-2xl">📊</span>
            </div>
            <h1 className="text-4xl font-bold bg-gradient-to-r from-purple-600 to-pink-600 bg-clip-text text-transparent mb-2">Your Progress</h1>
            <p className="text-gray-600 dark:text-gray-400 text-lg">Track your fitness journey</p>
          </header>

          {/* Tab Navigation */}
          <div className="flex justify-center mb-6">
            <div className="bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm p-1 rounded-xl shadow-md border border-white/20 flex">
              <button 
                onClick={() => setActiveTab('progress')} 
                className={`px-6 py-3 rounded-lg font-semibold transition-all duration-200 ${activeTab === 'progress' ? 'bg-gradient-to-r from-purple-500 to-pink-500 text-white shadow-md' : 'text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700'}`}
              >
                Progress
              </button>
              <button 
                onClick={() => setActiveTab('habits')} 
                className={`px-6 py-3 rounded-lg font-semibold transition-all duration-200 ${activeTab === 'habits' ? 'bg-gradient-to-r from-purple-500 to-pink-500 text-white shadow-md' : 'text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700'}`}
              >
                Habit Tracker
              </button>
              <button 
                onClick={() => setActiveTab('stress')} 
                className={`px-6 py-3 rounded-lg font-semibold transition-all duration-200 ${activeTab === 'stress' ? 'bg-gradient-to-r from-purple-500 to-pink-500 text-white shadow-md' : 'text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700'}`}
              >
                Stress Analyzer
              </button>
            </div>
          </div>

          {/* Tab Content */}
          {activeTab === 'progress' && (
            <>
              {/* Streak & Stats Cards */}
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-8">
            {/* Current Streak */}
            <div className="bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm p-6 rounded-3xl shadow-xl border border-white/20">
              <div className="flex items-center justify-between mb-3">
                <div className="w-12 h-12 bg-gradient-to-r from-orange-400 to-red-500 rounded-2xl flex items-center justify-center">
                  <span className="text-xl">🔥</span>
                </div>
                <span className="text-3xl font-bold bg-gradient-to-r from-orange-500 to-red-500 bg-clip-text text-transparent">
                  {currentStreak}
                </span>
              </div>
              <h3 className="font-semibold text-gray-800 dark:text-gray-200">Day Streak</h3>
              <p className="text-sm text-gray-600 dark:text-gray-400">Keep it going! 💪</p>
              <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">Counts consecutive days with Health Score &ge; 70.</p>
            </div>

            {/* Monthly Average */}
            <div className="bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm p-6 rounded-3xl shadow-xl border border-white/20">
              <div className="flex items-center justify-between mb-3">
                <div className="w-12 h-12 bg-gradient-to-r from-blue-400 to-purple-500 rounded-2xl flex items-center justify-center">
                  <span className="text-xl">📈</span>
                </div>
                <span className="text-3xl font-bold bg-gradient-to-r from-blue-500 to-purple-500 bg-clip-text text-transparent">
                  {monthlyStats.avg}
                </span>
              </div>
              <h3 className="font-semibold text-gray-800 dark:text-gray-200">Monthly Avg</h3>
              <p className="text-sm text-gray-600 dark:text-gray-400">{monthlyStats.days} active days</p>
            </div>

            {/* Best Score */}
            <div className="bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm p-6 rounded-3xl shadow-xl border border-white/20">
              <div className="flex items-center justify-between mb-3">
                <div className="w-12 h-12 bg-gradient-to-r from-emerald-400 to-green-500 rounded-2xl flex items-center justify-center">
                  <span className="text-xl">🏆</span>
                </div>
                <span className="text-3xl font-bold bg-gradient-to-r from-emerald-500 to-green-500 bg-clip-text text-transparent">
                  {monthlyStats.best}
                </span>
              </div>
              <h3 className="font-semibold text-gray-800 dark:text-gray-200">Best Score</h3>
              <p className="text-sm text-gray-600 dark:text-gray-400">This month</p>
            </div>
          </div>

          {/* Modern Calendar */}
          <div className="bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm rounded-3xl shadow-2xl border border-white/20 overflow-hidden">
            {/* Calendar Header */}
            <div className="bg-blue-500 p-6">
              <div className="flex justify-between items-center">
                <button 
                  onClick={() => setCurrentDate(new Date(currentDate.setMonth(currentDate.getMonth() - 1)))} 
                  className="w-12 h-12 bg-white/20 hover:bg-white/30 rounded-2xl flex items-center justify-center text-white transition-all duration-200 hover:scale-105"
                >
                  <span className="text-xl">←</span>
                </button>
                
                <div className="text-center">
                  <h2 className="text-2xl font-bold text-white mb-1">
                    {currentDate.toLocaleString('default', { month: 'long', year: 'numeric' })}
                  </h2>
                  <p className="text-white/80 text-sm">Tap any day to see details</p>
                </div>
                
                <button 
                  onClick={() => setCurrentDate(new Date(currentDate.setMonth(currentDate.getMonth() + 1)))} 
                  className="w-12 h-12 bg-white/20 hover:bg-white/30 rounded-2xl flex items-center justify-center text-white transition-all duration-200 hover:scale-105"
                >
                  <span className="text-xl">→</span>
                </button>
              </div>
            </div>

            {/* Calendar Grid */}
            <div className="p-6">
              {/* Day Headers - Monday to Sunday */}
              <div className="grid grid-cols-7 gap-1 mb-2 bg-gray-100 dark:bg-gray-700 rounded-xl p-2">
                {['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'].map((day, index) => (
                  <div key={day} className={`text-center py-3 text-sm font-semibold rounded-lg border ${
                    index === 5 || index === 6 
                      ? 'bg-red-50 dark:bg-red-900/20 text-red-600 dark:text-red-400 border-red-200 dark:border-red-700' 
                      : 'bg-white dark:bg-gray-600 text-gray-600 dark:text-gray-300 border-gray-200 dark:border-gray-500'
                  }`}>
                    {day}
                  </div>
                ))}
              </div>

              {/* Calendar Days with Monday-first layout */}
              <div className="grid grid-cols-7 gap-1 bg-gray-100 dark:bg-gray-700 p-2 rounded-xl">
                {Array.from({ length: startDay }).map((_, i) => {
                  const dayOfWeek = i;
                  const isWeekend = dayOfWeek === 5 || dayOfWeek === 6; // Saturday=5, Sunday=6
                  return (
                    <div key={`empty-${i}`} className={`aspect-square rounded-lg border ${
                      isWeekend 
                        ? 'bg-red-50 dark:bg-red-900/10 border-red-200 dark:border-red-700' 
                        : 'bg-white dark:bg-gray-600 border-gray-200 dark:border-gray-500'
                    }`}></div>
                  );
                })}
                
                {Array.from({ length: daysInMonth }).map((_, day) => {
                  const date = new Date(currentDate.getFullYear(), currentDate.getMonth(), day + 1);
                  const dateString = getLocalDateString(date);
                  const data = dailyHistory[dateString];
                  const isToday = dateString === getLocalDateString(new Date());
                  // Adjust day of week calculation for Monday-first calendar
                  const dayOfWeek = (startDay + day) % 7;
                  const isWeekend = dayOfWeek === 5 || dayOfWeek === 6; // Saturday=5, Sunday=6
                  
                  return (
                    <div 
                      key={day} 
                      onClick={() => data && setSelectedDay({date: dateString, ...data})} 
                      className={`aspect-square flex items-center justify-center cursor-pointer group relative rounded-lg border transition-all duration-200 ${
                        isWeekend 
                          ? 'bg-red-50 dark:bg-red-900/10 border-red-200 dark:border-red-700 hover:border-red-300 dark:hover:border-red-600' 
                          : 'bg-white dark:bg-gray-600 border-gray-200 dark:border-gray-500 hover:border-gray-300 dark:hover:border-gray-400'
                      }`}
                    >
                      {data ? (
                        <div className={`w-10 h-10 bg-gradient-to-br ${getScoreColor(data.score)} rounded-xl flex items-center justify-center text-white font-bold text-sm shadow-lg ${getScoreGlow(data.score)} transform transition-all duration-200 group-hover:scale-110 group-hover:shadow-2xl ${isToday ? 'ring-3 ring-purple-400 ring-opacity-60' : ''} ${isWeekend ? 'ring-2 ring-red-300 dark:ring-red-600' : ''}`}>
                          {data.score}
                        </div>
                      ) : (
                        <div className={`w-10 h-10 rounded-xl flex items-center justify-center font-medium transition-all duration-200 ${
                          isWeekend 
                            ? 'text-red-500 dark:text-red-400 group-hover:bg-red-100 dark:group-hover:bg-red-900/20' 
                            : 'text-gray-500 dark:text-gray-400 group-hover:bg-gray-50 dark:group-hover:bg-gray-500'
                        } ${isToday ? 'bg-purple-100 dark:bg-purple-900/40 text-purple-600 dark:text-purple-400 ring-2 ring-purple-400 ring-opacity-60' : ''}`}>
                          {day + 1}
                        </div>
                      )}
                      
                      {/* Weekend Corner Marker */}
                      {isWeekend && (
                        <div className="absolute top-1 right-1 w-2 h-2 bg-red-400 dark:bg-red-500 rounded-full opacity-60"></div>
                      )}
                    </div>
                  );
                })}
              </div>
            </div>
          </div>

          {/* Workout Analytics Dashboard */}
          <div className="mt-8 bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm p-6 rounded-3xl shadow-xl border border-white/20">
            <h3 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-4 flex items-center">
              <span className="mr-2">💪</span>
              Workout Analytics
            </h3>
            {(() => {
              const last7Days = Array.from({length: 7}, (_, i) => {
                const date = new Date();
                date.setDate(date.getDate() - i);
                return date.toDateString();
              }).reverse();
              
              const weeklyWorkouts = last7Days.map(dateStr => {
                const dayWorkouts = workoutHistory.filter(w => new Date(w.timestamp).toDateString() === dateStr);
                return {
                  date: dateStr,
                  count: dayWorkouts.length,
                  totalTime: dayWorkouts.reduce((sum, w) => sum + w.duration, 0),
                  avgCompletion: dayWorkouts.length > 0 ? dayWorkouts.reduce((sum, w) => sum + w.completionRate, 0) / dayWorkouts.length : 0
                };
              });
              
              const totalWorkouts = workoutHistory.length;
              const avgCompletionRate = totalWorkouts > 0 ? workoutHistory.reduce((sum, w) => sum + w.completionRate, 0) / totalWorkouts : 0;
              const totalWorkoutTime = workoutHistory.reduce((sum, w) => sum + w.duration, 0);
              const workoutStreak = (() => {
                let streak = 0;
                for (let i = 0; i < 30; i++) {
                  const date = new Date();
                  date.setDate(date.getDate() - i);
                  const hasWorkout = workoutHistory.some(w => new Date(w.timestamp).toDateString() === date.toDateString());
                  if (hasWorkout) streak++;
                  else break;
                }
                return streak;
              })();
              
              return (
                <div className="space-y-4">
                  {/* Key Metrics */}
                  <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                    <div className="bg-gradient-to-br from-purple-500 to-pink-500 p-4 rounded-2xl text-white text-center">
                      <div className="text-2xl font-bold">{totalWorkouts}</div>
                      <div className="text-xs opacity-90">Total Workouts</div>
                    </div>
                    <div className="bg-gradient-to-br from-blue-500 to-cyan-500 p-4 rounded-2xl text-white text-center">
                      <div className="text-2xl font-bold">{Math.round(avgCompletionRate)}%</div>
                      <div className="text-xs opacity-90">Avg Completion</div>
                    </div>
                    <div className="bg-gradient-to-br from-green-500 to-emerald-500 p-4 rounded-2xl text-white text-center">
                      <div className="text-2xl font-bold">
                        {totalWorkoutTime >= 60 
                          ? `${Math.floor(totalWorkoutTime/60)}h ${totalWorkoutTime%60}m`
                          : `${totalWorkoutTime}m`
                        }
                      </div>
                      <div className="text-xs opacity-90">Total Time</div>
                    </div>
                    <div className="bg-gradient-to-br from-orange-500 to-red-500 p-4 rounded-2xl text-white text-center">
                      <div className="text-2xl font-bold">{workoutStreak}</div>
                      <div className="text-xs opacity-90">Workout Streak</div>
                    </div>
                  </div>
                  
                  {/* Weekly Activity Chart */}
                  <div className="bg-gray-50 dark:bg-gray-700/50 p-4 rounded-2xl">
                    <h4 className="text-sm font-semibold text-gray-700 dark:text-gray-300 mb-3">7-Day Activity</h4>
                    <div className="flex items-end justify-between h-20 space-x-1">
                      {weeklyWorkouts.map((day, index) => {
                        const maxTime = Math.max(...weeklyWorkouts.map(d => d.totalTime), 1);
                        const height = (day.totalTime / maxTime) * 100;
                        return (
                          <div key={index} className="flex-1 flex flex-col items-center">
                            <div 
                              className={`w-full rounded-t transition-all duration-300 ${
                                day.count > 0 
                                  ? 'bg-gradient-to-t from-purple-500 to-pink-500' 
                                  : 'bg-gray-300 dark:bg-gray-600'
                              }`}
                              style={{height: `${Math.max(height, 5)}%`}}
                              title={`${day.count} workouts, ${day.totalTime}min`}
                            ></div>
                            <div className="text-xs text-gray-500 dark:text-gray-400 mt-1">
                              {new Date(day.date).toLocaleDateString('en', {weekday: 'short'}).slice(0,1)}
                            </div>
                          </div>
                        );
                      })}
                    </div>
                  </div>
                  
                  {/* Recent Workouts */}
                  {workoutHistory.length > 0 && (
                    <div className="bg-gray-50 dark:bg-gray-700/50 p-4 rounded-2xl">
                      <h4 className="text-sm font-semibold text-gray-700 dark:text-gray-300 mb-3">📋 Recent Workouts</h4>
                      <div className="space-y-2 max-h-40 overflow-y-auto">
                        {[...workoutHistory].sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp)).slice(0, 5).map((workout, index) => (
                          <div key={index} className="flex justify-between items-center p-3 bg-white dark:bg-gray-600 rounded-lg text-xs">
                            <div className="flex-1">
                              <div className="font-medium text-gray-800 dark:text-gray-200">{workout.workoutTitle}</div>
                              <div className="text-gray-500 dark:text-gray-400 space-y-1">
                                <div className="flex items-center gap-2">
                                  <span className={`px-2 py-0.5 rounded-full text-xs font-medium ${
                                    workout.workoutLevel === 'beginner' ? 'bg-green-100 text-green-700 dark:bg-green-900/30 dark:text-green-400' :
                                    workout.workoutLevel === 'intermediate' ? 'bg-yellow-100 text-yellow-700 dark:bg-yellow-900/30 dark:text-yellow-400' :
                                    'bg-red-100 text-red-700 dark:bg-red-900/30 dark:text-red-400'
                                  }`}>
                                    {workout.workoutLevel ? workout.workoutLevel.charAt(0).toUpperCase() + workout.workoutLevel.slice(1) : 'Beginner'}
                                  </span>
                                  <span>•</span>
                                  <span>{workout.duration}min</span>
                                  <span>•</span>
                                  <span>{Math.round(workout.completionRate)}% complete</span>
                                </div>
                                <div className="text-xs">
                                  {new Date(workout.timestamp).toLocaleDateString()} at {new Date(workout.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}
                                </div>
                              </div>
                            </div>
                            <div className="text-right">
                              <div className="text-green-600 dark:text-green-400 font-medium">{workout.exercisesCompleted}/{workout.totalExercises}</div>
                            </div>
                          </div>
                        ))}
                      </div>
                    </div>
                  )}
                  
                  {/* Workout Quality Insights */}
                  {workoutHistory.length > 0 && (
                    <div className="bg-gradient-to-r from-indigo-50 to-purple-50 dark:from-indigo-900/20 dark:to-purple-900/20 p-4 rounded-2xl">
                      <h4 className="text-sm font-semibold text-gray-700 dark:text-gray-300 mb-2">💡 Insights</h4>
                      <div className="text-sm text-gray-600 dark:text-gray-400 space-y-1">
                        {avgCompletionRate >= 90 && <div>🌟 Excellent completion rate! You're crushing your workouts.</div>}
                        {workoutStreak >= 7 && <div>🔥 Amazing streak! Consistency is key to success.</div>}
                        {totalWorkoutTime >= 300 && <div>⏱️ You've invested serious time in your fitness journey.</div>}
                        {workoutHistory.filter(w => new Date(w.timestamp).toDateString() === new Date().toDateString()).length > 0 && 
                         <div>✅ Great job working out today!</div>}
                      </div>
                    </div>
                  )}
                </div>
              );
            })()}
          </div>

          {/* Achievement Badges */}
          <div className="mt-8 bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm p-6 rounded-3xl shadow-xl border border-white/20">
            <h3 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-4 flex items-center">
              <span className="mr-2">🏅</span>
              Achievement Badges
            </h3>
            {(() => {
              const totalWorkouts = workoutHistory.length;
              const workoutStreak = (() => {
                let streak = 0;
                for (let i = 0; i < 30; i++) {
                  const date = new Date();
                  date.setDate(date.getDate() - i);
                  const hasWorkout = workoutHistory.some(w => new Date(w.timestamp).toDateString() === date.toDateString());
                  if (hasWorkout) streak++;
                  else break;
                }
                return streak;
              })();
              const avgCompletionRate = totalWorkouts > 0 ? workoutHistory.reduce((sum, w) => sum + w.completionRate, 0) / totalWorkouts : 0;
              const totalWorkoutTime = workoutHistory.reduce((sum, w) => sum + w.duration, 0);
              
              return (
                <div className="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-6 gap-4">
                  {/* Health Score Achievements */}
                  <div className={`p-4 rounded-2xl text-center ${currentStreak >= 7 ? 'bg-gradient-to-br from-yellow-400 to-orange-500 text-white' : 'bg-gray-100 dark:bg-gray-700 text-gray-400'}`}>
                    <div className="text-2xl mb-2">🔥</div>
                    <div className="text-xs font-semibold">Week Warrior</div>
                    <div className="text-xs opacity-80">7 day streak</div>
                  </div>
                  
                  <div className={`p-4 rounded-2xl text-center ${currentStreak >= 30 ? 'bg-gradient-to-br from-purple-400 to-pink-500 text-white' : 'bg-gray-100 dark:bg-gray-700 text-gray-400'}`}>
                    <div className="text-2xl mb-2">💎</div>
                    <div className="text-xs font-semibold">Diamond</div>
                    <div className="text-xs opacity-80">30 day streak</div>
                  </div>
                  
                  <div className={`p-4 rounded-2xl text-center ${monthlyStats.avg >= 80 ? 'bg-gradient-to-br from-green-400 to-emerald-500 text-white' : 'bg-gray-100 dark:bg-gray-700 text-gray-400'}`}>
                    <div className="text-2xl mb-2">⭐</div>
                    <div className="text-xs font-semibold">Superstar</div>
                    <div className="text-xs opacity-80">80+ avg score</div>
                  </div>
                  
                  <div className={`p-4 rounded-2xl text-center ${monthlyStats.best >= 95 ? 'bg-gradient-to-br from-blue-400 to-cyan-500 text-white' : 'bg-gray-100 dark:bg-gray-700 text-gray-400'}`}>
                    <div className="text-2xl mb-2">🚀</div>
                    <div className="text-xs font-semibold">Perfectionist</div>
                    <div className="text-xs opacity-80">95+ best score</div>
                  </div>
                  
                  {/* Workout Achievements */}
                  <div className={`p-4 rounded-2xl text-center ${totalWorkouts >= 10 ? 'bg-gradient-to-br from-indigo-400 to-blue-500 text-white' : 'bg-gray-100 dark:bg-gray-700 text-gray-400'}`}>
                    <div className="text-2xl mb-2">💪</div>
                    <div className="text-xs font-semibold">Fitness Starter</div>
                    <div className="text-xs opacity-80">10 workouts</div>
                  </div>
                  
                  <div className={`p-4 rounded-2xl text-center ${workoutStreak >= 5 ? 'bg-gradient-to-br from-red-400 to-pink-500 text-white' : 'bg-gray-100 dark:bg-gray-700 text-gray-400'}`}>
                    <div className="text-2xl mb-2">🏃</div>
                    <div className="text-xs font-semibold">Consistent</div>
                    <div className="text-xs opacity-80">5 workout streak</div>
                  </div>
                  
                  <div className={`p-4 rounded-2xl text-center ${avgCompletionRate >= 90 ? 'bg-gradient-to-br from-emerald-400 to-teal-500 text-white' : 'bg-gray-100 dark:bg-gray-700 text-gray-400'}`}>
                    <div className="text-2xl mb-2">🎯</div>
                    <div className="text-xs font-semibold">Finisher</div>
                    <div className="text-xs opacity-80">90% completion</div>
                  </div>
                  
                  <div className={`p-4 rounded-2xl text-center ${totalWorkoutTime >= 600 ? 'bg-gradient-to-br from-amber-400 to-yellow-500 text-white' : 'bg-gray-100 dark:bg-gray-700 text-gray-400'}`}>
                    <div className="text-2xl mb-2">⏰</div>
                    <div className="text-xs font-semibold">Time Master</div>
                    <div className="text-xs opacity-80">10+ hours total workout time</div>
                  </div>
                </div>
              );
            })()}
          </div>

          {/* Health Score Info */}
          <div className="mt-8 bg-gradient-to-r from-indigo-500/10 to-purple-500/10 dark:from-indigo-500/5 dark:to-purple-500/5 p-6 rounded-3xl border border-indigo-200/50 dark:border-indigo-700/50">
            <h3 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-3 flex items-center">
              <span className="mr-2">🧮</span>
              Health Score Formula
            </h3>
            <div className="grid grid-cols-1 md:grid-cols-4 gap-4 text-center">
              <div className="bg-white/50 dark:bg-gray-800/50 p-4 rounded-2xl">
                <div className="text-2xl font-bold text-pink-500 mb-1">40%</div>
                <div className="text-sm font-semibold text-gray-700 dark:text-gray-300">Nutrition</div>
                <div className="text-xs text-gray-600 dark:text-gray-400">25% Calories + 5% Protein + 5% Carbs + 5% Fat</div>
              </div>
              
              <div className="bg-white/50 dark:bg-gray-800/50 p-4 rounded-2xl">
                <div className="text-2xl font-bold text-purple-500 mb-1">15%</div>
                <div className="text-sm font-semibold text-gray-700 dark:text-gray-300">Activity</div>
                <div className="text-xs text-gray-600 dark:text-gray-400">10m=5, 20m=10, 30m+=15 (cap)</div>
              </div>
              
              <div className="bg-white/50 dark:bg-gray-800/50 p-4 rounded-2xl">
                <div className="text-2xl font-bold text-indigo-500 mb-1">30%</div>
                <div className="text-sm font-semibold text-gray-700 dark:text-gray-300">Workout</div>
                <div className="text-xs text-gray-600 dark:text-gray-400">1 pt per 10% completion (max 10/workout), cap 30/day</div>
              </div>
              
              <div className="bg-white/50 dark:bg-gray-800/50 p-4 rounded-2xl">
                <div className="text-2xl font-bold text-blue-500 mb-1">15%</div>
                <div className="text-sm font-semibold text-gray-700 dark:text-gray-300">Hydration</div>
                <div className="text-xs text-gray-600 dark:text-gray-400">Water intake (1 glass ≈ 250 ml)</div>
              </div>

            </div>
          </div>
            </>
          )}

          {activeTab === 'habits' && (
            <div className="space-y-8">
              {/* Habit Tracker Content */}
              <div className="bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm p-6 rounded-3xl shadow-xl border border-white/20">
                <h3 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-4 flex items-center">
                  <span className="mr-2">✅</span>
                  My Habits
                </h3>
                
                {/* Add New Habit */}
                <div className="flex mb-6">
                  <input 
                    type="text" 
                    value={newHabit}
                    onChange={(e) => setNewHabit(e.target.value)}
                    placeholder="Add a new habit..."
                    className="flex-grow p-3 rounded-l-xl border border-gray-200 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 focus:outline-none focus:ring-2 focus:ring-purple-500"
                  />
                  <button 
                    onClick={() => {
                      if (newHabit.trim()) {
                        setHabits([...habits, {
                          id: Date.now().toString(),
                          name: newHabit.trim(),
                          streak: 0,
                          completed: {},
                          created: new Date().toISOString()
                        }]);
                        setNewHabit('');
                      }
                    }}
                    className="bg-gradient-to-r from-purple-500 to-pink-500 text-white font-bold p-3 rounded-r-xl hover:from-purple-600 hover:to-pink-600 transition-all duration-200"
                  >
                    Add
                  </button>
                </div>
                
                {/* Habits List */}
                <div className="space-y-4 max-h-96 overflow-y-auto">
                  {habits.length === 0 ? (
                    <div className="text-center p-8 text-gray-500 dark:text-gray-400">
                      <div className="text-4xl mb-2">🌱</div>
                      <p>No habits yet. Add your first habit to start tracking!</p>
                    </div>
                  ) : (
                    habits.map(habit => {
                      const today = new Date().toISOString().split('T')[0];
                      const isCompletedToday = habit.completed && habit.completed[today];
                      
                      return (
                        <div key={habit.id} className="bg-white dark:bg-gray-700 rounded-2xl p-4 shadow-md border border-gray-100 dark:border-gray-600">
                          <div className="flex items-center justify-between">
                            <div className="flex items-center">
                              <button 
                                onClick={() => {
                                  const updatedHabits = habits.map(h => {
                                    if (h.id === habit.id) {
                                      const completed = {...h.completed};
                                      const wasCompleted = completed[today];
                                      
                                      if (completed[today]) {
                                        delete completed[today];
                                      } else {
                                        completed[today] = true;
                                      }
                                      
                                      // Note: Auto-sync with dailyIntake would require passing setDailyIntake as prop
                                      // This functionality is commented out to avoid prop drilling
                                      // if (!wasCompleted && (h.name.toLowerCase().includes('cardio') || h.name.toLowerCase().includes('exercise') || h.name.toLowerCase().includes('workout') || h.name.toLowerCase().includes('run') || h.name.toLowerCase().includes('walk') || h.name.toLowerCase().includes('gym'))) {
                                      //   const minutes = parseInt(h.name.match(/\d+/)?.[0]) || 30;
                                      //   setDailyIntake(prev => ({ ...prev, activity: prev.activity + minutes }));
                                      // }
                                      // if (!wasCompleted && h.name.toLowerCase().includes('water')) {
                                      //   const glasses = parseInt(h.name.match(/\d+/)?.[0]) || 1;
                                      //   setDailyIntake(prev => ({ ...prev, water: prev.water + glasses }));
                                      // }
                                      
                                      // Calculate streak
                                      let streak = 0;
                                      let currentDate = new Date();
                                      
                                      while (true) {
                                        const dateStr = currentDate.toISOString().split('T')[0];
                                        if (completed[dateStr]) {
                                          streak++;
                                          currentDate.setDate(currentDate.getDate() - 1);
                                        } else {
                                          break;
                                        }
                                      }
                                      
                                      return {...h, completed, streak};
                                    }
                                    return h;
                                  });
                                  
                                  setHabits(updatedHabits);
                                }}
                                className={`w-8 h-8 rounded-lg mr-3 flex items-center justify-center transition-all duration-200 ${isCompletedToday ? 'bg-gradient-to-r from-green-400 to-emerald-500 text-white' : 'bg-gray-100 dark:bg-gray-600 text-gray-400 dark:text-gray-500'}`}
                              >
                                {isCompletedToday ? '✓' : ''}
                              </button>
                              <div>
                                <h4 className="font-semibold text-gray-800 dark:text-gray-200">{habit.name}</h4>
                                <div className="text-xs text-gray-500 dark:text-gray-400 flex items-center">
                                  <span className="mr-2">🔥</span>
                                  <span>{habit.streak} day streak</span>
                                </div>
                              </div>
                            </div>
                            <button 
                              onClick={() => {
                                setHabits(habits.filter(h => h.id !== habit.id));
                              }}
                              className="text-gray-400 hover:text-red-500 transition-colors duration-200"
                            >
                              ×
                            </button>
                          </div>
                        </div>
                      );
                    })
                  )}
                </div>
              </div>
              
              {/* AI Habit Coach */}
              <div className="bg-gradient-to-r from-blue-500/10 to-purple-500/10 dark:from-blue-500/5 dark:to-purple-500/5 p-6 rounded-3xl border border-blue-200/50 dark:border-blue-700/50">
                <h3 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-4 flex items-center">
                  <span className="mr-2">🤖</span>
                  AI Habit Coach
                </h3>
                
                <div className="bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm p-4 rounded-2xl mb-4">
                  {habitAIAdvice ? (
                    <div className="text-gray-800 dark:text-gray-200">
                      {habitAIAdvice}
                    </div>
                  ) : (
                    <div className="text-center p-4 text-gray-500 dark:text-gray-400">
                      <p>Ask for habit recommendations or insights</p>
                    </div>
                  )}
                </div>
                
                <div className="flex">
                  <button 
                    onClick={async () => {
                      setIsLoadingAdvice(true);
                      try {
                        // Get habits data for context
                        const habitsContext = habits.map(h => `${h.name} (${h.streak} day streak)`);

                        // Consolidate hydration: combine dashboard water with completed water habit for today
                        const _today = new Date().toISOString().split('T')[0];
                        const waterHabitGlasses = habits.reduce((max, h) => {
                          const isWater = /\b(drink)?\s*\d+\s*(glass|glasses)\s*of\s*water\b|\bwater\b|\bhydrate\b/i.test(h.name);
                          const doneToday = h.completed && h.completed[_today];
                          if (!isWater || !doneToday) return max;
                          const m = h.name.match(/(\d+)\s*(glass|glasses)/i);
                          const g = m ? parseInt(m[1], 10) : 0;
                          return Math.max(max, g);
                        }, 0);
                        const effectiveWater = Math.max(dailyIntake.water || 0, waterHabitGlasses || 0);
                        
                        // Consolidate activity: include completed activity habit for today
                        const _todayAct = new Date().toISOString().split('T')[0];
                        const activityHabitMins = habits.reduce((max, h) => {
                          const isAct = /(cardio|exercise|workout|run|walk|gym)/i.test(h.name || '');
                          const done = h.completed && h.completed[_todayAct];
                          if (!isAct || !done) return max;
                          const m = (h.name || '').match(/(\d+)\s*(min|mins|minutes)/i) || (h.name || '').match(/(\d+)/);
                          const mins = m ? parseInt(m[1], 10) : 30;
                          return Math.max(max, mins);
                        }, 0);
                        const effectiveActivity = Math.max(dailyIntake.activity || 0, activityHabitMins || 0);

                        // Create prompt for the AI
                        let prompt = `You are an AI Habit Coach with comprehensive knowledge of the FitMate app. Analyze user data and provide smart recommendations using all app features.

**HABIT STATUS TODAY:**
${habits.map(habit => {
  const today = new Date().toISOString().split('T')[0];
  const isCompleted = habit.completed && habit.completed[today];
  return `• ${habit.name}: ${isCompleted ? '✅ COMPLETED' : '❌ NOT DONE'} (${habit.streak}d streak)`;
}).join('\n')}

**DAILY PROGRESS:**
• Calories: ${dailyIntake.calories}/${goals.calories} (${((dailyIntake.calories / goals.calories) * 100).toFixed(0)}%)
• Protein: ${dailyIntake.protein}g/${goals.protein}g (${((dailyIntake.protein / goals.protein) * 100).toFixed(0)}%)
• Activity: ${Math.min(effectiveActivity, goals.activity)}/${goals.activity}min (${Math.min(100, ((effectiveActivity / goals.activity) * 100)).toFixed(0)}%)
• Water: ${Math.min(effectiveWater, goals.water)}/${goals.water} glasses (${Math.min(100, ((effectiveWater / goals.water) * 100)).toFixed(0)}%)

**APP FEATURES TO REFERENCE:**
📊 Dashboard: Track progress and view health score
🔍 Food Scanner: Log meals accurately with portion sizes
🏋️ Workout Planner: Access 15+ exercises with video guides
🍽️ Meal Planner: Generate recipes and scan pantry items
👤 Profile: Adjust goals and manage preferences
🤖 AI Coaches: Get form tips and personalized guidance

**INSTRUCTIONS:**
1. If habits are completed today, congratulate and suggest app features to maintain momentum
2. If habits are incomplete, recommend specific app screens/features to help complete them
3. For nutrition goals, suggest Food Scanner for accurate tracking
4. For activity goals, recommend Workout Planner with specific exercises
5. Reference actual app features users can access immediately

**FORMAT (exactly 4 lines, max 120 chars total):**
🎯 [Focus area with app feature reference]
⚡ [Specific action using app screen/feature]
🔥 [App-based habit tip]
💪 [Motivation with feature suggestion]

**RULES:**
- Maximum 120 characters total across all 4 lines
- Reference specific app screens when relevant (Dashboard, Scanner, Workout, etc.)
- Acknowledge completed habits positively
- Guide users to appropriate app features for improvement
- Use actual percentages and app-specific recommendations`;
                        
                        // Call the AI API
                        const response = await fetch(getDirectGeminiConfig().url, {
                          method: 'POST',
                          headers: getDirectGeminiConfig().headers,
                          signal: AbortSignal.timeout(25000),
                          body: JSON.stringify({
                            model: OPENROUTER_QWEN_MODEL,
                            messages: [{ role: 'user', content: prompt }]
                          })
                        });
                        
                        if (!response.ok) {
                          let details = '';
                          try {
                            const errText = await response.text();
                            try { const errJson = JSON.parse(errText); details = errJson?.error?.message || errJson?.message || errText; } catch { details = errText; }
                          } catch {}
                          throw new Error(`OpenRouter API error (${response.status}): ${details}`);
                        }
                        
                        const result = await response.json();
                        const advice = (result.choices?.[0]?.message?.content || '');
                        setHabitAIAdvice(advice);
                      } catch (error) {
                        console.error("Failed to get habit recommendations:", error);
                        setHabitAIAdvice("Sorry, I couldn't generate recommendations right now. Please try again later.");
                      } finally {
                        setIsLoadingAdvice(false);
                      }
                    }}
                    disabled={isLoadingAdvice}
                    className="flex-grow bg-gradient-to-r from-blue-500 to-purple-500 text-white font-bold p-3 rounded-xl hover:from-blue-600 hover:to-purple-600 transition-all duration-200 disabled:opacity-50"
                  >
                    {isLoadingAdvice ? 'Thinking...' : 'Get AI Recommendations'}
                  </button>
                </div>
              </div>
              
              {/* Habit Statistics */}
              <div className="bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm p-6 rounded-3xl shadow-xl border border-white/20">
                <h3 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-4 flex items-center">
                  <span className="mr-2">📈</span>
                  Habit Statistics
                </h3>
                
                <div className="grid grid-cols-1 md:grid-cols-3 gap-4 text-center">
                  <div className="bg-gradient-to-br from-purple-500/10 to-pink-500/10 dark:from-purple-500/5 dark:to-pink-500/5 p-4 rounded-2xl">
                    <div className="text-2xl font-bold text-purple-500 mb-1">{habits.length}</div>
                    <div className="text-sm font-semibold text-gray-700 dark:text-gray-300">Active Habits</div>
                  </div>
                  <div className="bg-gradient-to-br from-blue-500/10 to-cyan-500/10 dark:from-blue-500/5 dark:to-cyan-500/5 p-4 rounded-2xl">
                    <div className="text-2xl font-bold text-blue-500 mb-1">
                      {habits.reduce((total, habit) => {
                        const today = new Date().toISOString().split('T')[0];
                        return total + (habit.completed && habit.completed[today] ? 1 : 0);
                      }, 0)}
                    </div>
                    <div className="text-sm font-semibold text-gray-700 dark:text-gray-300">Completed Today</div>
                  </div>
                  <div className="bg-gradient-to-br from-green-500/10 to-emerald-500/10 dark:from-green-500/5 dark:to-emerald-500/5 p-4 rounded-2xl">
                    <div className="text-2xl font-bold text-green-500 mb-1">
                      {habits.length > 0 ? Math.max(...habits.map(h => h.streak)) : 0}
                    </div>
                    <div className="text-sm font-semibold text-gray-700 dark:text-gray-300">Longest Streak</div>
                  </div>
                </div>
              </div>
            </div>
          )}

          {activeTab === 'stress' && (
            <div className="space-y-8">
              <div className="bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm p-6 rounded-3xl shadow-xl border border-white/20">
                <h3 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-4 flex items-center">
                  <span className="mr-2">🧠</span>
                  Stress Analyzer
                </h3>

                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div>
                    <label className="text-sm font-semibold text-gray-700 dark:text-gray-300">Sleep hours</label>
                    <input type="number" min="0" step="0.5" value={stressForm.sleepHours}
                      onChange={e=>setStressForm({...stressForm, sleepHours:e.target.value})}
                      className="w-full p-3 rounded-xl border border-gray-200 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 focus:outline-none focus:ring-2 focus:ring-purple-500" />
                  </div>
                  <div>
                    <label className="text-sm font-semibold text-gray-700 dark:text-gray-300">Work hours</label>
                    <input type="number" min="0" step="0.5" value={stressForm.workHours}
                      onChange={e=>setStressForm({...stressForm, workHours:e.target.value})}
                      className="w-full p-3 rounded-xl border border-gray-200 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 focus:outline-none focus:ring-2 focus:ring-purple-500" />
                  </div>
                  <div>
                    <label className="text-sm font-semibold text-gray-700 dark:text-gray-300">Self‑rated stress (1–10)</label>
                    <input type="number" min="1" max="10" value={stressForm.stressRating}
                      onChange={e=>setStressForm({...stressForm, stressRating: Number(e.target.value)})}
                      className="w-full p-3 rounded-xl border border-gray-200 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 focus:outline-none focus:ring-2 focus:ring-purple-500" />
                  </div>
                  <div>
                    <label className="text-sm font-semibold text-gray-700 dark:text-gray-300">Stress episodes (count)</label>
                    <input type="number" min="0" step="1" value={stressForm.stressEpisodes}
                      onChange={e=>setStressForm({...stressForm, stressEpisodes:e.target.value})}
                      className="w-full p-3 rounded-xl border border-gray-200 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 focus:outline-none focus:ring-2 focus:ring-purple-500" />
                  </div>
                  <div>
                    <label className="text-sm font-semibold text-gray-700 dark:text-gray-300">Exercise (mins)</label>
                    <input type="number" min="0" step="5" value={stressForm.exerciseMins}
                      onChange={e=>setStressForm({...stressForm, exerciseMins:e.target.value})}
                      className="w-full p-3 rounded-xl border border-gray-200 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 focus:outline-none focus:ring-2 focus:ring-purple-500" />
                  </div>
                  <div>
                    <label className="text-sm font-semibold text-gray-700 dark:text-gray-300">Meditation (mins)</label>
                    <input type="number" min="0" step="5" value={stressForm.meditationMins}
                      onChange={e=>setStressForm({...stressForm, meditationMins:e.target.value})}
                      className="w-full p-3 rounded-xl border border-gray-200 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 focus:outline-none focus:ring-2 focus:ring-purple-500" />
                  </div>
                  <div>
                    <label className="text-sm font-semibold text-gray-700 dark:text-gray-300">Social interaction (mins)</label>
                    <input type="number" min="0" step="5" value={stressForm.socialMins}
                      onChange={e=>setStressForm({...stressForm, socialMins:e.target.value})}
                      className="w-full p-3 rounded-xl border border-gray-200 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 focus:outline-none focus:ring-2 focus:ring-purple-500" />
                  </div>
                  <div>
                    <label className="text-sm font-semibold text-gray-700 dark:text-gray-300">Screen time (hours)</label>
                    <input type="number" min="0" step="0.5" value={stressForm.screenHours}
                      onChange={e=>setStressForm({...stressForm, screenHours:e.target.value})}
                      className="w-full p-3 rounded-xl border border-gray-200 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 focus:outline-none focus:ring-2 focus:ring-purple-500" />
                  </div>
                  <div>
                    <label className="text-sm font-semibold text-gray-700 dark:text-gray-300">Life event</label>
                    <div className="flex items-center gap-3">
                      <select value={stressForm.lifeEvent}
                        onChange={e=>setStressForm({...stressForm, lifeEvent:e.target.value})}
                        className="flex-1 p-3 rounded-xl border border-gray-200 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 focus:outline-none focus:ring-2 focus:ring-purple-500">
                        <option value="none">None</option>
                        <option value="minor">Minor</option>
                        <option value="major">Major</option>
                      </select>
                      <span className="text-xs text-gray-600 dark:text-gray-400">
                        Amplifies stress: None 1.0×, Minor 1.5×, Major 2.0×
                        <span
                          className="ml-2 inline-flex items-center text-gray-500 dark:text-gray-400 cursor-help select-none"
                          title={
                            'What counts as a life event?\n' +
                            '• None: regular day, routine changes.\n' +
                            '• Minor: exam week, tight deadline, travel, minor illness, brief conflict.\n' +
                            '• Major: bereavement, job loss, breakup/divorce, serious illness, major financial or safety crisis.'
                          }
                        >
                          ⓘ
                        </span>
                      </span>
                    </div>
                  </div>
                  
                </div>

                <div className="flex mt-4">
                  <button
                    onClick={() => { const r = computeStressScore(stressForm); setStressResult(r); setStressInsight(generateStressInsight(r, stressForm)); }}
                    className="flex-grow bg-gradient-to-r from-purple-500 to-pink-500 text-white font-bold p-3 rounded-xl hover:from-purple-600 hover:to-pink-600 transition-all duration-200">
                    Compute Stress Score
                  </button>
                </div>
              </div>

              {stressResult && (
                <div className="bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm p-6 rounded-3xl shadow-xl border border-white/20">
                  <div className="flex items-center justify-between mb-4">
                    <div className={`w-20 h-20 bg-gradient-to-br ${stressResult.stressScore >= 70 ? 'from-red-500 to-red-600' : (stressResult.stressScore >= 35 ? 'from-yellow-400 to-orange-500' : 'from-emerald-400 to-green-600')} rounded-3xl flex items-center justify-center text-white font-bold text-2xl shadow-lg`}>
                      {stressResult.stressScore}
                    </div>
                    <div className="text-right">
                      <div className="text-2xl font-bold text-gray-800 dark:text-gray-200">{stressResult.category}</div>
                      <div className="text-sm text-gray-600 dark:text-gray-400">Confidence {stressResult.confidence}%</div>
                      {stressResult.lifeEventMultiplier > 1.0 && (
                        <div className="text-xs text-orange-600 dark:text-orange-400 mt-1">Life event: {stressResult.lifeEventMultiplier}× amplifier</div>
                      )}
                    </div>
                  </div>

                  <div className="grid grid-cols-1 md:grid-cols-2 gap-3 mb-2">
                    {/* Sleep Driver */}
                    <div className="p-3 bg-gray-50 dark:bg-gray-700 rounded-xl">
                      <div className="flex justify-between items-center mb-1">
                        <div className="text-xs font-semibold text-gray-500 dark:text-gray-400">Sleep Quality (25%)</div>
                        <div className="text-lg font-bold text-pink-600 dark:text-pink-400">{stressResult.breakdown.drivers.sleep}/25</div>
                      </div>
                      <div className="w-full bg-gray-200 dark:bg-gray-600 rounded-full h-2 mb-1">
                        <div className="bg-gradient-to-r from-pink-400 to-pink-600 h-2 rounded-full" style={{width: `${Math.min(100, (stressResult.breakdown.drivers.sleep / 25) * 100)}%`}}></div>
                      </div>
                      <div className="text-xs text-gray-600 dark:text-gray-400">Deviation from 8h optimal sleep</div>
                    </div>

                    {/* Work Driver */}
                    <div className="p-3 bg-gray-50 dark:bg-gray-700 rounded-xl">
                      <div className="flex justify-between items-center mb-1">
                        <div className="text-xs font-semibold text-gray-500 dark:text-gray-400">Work Hours (20%)</div>
                        <div className="text-lg font-bold text-purple-600 dark:text-purple-400">{stressResult.breakdown.drivers.work}/20</div>
                      </div>
                      <div className="w-full bg-gray-200 dark:bg-gray-600 rounded-full h-2 mb-1">
                        <div className="bg-gradient-to-r from-purple-400 to-purple-600 h-2 rounded-full" style={{width: `${Math.min(100, (stressResult.breakdown.drivers.work / 20) * 100)}%`}}></div>
                      </div>
                      <div className="text-xs text-gray-600 dark:text-gray-400">Higher work hours increase stress</div>
                    </div>

                    {/* Self-rating + Episodes Group */}
                    <div className="p-3 bg-gradient-to-br from-indigo-50 to-orange-50 dark:from-indigo-900/20 dark:to-orange-900/20 rounded-xl border border-indigo-200 dark:border-indigo-700">
                      <div className="text-xs font-bold text-gray-700 dark:text-gray-300 mb-2">Psychological (20%)</div>
                      
                      <div className="mb-2">
                        <div className="flex justify-between items-center mb-1">
                          <div className="text-xs text-gray-600 dark:text-gray-400">Self‑rating (12%)</div>
                          <div className="text-sm font-bold text-indigo-600 dark:text-indigo-400">{stressResult.breakdown.drivers.selfRating}/12</div>
                        </div>
                        <div className="w-full bg-gray-200 dark:bg-gray-600 rounded-full h-1.5">
                          <div className="bg-gradient-to-r from-indigo-400 to-indigo-600 h-1.5 rounded-full" style={{width: `${Math.min(100, (stressResult.breakdown.drivers.selfRating / 12) * 100)}%`}}></div>
                        </div>
                      </div>

                      <div>
                        <div className="flex justify-between items-center mb-1">
                          <div className="text-xs text-gray-600 dark:text-gray-400">Episodes (8%)</div>
                          <div className="text-sm font-bold text-orange-600 dark:text-orange-400">{stressResult.breakdown.drivers.episodes}/8</div>
                        </div>
                        <div className="w-full bg-gray-200 dark:bg-gray-600 rounded-full h-1.5">
                          <div className="bg-gradient-to-r from-orange-400 to-orange-600 h-1.5 rounded-full" style={{width: `${Math.min(100, (stressResult.breakdown.drivers.episodes / 8) * 100)}%`}}></div>
                        </div>
                      </div>
                      
                      <div className="text-xs text-gray-600 dark:text-gray-400 mt-2">How you feel + stress events</div>
                    </div>

                    {/* Screen Driver */}
                    <div className="p-3 bg-gray-50 dark:bg-gray-700 rounded-xl">
                      <div className="flex justify-between items-center mb-1">
                        <div className="text-xs font-semibold text-gray-500 dark:text-gray-400">Screen Time (10%)</div>
                        <div className="text-lg font-bold text-blue-600 dark:text-blue-400">{stressResult.breakdown.drivers.screen}/10</div>
                      </div>
                      <div className="w-full bg-gray-200 dark:bg-gray-600 rounded-full h-2 mb-1">
                        <div className="bg-gradient-to-r from-blue-400 to-blue-600 h-2 rounded-full" style={{width: `${Math.min(100, (stressResult.breakdown.drivers.screen / 10) * 100)}%`}}></div>
                      </div>
                      <div className="text-xs text-gray-600 dark:text-gray-400">Excessive screen use adds stress</div>
                    </div>
                  </div>

                  <div className="text-xs font-bold text-gray-700 dark:text-gray-300 mb-2">Protective Buffers (higher = more stress reduction)</div>
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-3 mb-4">
                    {/* Exercise + Meditation Group */}
                    <div className="p-3 bg-gradient-to-br from-emerald-50 to-teal-50 dark:from-emerald-900/20 dark:to-teal-900/20 rounded-xl border border-emerald-200 dark:border-emerald-700">
                      <div className="text-xs font-bold text-gray-700 dark:text-gray-300 mb-2">Wellness Activities (20%)</div>
                      
                      <div className="mb-2">
                        <div className="flex justify-between items-center mb-1">
                          <div className="text-xs text-gray-600 dark:text-gray-400">Exercise (15%)</div>
                          <div className="text-sm font-bold text-emerald-600 dark:text-emerald-400">{stressResult.breakdown.buffers.exercise}/15</div>
                        </div>
                        <div className="w-full bg-gray-200 dark:bg-gray-600 rounded-full h-1.5">
                          <div className="bg-gradient-to-r from-emerald-400 to-emerald-600 h-1.5 rounded-full" style={{width: `${Math.min(100, (stressResult.breakdown.buffers.exercise / 15) * 100)}%`}}></div>
                        </div>
                      </div>

                      <div>
                        <div className="flex justify-between items-center mb-1">
                          <div className="text-xs text-gray-600 dark:text-gray-400">Meditation (5%)</div>
                          <div className="text-sm font-bold text-teal-600 dark:text-teal-400">{stressResult.breakdown.buffers.meditation}/5</div>
                        </div>
                        <div className="w-full bg-gray-200 dark:bg-gray-600 rounded-full h-1.5">
                          <div className="bg-gradient-to-r from-teal-400 to-teal-600 h-1.5 rounded-full" style={{width: `${Math.min(100, (stressResult.breakdown.buffers.meditation / 5) * 100)}%`}}></div>
                        </div>
                      </div>
                      
                      <div className="text-xs text-gray-600 dark:text-gray-400 mt-2">Higher values reduce stress</div>
                    </div>

                    {/* Social Buffer */}
                    <div className="p-3 bg-gray-50 dark:bg-gray-700 rounded-xl">
                      <div className="flex justify-between items-center mb-1">
                        <div className="text-xs font-semibold text-gray-500 dark:text-gray-400">Social Connection (5%)</div>
                        <div className="text-lg font-bold text-emerald-600 dark:text-emerald-400">{stressResult.breakdown.buffers.social}/5</div>
                      </div>
                      <div className="w-full bg-gray-200 dark:bg-gray-600 rounded-full h-2 mb-1">
                        <div className="bg-gradient-to-r from-emerald-400 to-green-600 h-2 rounded-full" style={{width: `${Math.min(100, (stressResult.breakdown.buffers.social / 5) * 100)}%`}}></div>
                      </div>
                      <div className="text-xs text-gray-600 dark:text-gray-400">Quality time with others buffers stress</div>
                    </div>
                  </div>

                  {stressInsight && (
                    <div className="bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm p-4 rounded-2xl text-gray-800 dark:text-gray-200">
                      {stressInsight}
                    </div>
                  )}
                </div>
              )}
            </div>
          )}

          {/* Day Detail Modal */}
          {selectedDay && (
            <div className="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center p-4 z-50 animate-fade-in" onClick={() => setSelectedDay(null)}>
              <div className="bg-white dark:bg-gray-800 p-4 sm:p-6 md:p-8 rounded-3xl shadow-2xl max-w-md w-full max-h-[90vh] overflow-y-auto transform transition-all duration-300 scale-100" onClick={e => e.stopPropagation()}>
                <div className="text-center mb-6">
                  <div className={`w-20 h-20 bg-gradient-to-br ${getScoreColor(selectedDay.score)} rounded-3xl flex items-center justify-center text-white font-bold text-2xl mx-auto mb-4 shadow-lg ${getScoreGlow(selectedDay.score)}`}>
                    {selectedDay.score}
                  </div>
                  <h3 className="text-2xl font-bold text-gray-800 dark:text-gray-200 mb-2">
                    {new Date(selectedDay.date).toLocaleDateString('en-US', { 
                      weekday: 'long', 
                      year: 'numeric', 
                      month: 'long', 
                      day: 'numeric' 
                    })}
                  </h3>
                </div>
                
                {(() => {
                  // Derive components using stored breakdown or compute on the fly
                  const dateISO = selectedDay.date;
                  const comps = selectedDay.components || computeHealthScoreForDate(selectedDay.intake, goals, dateISO).components;
                  // Workout summary for this day
                  let numWorkouts = 0, avgCompletion = 0, totalTime = 0;
                  try {
                    const all = JSON.parse(localStorage.getItem('workoutHistory') || '[]');
                    const dayWorkouts = (Array.isArray(all) ? all : []).filter(w => {
                      try { return toLocalISODate(new Date(w.timestamp)) === dateISO; } catch { return false; }
                    });
                    numWorkouts = dayWorkouts.length;
                    if (numWorkouts > 0) {
                      avgCompletion = Math.round(dayWorkouts.reduce((s, w) => s + (Number(w.completionRate)||0), 0) / numWorkouts);
                      totalTime = dayWorkouts.reduce((s, w) => s + (Number(w.duration)||0), 0);
                    }
                  } catch {}
                  return (
                    <div className="mb-6">
                      <h4 className="font-bold text-gray-800 dark:text-gray-200 mb-3">How this score was calculated</h4>
                      <div className="grid grid-cols-2 gap-3">
                        <div className="p-3 bg-gray-50 dark:bg-gray-700 rounded-xl">
                          <div className="text-xs text-gray-500 dark:text-gray-400">Nutrition (40%)</div>
                          <div className="text-lg font-semibold text-pink-600 dark:text-pink-400">{comps.nutrition} pts</div>
                        </div>
                        <div className="p-3 bg-gray-50 dark:bg-gray-700 rounded-xl">
                          <div className="text-xs text-gray-500 dark:text-gray-400">Activity (15%)</div>
                          <div className="text-lg font-semibold text-purple-600 dark:text-purple-400">{comps.activity} pts</div>
                        </div>
                        <div className="p-3 bg-gray-50 dark:bg-gray-700 rounded-xl">
                          <div className="text-xs text-gray-500 dark:text-gray-400">Workout (30%)</div>
                          <div className="text-lg font-semibold text-indigo-600 dark:text-indigo-400">{comps.workout} pts</div>
                          {numWorkouts > 0 && (
                            <div className="text-xs text-gray-500 dark:text-gray-400 mt-1">{numWorkouts} workouts • {avgCompletion}% avg • {totalTime}m</div>
                          )}
                        </div>
                        <div className="p-3 bg-gray-50 dark:bg-gray-700 rounded-xl">
                          <div className="text-xs text-gray-500 dark:text-gray-400">Hydration (15%)</div>
                          <div className="text-lg font-semibold text-blue-600 dark:text-blue-400">{comps.hydration} pts</div>
                        </div>
                      </div>
                      <div className="text-xs text-gray-500 dark:text-gray-400 mt-2">
                        Scoring: Activity 10m=5, 20m=10, 30m+=15 (cap 15). Workouts 1 pt per 10% completion (max 10/workout), cap 30/day; Hydration 15.
                      </div>
                    </div>
                  );
                })()}

                <div className="space-y-4 mb-6">
                  <div className="flex justify-between items-center p-3 bg-gray-50 dark:bg-gray-700 rounded-2xl">
                    <span className="font-semibold text-gray-700 dark:text-gray-300">🍽️ Calories</span>
                    <span className="font-bold text-gray-800 dark:text-gray-200">{selectedDay.intake.calories.toFixed(0)}</span>
                  </div>
                  <div className="flex justify-between items-center p-3 bg-gray-50 dark:bg-gray-700 rounded-2xl">
                    <span className="font-semibold text-gray-700 dark:text-gray-300">🏃 Activity</span>
                    <span className="font-bold text-gray-800 dark:text-gray-200">{selectedDay.intake.activity} mins</span>
                  </div>
                  <div className="flex justify-between items-center p-3 bg-gray-50 dark:bg-gray-700 rounded-2xl">
                    <span className="font-semibold text-gray-700 dark:text-gray-300">💧 Water</span>
                    <span className="font-bold text-gray-800 dark:text-gray-200">{selectedDay.intake.water} glasses</span>
                  </div>
                </div>
                
                {selectedDay.meals && selectedDay.meals.length > 0 && (
                  <div className="mb-6">
                    <h4 className="font-bold text-gray-800 dark:text-gray-200 mb-3 flex items-center">
                      <span className="mr-2">🍽️</span>
                      Meals
                    </h4>
                    <div className="space-y-2 max-h-32 overflow-y-auto">
                      {selectedDay.meals.map(m => (
                        <div key={m.id} className="p-2 bg-gray-50 dark:bg-gray-700 rounded-xl text-sm text-gray-700 dark:text-gray-300">
                          {m.name}
                        </div>
                      ))}
                    </div>
                  </div>
                )}
                
                <button 
                  onClick={() => setSelectedDay(null)} 
                  className="w-full bg-gradient-to-r from-purple-500 to-pink-500 text-white font-bold py-4 rounded-2xl hover:from-purple-600 hover:to-pink-600 transition-all duration-200 transform hover:scale-105 shadow-lg"
                >
                  Close
                </button>
              </div>
            </div>
          )}
        </div>
      );
    };

    // --- Helper Components ---

    // Activity Timer Component (for Dashboard) - persistent across navigation/reloads
    const ActivityTimer = ({ onLogActivity }) => {
      const STORAGE_KEY = 'activityTimerState';
      const [timeLeft, setTimeLeft] = useState(0);
      const [isActive, setIsActive] = useState(false);
      const [duration, setDuration] = useState(0); // in minutes
      const [startedAt, setStartedAt] = useState(null); // epoch ms
      const [pendingMins, setPendingMins] = useState(0);
      const timerRef = useRef(null);

      // Recalculate timer state from startedAt (used on mount and when returning from background)
      const recalculateTimer = useCallback(() => {
        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          if (!raw) return;
          const st = JSON.parse(raw);
          if (!st || !st.isActive) return;

          const todayISO = toLocalISODate(new Date());
          if (st.intakeDate && st.intakeDate !== todayISO) {
            // Timer belongs to a previous day; drop it
            localStorage.removeItem(STORAGE_KEY);
            return;
          }

          const now = Date.now();
          const elapsed = Math.floor((now - Number(st.startedAt || now)) / 1000);
          const remaining = Math.max(0, Number(st.durationSec || 0) - elapsed);

          if (remaining > 0) {
            setIsActive(true);
            setDuration(Math.round((st.durationSec || 0) / 60));
            setStartedAt(Number(st.startedAt));
            setTimeLeft(remaining);
          } else {
            // Completed while away — require user confirmation to log
            const mins = Math.round((st.durationSec || 0) / 60);
            localStorage.setItem(
              STORAGE_KEY,
              JSON.stringify({ ...st, isActive: false, logged: false, pendingMinutes: mins, pendingDate: todayISO, completedAt: now })
            );
            setPendingMins(mins);
            try {
              if ('Notification' in window && Notification.permission === 'granted') {
                new Notification('Activity Complete!', { body: `Session finished. Confirm to log ${mins} min.` });
              }
            } catch (_) {}
            setIsActive(false);
          }
        } catch (_) {}
      }, [onLogActivity]);

      // Hydrate from storage on mount
      useEffect(() => {
        recalculateTimer();
      }, [recalculateTimer]);

      // Recalculate when returning from background/sleep
      useEffect(() => {
        const handleVisibilityChange = () => {
          if (!document.hidden) {
            recalculateTimer();
          }
        };
        document.addEventListener('visibilitychange', handleVisibilityChange);
        return () => document.removeEventListener('visibilitychange', handleVisibilityChange);
      }, [recalculateTimer]);

      // Tick effect
      useEffect(() => {
        if (timeLeft > 0 && isActive) {
          timerRef.current = setTimeout(() => setTimeLeft((t) => t - 1), 1000);
        } else if (timeLeft === 0 && isActive) {
          // Finish — require confirmation to log
          const mins = duration;
          setIsActive(false);
          try {
            const todayISO = toLocalISODate(new Date());
            const st = JSON.parse(localStorage.getItem(STORAGE_KEY) || 'null') || {};
            localStorage.setItem(
              STORAGE_KEY,
              JSON.stringify({ ...st, isActive: false, logged: false, pendingMinutes: mins, pendingDate: todayISO, completedAt: Date.now() })
            );
          } catch (_) {}
          setPendingMins(mins);
          if ('Notification' in window && Notification.permission === 'granted') {
            try { new Notification('Activity Complete!', { body: `Session finished. Confirm to log ${mins} min.` }); } catch (_) {}
          }
        }
        return () => clearTimeout(timerRef.current);
      }, [timeLeft, isActive, duration, onLogActivity]);

      const startTimer = (minutes) => {
        const durSec = minutes * 60;
        const now = Date.now();
        const todayISO = toLocalISODate(new Date());
        setTimeLeft(durSec);
        setDuration(minutes);
        setIsActive(true);
        setStartedAt(now);
        // Persist start so it survives navigation/reload
        try {
          localStorage.setItem(STORAGE_KEY, JSON.stringify({
            isActive: true,
            startedAt: now,
            durationSec: durSec,
            intakeDate: todayISO,
            logged: false
          }));
        } catch (_) {}
      };

      const confirmPending = () => {
        const now = Date.now();
        try {
          const st = JSON.parse(localStorage.getItem(STORAGE_KEY) || 'null') || {};
          const mins = Number(st.pendingMinutes || pendingMins || 0);
          if (mins > 0) {
            onLogActivity({ minutes: mins });
          }
          localStorage.setItem(STORAGE_KEY, JSON.stringify({ ...st, isActive: false, logged: true, pendingMinutes: 0, completedAt: now }));
        } catch (_) {}
        setPendingMins(0);
      };

      const dismissPending = () => {
        const now = Date.now();
        try {
          const st = JSON.parse(localStorage.getItem(STORAGE_KEY) || 'null') || {};
          localStorage.setItem(STORAGE_KEY, JSON.stringify({ ...st, isActive: false, logged: true, pendingMinutes: 0, completedAt: now }));
        } catch (_) {}
        setPendingMins(0);
      };

      const formatTime = (seconds) => {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins}:${secs < 10 ? '0' : ''}${secs}`;
      };

      if (isActive) {
        return <div className="text-center font-bold text-3xl text-pink-500">{formatTime(timeLeft)}</div>;
      }

      return (
        <div className="space-y-2">
          {pendingMins > 0 && (
            <div className="p-3 bg-yellow-100 dark:bg-yellow-900 rounded-lg flex items-center justify-between">
              <span className="text-sm font-semibold text-gray-800 dark:text-gray-200">Log {pendingMins} min activity?</span>
              <div className="space-x-2">
                <button onClick={confirmPending} className="px-3 py-1 bg-green-600 hover:bg-green-700 text-white rounded-lg">Log</button>
                <button onClick={dismissPending} className="px-3 py-1 bg-gray-300 dark:bg-gray-600 text-gray-800 dark:text-gray-200 rounded-lg">Dismiss</button>
              </div>
            </div>
          )}
          <p className="font-semibold text-gray-800 dark:text-gray-200 text-center">Start a quick session:</p>
          <div className="grid grid-cols-3 gap-2">
            <button onClick={() => startTimer(10)} className="p-2 bg-pink-500 text-white rounded-lg">10 min</button>
            <button onClick={() => startTimer(20)} className="p-2 bg-pink-500 text-white rounded-lg">20 min</button>
            <button onClick={() => startTimer(30)} className="p-2 bg-pink-500 text-white rounded-lg">30 min</button>
          </div>
        </div>
      );
    };

    // Water Tracker Component (for Dashboard)
    const WaterTracker = ({ onLogWater, dailyIntake, goals }) => {
      useEffect(() => {
        const interval = setInterval(() => {
          if ('Notification' in window && Notification.permission === "granted") {
            new Notification("Stay Hydrated!", { body: "Time for a glass of water to keep you going." });
          }
        }, 2 * 60 * 60 * 1000); // Remind every 2 hours
        return () => clearInterval(interval);
      }, []);

      return (
        <div>
          <p className="font-semibold text-gray-800 dark:text-gray-200 text-center">Water Intake: {dailyIntake.water} / {goals.water} glasses</p>
          <button onClick={onLogWater} className="w-full mt-2 bg-blue-500 text-white font-bold py-2 rounded-xl">Log a Glass</button>
        </div>
      );
    };

    const MacroCard = ({ title, value, goal, unit, color }) => (
      <div className="bg-white dark:bg-gray-800 rounded-2xl p-4 flex flex-col items-center justify-center shadow-md">
        <p className={`font-bold ${color}`}>{title}</p>
        <p className="text-xl font-bold my-1 text-gray-800 dark:text-gray-200">{Math.round(value)}{unit}</p>
        <p className="text-xs text-gray-500 dark:text-gray-400">Goal: {goal}{unit}</p>
      </div>
    );

    const MealCard = ({ meal }) => (
      <div className="flex items-center bg-white dark:bg-gray-800 rounded-2xl p-3 shadow-md">
        <img src={meal.image} alt={meal.name} className="w-16 h-16 rounded-lg" />
        <div className="ml-4 flex-grow">
          <p className="font-bold text-gray-800 dark:text-gray-200">{meal.name}</p>
          <p className="text-gray-500 dark:text-gray-400">{Math.round(meal.calories)} kcal</p>
        </div>
        {meal.mood && (
          <span className="text-3xl">{{ Energized: '⚡️', Happy: '😊', Sluggish: '😴', Bloated: '🤢' }[meal.mood]}</span>
        )}
      </div>
    );

    const GoalItem = ({ label, value }) => (
      <div className="flex justify-between items-center p-2">
        <p className="text-gray-600 dark:text-gray-300">{label}</p>
        <p className="font-bold text-gray-800 dark:text-gray-200">{value}</p>
      </div>
    );

    const SettingItem = ({ label }) => (
      <button className="w-full text-left p-3 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-300 transition-colors">
        {label}
      </button>
    );

    const MealPlanDisplay = ({ mealPlan }) => {
      return (
        <div className="space-y-8">
          {/* Breakfast Section */}
          <div className="bg-white dark:bg-gray-800 rounded-lg p-6 shadow-md">
            <h3 className="text-xl font-bold text-gray-800 dark:text-white mb-4">Breakfast: {mealPlan.breakfast.name}</h3>
            
            <div className="mb-4">
              <div className="flex items-center justify-between mb-2">
                <h4 className="font-semibold text-gray-700 dark:text-gray-300">Ingredients:</h4>
                <VoiceButton 
                  text={`Breakfast ingredients: ${mealPlan.breakfast.ingredients.join(', ')}`}
                  buttonId="breakfast-ingredients"
                  label="Ingredients"
                  className="ml-2"
                />
              </div>
              <ul className="list-disc list-inside text-gray-600 dark:text-gray-400">
                {mealPlan.breakfast.ingredients.map((ingredient, index) => (
                  <li key={index}>{ingredient}</li>
                ))}
              </ul>
            </div>
            
            <div>
              <div className="flex items-center justify-between mb-2">
                <h4 className="font-semibold text-gray-700 dark:text-gray-300">Instructions:</h4>
                <VoiceButton 
                  text={`Breakfast instructions: ${mealPlan.breakfast.instructions.join('. ')}`}
                  buttonId="breakfast-instructions"
                  label="Instructions"
                  className="ml-2"
                />
              </div>
              <ol className="list-decimal list-inside text-gray-600 dark:text-gray-400 space-y-1">
                {mealPlan.breakfast.instructions.map((instruction, index) => (
                  <li key={index}>{instruction}</li>
                ))}
              </ol>
            </div>
          </div>

          {/* Lunch Section */}
          <div className="bg-white dark:bg-gray-800 rounded-lg p-6 shadow-md">
            <h3 className="text-xl font-bold text-gray-800 dark:text-white mb-4">Lunch: {mealPlan.lunch.name}</h3>
            
            <div className="mb-4">
              <div className="flex items-center justify-between mb-2">
                <h4 className="font-semibold text-gray-700 dark:text-gray-300">Ingredients:</h4>
                <VoiceButton 
                  text={`Lunch ingredients: ${mealPlan.lunch.ingredients.join(', ')}`}
                  buttonId="lunch-ingredients"
                  label="Ingredients"
                  className="ml-2"
                />
              </div>
              <ul className="list-disc list-inside text-gray-600 dark:text-gray-400">
                {mealPlan.lunch.ingredients.map((ingredient, index) => (
                  <li key={index}>{ingredient}</li>
                ))}
              </ul>
            </div>
            
            <div>
              <div className="flex items-center justify-between mb-2">
                <h4 className="font-semibold text-gray-700 dark:text-gray-300">Instructions:</h4>
                <VoiceButton 
                  text={`Lunch instructions: ${mealPlan.lunch.instructions.join('. ')}`}
                  buttonId="lunch-instructions"
                  label="Instructions"
                  className="ml-2"
                />
              </div>
              <ol className="list-decimal list-inside text-gray-600 dark:text-gray-400 space-y-1">
                {mealPlan.lunch.instructions.map((instruction, index) => (
                  <li key={index}>{instruction}</li>
                ))}
              </ol>
            </div>
          </div>

          {/* Dinner Section */}
          <div className="bg-white dark:bg-gray-800 rounded-lg p-6 shadow-md">
            <h3 className="text-xl font-bold text-gray-800 dark:text-white mb-4">Dinner: {mealPlan.dinner.name}</h3>
            
            <div className="mb-4">
              <div className="flex items-center justify-between mb-2">
                <h4 className="font-semibold text-gray-700 dark:text-gray-300">Ingredients:</h4>
                <VoiceButton 
                  text={`Dinner ingredients: ${mealPlan.dinner.ingredients.join(', ')}`}
                  buttonId="dinner-ingredients"
                  label="Ingredients"
                  className="ml-2"
                />
              </div>
              <ul className="list-disc list-inside text-gray-600 dark:text-gray-400">
                {mealPlan.dinner.ingredients.map((ingredient, index) => (
                  <li key={index}>{ingredient}</li>
                ))}
              </ul>
            </div>
            
            <div>
              <div className="flex items-center justify-between mb-2">
                <h4 className="font-semibold text-gray-700 dark:text-gray-300">Instructions:</h4>
                <VoiceButton 
                  text={`Dinner instructions: ${mealPlan.dinner.instructions.join('. ')}`}
                  buttonId="dinner-instructions"
                  label="Instructions"
                  className="ml-2"
                />
              </div>
              <ol className="list-decimal list-inside text-gray-600 dark:text-gray-400 space-y-1">
                {mealPlan.dinner.instructions.map((instruction, index) => (
                  <li key={index}>{instruction}</li>
                ))}
              </ol>
            </div>
          </div>
        </div>
      );
    };

    // Workout Plan Display Component
    const WorkoutPlanDisplay = ({ workoutPlan }) => {
      // Channel allowlist (label + YouTube handle if known). If handle missing, we fall back to general search including label.
      const CHANNELS = [
        { label: 'All YouTube', value: 'all' },
        { label: 'Athlean-X', value: 'athleanx', handle: '@ATHLEANX' },
        { label: 'Jeff Nippard', value: 'jeffnippard', handle: '@JeffNippard' },
        { label: 'Renaissance Periodization', value: 'rp', handle: '@RenaissancePeriodization' },
        { label: 'Juggernaut Training Systems', value: 'juggernaut', handle: '@JuggernautTrainingSystems' },
        { label: 'Barbell Medicine', value: 'barbellmedicine', handle: '@BarbellMedicine' },
        { label: 'Alan Thrall', value: 'alanthrall', handle: '@AlanThrall' },
        { label: 'Squat University', value: 'squatuniversity', handle: '@SquatUniversity' },
        { label: 'Calisthenic Movement', value: 'calimove', handle: '@calimove' },
        { label: 'FitnessFAQs', value: 'fitnessfaqs', handle: '@FitnessFAQs' },
        { label: 'ThenX', value: 'thenx', handle: '@OFFICIALTHENX' },
        { label: 'StrongFirst', value: 'strongfirst', handle: '@strongfirst' },
        { label: 'Kettlebell Kings', value: 'kettlebellkings', handle: '@KettlebellKings' },
        { label: 'Onnit Academy', value: 'onnit', handle: '@OnnitAcademy' },
        { label: 'Catalyst Athletics', value: 'catalyst', handle: '@catalystathletics' },
        { label: 'California Strength', value: 'calstrength', handle: '@CaliforniaStrength' },
        { label: 'E3Rehab', value: 'e3rehab', handle: '@E3Rehab' },
        { label: 'PhysioTutors', value: 'physiotutors', handle: '@PhysioTutors' },
        { label: 'Girls Gone Strong', value: 'ggs', handle: '@GirlsGoneStrong' },
      ];

      const [selectedChannel, setSelectedChannel] = useState('all');
      const [shortOnly, setShortOnly] = useState(false);

      // Helpers to generate YouTube search URLs with channel/duration preferences
      const normalizeExerciseName = (exerciseName) => {
        let name = String(exerciseName || '');
        // Capture equipment before stripping parens
        const equipment = (name.match(/\((.*?)\)/)?.[1] || '').toLowerCase();
        // Strip parentheses content
        name = name.replace(/\(.*?\)/g, '').trim();
        // Drop prefixes like "Exercise 1:", "Warm-up:", "Cooldown:"
        if (name.includes(':')) {
          const parts = name.split(':');
          name = parts[parts.length - 1].trim();
        }
        name = name.replace(/^Exercise\s*\d+\s*-?\s*/i, '').trim();
        name = name.replace(/^Warm-?up\s*-?\s*/i, '').trim();
        name = name.replace(/^Cooldown\s*-?\s*/i, '').trim();
        return { baseName: name, equipment };
      };

      const getYouTubeGlobalSearchUrl = (exerciseName) => {
        const { baseName, equipment } = normalizeExerciseName(exerciseName);
        const level = (workoutPlan?.plan_name || '').toLowerCase();
        const levelHint = /beginner/.test(level) ? 'beginner' : /intermediate/.test(level) ? 'intermediate' : /advanced|expert/.test(level) ? 'advanced' : '';

        const extras = ['proper form', 'tutorial'];
        if (shortOnly) extras.push('short tutorial', 'quick');
        if (equipment) extras.push(equipment);
        if (levelHint) extras.push(levelHint);

        // Keep negatives minimal to avoid zero-results; do not exclude shorts globally by default
        const negatives = ['-compilation', '-montage', '-meme'];

        const query = `${baseName} ${extras.join(' ')} ${negatives.join(' ')}`.replace(/\s+/g, ' ').trim();
        return `https://www.youtube.com/results?search_query=${encodeURIComponent(query)}&hl=en`;
      };

      const getYouTubeChannelSearchUrl = (exerciseName) => {
        if (selectedChannel === 'all') return null;
        const ch = CHANNELS.find(c => c.value === selectedChannel);
        const { baseName, equipment } = normalizeExerciseName(exerciseName);
        // Use a minimal, broad query for channel search; avoid time hints
        const terms = [baseName, 'tutorial', 'form'];
        if (equipment) terms.push(equipment);
        const query = terms.join(' ').replace(/\s+/g, ' ').trim();
        if (ch?.handle) return `https://www.youtube.com/${encodeURIComponent(ch.handle)}/search?query=${encodeURIComponent(query)}&hl=en`;
        const biased = `${query} \"${ch?.label || ''}\"`;
        return `https://www.youtube.com/results?search_query=${encodeURIComponent(biased)}&hl=en`;
      };

      return (
        <div className="space-y-4 sm:space-y-6">
          {workoutPlan.exercises.map((exercise, index) => (
            <div key={index} className="bg-white dark:bg-gray-800 rounded-lg p-4 sm:p-6 shadow-md">
              <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between mb-4 gap-2">
                <h3 className="text-lg sm:text-xl font-bold text-gray-800 dark:text-white">
                  Exercise {index + 1}: {exercise.name}
                </h3>
                <VoiceButton 
                  text={`Exercise ${index + 1}: ${exercise.name}. You will do ${exercise.sets} sets of ${exercise.reps} repetitions. Instructions: ${exercise.instructions}`}
                  buttonId={`exercise-${index}`}
                  label="Listen"
                  className="self-start sm:ml-2"
                />
              </div>
              
              <div className="grid grid-cols-2 gap-2 sm:gap-4 mb-4">
                <div className="text-center p-2 sm:p-3 bg-blue-50 dark:bg-blue-900/20 rounded-lg">
                  <div className="text-xl sm:text-2xl font-bold text-blue-600 dark:text-blue-400">{exercise.sets}</div>
                  <div className="text-xs sm:text-sm text-gray-600 dark:text-gray-400">Sets</div>
                </div>
                <div className="text-center p-2 sm:p-3 bg-green-50 dark:bg-green-900/20 rounded-lg">
                  <div className="text-xl sm:text-2xl font-bold text-green-600 dark:text-green-400">{exercise.reps}</div>
                  <div className="text-xs sm:text-sm text-gray-600 dark:text-gray-400">Reps</div>
                </div>
              </div>
              
              <div className="mb-4">
                <h4 className="font-semibold text-gray-700 dark:text-gray-300 mb-2 text-sm sm:text-base">Instructions:</h4>
                <p className="text-gray-600 dark:text-gray-400 text-sm sm:text-base leading-relaxed">{exercise.instructions}</p>
              </div>
              
              {/* YouTube Video Search Link with Channel Filter */}
              <div className="mt-4 p-3 sm:p-4 bg-red-50 dark:bg-red-900/20 rounded-lg border border-red-200 dark:border-red-800">
                <div className="grid gap-3 sm:flex sm:items-center sm:justify-between">
                  <div className="flex items-center">
                    <svg className="w-5 h-5 sm:w-6 sm:h-6 text-red-600 dark:text-red-400 mr-2 flex-shrink-0" fill="currentColor" viewBox="0 0 24 24">
                      <path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"/>
                    </svg>
                    <span className="font-semibold text-red-700 dark:text-red-300 text-sm sm:text-base">Watch Tutorial</span>
                  </div>
                  <div className="flex flex-col sm:flex-row items-stretch sm:items-center gap-2 sm:gap-3">
                    <select
                      value={selectedChannel}
                      onChange={(e) => setSelectedChannel(e.target.value)}
                      className="bg-white dark:bg-gray-800 border border-red-200 dark:border-red-700 rounded-md px-2 py-2 text-sm text-gray-800 dark:text-gray-200"
                      aria-label="Preferred channel"
                    >
                      {CHANNELS.map(ch => (
                        <option key={ch.value} value={ch.value}>{ch.label}</option>
                      ))}
                    </select>
                    <label className="inline-flex items-center gap-2 text-xs sm:text-sm text-gray-700 dark:text-gray-300">
                      <input
                        type="checkbox"
                        checked={shortOnly}
                        onChange={(e) => setShortOnly(e.target.checked)}
                        className="w-4 h-4 accent-red-600"
                      />
                      Prefer shorter
                    </label>
                    {selectedChannel !== 'all' && (
                      <a 
                        href={getYouTubeChannelSearchUrl(exercise.name)} 
                        target="_blank" 
                        rel="noopener noreferrer"
                        className="bg-red-600 hover:bg-red-700 text-white px-3 py-2 sm:px-4 sm:py-2 rounded-lg font-medium transition-colors flex items-center justify-center gap-2 text-sm sm:text-base w-full sm:w-auto"
                      >
                        <svg className="w-4 h-4 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                        </svg>
                        Search This Channel
                      </a>
                    )}
                    <a 
                      href={getYouTubeGlobalSearchUrl(exercise.name)} 
                      target="_blank" 
                      rel="noopener noreferrer"
                      className="bg-red-600 hover:bg-red-700 text-white px-3 py-2 sm:px-4 sm:py-2 rounded-lg font-medium transition-colors flex items-center justify-center gap-2 text-sm sm:text-base w-full sm:w-auto"
                    >
                      <svg className="w-4 h-4 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                      </svg>
                      Search All
                    </a>
                  </div>
                </div>
              </div>
            </div>
          ))}
        </div>
      );
    };


    const BottomNavBar = ({ screen, setScreen }) => (
      <nav className="fixed bottom-0 left-0 right-0 bg-white/80 dark:bg-gray-900/80 backdrop-blur-sm shadow-[0_-2px_10px_rgba(0,0,0,0.05)] dark:shadow-[0_-2px_10px_rgba(0,0,0,0.2)] h-20 flex justify-around items-center px-4">
        <button onClick={() => setScreen('dashboard')} className={`flex flex-col items-center justify-center font-semibold transition-colors ${screen === 'dashboard' ? 'text-pink-500' : 'text-gray-400'}`}>
          <span className="text-2xl mb-1">🏠</span>
        </button>
        <button onClick={() => setScreen('progress')} className={`flex flex-col items-center justify-center font-semibold transition-colors ${screen === 'progress' ? 'text-pink-500' : 'text-gray-400'}`}>
          <span className="text-2xl mb-1">📊</span>
        </button>
        <button onClick={() => setScreen('planner')} className={`flex flex-col items-center justify-center font-semibold transition-colors ${screen === 'planner' ? 'text-pink-500' : 'text-gray-400'}`}>
          <span className="text-2xl mb-1">🍽️</span>
        </button>
        <button onClick={() => setScreen('scan')} className="bg-blue-500 text-white w-14 h-14 rounded-full flex items-center justify-center text-lg font-bold shadow-lg">
          Cal
        </button>
        <button onClick={() => setScreen('workout')} className={`flex flex-col items-center justify-center font-semibold transition-colors ${screen === 'workout' ? 'text-pink-500' : 'text-gray-400'}`}>
          <span className="text-2xl mb-1">🏋️</span>
        </button>
        <button onClick={() => setScreen('coach')} className={`flex flex-col items-center justify-center font-semibold transition-colors ${screen === 'coach' ? 'text-pink-500' : 'text-gray-400'}`}>
          <span className="text-2xl mb-1">🤖</span>
        </button>
        <button onClick={() => setScreen('profile')} className={`flex flex-col items-center justify-center font-semibold transition-colors ${screen === 'profile' ? 'text-pink-500' : 'text-gray-400'}`}>
          <span className="text-2xl mb-1">👤</span>
        </button>
      </nav>
    );
  </script>
  <script type="text/babel">
    // --- Mount App ---
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(
      <AuthProvider>
        <App />
      </AuthProvider>
    );
  </script>
  <!-- PDF Generation Library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script>
    // Register service worker (safe, idempotent). Remove duplicate registrations if already present
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/sw.js')
          .then(reg => console.log('ServiceWorker registered:', reg.scope))
          .catch(err => console.warn('ServiceWorker registration failed:', err));
      });
    }
  </script>
  
  <!-- ✅ Animated Install FitnessMate App Banner -->
  <style>
    #installBanner {
      position: fixed;
      bottom: -100px;
      left: 0;
      right: 0;
      background: #2563EB;
      color: white;
      text-align: center;
      padding: 14px;
      font-family: system-ui, sans-serif;
      font-size: 15px;
      z-index: 9999;
      box-shadow: 0 -2px 8px rgba(0,0,0,0.3);
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      transition: bottom 0.4s ease;
    }
    #installBanner.show { bottom: 0; }
    #installBanner button {
      background: white;
      color: #2563EB;
      border: none;
      border-radius: 6px;
      padding: 6px 12px;
      font-weight: 600;
      cursor: pointer;
    }
    #closeBanner {
      background: transparent;
      border: none;
      color: white;
      font-size: 20px;
      line-height: 1;
      cursor: pointer;
      position: absolute;
      right: 12px;
      top: 8px;
    }
    /* Mobile-only: prevent close (×) from overlapping Install button */
    @media (max-width: 480px) {
      #closeBanner {
        position: static;
        right: auto;
        top: auto;
        margin-left: auto; /* push close to the far right */
      }
    }
  </style>
  
  <div id="installBanner">
    <span class="android-icon" aria-hidden="true">
      <svg viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
        <path d="M4 9h2V7a2 2 0 1 1 4 0v10a2 2 0 1 1-4 0v-2H4V9zm14 0h2v6h-2v2a2 2 0 1 1-4 0V7a2 2 0 1 1 4 0v2zM9 11h6v2H9v-2z"/>
      </svg>
    </span>
    Install <b>FitnessMate</b> for faster access!
    <button id="installBtn">Install</button>
    <button id="closeBanner">×</button>
  </div>
  <div id="installBannerIOS">
    <div class="banner-content">
      <div class="main-text">
        <span class="ios-icon" aria-hidden="true">
          <svg viewBox="0 0 814 1000" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
            <path d="M788.1 340.9c-5.8 4.5-108.2 62.2-108.2 190.5 0 148.4 130.3 200.9 134.2 202.2-.6 3.2-20.7 71.9-68.7 141.9-42.8 61.6-87.5 123.1-155.5 123.1s-85.5-39.5-164-39.5c-76.5 0-103.7 40.8-165.9 40.8s-105.6-57-155.5-127C46.7 790.7 0 663 0 541.8c0-194.4 126.4-297.5 250.8-297.5 66.1 0 121.2 43.4 162.7 43.4 39.5 0 101.1-46 176.3-46 28.5 0 130.9 2.6 198.3 99.2zm-234-181.5c31.1-36.9 53.1-88.1 53.1-139.3 0-7.1-.6-14.3-1.9-20.1-50.6 1.9-110.8 33.7-147.1 75.8-28.5 32.4-55.1 83.6-55.1 135.5 0 7.8 1.3 15.6 1.9 18.1 3.2.6 8.4 1.3 13.6 1.3 45.4 0 102.5-30.4 135.5-71.3z"/>
          </svg>
        </span>
        Install <b class="app-name">FitnessMate</b>
      </div>
      <div class="sub-text">On iPhone: Tap Share, then Add to Home Screen</div>
    </div>
    <button id="installBtnIOS">Install</button>
    <button id="closeBannerIOS">×</button>
  </div>
  
  <script>
    let deferredPrompt;
    const banner = document.getElementById('installBanner');
    const installBtn = document.getElementById('installBtn');
    const closeBanner = document.getElementById('closeBanner');
  
    window.addEventListener('beforeinstallprompt', (e) => {
      e.preventDefault();
      deferredPrompt = e;
      banner.classList.add('show');
    });
  
    installBtn.addEventListener('click', async () => {
      banner.classList.remove('show');
      if (deferredPrompt) {
        deferredPrompt.prompt();
        const { outcome } = await deferredPrompt.userChoice;
        deferredPrompt = null;
        console.log('User response:', outcome);
      }
    });
  
    closeBanner.addEventListener('click', () => {
      banner.classList.remove('show');
    });
  
    window.addEventListener('appinstalled', () => {
      banner.classList.remove('show');
      console.log('PWA installed');
    });
    const isiOS = /iphone|ipad|ipod/i.test(navigator.userAgent) || (navigator.userAgent.includes('Mac') && 'ontouchend' in document);
    const isStandalone = (window.navigator.standalone === true) || window.matchMedia('(display-mode: standalone)').matches;
    const bannerIOS = document.getElementById('installBannerIOS');
    const installBtnIOS = document.getElementById('installBtnIOS');
    const closeBannerIOS = document.getElementById('closeBannerIOS');
    window.addEventListener('load', () => {
      if (isiOS && !isStandalone && bannerIOS) {
        bannerIOS.classList.add('show');
      }
    });
    if (installBtnIOS && bannerIOS) {
      installBtnIOS.addEventListener('click', () => {
        alert('To install FitnessMate on iPhone: tap the Share icon in Safari, then select "Add to Home Screen".');
        bannerIOS.classList.remove('show');
      });
    }
    if (closeBannerIOS && bannerIOS) {
      closeBannerIOS.addEventListener('click', () => {
        bannerIOS.classList.remove('show');
      });
    }
    window.addEventListener('appinstalled', () => {
      if (bannerIOS) bannerIOS.classList.remove('show');
    });
  </script>
<!-- Stripe Pricing Table modal -->
<script async src="https://js.stripe.com/v3/pricing-table.js"></script>
<div id="stripePricingModal" style="display:none; position:fixed; inset:0; z-index:10000; background:rgba(0,0,0,0.6); align-items:center; justify-content:center; overflow:auto;">
  <div style="background:#fff; max-width:480px; width:100%; margin:40px; padding:20px; border-radius:8px; position:relative;">
    <button onclick="window.closeStripePricingModal()" style="position:absolute; top:8px; right:12px; font-size:24px; border:none; background:transparent; cursor:pointer;">×</button>
    <stripe-pricing-table pricing-table-id="prctbl_1SIvLCJRFG3zIhTKhJSKc5jk"
      publishable-key="pk_live_51SIu0RJRFG3zIhTKZkkXcQZdRbWXshYT78KWQqpsRfDPIhuxYh9Ngtz5HbqcIMBioEXrpk9rp6dJtHLp0IQ106f900MI4zPe2M">
    </stripe-pricing-table>
  </div>
</div>
<script>
(function(){
  window.openStripePricingModal = function(){ var m=document.getElementById('stripePricingModal'); if(m) m.style.display='flex'; };
  window.closeStripePricingModal = function(){ var m=document.getElementById('stripePricingModal'); if(m) m.style.display='none'; };
})();
</script>
</body>
</html>
