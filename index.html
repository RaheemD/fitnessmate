<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover"/>
  <title>FitnessMate - AI Workout Hub</title>
 
 <meta name="description" content="FitnessMate ‚Äî AI workout plans and guided sessions. Personalized home & gym workouts, bodyweight routines, and progress tracking.">
<meta property="og:title" content="FitnessMate - AI Workout Hub">
<meta property="og:description" content="Personalized AI workout plans for home and gym.">
<meta property="og:image" content="https://fitnessmate.netlify.app/og-image.png">
<meta property="og:type" content="website">
<meta property="og:url" content="https://fitnessmate.netlify.app/">
<meta name="keywords" content="AI workout app, fitness planner, gym tracker, home workouts, FitnessMate">

<meta name="twitter:card" content="summary_large_image">
<meta name="author" content="FitnessMate Team">
<meta name="robots" content="index, follow">


<link rel="canonical" href="https://fitnessmate.netlify.app/">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="preconnect" href="https://cdn.tailwindcss.com">
  <link rel="preconnect" href="https://unpkg.com">
  <link rel="prefetch" href="/workout.html">
  <link rel="prefetch" href="/icon-192.png">
  


  <link rel="icon" type="image/x-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' fill='%23ec4899'/><text x='50' y='70' text-anchor='middle' fill='white' font-family='Arial, sans-serif' font-weight='bold' font-size='60'>F</text></svg>">
  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      darkMode: 'class',
    }
  </script>
  <!-- Global mobile-safe adjustments to reduce WebView text overflow -->
  <style>
    html { -webkit-text-size-adjust: 100%; text-size-adjust: 100%; }
    /* Ensure flex children can shrink and not overflow on small screens */
    .min-w-0 { min-width: 0; }
  </style>
  
  <script>
    // Prevent white flash on page load - apply background immediately
    (function() {
      const rawTheme = localStorage.getItem('fitmate-dark-mode');
      const isDarkMode = (rawTheme === null) ? true : (rawTheme === 'true'); // default to dark
      if (isDarkMode) {
        document.documentElement.classList.add('dark');
        document.documentElement.style.backgroundColor = '#111827';
      } else {
        document.documentElement.classList.remove('dark');
        document.documentElement.style.backgroundColor = '#f9fafb';
      }
    })();
  </script>
  <script>
    (function(){
      function todayInSelectedTZ(){
        try {
          const tz = localStorage.getItem('userTimeZone') || Intl.DateTimeFormat().resolvedOptions().timeZone;
          const parts = new Intl.DateTimeFormat('en-CA', { timeZone: tz, year:'numeric', month:'2-digit', day:'2-digit' }).formatToParts(new Date());
          const y = parts.find(p=>p.type==='year')?.value;
          const m = parts.find(p=>p.type==='month')?.value;
          const d = parts.find(p=>p.type==='day')?.value;
          return `${y}-${m}-${d}`;
        } catch(_){
          const d = new Date();
          return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
        }
      }

      function sanitize(){
        try {
          // No-op: keep current intake; only ensure it exists on first launch
          const zero = { calories:0, protein:0, carbs:0, fat:0, activity:0, water:0 };
          if (!localStorage.getItem('dailyIntake')) {
            localStorage.setItem('dailyIntake', JSON.stringify(zero));
          }
        } catch(_) {}
      }

      // Run at first paint and on visibility return
      sanitize();
      document.addEventListener('visibilitychange', function(){ if(!document.hidden) sanitize(); }, true);
    })();
  </script>
  
  <!-- Supabase SDK -->
  <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
  
  <!-- Custom Booking System - No longer using Calendly -->
  
  <!-- Stripe.js removed - using invoice-based payment system -->
  
  <!-- Whereby for video meetings -->
  
  <!-- EmailJS for email sending -->
  <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@emailjs/browser@3/dist/email.min.js"></script>
  <script>
    (function() {
      // Initialize EmailJS with your public key
      emailjs.init("NBoWj-4wIbDY-qLS8"); // Replace with your actual EmailJS public key
      
      /* 
      IMPORTANT: To set up EmailJS for booking confirmations:
      
      1. Sign up at https://www.emailjs.com/ (free tier available)
      2. Create a new Email Service (Gmail, Outlook, etc.)
      3. Create two email templates:
         - For free sessions (template_id): Include {{to_name}}, {{session_date}}, {{session_time}}, {{session_type}}, {{meeting_link}}
         - For paid sessions (template_paid_id): Include all above plus {{sessions_count}} and {{amount_paid}}
      4. Replace 'YOUR_PUBLIC_KEY' above with your EmailJS public key
      5. Replace 'service_id', 'template_id', and 'template_paid_id' in the code with your actual IDs
      */
    })();
  </script>
  
  <!-- Custom Booking Calendar Styles -->
  <style>
    .booking-calendar-container {
      width: 100%;
      min-height: 650px;
    }
    
    .booking-step {
      animation: fadeIn 0.3s ease-in-out;
    }
    
    .calendar-container {
      width: 100%;
    }
    
    .calendar-day {
      aspect-ratio: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }
    
    .time-slots-container {
      max-height: 400px;
      overflow-y: auto;
    }
    
    .time-slot {
      transition: all 0.2s ease;
    }
    
    .package-card {
      height: 100%;
      display: flex;
      flex-direction: column;
      transition: all 0.2s ease;
    }
    
    .package-price {
      margin-bottom: 1rem;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* Merch teaser text with subtle glow and shadow */
    .merch-teaser {
      font-weight: 600;
      text-shadow: 0 1px 2px rgba(0,0,0,0.18), 0 0 10px rgba(236,72,153,0.25), 0 0 6px rgba(59,130,246,0.25);
    }
    .merch-teaser .twinkle-star {
      display: inline-block;
      margin: 0 6px;
      animation: twinkle 1.2s ease-in-out infinite;
    }
    .merch-teaser .twinkle-star.delay { animation-delay: .6s; }
    /* Starry overlay effect on the text itself */
    .merch-teaser.starry { position: relative; }
    .merch-teaser.starry::after {
      content: '';
      position: absolute;
      inset: 0;
      pointer-events: none;
      mix-blend-mode: screen;
      /* Starry overlay; keep subtle sparkles for larger screens */
      background:
        radial-gradient(circle at 56% 28%, rgba(255,255,255,0.85) 0, rgba(255,255,255,0.85) 1.2px, transparent 2.2px);
      animation: sparkle 2.8s ease-in-out infinite;
    }
    /* Mobile: remove side dots entirely to avoid visual bullets */
    @media (max-width: 640px) {
      .merch-teaser.starry::after { background: none !important; }
    }
    /* Hard blink on/off for the whole line */
    .merch-teaser.blink { animation: blinker 1.6s steps(2, start) infinite; }
    @keyframes blinker { 0% { opacity: 1; } 50% { opacity: 0; } 100% { opacity: 1; } }
    @keyframes sparkle {
      0%, 100% { opacity: .45; filter: brightness(1); }
      50% { opacity: 1; filter: brightness(1.25); }
    }
    @keyframes twinkle {
      0%, 100% { opacity: 0.35; transform: scale(0.9); filter: drop-shadow(0 0 0 rgba(255,255,255,0)); }
      50% { opacity: 1; transform: scale(1.1); filter: drop-shadow(0 0 6px rgba(255,215,0,0.9)); }
    }
    #installBannerIOS {
      position: fixed;
      bottom: -100px;
      left: 0;
      right: 0;
      background: #2563EB;
      color: white;
      text-align: center;
      padding: 10px;
      font-family: system-ui, sans-serif;
      font-size: 14px;
      z-index: 9999;
      box-shadow: 0 -2px 8px rgba(0,0,0,0.3);
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      transition: bottom 0.4s ease;
    }
    #installBannerIOS .banner-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2px;
      width: 100%;
      padding-right: 36px; /* space for close button so centering is true */
    }
    #installBannerIOS .main-text {
      display: flex;
      align-items: center;
      justify-content: center; /* ensure icon + title are centered */
      font-weight: 600;
      font-size: 15px;
    }
    #installBannerIOS .main-text .app-name { margin-left: 4px; }
    #installBannerIOS .sub-text {
      font-size: 11px;
      opacity: 0.9;
      line-height: 1.2;
    }
    #installBannerIOS.show { bottom: 0; }
    #installBannerIOS button {
      background: white;
      color: #2563EB;
      border: none;
      border-radius: 6px;
      padding: 6px 10px;
      font-size: 13px;
      font-weight: 600;
      line-height: 1.2;
      cursor: pointer;
    }
    #installBannerIOS .ios-icon {
      display: inline-flex;
      width: 22px;
      height: 22px;
      color: #fff;
      margin-right: 6px;
      flex-shrink: 0;
      align-items: center;
      justify-content: center;
    }
    #closeBannerIOS {
      background: transparent;
      border: none;
      color: white;
      font-size: 20px;
      line-height: 1;
      cursor: pointer;
      position: absolute;
      right: 12px;
      top: 8px;
    }
    @media (max-width: 480px) {
      #installBannerIOS {
        padding: 8px;
        font-size: 13px;
        gap: 8px;
      }
      #closeBannerIOS {
        position: absolute; /* keep absolute so content stays centered */
        right: 8px;
        top: 6px;
      }
      #installBannerIOS .banner-content { padding-right: 32px; }
    }
  </style>
  <style>
    /* Android install banner icon styling */
    #installBanner .android-icon {
      display: inline-flex;
      width: 30px;
      height: 30px;
      color: #ec4899; /* Tailwind pink-500 to match header icon */
      margin-right: 8px;
      vertical-align: middle;
    }
  </style>
  <!-- PWA manifest + theme -->
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#ec4899"> <!-- main app pink -->
  <meta name="color-scheme" content="light dark"> <!-- Let browser auto-select Light/dark -->

  <!-- icons (ensure these files exist at repo root) -->
  <link rel="icon" href="/icon.png">
  <link rel="apple-touch-icon" href="/icon-192.png">
  
  <script>
    // Conditionally load AdSense: iOS (iPhone/iPad/iPod) and desktop only. Never on Android.
    // Also disable for subscribed users (Stripe/Play), and react to runtime subscription changes.
    (function(){
      try {
        var ua = navigator.userAgent || '';
        var plat = (navigator.userAgentData && navigator.userAgentData.platform) || '';
        var isAndroid = /Android/i.test(ua) || /Android/i.test(plat);
        var isIPhone = /iPhone/i.test(ua);
        var isIPadUA = /iPad/i.test(ua);
        var isIPadLikeMac = /Macintosh/.test(ua) && navigator.maxTouchPoints > 1; // iPadOS 13+ masquerades as Mac
        var isIPad = isIPadUA || isIPadLikeMac;
        var isIPod = /iPod/i.test(ua);
        var isIOS = isIPhone || isIPad || isIPod;
        // Desktop: anything not mobile (exclude Android/iOS)
        var isDesktop = !(isAndroid || isIOS || /Mobile/i.test(ua));
        var subscribed = false; try { subscribed = JSON.parse(localStorage.getItem('subscriptionActive') || 'false') === true; } catch(_) {}

        function qualifiesForAdsense(){ return (isIOS || isDesktop) && !subscribed; }
        function injectAdsense(){
          if (!window.__adsenseLoaded) {
            var s = document.createElement('script');
            s.async = true;
            s.src = 'https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4496629998193729';
            s.crossOrigin = 'anonymous';
            document.head.appendChild(s);
            window.__adsenseLoaded = true;
          }
        }
        function hideAdsenseUnits(){
          try {
            document.querySelectorAll('ins.adsbygoogle, iframe[id^="google_ads_iframe"], .google-auto-placed').forEach(function(el){ el.style.display = 'none'; });
          } catch(_) {}
        }

        var shouldLoadAdsense = qualifiesForAdsense();
        if (shouldLoadAdsense) injectAdsense(); else hideAdsenseUnits();

        window.__fitmateAds = { android: isAndroid, iphone: isIPhone, ipad: isIPad, ipod: isIPod, ios: isIOS, desktop: isDesktop, subscribed: subscribed, adsense: shouldLoadAdsense };

        // React to runtime subscription changes
        window.addEventListener('subscription-status-changed', function(e){
          try {
            subscribed = !!(e && e.detail && e.detail.active);
            window.__fitmateAds.subscribed = subscribed;
            window.__fitmateAds.adsense = qualifiesForAdsense();
            if (window.__fitmateAds.adsense) {
              injectAdsense();
            } else {
              hideAdsenseUnits();
            }
          } catch(_) {}
        });
      } catch (e) { /* no-op */ }
    })();
  </script>
  <script>
    // Lightweight platform detection to decide which subscription button to show
    (function(){
      try {
        var ua = navigator.userAgent || '';
        var plat = (navigator.userAgentData && navigator.userAgentData.platform) || '';
        var isAndroid = /Android/i.test(ua) || /Android/i.test(plat);
        // Play Billing via Digital Goods API only available in native/TWA WebView contexts
        var hasDigitalGoods = typeof window.getDigitalGoodsService === 'function';
        // Android WebView userAgent commonly includes "wv"; treat as native-hosted
        var isWebView = /\bwv\b/i.test(ua) || /Version\/\d+/i.test(ua);
        var isStandalone = (window.matchMedia && window.matchMedia('(display-mode: standalone)').matches) || (navigator.standalone === true);
        var isTWA = isAndroid && isStandalone && hasDigitalGoods;
        // Explicitly detect Android browsers (Chrome/Edge/Firefox/Opera/Samsung Internet)
        var isChromeAndroid = /Chrome\/\d+/i.test(ua) && !/EdgA?\/\d+/i.test(ua) && !/OPR\/\d+/i.test(ua) && !/SamsungBrowser\/\d+/i.test(ua);
        var isEdgeAndroid = /EdgA?\/\d+/i.test(ua);
        var isFirefoxAndroid = /Firefox\/\d+/i.test(ua);
        var isOperaAndroid = /OPR\/\d+/i.test(ua) || /Opera/i.test(ua);
        var isSamsungAndroid = /SamsungBrowser\/\d+/i.test(ua);
        window.__isAndroidWebBrowser = !!(isAndroid && (isChromeAndroid || isEdgeAndroid || isFirefoxAndroid || isOperaAndroid || isSamsungAndroid) && !isWebView && !hasDigitalGoods);
        // Strong signal: native WebView bridge injected by the app
        var hasAndroidBridge = !!(window.Android && (typeof window.Android.subscribe === 'function' || typeof window.Android.restore === 'function'));
        window.__hasAndroidBridge = !!hasAndroidBridge;
        // Native app contexts: WebView with bridge OR TWA/DigitalGoods. Browsers are excluded.
        window.__isNativeAndroidApp = !!(isAndroid && (hasAndroidBridge || hasDigitalGoods || isWebView || isTWA) && !window.__isAndroidWebBrowser);
      } catch(_) {
        window.__isNativeAndroidApp = false;
        window.__hasAndroidBridge = false;
        window.__isAndroidWebBrowser = false;
      }
    })();
  </script>
  <script>
    // Android Play Billing bridge (no product IDs or web-side billing logic)
    (function(){
      try {
        // Public API expected by UI buttons
        window.FitnessMateBilling = {
          subscribe: async function(){
            try {
              if (window.Android && typeof window.Android.subscribe === 'function') {
                // Delegate to native Android bridge; result (if any) is handled on Android
                return await window.Android.subscribe();
              }
            } catch(_) {}
            // If not available, return false (no-op in web)
            return false;
          },
          restore: async function(){
            try {
              if (window.Android && typeof window.Android.restore === 'function') {
                return await window.Android.restore();
              }
            } catch(_) {}
            return false;
          }
        };

        // Lightweight toast utility (used for subscription activation/restoration)
        window.fmToast = function(message, opts){
          try {
            opts = opts || {};
            var duration = typeof opts.duration === 'number' ? opts.duration : 2200;
            var type = opts.type || 'success';
            var bg = type === 'error' ? '#dc2626' : (type === 'info' ? '#2563eb' : '#16a34a');
            var el = document.createElement('div');
            el.textContent = message;
            el.style.position = 'fixed';
            el.style.left = '50%';
            el.style.bottom = '24px';
            el.style.transform = 'translateX(-50%) translateY(8px)';
            el.style.zIndex = '9999';
            el.style.background = bg;
            el.style.color = '#fff';
            el.style.padding = '8px 12px';
            el.style.borderRadius = '10px';
            el.style.boxShadow = '0 6px 18px rgba(0,0,0,0.25)';
            el.style.fontSize = '13px';
            el.style.lineHeight = '1.2';
            el.style.pointerEvents = 'none';
            el.style.opacity = '0';
            el.style.transition = 'opacity 180ms ease, transform 180ms ease';
            document.body.appendChild(el);
            requestAnimationFrame(function(){
              el.style.opacity = '1';
              el.style.transform = 'translateX(-50%) translateY(0)';
            });
            setTimeout(function(){
              el.style.opacity = '0';
              el.style.transform = 'translateX(-50%) translateY(8px)';
              setTimeout(function(){
                try { document.body.removeChild(el); } catch(_) {}
              }, 220);
            }, duration);
          } catch(_) {}
        };

        // Called by Android after successful purchase/restore
        window.fmSetProStatus = function(isPro){
          var newStatus = !!isPro;
          var prevStatus = false;
          try {
            prevStatus = JSON.parse(localStorage.getItem('subscriptionActive') || 'false') === true;
          } catch(_) { prevStatus = false; }

          // Persist subscription flag so AI limiter uses 15 prompts when true
          try { localStorage.setItem('subscriptionActive', JSON.stringify(newStatus)); } catch(_) {}

          // Notify any listeners (ads, UI) that subscription changed
          try { window.dispatchEvent(new CustomEvent('subscription-status-changed', { detail: { active: newStatus } })); } catch(_) {}

          // Trigger AI quota recompute in UI without navigating
          try { document.dispatchEvent(new Event('visibilitychange')); } catch(_) {}

          // Show toast ONLY on actual transition from non-pro -> pro,
          // and guard with a session flag + short cooldown to avoid sporadic repeats.
          try {
            var now = Date.now();
            var COOLDOWN_MS = 2 * 60 * 1000; // 2 minutes
            var lastToastAt = 0;
            try { lastToastAt = parseInt(localStorage.getItem('subscriptionLastToastAt') || '0', 10) || 0; } catch(_) {}
            var sessionShown = !!window.__fmActivationToastShown;

            if (newStatus && !prevStatus && !sessionShown && (now - lastToastAt > COOLDOWN_MS)) {
              window.fmToast('Welcome to FitnessMate üí™', { type: 'success' });
              window.__fmActivationToastShown = true; // session guard
              try { localStorage.setItem('subscriptionLastToastAt', String(now)); } catch(_) {}
            }
          } catch(_) {}
        };
      } catch(_) { /* no-op */ }
    })();
  </script>
</head>
<body class="bg-gray-50 dark:bg-gray-900">
  <!-- Hidden Netlify Form for Support -->
  <form name="support-form" netlify hidden>
    <input type="text" name="full-name" />
    <input type="email" name="email" />
    <input type="text" name="subject" />
    <textarea name="message"></textarea>
  </form>
  
  <!-- Background Music Audio Element -->
  <audio id="background-music" loop preload="auto">
    <source src="./Gym.mp3" type="audio/mpeg">
    Your browser does not support the audio element.
  </audio>
  
  <div id="root"></div>

  <!-- Preload Exercises app at startup; kept off-screen until shown -->
  <div id="workout-preload-container" style="position:fixed;width:1px;height:1px;top:-9999px;left:-9999px;opacity:0;pointer-events:none;z-index:-1;">
    <iframe src="./workout.html" id="workout-preload" loading="eager" allow="autoplay" style="width:1px;height:1px;border:0;"></iframe>
  </div>

  <script>
    (function(){
      if (!('speechSynthesis' in window)) return;
      try { speechSynthesis.getVoices(); } catch(_) {}
      let __fitmateVoiceGender = 'female';
      function parentSpeak(text, gender){
        try {
          const u = new SpeechSynthesisUtterance(String(text || ''));
          u.rate = 1; u.pitch = 1; u.volume = 1;
          try {
            const vs = speechSynthesis.getVoices();
            const g = (gender || __fitmateVoiceGender || '').toLowerCase();
            let v = null;
            if (vs && vs.length) {
              if (g === 'female') {
                v = vs.find(x => x.name && /female|samantha|zira|jenny|karen|lisa|joanna|en-gb female/i.test(x.name));
              } else if (g === 'male') {
                v = vs.find(x => x.name && /male|david|brian|matthew|en-gb male/i.test(x.name));
              }
              if (!v) v = vs.find(x => /en/i.test(x.lang)) || vs[0];
            }
            if (v) u.voice = v;
          } catch(_) {}
          speechSynthesis.speak(u);
        } catch(_) {}
      }
      function parentWarmup(){
        try {
          const u = new SpeechSynthesisUtterance('.');
          u.rate = 1; u.pitch = 1; u.volume = 0.01;
          try {
            const vs = speechSynthesis.getVoices();
            let v = vs && vs.length ? vs.find(x => /en/i.test(x.lang)) || vs[0] : null;
            if (v) u.voice = v;
          } catch(_) {}
          speechSynthesis.speak(u);
        } catch(_) {}
      }
      window.addEventListener('message', function(e){
        try {
          if (e.data && e.data.type === 'fitmate-voice-gender' && e.data.gender) { __fitmateVoiceGender = String(e.data.gender).toLowerCase(); }
          if (e.data && e.data.type === 'fitmate-speak' && e.data.text) parentSpeak(e.data.text, e.data.gender);
          if (e.data && e.data.type === 'fitmate-tts-warmup') parentWarmup();
        } catch(_) {}
      });
    })();
  </script>
  <!-- React + ReactDOM + Babel (for JSX in-browser) -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    const { useState, useRef, useEffect, useCallback } = React;

    // Global safe stub to avoid ReferenceError before the real helper is defined
    if (typeof window !== 'undefined' && typeof window.setLocalStorageWithSync === 'undefined') {
      window.setLocalStorageWithSync = function (key, value) {
        try {
          localStorage.setItem(key, value);
        } catch (error) {
          if (error && (error.name === 'QuotaExceededError' || error.code === 22)) {
            try {
              ['pantryChef_imagePreview','menuDecoder_imagePreview','pantryChef_ingredients','pantryChef_recipes','menuDecoder_menuItems','menuDecoder_recommendations','dailyQuote','lastQuoteFetchDate']
                .forEach(k => { try { localStorage.removeItem(k); } catch (_) {} });
              localStorage.setItem(key, value);
            } catch (e) {
              if (key === 'profilePicture' || /imagePreview/.test(key)) return;
              console.warn('setLocalStorageWithSync stub failed after cleanup:', e);
            }
          } else {
            console.warn('setLocalStorageWithSync stub store failed:', error);
          }
        }
      };

      // Enhanced multi-frame analysis for better accuracy on uploads
      const enhancedAnalyzeForm = async (videoBlob) => {
        setIsLoading(true);
        setError(null);
        try {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d', { willReadFrequently: true });
          const video = document.createElement('video');
          video.src = URL.createObjectURL(videoBlob);
          video.muted = true;
          video.playsInline = true;

          const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error('Video processing timeout')), 30000));

          const loadMeta = new Promise((resolve, reject) => {
            video.onloadedmetadata = () => resolve(true);
            video.onerror = () => reject(new Error('Failed to load video metadata'));
            try { video.load(); } catch (_) {}
          });

          await Promise.race([loadMeta, timeoutPromise]);
          if (!video.videoWidth || !video.videoHeight) throw new Error('Invalid video dimensions');

          const duration = Math.max(0.5, isFinite(video.duration) ? video.duration : 3);
          const times = Array.from({ length: 4 }, (_, i) => Math.min(duration - 0.1, Math.max(0.1, ((i + 1) / 5) * duration)));

          const seekTo = (t) => new Promise((resolve, reject) => {
            const onSeeked = () => { video.removeEventListener('seeked', onSeeked); resolve(true); };
            const onError = () => { video.removeEventListener('error', onError); reject(new Error('Failed to seek video')); };
            video.addEventListener('seeked', onSeeked, { once: true });
            video.addEventListener('error', onError, { once: true });
            try { video.currentTime = t; } catch (_) { reject(new Error('Seek failed')); }
          });

          const computeMetrics = (imageData, w, h) => {
            const data = imageData.data;
            const step = Math.max(1, Math.floor(Math.min(w, h) / 160));
            let sumL = 0, count = 0;
            const gray = new Float32Array(w * h);
            for (let y = 0; y < h; y += step) {
              for (let x = 0; x < w; x += step) {
                const idx = (y * w + x) * 4;
                const r = data[idx], g = data[idx + 1], b = data[idx + 2];
                const l = 0.299 * r + 0.587 * g + 0.114 * b;
                gray[y * w + x] = l;
                sumL += l; count++;
              }
            }
            const meanL = sumL / Math.max(1, count) / 255; // 0..1
            let sharpSum = 0, sCount = 0;
            for (let y = step; y < h - step; y += step) {
              for (let x = step; x < w - step; x += step) {
                const rx = gray[y * w + (x + step)] - gray[y * w + (x - step)];
                const ry = gray[(y + step) * w + x] - gray[(y - step) * w + x];
                const mag = Math.abs(rx) + Math.abs(ry);
                sharpSum += mag; sCount++;
              }
            }
            const sharpness = (sharpSum / Math.max(1, sCount)) / 255; // normalized
            return { brightness: meanL, sharpness };
          };

          const captureFrame = () => {
            const maxSide = 640;
            const scale = Math.min(1, maxSide / Math.max(video.videoWidth, video.videoHeight));
            const w = Math.max(1, Math.floor(video.videoWidth * scale));
            const h = Math.max(1, Math.floor(video.videoHeight * scale));
            canvas.width = w; canvas.height = h;
            ctx.drawImage(video, 0, 0, w, h);
            const imgData = ctx.getImageData(0, 0, w, h);
            const { brightness, sharpness } = computeMetrics(imgData, w, h);
            const base64 = canvas.toDataURL('image/jpeg', 0.7).split(',')[1];
            return { base64, brightness, sharpness, w, h };
          };

          const frames = [];
          for (const t of times) {
            try {
              await Promise.race([seekTo(t), timeoutPromise]);
              frames.push({ t, ...captureFrame() });
            } catch (e) { console.warn('Frame capture failed at', t, e); }
          }

          if (frames.length === 0) {
            await Promise.race([seekTo(Math.min(duration / 2, duration - 0.1)), timeoutPromise]);
            frames.push({ t: duration / 2, ...captureFrame() });
          }

          const scored = frames.map(f => ({
            ...f,
            quality: f.sharpness * 0.8 + (1 - Math.abs(f.brightness - 0.55)) * 0.2
          }))
          .sort((a, b) => b.quality - a.quality)
          .slice(0, Math.min(3, frames.length));

          const selectedExerciseData = exercises.find(ex => ex.id === selectedExercise);
          if (!selectedExerciseData) throw new Error('No exercise selected');

          const prompt = `You will analyze multiple frames from a video of a ${selectedExerciseData.name} exercise.

Use the sequence to judge posture, joint angles, and safety across the movement. Do not penalize for limited visible motion per frame; consider consistency across frames. If visibility is partial or lighting is poor, avoid overly low scores‚Äîprovide constructive feedback instead.

Focus on:
1. Body alignment and posture
2. Joint positioning and angles
3. Common mistakes to avoid
4. Specific improvements for better form
5. Safety considerations
6. Reference relevant FitMate features (e.g., Workout Planner videos for ${selectedExerciseData.name})

Respond ONLY with a valid JSON object in this exact format:
{
  "exercise_detected": "${selectedExerciseData.name}",
  "overall_score": 1-10,
  "form_analysis": {
    "posture": "...",
    "technique": "...",
    "safety": "..."
  },
  "feedback": {
    "positive_points": ["..."],
    "improvements": ["..."],
    "tips": ["..."]
  },
  "next_steps": "..."
}`;

          const contentImages = scored.map(s => ({ type: 'image_url', image_url: `data:image/jpeg;base64,${s.base64}` }));

          const response = await fetch(getDirectGeminiConfig().url, {
            method: 'POST',
            headers: getDirectGeminiConfig().headers,
            body: JSON.stringify({
              model: OPENROUTER_QWEN_VL_MODEL,
              messages: [{
                role: 'user',
                content: [
                  { type: 'text', text: prompt },
                  ...contentImages
                ]
              }]
            })
          });

          if (!response.ok) {
            const errorText = await response.text();
            console.error('API Error Response:', errorText);
            throw new Error(`API Error: ${response.status} ${response.statusText}`);
          }

          const result = await response.json();
          const textResponse = (result.choices?.[0]?.message?.content || '');
          if (!textResponse) throw new Error('Invalid API response format');

          let jsonString = textResponse.replace(/```json|```/g, '').trim();
          if (jsonString.includes('```')) {
            const jsonMatchMd = jsonString.match(/```(?:json)?\s*({[\s\S]*?})\s*```/);
            if (jsonMatchMd) jsonString = jsonMatchMd[1];
          }
          const jsonMatch = jsonString.match(/{[\s\S]*}/);
          if (jsonMatch) jsonString = jsonMatch[0];

          const data = JSON.parse(jsonString);

          if (!data.overall_score && data.overall_score !== 0) data.overall_score = 3;
          if (!data.form_analysis) {
            data.form_analysis = {
              posture: data.posture || 'Unable to analyze posture from this video.',
              technique: data.technique || 'Unable to assess technique from this video.',
              safety: data.safety || 'Please ensure proper form and safety when exercising.'
            };
          }
          if (!data.feedback) {
            data.feedback = {
              positive_points: data.positive_points || [],
              improvements: data.improvements || ['Please upload a clearer video showing the full exercise movement'],
              tips: data.tips || ['Ensure good lighting and clear view of your full body', 'Upload from a side or slightly angled perspective']
            };
          }
          if (data.exercise_detected && data.exercise_detected.toLowerCase().includes('no ') && data.exercise_detected.toLowerCase().includes('detected')) {
            const sel = exercises.find(ex => ex.id === selectedExercise);
            data.exercise_detected = sel ? sel.name : 'Exercise';
            data.overall_score = 2;
            data.feedback.improvements = [
              'The selected exercise was not clearly visible in the video',
              'Please ensure your full body is visible in the frame',
              'Use a side angle for clearer joint visibility',
              'Ensure adequate lighting and a clear background'
            ];
            data.feedback.tips = [
              'Place camera 6-8 feet away to capture full body',
              'Avoid backlighting; face the light source',
              'Perform the movement slowly with full range of motion',
              'Keep the camera stable at chest height'
            ];
            data.next_steps = 'Please upload another video with better positioning and lighting for accurate form analysis.';
          }
          if (!data.next_steps) data.next_steps = 'Continue practicing with proper form and consider uploading from different angles for comprehensive analysis.';

          setFormAnalysis(data);
        } catch (err) {
          console.error('Enhanced form analysis failed, falling back to single-frame:', err);
          try {
            await analyzeForm(videoBlob);
            return;
          } catch (fallbackErr) {
            console.error('Fallback analyzeForm also failed:', fallbackErr);
            setError('Could not analyze form. Please upload a clearer video.');
          }
        } finally {
          setIsLoading(false);
        }
      };
    }

    // Supabase Configuration
    const getSupabaseConfig = () => {
      // Replace these with your actual Supabase project URL and anon key
      return {
        url: 'https://bhtabgrcxaahkuwrdwec.supabase.co',
        anonKey: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJodGFiZ3JjeGFhaGt1d3Jkd2VjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgzNzc1MjMsImV4cCI6MjA3Mzk1MzUyM30._Cydy4B6QMF353OG8jnhK7juWgz2j4RirATIfCgAflQ'
      };
    };

    const supabaseConfig = getSupabaseConfig();

    // Initialize Supabase
    let supabase, auth, currentUser = null;
    const USERS_REALTIME_ENABLED = true;
    try {
      const { createClient } = window.supabase;
      supabase = createClient(supabaseConfig.url, supabaseConfig.anonKey);
      auth = supabase.auth;
      
      // Expose for console access (e.g., repair scripts)
      window.__fitmateSupabase = supabase;
      
      // Join a single realtime channel for AI-usage broadcasts
      try {
        if (!window.__aiUsageChannel) {
          window.__aiUsageChannel = supabase.channel('ai-usage');
          window.__aiUsageChannel.subscribe();
        }
      } catch(_) {}
      
      // Auth state change listener will be set up inside React component
    } catch (error) {
      console.log('Supabase not configured yet:', error.message);
      // Show user-friendly error message
      setTimeout(() => {
        const errorDiv = document.createElement('div');
        errorDiv.className = 'supabase-error';
        errorDiv.innerHTML = `
          <div style="position: fixed; top: 20px; left: 20px; right: 20px; background: #fee; border: 1px solid #fcc; color: #c33; padding: 15px; border-radius: 8px; z-index: 9999; font-family: Arial, sans-serif;">
            <strong>‚ö†Ô∏è Supabase Connection Issue:</strong><br>
            The app is running in offline mode. Some features may be limited.<br>
            <small>Error: ${error.message}</small>
          </div>
        `;
        document.body.appendChild(errorDiv);
        setTimeout(() => errorDiv.remove(), 10000);
      }, 1000);
    }

    // Helper: upload image data URL to Supabase Storage and return a public URL
    const uploadImageDataUrlToPublic = async (dataUrl, mimeType) => {
      try {
        if (!supabase || !supabase.storage) return null;
        const bucket = 'fitmate-images'; // Ensure this bucket exists and is public
        const ext = (mimeType && mimeType.split('/')[1]) || 'jpg';
        const filename = `ai/${Date.now()}_${Math.random().toString(36).slice(2)}.${ext}`;

        // Convert data URL to Blob
        const res = await fetch(dataUrl);
        const blob = await res.blob();

        const { data, error } = await supabase.storage
          .from(bucket)
          .upload(filename, blob, { contentType: mimeType, upsert: true });
        if (error) {
          console.warn('Supabase upload failed:', error.message || error);
          return null;
        }
        const { data: publicUrl } = supabase.storage
          .from(bucket)
          .getPublicUrl(filename);
        return (publicUrl && (publicUrl.publicUrl || publicUrl.publicURL || publicUrl)) || null;
      } catch (e) {
        console.warn('Upload to storage failed:', e);
        return null;
      }
    };

    // Database helper functions for Supabase
    const db = {
      // Helper function to clean and validate user data
      cleanUserData(data) {
        const cleaned = {};
        
        for (const [key, value] of Object.entries(data)) {
          // Skip null or undefined values
          if (value === null || value === undefined) {
            continue;
          }
          
          // Handle different data types
          if (typeof value === 'string') {
            // Ensure strings are not empty unless they should be
            if (value.trim() !== '' || ['profile_picture', 'habit_ai_advice'].includes(key)) {
              cleaned[key] = value;
            }
          } else if (typeof value === 'boolean') {
            cleaned[key] = value;
          } else if (typeof value === 'number') {
            cleaned[key] = value;
          } else if (typeof value === 'object') {
            // For JSONB fields, ensure they're valid JSON
            try {
              if (Array.isArray(value) || (value && typeof value === 'object')) {
                cleaned[key] = value;
              }
            } catch (e) {
              console.warn(`Skipping invalid JSON data for field ${key}:`, e);
            }
          }
        }
        
        return cleaned;
      },
      // User operations
      async createUser(userId, userData) {
        const { data, error } = await supabase
          .from('users')
          .insert([{ id: userId, ...userData }], { returning: 'minimal' });
        if (error) throw error;
        return data;
      },

      async getUser(userId) {
        const { data, error } = await supabase
          .from('users')
          .select('id, updated_at, goals, profile_picture, notifications_enabled, dark_mode, daily_intake, recent_meals, daily_history, coach_messages, habit_ai_advice, habits, meal_plan, workout_plan, scan_result, form_analysis, subscription, ai_usage')
          .eq('id', userId)
          .single();
        if (error && error.code !== 'PGRST116') throw error; // PGRST116 = not found
        return data;
      },

      async updateUser(userId, updates) {
        // Validate user ID
        if (!userId || typeof userId !== 'string') {
          throw new Error('Invalid user ID provided to updateUser');
        }
        
        // Ensure updated_at is always set to current timestamp
        const updateData = { ...updates };
        if (!updateData.updated_at) {
          updateData.updated_at = new Date().toISOString();
        }
        
        // Validate and clean data before sending to Supabase
        const cleanedData = this.cleanUserData(updateData);
        
        // SAFEGUARD: Deep-merge daily_history with existing remote value to avoid overwriting past days
        if (cleanedData && typeof cleanedData === 'object' && 'daily_history' in cleanedData) {
          try {
            const { data: existing, error: fetchErr } = await supabase
              .from('users')
              .select('daily_history')
              .eq('id', userId)
              .single();

            if (!fetchErr) {
              const current = (existing && existing.daily_history) || {};
              const patch = cleanedData.daily_history || {};
              // Merge by day key: remote retains past days, patch updates/adds current day
              const merged = { ...current, ...patch };
              cleanedData.daily_history = merged;
              try { console.log('üîß Merged daily_history before update', { userId, remoteDays: Object.keys(current).length, patchDays: Object.keys(patch).length, mergedDays: Object.keys(merged).length }); } catch (_) {}
            } else if (fetchErr && fetchErr.code !== 'PGRST116') {
              console.warn('daily_history prefetch failed, proceeding without merge:', fetchErr);
            }
          } catch (e) {
            console.warn('daily_history merge attempt failed, proceeding with provided payload:', e);
          }
        }
        
        // Don't update if no valid data to update
        if (Object.keys(cleanedData).length === 0) {
          console.log('No valid data to update, skipping');
          return [];
        }
        
        console.log('Updating user data:', { userId, cleanedData });
        
        const { data, error } = await supabase
          .from('users')
          .update(cleanedData, { returning: 'minimal' })
          .eq('id', userId);
        if (error) {
          console.error('Supabase update error:', error);
          throw error;
        }
        return data;
      },

      async upsertUser(userId, userData) {
        // Validate user ID
        if (!userId || typeof userId !== 'string') {
          throw new Error('Invalid user ID provided to upsertUser');
        }
        
        // Ensure updated_at is always set to current timestamp
        const upsertData = { id: userId, ...userData };
        if (!upsertData.updated_at) {
          upsertData.updated_at = new Date().toISOString();
        }
        
        // Validate and clean data before sending to Supabase
        const cleanedData = this.cleanUserData(upsertData);
        
        console.log('Upserting user data:', { userId, cleanedData });
        
        const { data, error } = await supabase
          .from('users')
          .upsert([cleanedData], { returning: 'minimal' });
        if (error) {
          console.error('Supabase upsert error:', error);
          throw error;
        }
        return data;
      },

      // Workout history operations
      async addWorkoutHistory(userId, workoutData) {
        const { data, error } = await supabase
          .from('workout_history')
          .insert([{ user_id: userId, ...workoutData }], { returning: 'minimal' });
        if (error) throw error;
        return data;
      },

      // Booking operations
      async addBooking(userId, bookingData) {
        const { data, error } = await supabase
          .from('bookings')
          .insert([{ user_id: userId, ...bookingData }], { returning: 'minimal' });
        if (error) throw error;
        return data;
      },

      async getBookings(userId) {
        const { data, error } = await supabase
          .from('bookings')
          .select('*')
          .eq('user_id', userId)
          .order('created_at', { ascending: false });
        if (error) throw error;
        return data || [];
      },

      async getGlobalBookings(date) {
        const { data, error } = await supabase
          .from('bookings')
          .select('date, time, status')
          .eq('date', date);
        if (error) throw error;
        return data || [];
      },

      // General query operations
      async query(table, options = {}) {
        let query = supabase.from(table).select(options.select || '*');
        
        if (options.eq) {
          for (const [column, value] of Object.entries(options.eq)) {
            query = query.eq(column, value);
          }
        }
        
        if (options.order) {
          query = query.order(options.order.column, { ascending: options.order.ascending !== false });
        }
        
        if (options.limit) {
          query = query.limit(options.limit);
        }
        
        const { data, error } = await query;
        if (error) throw error;
        return data || [];
      },

      // Real-time subscriptions (similar to Firebase's .on())
      subscribe(table, callback, options = {}) {
        let subscription = supabase
          .channel(`${table}_changes`)
          .on('postgres_changes', { 
            event: '*', 
            schema: 'public', 
            table: table,
            ...options 
          }, callback);
        
        subscription.subscribe();
        return subscription;
      }
    };

    // Authentication Context
    const AuthContext = React.createContext();

    const AuthProvider = ({ children }) => {
      const [user, setUser] = useState(null);
      const [loading, setLoading] = useState(true);
      const [authError, setAuthError] = useState(null);
      const forceNextRemoteOnlyRef = useRef(false);
      // Track when remote data has been applied at least once on this device
      const authInitialRemoteAppliedRef = useRef(false);

      // Expose current user on window for console access (e.g., repair scripts)
      useEffect(() => {
        window.__fitmateUser = user;
      }, [user]);

      useEffect(() => {
        if (!auth) {
          setLoading(false);
          return;
        }

        // Get initial session
        auth.getSession().then(({ data: { session } }) => {
          setUser(session?.user || null);
          setLoading(false);
          if (session?.user) {
            // Sync user data when authenticated
            // Treat initial session like a sign-in for one cycle: fetch remote only
            forceNextRemoteOnlyRef.current = true;
            // Purge local profile so we only accept remote
            try { clearLocalProfileForRemoteOnly(); } catch (_) {}
            syncUserData(session.user);
          }
        });

        // Mark remote applied completion when event fires (initial or realtime)
        const onRemoteApplied = () => { authInitialRemoteAppliedRef.current = true; };
        window.addEventListener('remoteDataApplied', onRemoteApplied);

        // Listen for auth state changes
        const { data: { subscription } } = auth.onAuthStateChange((event, session) => {
          const currentUser = session?.user || null;
          setUser(currentUser);
          setLoading(false);
          
          if (currentUser) {
            console.log('User signed in:', currentUser.id);
            // Enforce remote-only fetch on explicit sign-in events
            if (event === 'SIGNED_IN') {
              try { auth.signOut({ scope: 'others' }); } catch (_) {}
              forceNextRemoteOnlyRef.current = true;
              // Purge local profile so we only accept remote
              try { clearLocalProfileForRemoteOnly(); } catch (_) {}
              // DO NOT clear aiUsage on sign-in - use handshake to sync MAX value across devices
            }
            // Sync user data when authenticated
            syncUserData(currentUser);
          } else {
            console.log('User signed out');
            // Force UI to reflect signed-out state immediately
            try { localStorage.setItem('subscriptionActive', JSON.stringify(false)); } catch (_) {}
            try { window.dispatchEvent(new CustomEvent('subscription-status-changed', { detail: { active: false } })); } catch (_) {}
            try { window.dispatchEvent(new CustomEvent('ads-control', { detail: { enabled: true } })); } catch (_) {}
            // Only clear aiUsage on an explicit SIGNED_OUT event; preserve counts on initial load
            if (event === 'SIGNED_OUT') {
              try { localStorage.removeItem('aiUsage'); } catch (_) {}
              try { localStorage.removeItem('dailyIntake'); } catch (_) {}
              try { localStorage.removeItem('recentMeals'); } catch (_) {}
              try { localStorage.removeItem('dailyHistory'); } catch (_) {}
              try { localStorage.removeItem('workoutHistory'); } catch (_) {}
              try { localStorage.removeItem('goals'); } catch (_) {}
            }
            try { window.dispatchEvent(new Event('userDataSynced')); } catch (_) {}
          }
          // Surface password recovery flow even if URL lacks type=recovery
          if (event === 'PASSWORD_RECOVERY') {
            try {
              window.dispatchEvent(new CustomEvent('supabase-password-recovery', { detail: { session } }));
            } catch (_) { /* no-op */ }
          }
        });

        return () => {
          subscription?.unsubscribe();
          window.removeEventListener('remoteDataApplied', onRemoteApplied);
        };
      }, [auth]);

      const createInitialUserDocument = async (user) => {
        if (!supabase) return;
        
        try {
          // Ensure we have a valid session before creating user document
          const { data: { session } } = await auth.getSession();
          if (!session?.user) {
            console.log('‚è≥ No valid session found, skipping user document creation');
            return;
          }
          
          await db.upsertUser(user.id, {
            // Basic user info
            display_name: user.user_metadata?.display_name || user.email?.split('@')[0] || 'User',
            email: user.email,
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString(),
            
            // Profile data
            goals: JSON.parse(localStorage.getItem('goals') || '{}'),
            // profile_picture omitted to avoid overwriting remote value during remote-only mode,
            notifications_enabled: JSON.parse(localStorage.getItem('notificationsEnabled') || 'true'),
            dark_mode: JSON.parse(localStorage.getItem('fitmate-dark-mode') || 'false'),
            
            // Fitness data
            daily_intake: JSON.parse(localStorage.getItem('dailyIntake') || '{"calories":0,"protein":0,"carbs":0,"fat":0,"activity":0,"water":0}'),
            recent_meals: (() => { try { const meals = JSON.parse(localStorage.getItem('recentMeals') || '[]') || []; const todayISO = toLocalISODate(new Date()); return Array.isArray(meals) ? meals.filter(m => m && m.__day === todayISO) : []; } catch { return []; } })(),
            daily_history: JSON.parse(localStorage.getItem('dailyHistory') || '{}'),
            
            // AI and coaching data
            coach_messages: JSON.parse(localStorage.getItem('coachMessages') || '[{"text":"Hello! I\'m your AI Health Coach. Ask me anything about your nutrition or meals.","sender":"ai"}]'),
            habit_ai_advice: localStorage.getItem('habitAIAdvice') || '',
            habits: JSON.parse(localStorage.getItem('habits') || '[]'),
            
            // AI-generated content
            meal_plan: JSON.parse(localStorage.getItem('mealPlan') || 'null'),
            workout_plan: JSON.parse(localStorage.getItem('workoutPlan') || 'null'),
            // workout_history: JSON.parse(localStorage.getItem('workoutHistory') || '[]'), // Removed - using separate table
            scan_result: JSON.parse(localStorage.getItem('scanResult') || 'null'),
            form_analysis: JSON.parse(localStorage.getItem('formAnalysis') || 'null'),
            
            // AI usage tracking removed - using localStorage only for quota sync
          });
          console.log('‚úÖ Comprehensive user document created in Supabase Database');
        } catch (error) {
          console.error('Error creating initial user document:', error);
          console.error('Error details:', {
            message: error.message,
            code: error.code,
            details: error.details,
            hint: error.hint
          });
        }
      };

      // Helper function to detect if local data has meaningful content (not just defaults)
      const hasMeaningfulLocalData = () => {
        // Check if we have any meaningful data in localStorage
        const goals = JSON.parse(localStorage.getItem('goals') || '{}');
        const dailyIntake = JSON.parse(localStorage.getItem('dailyIntake') || '{}');
        const recentMeals = JSON.parse(localStorage.getItem('recentMeals') || '[]');
        const dailyHistory = JSON.parse(localStorage.getItem('dailyHistory') || '{}');
        const coachMessages = JSON.parse(localStorage.getItem('coachMessages') || '[]');
        const habits = JSON.parse(localStorage.getItem('habits') || '[]');
        const mealPlan = JSON.parse(localStorage.getItem('mealPlan') || 'null');
        const workoutPlan = JSON.parse(localStorage.getItem('workoutPlan') || 'null');
        
        // Check if any of these have meaningful content
        const isDefaultGoals = (() => { try { return JSON.stringify(goals) === JSON.stringify(defaultGoals); } catch { return false; } })();
        const hasGoals = Object.keys(goals).length > 0 && !isDefaultGoals;
        const hasIntake = dailyIntake.calories > 0 || dailyIntake.protein > 0 || dailyIntake.carbs > 0 || dailyIntake.fat > 0 || dailyIntake.activity > 0 || dailyIntake.water > 0;
        const hasMeals = recentMeals.length > 0;
        const hasHistory = Object.keys(dailyHistory).length > 0;
        const hasCoachMessages = coachMessages.length > 1; // More than just the default welcome message
        const hasHabits = habits.length > 0;
        const hasMealPlan = mealPlan !== null && mealPlan !== 'null';
        const hasWorkoutPlan = workoutPlan !== null && workoutPlan !== 'null';
        
        return hasGoals || hasIntake || hasMeals || hasHistory || hasCoachMessages || hasHabits || hasMealPlan || hasWorkoutPlan;
      };

      // Purge local profile data so sign-in starts from remote source of truth,
      // but preserve today's intake and meals to avoid score drops after midnight reset
      const clearLocalProfileForRemoteOnly = () => {
        const keys = [
          'goals',
          'dailyHistory'
        ];
        // Preserve 'dailyIntake' and 'recentMeals' along with 'dailyIntakeDate' and 'lastSavedDate'
        keys.forEach(k => { try { localStorage.removeItem(k); } catch (_) {} });
      };

      const syncUserData = async (u, retryCount = 0) => {
        if (!supabase) {
          console.log('Supabase Database not available - data will be stored locally only');
          return;
        }
        const effectiveUser = u || currentUser || user;
        if (!effectiveUser || !effectiveUser.id) {
          console.log('No authenticated user found for sync; skipping.');
          return;
        }
        
        // If set, enforce a one-time remote-only fetch (no local->remote writes)
        const remoteOnly = forceNextRemoteOnlyRef?.current === true;
        if (remoteOnly) {
          console.log('üîí Remote-only sync mode is active for this sign-in.');
        }
        
        try {
          console.log('üîç Starting sync process for user:', effectiveUser.id);
          const userData = await db.getUser(effectiveUser.id);
          console.log('üìä Remote user data received:', userData ? 'YES' : 'NO');
          
          if (userData) {
            const localLastSync = localStorage.getItem('lastSyncTimestamp');
            const remoteLastSync = userData.updated_at;
            const localLastSyncTs = localLastSync ? parseInt(localLastSync) : 0;
            const remoteLastSyncTs = remoteLastSync ? new Date(remoteLastSync).getTime() : 0;
            
            console.log('üîÑ Intelligent sync - comparing timestamps...');
            console.log('Local last sync:', localLastSync);
            console.log('Remote last sync:', remoteLastSync);
            console.log('üìä Remote data summary:', {
              hasGoals: !!userData.goals,
              hasDailyIntake: !!userData.daily_intake,
              hasRecentMeals: !!userData.recent_meals,
              hasDailyHistory: !!userData.daily_history,
              hasProfilePicture: !!userData.profile_picture,
              updatedAt: userData.updated_at
            });
            
            // Enhanced sync logic: prioritize remote data for new devices
            const isNewDevice = !localLastSync;
            const hasLocalData = hasMeaningfulLocalData();
            const remoteIsNewer = remoteLastSyncTs > localLastSyncTs;
            
            console.log('üîç Local data analysis:', {
              isNewDevice,
              hasLocalData,
              remoteIsNewer,
              localGoals: JSON.parse(localStorage.getItem('goals') || '{}'),
              localDailyIntake: JSON.parse(localStorage.getItem('dailyIntake') || '{}'),
              localRecentMeals: JSON.parse(localStorage.getItem('recentMeals') || '[]')
            });
            
            // Always sync from remote if:
            // 1. This is a new device (no local sync timestamp), OR
            // 2. Remote data is newer than local, OR
            // 3. Local data is empty/default (no meaningful content)
            const shouldSyncFromRemote = remoteOnly || isNewDevice || remoteIsNewer || !hasLocalData;
            
            console.log('üìä Sync decision factors:', {
              isNewDevice,
              hasLocalData,
              remoteIsNewer,
              shouldSyncFromRemote
            });
            
            if (shouldSyncFromRemote) {
              console.log('üì• Syncing newer data from remote to local');
              console.log('üìä Remote data received:', {
                hasGoals: !!userData.goals,
                hasDailyIntake: !!userData.daily_intake,
                hasRecentMeals: !!userData.recent_meals,
                hasDailyHistory: !!userData.daily_history,
                hasProfilePicture: !!userData.profile_picture,
                hasNotifications: userData.notifications_enabled !== undefined,
                hasDarkMode: userData.dark_mode !== undefined
              });
              
              // Sync all user data to localStorage
              if (userData.goals) {
                localStorage.setItem('goals', JSON.stringify(userData.goals));
                console.log('‚úÖ Goals synced to localStorage');
              }
              if (userData.profile_picture) {
                localStorage.setItem('profilePicture', userData.profile_picture);
                console.log('‚úÖ Profile picture synced to localStorage');
              }
              if (userData.notifications_enabled !== undefined) {
                localStorage.setItem('notificationsEnabled', JSON.stringify(userData.notifications_enabled));
                console.log('‚úÖ Notifications setting synced to localStorage');
              }
              
              // Sync additional user data - REMOTE-ONLY on sign-in (like workout_history)
              if (remoteOnly) {
                // Remote-only: guard overwrites after reset; otherwise set from remote
                if (userData.daily_intake) {
                  try {
                    const todayISO = toLocalISODate(new Date());
                    const remoteUpdateIsToday = !!userData.updated_at && toLocalISODate(new Date(userData.updated_at)) === todayISO;
                    const remoteDayStamp = userData.daily_intake?.__day;
                    const remoteDayMatchesToday = remoteDayStamp ? (remoteDayStamp === todayISO) : remoteUpdateIsToday;
                    const resetAt = parseInt(localStorage.getItem('midnightResetAt') || '0');
                    const remoteTs = userData.updated_at ? new Date(userData.updated_at).getTime() : 0;
                    const remoteOlderThanReset = resetAt && remoteTs && (remoteTs <= resetAt);
                    if (!remoteDayMatchesToday || remoteOlderThanReset) {
                      console.log(remoteOlderThanReset ? '‚è≠Ô∏è Remote-only: skipping remote daily_intake (stale vs midnight reset)' : '‚è≠Ô∏è Remote-only: skipping remote daily_intake (day stamp mismatch)');
                      // Archive past-day intake to history
                      try {
                        if (remoteDayStamp && remoteDayStamp !== todayISO) {
                          const remoteHasNonZero = ['calories','protein','carbs','fat','activity','water'].some(k => Number(userData.daily_intake?.[k]||0) > 0);
                          if (remoteHasNonZero) {
                            const dh = (() => { try { return JSON.parse(localStorage.getItem('dailyHistory')||'{}')||{}; } catch { return {}; } })();
                            const prev = dh[remoteDayStamp] || {};
                            const prevIntake = prev.intake || {};
                            dh[remoteDayStamp] = { ...prev, intake: { ...prevIntake, ...userData.daily_intake } };
                            localStorage.setItem('dailyHistory', JSON.stringify(dh));
                            console.log('üì¶ Remote-only: archived remote intake into history for past day', remoteDayStamp);
                          }
                        }
                      } catch (_) {}
                    } else {
                      const localIntakeDate = localStorage.getItem('dailyIntakeDate');
                      const lastSaved = localStorage.getItem('lastSavedDate');
                      const rolledToToday = (localIntakeDate === todayISO && lastSaved === todayISO);
                      const currentLocal = (() => { try { return JSON.parse(localStorage.getItem('dailyIntake') || '{}') || {}; } catch { return {}; } })();
                      const localIsZero = ['calories','protein','carbs','fat','activity','water'].every(k => Number(currentLocal[k]||0) === 0);
                      const remoteHasNonZero = ['calories','protein','carbs','fat','activity','water'].some(k => Number(userData.daily_intake?.[k]||0) > 0);
                      const localMeals = (() => { try { return JSON.parse(localStorage.getItem('recentMeals') || '[]') || []; } catch { return []; } })();
                      const localHasStarted = !localIsZero || (Array.isArray(localMeals) && localMeals.length > 0);
                      // Accept today's remote intake on sign-in to enable immediate cross-device sync
                      const merged = {
                        ...userData.daily_intake,
                        // Monotonic today-only merge: keep the higher values to avoid backtracks
                        activity: Math.max(Number(userData.daily_intake?.activity || 0), Number(currentLocal.activity || 0)),
                        water: Math.max(Number(userData.daily_intake?.water || 0), Number(currentLocal.water || 0))
                      };
                      localStorage.setItem('dailyIntake', JSON.stringify(merged));
                      console.log('üîí Remote-only: set daily_intake from remote (activity/water monotonic; cross-device sync enabled)');
                    }
                  } catch (_) {
                    console.log('‚ö†Ô∏è Remote-only: intake import failed; leaving local untouched');
                  }
                }
                if (userData.recent_meals) {
                  try {
                    const todayISO = toLocalISODate(new Date());
                    const remoteUpdateIsToday = !!userData.updated_at && toLocalISODate(new Date(userData.updated_at)) === todayISO;
                    if (!remoteUpdateIsToday) {
                      console.log('‚è≠Ô∏è Remote-only: skipping recent_meals (updated_at not today)');
                    } else {
                      const lastSyncTs = parseInt(localStorage.getItem('lastSyncTimestamp') || '0');
                      const remoteTs = userData.updated_at ? new Date(userData.updated_at).getTime() : 0;
                      const remoteOlderThanLocalWrite = !!lastSyncTs && !!remoteTs && remoteTs <= lastSyncTs;
                      if (remoteOlderThanLocalWrite) {
                        console.log('‚è≠Ô∏è Remote-only: skipping recent_meals (local newer write)');
                      } else {
                        const localIntakeDate = localStorage.getItem('dailyIntakeDate');
                        const lastSaved = localStorage.getItem('lastSavedDate');
                        const rolledToToday = (localIntakeDate === todayISO && lastSaved === todayISO);
                        const localMeals = (() => { try { return JSON.parse(localStorage.getItem('recentMeals') || '[]') || []; } catch { return []; } })();
                        const localIsEmpty = !Array.isArray(localMeals) || localMeals.length === 0;
                        const remoteHasMeals = Array.isArray(userData.recent_meals) && userData.recent_meals.length > 0;
                        if (rolledToToday && localIsEmpty && remoteHasMeals) {
                          console.log('‚è≠Ô∏è Remote-only: skipping recent_meals overwrite after local midnight reset');
                        } else {
                          const todaysMeals = (Array.isArray(userData.recent_meals) ? userData.recent_meals.filter(m => m && m.__day === todayISO) : []);
                          const byId = new Map((Array.isArray(localMeals) ? localMeals : []).map(m => [m && m.id, m]).filter(([id]) => id !== undefined && id !== null));
                          const patched = todaysMeals.map(m => {
                            const local = byId.get(m && m.id);
                            const remoteImg = m && m.image;
                            const isMissing = !remoteImg || (typeof remoteImg === 'string' && remoteImg.indexOf('placehold.co') !== -1);
                            if (local && isMissing && local.image) return { ...m, image: local.image };
                            return m;
                          });
                          localStorage.setItem('recentMeals', JSON.stringify(patched));
                          console.log('üîí Remote-only: set recent_meals from remote');
                        }
                      }
                    }
                  } catch (_) {
                    const todayISO = toLocalISODate(new Date());
                    const todaysMeals = (Array.isArray(userData.recent_meals) ? userData.recent_meals.filter(m => m && m.__day === todayISO) : []);
                    localStorage.setItem('recentMeals', JSON.stringify(todaysMeals));
                    console.log('üîí Remote-only: set recent_meals from remote');
                  }
                }
                if (userData.daily_history) {
                  try {
                    const localHistory = (() => { try { return JSON.parse(localStorage.getItem('dailyHistory') || '{}') || {}; } catch { return {}; } })();
                    const remoteHistory = userData.daily_history || {};
                    
                    // Remote-only past days: prefer remote for all past days, keep current day local
                    const todayISO = toLocalISODate(new Date());
                    const merged = { ...remoteHistory }; // Start with remote data
                    
                    // Only preserve local data for today
                    if (localHistory[todayISO]) {
                      merged[todayISO] = localHistory[todayISO];
                    }
                    
                    localStorage.setItem('dailyHistory', JSON.stringify(merged));
                    console.log('üîí Remote-only: merged daily_history (prefer remote for past days, local for today)');
                  } catch (_) {
                    localStorage.setItem('dailyHistory', JSON.stringify(userData.daily_history));
                    console.log('üîí Remote-only: set daily_history from remote');
                  }
                }
              } else {
                // Normal sync: guard overwrites after reset; otherwise merge
                if (userData.daily_intake) {
                  try {
                    const todayISO = toLocalISODate(new Date());
                    const remoteUpdateIsToday = !!userData.updated_at && toLocalISODate(new Date(userData.updated_at)) === todayISO;
                    const remoteDayStamp = userData.daily_intake?.__day;
                    const remoteDayMatchesToday = remoteDayStamp ? (remoteDayStamp === todayISO) : remoteUpdateIsToday;
                    const resetAt = parseInt(localStorage.getItem('midnightResetAt') || '0');
                    const remoteTs = userData.updated_at ? new Date(userData.updated_at).getTime() : 0;
                    const remoteOlderThanReset = resetAt && remoteTs && (remoteTs <= resetAt);
                    if (!remoteDayMatchesToday || remoteOlderThanReset) {
                      console.log(remoteOlderThanReset ? '‚è≠Ô∏è Normal sync: skipping remote daily_intake (stale vs midnight reset)' : '‚è≠Ô∏è Normal sync: skipping remote daily_intake (day stamp mismatch)');
                      // Archive past-day intake to history
                      try {
                        if (remoteDayStamp && remoteDayStamp !== todayISO) {
                          const remoteHasNonZero = ['calories','protein','carbs','fat','activity','water'].some(k => Number(userData.daily_intake?.[k]||0) > 0);
                          if (remoteHasNonZero) {
                            const dh = (() => { try { return JSON.parse(localStorage.getItem('dailyHistory')||'{}')||{}; } catch { return {}; } })();
                            const prev = dh[remoteDayStamp] || {};
                            const prevIntake = prev.intake || {};
                            dh[remoteDayStamp] = { ...prev, intake: { ...prevIntake, ...userData.daily_intake } };
                            localStorage.setItem('dailyHistory', JSON.stringify(dh));
                            console.log('üì¶ Normal sync: archived remote intake into history for past day', remoteDayStamp);
                          }
                        }
                      } catch (_) {}
                    } else {
                      const localIntakeDate = localStorage.getItem('dailyIntakeDate');
                      const lastSaved = localStorage.getItem('lastSavedDate');
                      const rolledToToday = (localIntakeDate === todayISO && lastSaved === todayISO);
                      const currentLocal = (() => { try { return JSON.parse(localStorage.getItem('dailyIntake') || '{}') || {}; } catch { return {}; } })();
                      const localIsZero = ['calories','protein','carbs','fat','activity','water'].every(k => Number(currentLocal[k]||0) === 0);
                      const remoteHasNonZero = ['calories','protein','carbs','fat','activity','water'].some(k => Number(userData.daily_intake?.[k]||0) > 0);
                      if (rolledToToday && localIsZero && remoteHasNonZero) {
                        console.log('‚è≠Ô∏è Normal sync: skipping remote daily_intake after midnight reset (no overwrites)');
                      } else {
                        const lastSyncTs = parseInt(localStorage.getItem('lastSyncTimestamp') || '0');
                        const remoteOlderThanLocalWrite = !!lastSyncTs && !!remoteTs && remoteTs <= lastSyncTs;
                        if (remoteOlderThanLocalWrite) {
                          console.log('‚è≠Ô∏è Normal sync: skipping remote daily_intake (local newer write)');
                        } else {
                          const merged = { 
                            ...userData.daily_intake, 
                            // Monotonic today-only merge: keep the higher values to avoid backtracks
                            activity: Math.max(Number(userData.daily_intake?.activity || 0), Number(currentLocal.activity || 0)),
                            water: Math.max(Number(userData.daily_intake?.water || 0), Number(currentLocal.water || 0))
                          };
                          localStorage.setItem('dailyIntake', JSON.stringify(merged));
                          console.log('‚úÖ Daily intake synced (activity/water monotonic merge)');
                        }
                      }
                    }
                  } catch (_) {
                    console.log('‚ö†Ô∏è Normal sync: intake merge failed; leaving local untouched');
                  }
                }
                if (userData.recent_meals) {
                  try {
                    const todayISO = toLocalISODate(new Date());
                    const remoteUpdateIsToday = !!userData.updated_at && toLocalISODate(new Date(userData.updated_at)) === todayISO;
                    if (!remoteUpdateIsToday) {
                      console.log('‚è≠Ô∏è Normal sync: skipping remote recent_meals (updated_at not today)');
                    } else {
                      const lastSyncTs = parseInt(localStorage.getItem('lastSyncTimestamp') || '0');
                      const remoteTs = userData.updated_at ? new Date(userData.updated_at).getTime() : 0;
                      const remoteOlderThanLocalWrite = !!lastSyncTs && !!remoteTs && remoteTs <= lastSyncTs;
                      if (remoteOlderThanLocalWrite) {
                        console.log('‚è≠Ô∏è Normal sync: skipping remote recent_meals (local newer write)');
                      } else {
                        const localIntakeDate = localStorage.getItem('dailyIntakeDate');
                        const lastSaved = localStorage.getItem('lastSavedDate');
                        const rolledToToday = (localIntakeDate === todayISO && lastSaved === todayISO);
                        const localMeals = (() => { try { return JSON.parse(localStorage.getItem('recentMeals') || '[]') || []; } catch { return []; } })();
                        const localIsEmpty = !Array.isArray(localMeals) || localMeals.length === 0;
                        const remoteHasMeals = Array.isArray(userData.recent_meals) && userData.recent_meals.length > 0;
                        if (rolledToToday && localIsEmpty && remoteHasMeals) {
                          console.log('‚è≠Ô∏è Skipping remote recent_meals to prevent post-rollover flicker');
                        } else {
                          const todaysMeals = (Array.isArray(userData.recent_meals) ? userData.recent_meals.filter(m => m && m.__day === todayISO) : []);
                          const byId = new Map((Array.isArray(localMeals) ? localMeals : []).map(m => [m && m.id, m]).filter(([id]) => id !== undefined && id !== null));
                          const patched = todaysMeals.map(m => {
                            const local = byId.get(m && m.id);
                            const remoteImg = m && m.image;
                            const isMissing = !remoteImg || (typeof remoteImg === 'string' && remoteImg.indexOf('placehold.co') !== -1);
                            if (local && isMissing && local.image) return { ...m, image: local.image };
                            return m;
                          });
                          localStorage.setItem('recentMeals', JSON.stringify(patched));
                          console.log('‚úÖ Recent meals synced to localStorage');
                        }
                      }
                    }
                  } catch (_) {
                    const todayISO = toLocalISODate(new Date());
                    const todaysMeals = (Array.isArray(userData.recent_meals) ? userData.recent_meals.filter(m => m && m.__day === todayISO) : []);
                    localStorage.setItem('recentMeals', JSON.stringify(todaysMeals));
                    console.log('‚úÖ Recent meals synced to localStorage');
                  }
                }
                if (userData.daily_history) {
                  try {
                    const localDH = JSON.parse(localStorage.getItem('dailyHistory') || '{}') || {};
                    const remoteHistory = userData.daily_history || {};
                    
                    // Remote-only past days: prefer remote for all past days, keep current day local
                    const todayISO = toLocalISODate(new Date());
                    const merged = { ...remoteHistory }; // Start with remote data
                    
                    // Only preserve local data for today
                    if (localDH[todayISO]) {
                      merged[todayISO] = localDH[todayISO];
                    }
                    
                    localStorage.setItem('dailyHistory', JSON.stringify(merged));
                    console.log('‚úÖ Daily history merged to localStorage (prefer remote for past days, local for today)');
                  } catch (_) {
                    localStorage.setItem('dailyHistory', JSON.stringify(userData.daily_history));
                    console.log('‚úÖ Daily history synced to localStorage');
                  }
                }
              }
              if (userData.coach_messages) {
                localStorage.setItem('coachMessages', JSON.stringify(userData.coach_messages));
                console.log('‚úÖ Coach messages synced to localStorage');
              }
              if (userData.habit_ai_advice) {
                localStorage.setItem('habitAIAdvice', userData.habit_ai_advice);
                console.log('‚úÖ Habit AI advice synced to localStorage');
              }
              if (userData.habits) {
                localStorage.setItem('habits', JSON.stringify(userData.habits));
                console.log('‚úÖ Habits synced to localStorage');
              }
              if (userData.subscription) {
                try { localStorage.setItem('subscriptionActive', JSON.stringify(!!userData.subscription.active)); } catch (_) {}
                try { window.dispatchEvent(new CustomEvent('subscription-status-changed', { detail: { active: !!userData.subscription.active } })); } catch (_) {}
              }
              
              // AI usage: remote-authoritative merge with local using MAX across all dates
              try {
                const remoteUsage = (userData && userData.ai_usage) ? userData.ai_usage : {};
                const localUsage = (() => { try { return JSON.parse(localStorage.getItem('aiUsage') || '{}') || {}; } catch { return {}; } })();
                const merged = {};

                // First, copy remote into merged
                Object.keys(remoteUsage || {}).forEach(date => {
                  merged[date] = { ...(remoteUsage[date] || {}) };
                });

                // Re-key 'anon' to user across all dates in local, then MAX against remote
                const uid = effectiveUser.id;
                Object.keys(localUsage || {}).forEach(date => {
                  if (!merged[date]) merged[date] = {};
                  const l = localUsage[date] || {};
                  const localAnon = Number(l['anon'] || 0);
                  const localUser = Number(l[uid] || 0);
                  const localMaxForUser = Math.max(localAnon, localUser);
                  const remoteUser = Number((merged[date] && merged[date][uid]) || 0);
                  const maxForUser = Math.max(remoteUser, localMaxForUser);
                  if (maxForUser > 0) merged[date][uid] = maxForUser;

                  // Also take MAX for any other keys present (future-proofing shared devices)
                  Object.keys(l).forEach(k => {
                    const lc = Number(l[k] || 0);
                    const rc = Number((merged[date] && merged[date][k]) || 0);
                    if (lc > rc) merged[date][k] = lc;
                  });
                });

                // Persist merged to local
                localStorage.setItem('aiUsage', JSON.stringify(merged));

                // If remote differs, write merged back to DB to make it authoritative
                const remoteStr = JSON.stringify(remoteUsage || {});
                const mergedStr = JSON.stringify(merged);
                if (remoteStr !== mergedStr) {
                  try { await db.updateUser(uid, { ai_usage: merged }); } catch (e) { console.warn('AI usage: failed to persist merged to DB', e); }
                }
                console.log('‚úÖ AI usage merged (remote-first MAX) and persisted');
              } catch (err) {
                console.error('Error syncing AI usage:', err);
              }
              
              // Skip syncing dark_mode from remote - it's a local UI preference
              // if (userData.dark_mode !== undefined) {
              //   localStorage.setItem('fitmate-dark-mode', userData.dark_mode.toString());
              //   console.log('‚úÖ Dark mode setting synced to localStorage');
              // }
              
              // Sync AI-generated content
              if (userData.meal_plan) {
                localStorage.setItem('mealPlan', JSON.stringify(userData.meal_plan));
                console.log('‚úÖ Meal plan synced to localStorage');
              }
              if (userData.workout_plan) {
                localStorage.setItem('workoutPlan', JSON.stringify(userData.workout_plan));
                console.log('‚úÖ Workout plan synced to localStorage');
              }
              // Special handling for workout_history
              if (remoteOnly) {
                try {
                  // Remote-only: fetch remote history and set locally (no merge, no local upsert)
                  const { data: remoteHistory, error: historyError } = await supabase
                    .from('workout_history')
                    .select('id, user_id, timestamp, duration, exercises_completed, total_exercises, completion_rate, type, workout_title, workout_level, incomplete')
                    .eq('user_id', effectiveUser.id)
                    .order('timestamp', { ascending: false })
                    .limit(100);

                  if (historyError) throw historyError;

                  localStorage.setItem('workoutHistory', JSON.stringify(remoteHistory || []));
                  setWorkoutHistory(remoteHistory || []);
                  console.log('üîí Remote-only: set workout history from remote without merging');

                } catch (error) {
                  console.error('Remote-only workout history fetch failed:', error);
                }
              } else {
                try {
                  // First, get local history that hasn't been synced to Supabase
                  const localHistory = JSON.parse(localStorage.getItem('workoutHistory') || '[]');
                  
                  // If we have local history, sync it to Supabase first
                  if (localHistory.length > 0) {
                    try {
                      // Get the most recent local workout timestamp
                      const mostRecentLocal = localHistory[0]?.timestamp;
                      
                      // Find workouts that don't exist in Supabase yet
                      const { data: recentRemoteWorkouts, error: fetchError } = await supabase
                        .from('workout_history')
                        .select('timestamp')
                        .eq('user_id', effectiveUser.id)
                        .gte('timestamp', new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString()) // Last 30 days
                        .order('timestamp', { ascending: false });
                        
                      if (fetchError) throw fetchError;
                      
                      const remoteTimestamps = new Set(recentRemoteWorkouts?.map(w => w.timestamp) || []);
                      const workoutsToSync = localHistory.filter(w => w.timestamp && !remoteTimestamps.has(w.timestamp));
                      
                      // Sync any missing workouts to Supabase
                      if (workoutsToSync.length > 0) {
                        const { error: syncError } = await supabase
                          .from('workout_history')
                          .upsert(
                            workoutsToSync.map(workout => ({
                              ...workout,
                              user_id: effectiveUser.id,
                              // Ensure all required fields have default values
                              duration: workout.duration || 0,
                              calories_burned: workout.calories_burned || 0,
                              exercises_completed: workout.exercises_completed || 0,
                              workout_title: workout.workout_title || 'Custom Workout',
                              created_at: workout.timestamp || new Date().toISOString()
                            })),
                            { onConflict: 'user_id,timestamp' }
                          );
                          
                        if (syncError) throw syncError;
                        console.log(`‚úÖ Synced ${workoutsToSync.length} local workouts to Supabase`);
                      }
                    } catch (syncError) {
                      console.error('Error syncing local workouts to Supabase:', syncError);
                    }
                  }
                  
                  // Now fetch complete history from Supabase
                  const { data: remoteHistory, error: historyError } = await supabase
                    .from('workout_history')
                    .select('id, user_id, timestamp, duration, exercises_completed, total_exercises, completion_rate, type, workout_title, workout_level, incomplete')
                    .eq('user_id', effectiveUser.id)
                    .order('timestamp', { ascending: false })
                    .limit(100); // Get more history for better sync

                  if (historyError) throw historyError;
                  
                  // If no remote history, keep local history
                  if (!remoteHistory || remoteHistory.length === 0) {
                    if (localHistory.length > 0) {
                      localStorage.setItem('workoutHistory', JSON.stringify(localHistory));
                      console.log('Using local workout history (no remote data)');
                    }
                    return;
                  }
                  
                  // If no local history, use remote
                  if (localHistory.length === 0) {
                    localStorage.setItem('workoutHistory', JSON.stringify(remoteHistory));
                    setWorkoutHistory(remoteHistory);
                    console.log('Using remote workout history (no local data)');
                    return;
                  }
                  
                  // Merge both histories, preferring remote data in case of conflicts
                  const historyMap = new Map();
                  
                  // Add remote workouts to map first (lower priority)
                  remoteHistory.forEach(workout => {
                    if (workout.timestamp) {
                      historyMap.set(workout.timestamp, workout);
                    }
                  });
                  
                  // Add local workouts (will only add if timestamp doesn't exist in remote)
                  localHistory.forEach(workout => {
                    if (workout.timestamp && !historyMap.has(workout.timestamp)) {
                      historyMap.set(workout.timestamp, workout);
                    }
                  });

                  // Convert map back to array and sort by timestamp
                  let mergedHistory = Array.from(historyMap.values())
                    .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))
                    .slice(0, 100); // Keep most recent 100 workouts

                  // Save merged history
                  localStorage.setItem('workoutHistory', JSON.stringify(mergedHistory));
                  setWorkoutHistory(mergedHistory);
                  console.log(`‚úÖ Workout history synced: ${mergedHistory.length} workouts`);
                  
                } catch (error) {
                  console.error('Error syncing workout history:', error);
                  // If sync fails, keep using local history
                  const localHistory = JSON.parse(localStorage.getItem('workoutHistory') || '[]');
                  setWorkoutHistory(localHistory);
                }
              }

              if (userData.scan_result) {
                localStorage.setItem('scanResult', JSON.stringify(userData.scan_result));
                console.log('‚úÖ Scan result synced to localStorage');
              }
              if (userData.form_analysis) {
                localStorage.setItem('formAnalysis', JSON.stringify(userData.form_analysis));
                console.log('‚úÖ Form analysis synced to localStorage');
              }
              
              // Update local sync timestamp
              localStorage.setItem('lastSyncTimestamp', remoteLastSync.toString());
              
              console.log('‚úÖ All remote data synced to local storage');
              
              // Directly notify UI to hydrate from fresh remote payload (no manual refresh)
              try {
                localStorage.setItem('pendingHydratePayload', JSON.stringify(userData));
                if (window.fitmateHydrateFromRemote) window.fitmateHydrateFromRemote(userData);
              } catch (_) {}

              // Trigger UI refresh and mark remote applied (with retries for late listeners)
              console.log('üì° Dispatching userDataSynced and remoteDataApplied events...');
              try { localStorage.setItem('pendingUserDataSynced', '1'); } catch (_) {}
              window.dispatchEvent(new CustomEvent('userDataSynced', { detail: { userData } }));
              window.dispatchEvent(new CustomEvent('remoteDataApplied', { detail: { userData } }));
              // Re-dispatch after short delays to catch listeners that mount slightly later
              setTimeout(() => {
                try { window.dispatchEvent(new CustomEvent('userDataSynced', { detail: { userData } })); } catch (_) {}
              }, 300);
              setTimeout(() => {
                try { window.dispatchEvent(new CustomEvent('userDataSynced', { detail: { userData } })); } catch (_) {}
                try { localStorage.removeItem('pendingUserDataSynced'); } catch (_) {}
              }, 800);
              setTimeout(() => {
                try { window.dispatchEvent(new CustomEvent('userDataSynced', { detail: { userData } })); } catch (_) {}
              }, 1500);
            } else {
              if (remoteOnly) {
                console.log('üîí Remote-only mode active; skipping local-to-remote sync.');
              } else {
                // Only push if local is truly newer (timestamp comparison) and has meaningful content
                if (hasLocalData && localLastSyncTs > remoteLastSyncTs) {
                  console.log('üì§ Local data is newer (timestamp), syncing to remote');
                  await syncAllDataToSupabase();
                  console.log('‚úÖ Local data synced to remote successfully');
                } else {
                  console.log('‚ö†Ô∏è Skipping local->remote push to avoid overwriting newer/authoritative remote data');
                }
              }
            }
          } else {
            if (remoteOnly) {
              console.log('üîí Remote-only mode: remote profile missing; not creating from local on sign-in.');
            } else {
              console.log('No user document found, creating new one');
              // Create comprehensive initial user document
              await createInitialUserDocument(effectiveUser);
            }
          }
        } catch (error) {
          if (error.code === 'PERMISSION_DENIED') {
            console.log('Realtime Database access denied - using local storage only');
          } else if (error.message && error.message.includes('NetworkError')) {
            console.log('üåê Network error during sync - will retry on next user action');
            // Retry logic for network errors
            if (retryCount < 2) {
              console.log(`üîÑ Retrying sync (attempt ${retryCount + 1}/3)...`);
              setTimeout(() => {
                syncUserData(effectiveUser, retryCount + 1);
              }, 2000 * (retryCount + 1)); // Exponential backoff
            }
          } else {
            console.error('Error syncing user data:', error);
          }
        } finally {
          // Reset remote-only mode after one sync cycle
          if (forceNextRemoteOnlyRef?.current) {
            forceNextRemoteOnlyRef.current = false;
          }
        }
      };

      const signUp = async (email, password, displayName) => {
        if (!auth) throw new Error('Supabase Authentication not available');
        
        setAuthError(null);
        
        // Validate password strength
        const passwordValidation = validatePassword(password);
        if (!passwordValidation.isValid) {
          setAuthError(passwordValidation.message);
          throw new Error(passwordValidation.message);
        }
        
        try {
          const { data, error } = await auth.signUp({
            email,
            password,
            options: {
              data: {
                display_name: displayName
              }
            }
          });
          
          if (error) throw error;
          
          // Wait a moment for the user to be fully authenticated
          setTimeout(async () => {
            if (supabase && data.user) {
              try {
                // Ensure we have a valid session before creating user document
                const { data: { session } } = await auth.getSession();
                if (session?.user) {
                  await createInitialUserDocument(data.user);
                  console.log('‚úÖ Initial user document created from local storage (sign-up)');
                } else {
                  console.log('‚è≥ User not fully authenticated yet, will retry later');
                }
              } catch (dbError) {
                console.warn('‚ö†Ô∏è Could not create user document in Supabase Database:', dbError.message);
                // Continue without Database - user can still use the app
              }
            } else {
              console.log('üì± Account created successfully (local mode)');
            }
          }, 1000); // Wait 1 second for authentication to complete
          
          return data.user;
        } catch (error) {
          let friendlyMessage = error.message;
          
          // Provide user-friendly error messages
          if (error.message?.includes('already registered')) {
            friendlyMessage = 'This email is already registered. Try signing in instead.';
          } else if (error.message?.includes('Password should be at least')) {
            friendlyMessage = 'Password is too weak. Please use at least 6 characters.';
          } else if (error.message?.includes('Invalid email')) {
            friendlyMessage = 'Please enter a valid email address.';
          }
          
          setAuthError(friendlyMessage);
          throw new Error(friendlyMessage);
        }
      };

      const signIn = async (email, password) => {
        if (!auth) throw new Error('Supabase Authentication not available');
        
        setAuthError(null);
        try {
          const { data, error } = await auth.signInWithPassword({
            email,
            password
          });
          
          if (error) throw error;
          
          console.log('‚úÖ User signed in successfully');
          try { await auth.signOut({ scope: 'others' }); } catch (_) {}
          // Enforce remote-only fetch for this sign-in so local data cannot overwrite remote
          try { localStorage.removeItem('lastSyncTimestamp'); } catch (_) {}
          try { forceNextRemoteOnlyRef.current = true; } catch (_) {}
          // DO NOT clear aiUsage on sign-in - use handshake to sync MAX value across devices
          // Trigger immediate remote fetch (onAuthStateChange will also call this, this is safe)
          try { await syncUserData(data.user); } catch (_) {}
          return data.user;
        } catch (error) {
          let friendlyMessage = error.message;
          
          // Provide user-friendly error messages
          if (error.message?.includes('Invalid login credentials')) {
            friendlyMessage = 'Invalid email or password. Please check your credentials and try again.';
          } else if (error.message?.includes('Email not confirmed')) {
            friendlyMessage = 'Please check your email and confirm your account before signing in.';
          } else if (error.message?.includes('Invalid email')) {
            friendlyMessage = 'Please enter a valid email address.';
          } else if (error.message?.includes('Too many requests')) {
            friendlyMessage = 'Too many failed attempts. Please try again later.';
          }
          
          setAuthError(friendlyMessage);
          throw new Error(friendlyMessage);
        }
      };

      const signOut = async () => {
        if (!auth) return true; // If no auth, consider it a success
        
        try {
          // First try to sign out properly
          try {
            const { error } = await auth.signOut();
            if (error) throw error;
          } catch (signOutError) {
            // If the session is already invalid on server, proceed with local cleanup
            const msg = signOutError?.message || '';
            if (
              msg.includes('Auth session missing') ||
              msg.includes('Invalid Refresh Token') ||
              msg.includes('Forbidden') ||
              msg.includes('403')
            ) {
              console.log('Session already invalidated on server, proceeding with local cleanup');
            } else {
              throw signOutError; // Re-throw other errors
            }
          }
          
          // Ensure local sign-out and purge cached tokens so UI updates immediately
          try {
            await auth.signOut({ scope: 'local' });
          } catch (_) {
            // ignore
          }

          // Reset subscription and quota local flags on sign-out so UI reflects anon state
          try { localStorage.setItem('subscriptionActive', JSON.stringify(false)); } catch (_) {}
          try { window.dispatchEvent(new CustomEvent('subscription-status-changed', { detail: { active: false } })); } catch (_) {}
          try { window.dispatchEvent(new CustomEvent('ads-control', { detail: { enabled: true } })); } catch (_) {}
          try { localStorage.removeItem('aiUsage'); } catch (_) {}
          try { window.dispatchEvent(new Event('userDataSynced')); } catch (_) {}

          // Clear Supabase v2 auth cache keys (sb-<projectRef>-auth-token) plus legacy key
          try {
            const projectRef = new URL(supabaseConfig.url).host.split('.')[0];
            const prefixes = [
              `sb-${projectRef}-auth-token`,
              'sb-' // fallback in case projectRef parsing fails
            ];
            [localStorage, sessionStorage].forEach((store) => {
              for (let i = store.length - 1; i >= 0; i--) {
                const key = store.key(i);
                if (key && prefixes.some(p => key.startsWith(p))) {
                  store.removeItem(key);
                }
              }
            });
          } catch (_) {
            // ignore
          }

          // Clear any legacy local tokens/storage
          localStorage.removeItem('supabase.auth.token');
          sessionStorage.removeItem('supabase.auth.token');
          
          // Immediately reflect sign-out in UI to avoid requiring a second click
          try { setUser(null); } catch (_) { /* no-op */ }

          return true;
        } catch (error) {
          console.error('Error during sign out:', error);
          const errorMessage = error.message || 'Failed to sign out';
          setAuthError(errorMessage);
          throw new Error(errorMessage);
        }
      };

      const resetPassword = async (email) => {
        if (!auth) throw new Error('Supabase Authentication not available');
        
        setAuthError(null);
        try {
          const { error } = await auth.resetPasswordForEmail(email, {
            redirectTo: 'https://fitnessmate.netlify.app/?type=recovery'
          });
          if (error) throw error;
          return true;
        } catch (error) {
          let friendlyMessage = error.message;
          
          if (error.message?.includes('User not found')) {
            friendlyMessage = 'No account found with this email address.';
          } else if (error.message?.includes('Invalid email')) {
            friendlyMessage = 'Please enter a valid email address.';
          }
          
          setAuthError(friendlyMessage);
          throw new Error(friendlyMessage);
        }
      };

      const validatePassword = (password) => {
        const minLength = 8;
        const hasUpperCase = /[A-Z]/.test(password);
        const hasLowerCase = /[a-z]/.test(password);
        const hasNumbers = /\d/.test(password);
        const hasSpecialChar = /[!@#$%^&*(),.?":{}|<>]/.test(password);
        
        const errors = [];
        
        if (password.length < minLength) {
          errors.push(`At least ${minLength} characters`);
        }
        if (!hasUpperCase) {
          errors.push('One uppercase letter');
        }
        if (!hasLowerCase) {
          errors.push('One lowercase letter');
        }
        if (!hasNumbers) {
          errors.push('One number');
        }
        if (!hasSpecialChar) {
          errors.push('One special character (!@#$%^&*)');
        }
        
        return {
          isValid: errors.length === 0,
          message: errors.length > 0 ? `Password must contain: ${errors.join(', ')}` : 'Password is valid',
          errors: errors
        };
      };

      // Write coalescing queue to serialize Supabase updates and handle timeouts safely
      let userUpdateQueue = {
        inFlight: false,
        pending: null,
        resolvers: [],
        backoffMs: 0,
        flushTimer: null,
      };

      const mergeUserUpdatePayloads = (base, add) => {
        const a = base || {};
        const b = add || {};
        const result = { ...a };
        for (const [k, v] of Object.entries(b)) {
          if (
            v && typeof v === 'object' && !Array.isArray(v) &&
            result[k] && typeof result[k] === 'object' && !Array.isArray(result[k])
          ) {
            // shallow merge nested objects to avoid overwriting entire JSONB fields
            result[k] = { ...result[k], ...v };
          } else {
            result[k] = v;
          }
        }
        return result;
      };

      const flushUserUpdate = async (userId) => {
        if (userUpdateQueue.inFlight || !userUpdateQueue.pending) return;
        userUpdateQueue.inFlight = true;
        const payload = userUpdateQueue.pending;
        userUpdateQueue.pending = null;
        try {
          await db.updateUser(userId, payload);
          const resolvers = userUpdateQueue.resolvers;
          userUpdateQueue.resolvers = [];
          userUpdateQueue.backoffMs = 0;
          userUpdateQueue.inFlight = false;
          resolvers.forEach(fn => fn());
        } catch (err) {
          // Handle statement timeout: retry with exponential backoff, do NOT create doc here
          const msg = (err && err.message || '').toLowerCase();
          if (err && (err.code === '57014' || msg.includes('statement timeout'))) {
            userUpdateQueue.inFlight = false;
            userUpdateQueue.pending = mergeUserUpdatePayloads(userUpdateQueue.pending, payload) || payload;
            userUpdateQueue.backoffMs = Math.min(userUpdateQueue.backoffMs ? userUpdateQueue.backoffMs * 2 : 2000, 8000);
            if (userUpdateQueue.flushTimer) clearTimeout(userUpdateQueue.flushTimer);
            userUpdateQueue.flushTimer = setTimeout(() => flushUserUpdate(userId), userUpdateQueue.backoffMs);
            return;
          }
          // Handle not found: create initial document then retry once
          if (err && err.code === 'PGRST116') {
            try { await createInitialUserDocument(user); } catch (e) { console.warn('createInitialUserDocument failed:', e); }
            userUpdateQueue.inFlight = false;
            if (userUpdateQueue.flushTimer) clearTimeout(userUpdateQueue.flushTimer);
            userUpdateQueue.flushTimer = setTimeout(() => flushUserUpdate(userId), 250);
            return;
          }
          // Propagate other errors to callers to preserve behavior
          const resolvers = userUpdateQueue.resolvers;
          userUpdateQueue.resolvers = [];
          userUpdateQueue.inFlight = false;
          resolvers.forEach(fn => fn(err));
        }
      };

      const scheduleUserUpdateFlush = (userId) => {
        if (userUpdateQueue.flushTimer) clearTimeout(userUpdateQueue.flushTimer);
        // Debounce flush to coalesce bursts of updates
        userUpdateQueue.flushTimer = setTimeout(() => flushUserUpdate(userId), 1000);
      };

      const queueUserUpdate = (userId, update) => {
        userUpdateQueue.pending = mergeUserUpdatePayloads(userUpdateQueue.pending, update);
        return new Promise((resolve, reject) => {
          userUpdateQueue.resolvers.push((err) => err ? reject(err) : resolve());
          if (!userUpdateQueue.inFlight) scheduleUserUpdateFlush(userId);
        });
      };

      const updateUserData = async (data) => {
        if (!user) {
          console.log('No user signed in');
          return;
        }
        
        if (!supabase) {
          console.log('Supabase Database not available, data saved locally only');
          return;
        }
        // Prevent writes during remote-only sign-in fetch
        if (forceNextRemoteOnlyRef?.current) {
          console.log('üîí Remote-only mode active: skipping updateUserData to avoid overwriting remote during sign-in');
          return;
        }
        // Block any writes until initial remote has been applied to this device
        if (!authInitialRemoteAppliedRef.current) {
          console.log('‚è∏Ô∏è Skipping updateUserData until initial remote sync completes (AuthProvider)');
          return;
        }
        
        try {
          const currentTimestamp = new Date().toISOString();

          // Build payload and guard against overwriting valid remote intake with local defaults on fresh devices
          let payload = { ...data };
          if (payload && typeof payload === 'object' && 'daily_intake' in payload) {
            const localIntake = payload.daily_intake || {};
            const isLocalDefault = Object.values(localIntake).every(v => Number(v) === 0);
            try {
              const remote = await db.getUser(user.id);
              const remoteIntake = remote?.daily_intake || {};
              const remoteHasNonZero = Object.values(remoteIntake).some(v => Number(v) > 0);
              const todayISO = toLocalISODate(new Date());
              const remoteDayStamp = typeof remoteIntake.__day === 'string' ? remoteIntake.__day : '';
              const remoteIsToday = remoteDayStamp === todayISO;
              if (isLocalDefault && remoteHasNonZero && remoteIsToday) {
                // Skip overwriting today's remote non-zero intake with local defaults
                delete payload.daily_intake;
              } else {
                // CRITICAL: Never import activity from remote; only explicit local logging allowed
                payload.daily_intake = { ...localIntake, activity: Number(localIntake.activity || 0) };
                // Stamp the day so reads can enforce same-day sync only
                try { payload.daily_intake.__day = toLocalISODate(new Date()); } catch (_) {}
              }
            } catch (cmpErr) {
              console.warn('Safe-guard compare failed, proceeding:', cmpErr);
            }
          }

          // Stamp and hard-filter recent_meals to today-only
          if (payload && typeof payload === 'object' && 'recent_meals' in payload) {
            const todayISO = toLocalISODate(new Date());
            const mealsArray = Array.isArray(payload.recent_meals) ? payload.recent_meals : [];
            payload.recent_meals = mealsArray
              .map(m => ({ ...(m || {}), __day: (m && m.__day) ? m.__day : todayISO }))
              .filter(m => m.__day === todayISO);
          }

          if (Object.keys(payload).length === 0) {
            console.log('‚è≠Ô∏è Skipping update to avoid overwriting remote with defaults on fresh device');
            return;
          }

          await queueUserUpdate(user.id, {
            ...payload,
            updated_at: new Date().toISOString()
          });
          
          // Update local sync timestamp
          localStorage.setItem('lastSyncTimestamp', Date.now().toString());
          
          console.log('‚úÖ User data updated in Supabase Database with timestamp:', currentTimestamp);
        } catch (error) {
          console.error('Error updating user data:', error);
          console.error('Error details:', {
            message: error.message,
            code: error.code,
            details: error.details,
            hint: error.hint
          });
          // Avoid creating user document here on timeouts; queue handles not-found and backoff.
        }
      };


      // Debounced auto-sync function to prevent excessive syncing
      let autoSyncTimeout = null;
      const triggerAutoSync = () => {
        if (!user || !db) return;
        // Do not auto-sync while in remote-only sign-in phase
        if (forceNextRemoteOnlyRef?.current) {
          console.log('‚è∏Ô∏è Auto-sync skipped (remote-only sign-in in progress)');
          return;
        }
        
        // Clear existing timeout
        if (autoSyncTimeout) {
          clearTimeout(autoSyncTimeout);
        }
        
        // Set new timeout for 2 seconds
        autoSyncTimeout = setTimeout(async () => {
          try {
            console.log('üîÑ Auto-sync triggered');
            await syncUserData(user);
          } catch (error) {
            console.error('Auto-sync failed:', error);
          }
        }, 2000);
      };

      // Enhanced localStorage setter with auto-sync trigger and quota management
      // Safe setter that auto-cleans once and retries when quota is exceeded
      const setLocalStorageWithSync = (key, value) => {
        try {
          localStorage.setItem(key, value);
        } catch (error) {
          if (error && (error.name === 'QuotaExceededError' || error.name === 'NS_ERROR_DOM_QUOTA_REACHED')) {
            console.warn('‚ö†Ô∏è LocalStorage full ‚Äî cleaning up and retrying...');
            cleanupLocalStorage();
            try {
              localStorage.setItem(key, value);
            } catch (retryError) {
              console.error('Failed to store data even after cleanup:', retryError);
              // Avoid storing heavy images if still failing
              if (key.includes('imagePreview') || key === 'profilePicture') {
                console.warn('Skipping image storage due to quota limits');
                return;
              }
              throw retryError;
            }
          } else {
            throw error;
          }
        }
        
        // Skip auto-sync for UI-only keys that don't need server sync
        const uiOnlyKeys = [
          'workoutPlanner_activeTab',
          'mealPlanner_activeTab',
          'progress_activeTab',
          'fitmate-current-screen',
          'fitmate-dark-mode',
          'lastSavedDate',
          'completedWorkoutIndex'
        ];
        const shouldSkipSync = uiOnlyKeys.some(prefix => key.startsWith(prefix) || key === prefix);
        if (!shouldSkipSync) {
          triggerAutoSync();
        }
      };
      if (typeof window !== 'undefined') { window.setLocalStorageWithSync = setLocalStorageWithSync; }

      // Clean up localStorage to free space
      const cleanupLocalStorage = () => {
        const keysToClean = [
          'pantryChef_imagePreview',
          'menuDecoder_imagePreview',
          'pantryChef_ingredients',
          'pantryChef_recipes',
          'menuDecoder_menuItems',
          'menuDecoder_recommendations',
          'dailyQuote',
          'lastQuoteFetchDate'
        ];
        
        // Remove image previews first (largest items)
        keysToClean.forEach(key => {
          try {
            localStorage.removeItem(key);
            console.log(`Cleaned up localStorage key: ${key}`);
          } catch (e) {
            console.warn(`Failed to remove ${key}:`, e);
          }
        });
        
        // Clean up old cache entries
        Object.keys(localStorage).forEach(key => {
          if (key.startsWith('fitmate-slots-') && key !== `fitmate-slots-${new Date().toISOString().split('T')[0]}`) {
            try {
              localStorage.removeItem(key);
              console.log(`Cleaned up old cache: ${key}`);
            } catch (e) {
              console.warn(`Failed to remove cache ${key}:`, e);
            }
          }
        });
      };

      const checkLocalStorageUsage = () => {
        let totalSize = 0;
        const usage = {};
        try {
          for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (!key) continue;
            const size = (localStorage.getItem(key) || '').length;
            totalSize += size;
            usage[key] = size;
          }
        } catch (_) {}
        if (totalSize > 4 * 1024 * 1024) {
          if (!window.__fitmateAutoCleaned) {
            try { cleanupLocalStorage(); } catch (_) {}
            window.__fitmateAutoCleaned = true;
          }
        }
        return { totalSize, usage };
      };

      // Check usage periodically (once) at a lower frequency to reduce console noise
      if (!window.__fitmateLSUsageInterval) {
        window.__fitmateLSUsageInterval = setInterval(checkLocalStorageUsage, 300000); // every 5 minutes
      }

      // Real-time listener for cross-device sync (using Supabase subscriptions)
      React.useEffect(() => {
        if (!user || !supabase || !USERS_REALTIME_ENABLED) return;
        
        console.log('üîó Setting up real-time sync listener for user:', user.id);
        
        const subscription = db.subscribe('users', (payload) => {
          if (payload.new && payload.new.id === user.id) {
            const remoteData = payload.new;
            const remoteTimestamp = remoteData.updated_at ? new Date(remoteData.updated_at).getTime() : 0;
            const localTimestamp = parseInt(localStorage.getItem('lastSyncTimestamp') || '0');
            
            // Only sync if remote data is newer than local
            if (remoteTimestamp > localTimestamp) {
              console.log('üîÑ Real-time sync: Remote data is newer, updating local data');
              
              // Update localStorage silently (without triggering auto-sync)
              if (remoteData.goals) localStorage.setItem('goals', JSON.stringify(remoteData.goals));
              if (remoteData.profile_picture) localStorage.setItem('profilePicture', remoteData.profile_picture);
              if (remoteData.notifications_enabled !== undefined) localStorage.setItem('notificationsEnabled', JSON.stringify(remoteData.notifications_enabled));
              // Subscription status from backend (Stripe/Play)
              if (remoteData.subscription) {
                try { localStorage.setItem('subscriptionActive', JSON.stringify(!!remoteData.subscription.active)); } catch (_) {}
                try { window.dispatchEvent(new CustomEvent('subscription-status-changed', { detail: { active: !!remoteData.subscription.active } })); } catch (_) {}
              }
              // Skip syncing dark_mode from remote - it's a local UI preference
              if (remoteData.daily_intake) {
                try {
                  const todayISO = toLocalISODate(new Date());
                  const remoteUpdateIsToday = !!remoteTimestamp && toLocalISODate(new Date(remoteTimestamp)) === todayISO;
                  const remoteDayStamp = remoteData.daily_intake?.__day;
                  const remoteDayMatchesToday = remoteDayStamp ? (remoteDayStamp === todayISO) : remoteUpdateIsToday;
                  const resetAt = parseInt(localStorage.getItem('midnightResetAt') || '0');
                  const remoteTs = remoteTimestamp ? new Date(remoteTimestamp).getTime() : 0;
                  const remoteOlderThanReset = resetAt && remoteTs && (remoteTs <= resetAt);
                  if (!remoteDayMatchesToday || remoteOlderThanReset) {
                    console.log(remoteOlderThanReset ? '‚è≠Ô∏è Realtime(sub): skipping remote daily_intake (stale vs midnight reset)' : '‚è≠Ô∏è Realtime(sub): skipping remote daily_intake (day stamp mismatch)');
                    // Fallback: if this is a past-day intake, archive it into local history to avoid loss
                    try {
                      if (remoteDayStamp && remoteDayStamp !== todayISO) {
                        const remoteHasNonZero = ['calories','protein','carbs','fat','activity','water'].some(k => Number(remoteData.daily_intake?.[k]||0) > 0);
                        if (remoteHasNonZero) {
                          const dh = (() => { try { return JSON.parse(localStorage.getItem('dailyHistory')||'{}')||{}; } catch { return {}; } })();
                          const prev = dh[remoteDayStamp] || {};
                          const prevIntake = prev.intake || {};
                          dh[remoteDayStamp] = { ...prev, intake: { ...prevIntake, ...remoteData.daily_intake } };
                          localStorage.setItem('dailyHistory', JSON.stringify(dh));
                          console.log('üì¶ Realtime(sub): archived remote intake into history for past day', remoteDayStamp);
                        }
                      }
                    } catch (_) {}
                  } else {
                    const currentLocal = (() => { try { return JSON.parse(localStorage.getItem('dailyIntake') || '{}') || {}; } catch { return {}; } })();
                    const localIsZero = ['calories','protein','carbs','fat','activity','water'].every(k => Number(currentLocal[k]||0) === 0);
                    const remoteHasNonZero = ['calories','protein','carbs','fat','activity','water'].some(k => Number(remoteData.daily_intake?.[k]||0) > 0);
                    const localMeals = (() => { try { return JSON.parse(localStorage.getItem('recentMeals') || '[]') || []; } catch { return []; } })();
                    const localHasStarted = !localIsZero || (Array.isArray(localMeals) && localMeals.length > 0);
                    // During remote-only sign-in, do not defer: allow cross-device hydration sync
                    const shouldDeferIntake = (!!resetAt && !localHasStarted && remoteHasNonZero && !forceNextRemoteOnlyRef?.current);
                    if (shouldDeferIntake) {
                      console.log('‚è≠Ô∏è Realtime(sub): deferring remote daily_intake until local activity starts', { resetAt, localHasStarted, remoteHasNonZero });
                    } else {
                      const mergedLocal = (() => { try { return JSON.parse(localStorage.getItem('dailyIntake') || '{}') || {}; } catch { return {}; } })();
                      const merged = { 
                        ...remoteData.daily_intake, 
                        // Monotonic today-only merge: prefer higher values to prevent UI backtrack
                        activity: Math.max(Number(remoteData.daily_intake?.activity || 0), Number(mergedLocal.activity || 0)),
                        water: Math.max(Number(remoteData.daily_intake?.water || 0), Number(mergedLocal.water || 0)) 
                      };
                      localStorage.setItem('dailyIntake', JSON.stringify(merged));
                      console.log('‚úÖ Realtime(sub): daily_intake synced');
                    }
                  }
                } catch (_) {
                  console.log('‚ö†Ô∏è Realtime(sub): intake merge failed; leaving local untouched');
                }
              }
              if (remoteData.recent_meals) {
                try {
                  const todayISO = toLocalISODate(new Date());
                  const remoteUpdateIsToday = !!remoteTimestamp && toLocalISODate(new Date(remoteTimestamp)) === todayISO;
                  if (!remoteUpdateIsToday) {
                    console.log('‚è≠Ô∏è Realtime(sub): skipping remote recent_meals (updated_at not today)');
                  } else {
                    const lastSyncTs = parseInt(localStorage.getItem('lastSyncTimestamp') || '0');
                    const remoteOlderThanLocalWrite = !!lastSyncTs && !!remoteTimestamp && remoteTimestamp <= lastSyncTs;
                    if (remoteOlderThanLocalWrite) {
                      console.log('‚è≠Ô∏è Realtime(sub): skipping remote recent_meals (local newer write)');
                      return;
                    }
                    const localIntakeDate = localStorage.getItem('dailyIntakeDate');
                    const lastSaved = localStorage.getItem('lastSavedDate');
                    const rolledToToday = (localIntakeDate === todayISO && lastSaved === todayISO);
                    const localMeals = (() => { try { return JSON.parse(localStorage.getItem('recentMeals') || '[]') || []; } catch { return []; } })();
                    const localIsEmpty = !Array.isArray(localMeals) || localMeals.length === 0;
                    const remoteHasMeals = Array.isArray(remoteData.recent_meals) && remoteData.recent_meals.length > 0;
                    const resetAt = parseInt(localStorage.getItem('midnightResetAt') || '0');
                    const shouldDeferMeals = rolledToToday && localIsEmpty && !!resetAt && remoteHasMeals;
                    if (shouldDeferMeals) {
                      console.log('‚è≠Ô∏è Realtime(sub): deferring remote recent_meals until local day start',{ resetAt, rolledToToday, localIsEmpty, remoteHasMeals });
                    } else {
                      const todaysMeals = (Array.isArray(remoteData.recent_meals) ? remoteData.recent_meals.filter(m => m && m.__day === todayISO) : []);
                      const byId = new Map((Array.isArray(localMeals) ? localMeals : []).map(m => [m && m.id, m]).filter(([id]) => id !== undefined && id !== null));
                      const patched = todaysMeals.map(m => {
                        const local = byId.get(m && m.id);
                        const remoteImg = m && m.image;
                        const isMissing = !remoteImg || (typeof remoteImg === 'string' && remoteImg.indexOf('placehold.co') !== -1);
                        if (local && isMissing && local.image) return { ...m, image: local.image };
                        return m;
                      });
                      localStorage.setItem('recentMeals', JSON.stringify(patched));
                    }
                  }
                } catch (_) {
                  const todayISO = toLocalISODate(new Date());
                  const todaysMeals = (Array.isArray(remoteData.recent_meals) ? remoteData.recent_meals.filter(m => m && m.__day === todayISO) : []);
                  localStorage.setItem('recentMeals', JSON.stringify(todaysMeals));
                }
              }
              if (remoteData.daily_history) {
                try {
                  const localDH = JSON.parse(localStorage.getItem('dailyHistory') || '{}') || {};
                  const remoteHistory = remoteData.daily_history || {};
                  
                  // Remote-only past days: prefer remote for all past days, keep current day local
                  const todayISO = toLocalISODate(new Date());
                  const merged = { ...remoteHistory }; // Start with remote data
                  
                  // Only preserve local data for today
                  if (localDH[todayISO]) {
                    merged[todayISO] = localDH[todayISO];
                  }
                  
                  localStorage.setItem('dailyHistory', JSON.stringify(merged));
                } catch (_) {
                  localStorage.setItem('dailyHistory', JSON.stringify(remoteData.daily_history));
                }
              }
              if (remoteData.coach_messages) localStorage.setItem('coachMessages', JSON.stringify(remoteData.coach_messages));
              if (remoteData.habit_ai_advice) localStorage.setItem('habitAIAdvice', remoteData.habit_ai_advice);
              if (remoteData.habits) localStorage.setItem('habits', JSON.stringify(remoteData.habits));
              if (remoteData.meal_plan) localStorage.setItem('mealPlan', JSON.stringify(remoteData.meal_plan));
              if (remoteData.workout_plan) localStorage.setItem('workoutPlan', JSON.stringify(remoteData.workout_plan));
              // workout_history is handled by separate table, not synced here
              if (remoteData.scan_result) localStorage.setItem('scanResult', JSON.stringify(remoteData.scan_result));
              if (remoteData.form_analysis) localStorage.setItem('formAnalysis', JSON.stringify(remoteData.form_analysis));
              // AI usage: merge remote with local using MAX to prevent overwrites
              if (remoteData.ai_usage) {
                try {
                  const remoteUsage = remoteData.ai_usage || {};
                  const localUsage = JSON.parse(localStorage.getItem('aiUsage') || '{}') || {};
                  const merged = { ...localUsage };
                  Object.keys(remoteUsage).forEach(date => {
                    if (!merged[date]) merged[date] = {};
                    Object.keys(remoteUsage[date]).forEach(uid => {
                      const remoteCount = Number(remoteUsage[date][uid] || 0);
                      const localCount = Number(merged[date][uid] || 0);
                      merged[date][uid] = Math.max(remoteCount, localCount);
                    });
                  });
                  localStorage.setItem('aiUsage', JSON.stringify(merged));
                  window.dispatchEvent(new CustomEvent('userDataSynced'));
                  console.log('‚úÖ Real-time: AI usage merged from remote (MAX)');
                } catch (e) {
                  console.warn('Realtime AI usage merge failed:', e);
                }
              }
              
              // Update local sync timestamp
              localStorage.setItem('lastSyncTimestamp', remoteTimestamp.toString());
              
              // Dispatch event to update React components
              window.dispatchEvent(new CustomEvent('userDataSynced'));
              
              console.log('‚úÖ Real-time sync completed');
            }
          }
        }, { filter: `id=eq.${user.id}` });
        
        // Cleanup subscription on unmount or user change
        return () => {
          console.log('üîå Removing real-time sync listener');
          subscription.unsubscribe();
        };
      }, [user, supabase]);

      const syncAllDataToSupabase = async () => {
        if (!user || !supabase) return;
        // Prevent bulk push during remote-only sign-in fetch
        if (forceNextRemoteOnlyRef?.current) {
          console.log('üîí Remote-only mode active: skipping syncAllDataToSupabase during sign-in');
          return;
        }
        // Also block until initial remote applied
        if (!authInitialRemoteAppliedRef?.current) {
          console.log('‚è∏Ô∏è Skipping syncAllDataToSupabase until initial remote sync completes');
          return;
        }
        
        try {
          const currentTimestamp = new Date().toISOString();
          const allLocalData = {
            goals: JSON.parse(localStorage.getItem('goals') || '{}'),
            // profile_picture intentionally excluded in remote-only mode to avoid overwriting remote data,
            notifications_enabled: JSON.parse(localStorage.getItem('notificationsEnabled') || 'true'),
            daily_intake: (() => { try { const di = JSON.parse(localStorage.getItem('dailyIntake') || '{}') || {}; di.__day = toLocalISODate(new Date()); return di; } catch { return { __day: toLocalISODate(new Date()) }; } })(),
            recent_meals: (() => { try { const meals = JSON.parse(localStorage.getItem('recentMeals') || '[]') || []; const todayISO = toLocalISODate(new Date()); return Array.isArray(meals) ? meals.filter(m => m && m.__day === todayISO) : []; } catch { return []; } })(),
            daily_history: JSON.parse(localStorage.getItem('dailyHistory') || '{}'),
            coach_messages: JSON.parse(localStorage.getItem('coachMessages') || '[]'),
            habit_ai_advice: localStorage.getItem('habitAIAdvice') || '',
            habits: JSON.parse(localStorage.getItem('habits') || '[]'),
            dark_mode: JSON.parse(localStorage.getItem('fitmate-dark-mode') || 'false'),
            meal_plan: JSON.parse(localStorage.getItem('mealPlan') || 'null'),
            workout_plan: JSON.parse(localStorage.getItem('workoutPlan') || 'null'),
            // workout_history: JSON.parse(localStorage.getItem('workoutHistory') || '[]'), // Removed - using separate table
            scan_result: JSON.parse(localStorage.getItem('scanResult') || 'null'),
            form_analysis: JSON.parse(localStorage.getItem('formAnalysis') || 'null'),
            updated_at: currentTimestamp
          };
          
          await queueUserUpdate(user.id, allLocalData);
          
          // Update local sync timestamp to match what we just sent
          localStorage.setItem('lastSyncTimestamp', Date.now().toString());
          
          console.log('‚úÖ All local data queued for Supabase update with timestamp:', currentTimestamp);
        } catch (error) {
          console.error('Error syncing all data to Supabase Database:', error);
          throw error; // Re-throw to handle in calling function
        }
      };

      // Sync daily intake data
      const syncDailyIntake = async (dailyIntake) => {
        if (user && supabase) {
          try {
            await updateUserData({ 
              daily_intake: dailyIntake
            });
          } catch (error) {
            console.error('Error syncing daily intake:', error);
          }
        }
      };

      // Sync meals data
      const syncMealsData = async (recentMeals) => {
        if (user && supabase) {
          try {
            const todayISO = toLocalISODate(new Date());
            const todaysMeals = Array.isArray(recentMeals) ? recentMeals.filter(m => m && m.__day === todayISO) : [];
            await updateUserData({ 
              recent_meals: todaysMeals
            });
          } catch (error) {
            console.error('Error syncing meals data:', error);
          }
        }
      };

      // Sync daily history
      const syncDailyHistory = async (dailyHistory) => {
        if (user && supabase) {
          try {
            await updateUserData({ 
              daily_history: dailyHistory
            });
          } catch (error) {
            console.error('Error syncing daily history:', error);
          }
        }
      };

      // Sync AI-generated content
      const syncAIContent = async (contentType, content) => {
        if (user && supabase) {
          try {
            // Convert camelCase to snake_case for database storage
            const dbContentType = contentType.replace(/([A-Z])/g, '_$1').toLowerCase();
            await updateUserData({ 
              [dbContentType]: content
              // Removed last_*_update fields as they don't exist in schema
            });
          } catch (error) {
            console.error(`Error syncing ${contentType}:`, error);
          }
        }
      };

      const value = {
        user,
        loading,
        authError,
        signUp,
        signIn,
        signOut,
        resetPassword,
        validatePassword,
        updateUserData,
        syncUserData,
        syncAllDataToSupabase,
        syncDailyIntake,
        syncMealsData,
        syncDailyHistory,
        syncAIContent,
        triggerAutoSync,
        setLocalStorageWithSync,
        setAuthError,
        forceNextRemoteOnlyRef,
        authInitialRemoteAppliedRef
      };

      return (
        <AuthContext.Provider value={value}>
          {children}
        </AuthContext.Provider>
      );
    };

    const useAuth = () => {
      const context = React.useContext(AuthContext);
      if (!context) {
        throw new Error('useAuth must be used within an AuthProvider');
      }
      return context;
    };

    // --- Centralized API Configuration ---
    // Netlify Functions direct endpoint (avoids redirect issues)
    const NETLIFY_API_URL = '/.netlify/functions/myapi';
    
    // Removed deprecated Gemini simple config and GEMINI_API_URL (migrated to OpenRouter)
    
    // Direct OpenRouter API (ChatGPT 4 Mini) with obfuscated key
    const OPENROUTER_QWEN_MODEL = 'google/gemini-3-flash-preview'; // text-only
    const OPENROUTER_QWEN_VL_MODEL = "google/gemini-3-flash-preview"
    const getDirectGeminiConfig = () => {
      return {
        // Route through Netlify Functions (redirected from /api/*)
        url: NETLIFY_API_URL,
        headers: {
          'Content-Type': 'application/json',
          'X-Title': 'Fitmate',
          
          'HTTP-Referer': (typeof window !== 'undefined' && window.location ? window.location.origin : 'http://localhost')
        }
      };
    };
    
    // Feature flag: hide manual cloud sync UI (auto-sync is active)
    const SHOW_MANUAL_CLOUD_SYNC = false;
    (function(){const installLimiter=()=>{if(window.__aiLimiterInstalled)return;const aiUrl=getDirectGeminiConfig().url;const orig=window.fetch.bind(window);window.__aiThinkingPending=window.__aiThinkingPending||0;window.fetch=async (input,init={})=>{try{const reqUrl=typeof input==='string'?input:((input&&input.url)||'');const method=(init&&init.method)?String(init.method).toUpperCase():'GET';const isAI=(reqUrl===aiUrl&&method==='POST');if(!isAI){return orig(input,init);}let hdrs=(init&&init.headers)||null;let ignore=false;try{if(hdrs&&typeof hdrs.get==='function'){ignore=!!hdrs.get('X-Fitmate-Ignore-Quota');}else if(hdrs&&typeof hdrs==='object'){ignore=!!(hdrs['X-Fitmate-Ignore-Quota']||hdrs['x-fitmate-ignore-quota']);}}catch(_){}let uid=null;try{if(auth&&auth.getSession){const { data:{ session } }=await auth.getSession();uid=session&&session.user?session.user.id:null;}}catch(_){}const todayISO=(typeof toLocalISODate==='function'?toLocalISODate(new Date()):new Date().toISOString().slice(0,10));let usage={};try{usage=JSON.parse(localStorage.getItem('aiUsage')||'{}')||{};}catch(_){}if(!usage[todayISO])usage[todayISO]={};const key=uid||'anon';let subscribed=false;try{subscribed=JSON.parse(localStorage.getItem('subscriptionActive')||'false');}catch(_){}const limit=subscribed?15:(uid?5:3);const count=Number(usage[todayISO][key]||0);if(count>=limit){try{if(uid){window.dispatchEvent(new Event('force-open-subscription-modal'));}else{window.dispatchEvent(new CustomEvent('ai-quota-exceeded',{detail:{key,limit}}));}}catch(_){}return new Response(JSON.stringify({error:'quota_exceeded'}),{status:429,headers:{'Content-Type':'application/json'}});}usage[todayISO][key]=count+1;try{localStorage.setItem('aiUsage',JSON.stringify(usage));
            try {
              // Sync AI usage to database immediately after incrementing
              if (uid && typeof supabase !== 'undefined' && typeof db !== 'undefined' && db.updateUser) {
                try {
                  // Debounce updates to avoid hammering the database
                  if (window.__aiUsageSyncTimeout) clearTimeout(window.__aiUsageSyncTimeout);
                  window.__aiUsageSyncTimeout = setTimeout(async () => {
                    try {
                      await db.updateUser(uid, { ai_usage: usage });
                      console.log('‚úÖ AI usage synced to database:', usage[todayISO]);
                    } catch (err) {
                      console.error('Failed to sync AI usage to database:', err);
                    }
                  }, 500);
                } catch(e) { 
                  console.error('AI limiter: Failed to schedule database sync:', e);
                }
              }
            } catch(e) { console.error('AI limiter: Database sync error:', e); }}
            catch(_){}
            // Dispatch global thinking indicator before network call
            try {
              window.__aiThinkingPending = (window.__aiThinkingPending || 0) + 1;
              window.dispatchEvent(new CustomEvent('ai-thinking', { detail: { pending: window.__aiThinkingPending } }));
            } catch(_) {}
            const _req = orig(input,init);
            // Ensure indicator stops after completion
            return _req.finally(() => {
              try {
                window.__aiThinkingPending = Math.max(0, (window.__aiThinkingPending || 0) - 1);
                window.dispatchEvent(new CustomEvent('ai-thinking', { detail: { pending: window.__aiThinkingPending } }));
              } catch(_) {}
            });
          }catch(_){return orig(input,init);}};window.__aiLimiterInstalled=true;};installLimiter();})();

    (function(){
      if (window.__iapSetupInstalled) return;
      window.__iapSetupInstalled = true;

      const PRODUCT_ID = 'fitnessmate_monthly'; // configure in Play Console
      const BILLING_METHOD = 'https://play.google.com/billing';

      const setSubActive = (active) => {
        try { localStorage.setItem('subscriptionActive', JSON.stringify(!!active)); } catch(_) {}
        try { window.dispatchEvent(new CustomEvent('subscription-status-changed', { detail: { active: !!active } })); } catch(_) {}
        try { window.dispatchEvent(new CustomEvent('ads-control', { detail: { enabled: !active } })); } catch(_) {}
        (async () => {
          try {
            if (auth && db) {
              const { data: { session } } = await auth.getSession();
              const uid = session && session.user ? session.user.id : null;
              if (uid) {
                // Read current subscription platform; do not overwrite Stripe-managed subscriptions
                let currentPlatform = null;
                try {
                  const existing = await db.getUser(uid);
                  currentPlatform = existing && existing.subscription ? existing.subscription.platform : null;
                } catch(_) {}
                if (currentPlatform && currentPlatform !== 'google_play') {
                  return; // Don't touch Stripe or other platforms
                }
                // Never push a false from Play to the backend; only persist true activations
                if (active) {
                  await db.updateUser(uid, { subscription: { active: true, platform: 'google_play', product_id: PRODUCT_ID, last_updated: new Date().toISOString() } });
                }
              }
            }
          } catch (_) {}
        })();
      };

      const isSupported = () => typeof window.getDigitalGoodsService === 'function';

      const refreshEntitlement = async () => {
        if (!isSupported()) return false;
        try {
          const service = await window.getDigitalGoodsService(BILLING_METHOD);
          const purchases = await service.listPurchases();
          const active = Array.isArray(purchases) && purchases.some(p => (p.productId||p.sku) === PRODUCT_ID && !p.isCanceled && !p.isRefunded && !p.isExpired);
          // Only update state if Play Billing actually returned purchases. This avoids overwriting
          // Stripe-based subscriptions to false on platforms where Digital Goods API is available
          // but the user subscribed via Stripe.
          if (Array.isArray(purchases) && purchases.length > 0) {
            if (active) setSubActive(true); // only set true; avoid overwriting Stripe users to false
          }
          return active;
        } catch (e) {
          return false;
        }
      };

      const subscribe = async (productId = PRODUCT_ID) => {
        const isNative = !!window.__isNativeAndroidApp;
        const openPlayManage = () => {
          const sku = (window.fitmateIAP && window.fitmateIAP.PRODUCT_ID) ? window.fitmateIAP.PRODUCT_ID : PRODUCT_ID;
          const pkg = 'app.netlify.fitnessmate.twa';
          const manageUrl = `https://play.google.com/store/account/subscriptions?sku=${encodeURIComponent(sku)}&package=${encodeURIComponent(pkg)}`;
          try { window.open(manageUrl, '_blank'); } catch(_) {}
        };

        if (isNative) {
          // Prefer Google Play Billing in native Android contexts; never fall back to Stripe
          const hasPR = ('PaymentRequest' in window);
          const hasDGA = (typeof window.getDigitalGoodsService === 'function');
          if (!hasPR || !hasDGA) { openPlayManage(); return false; }
          const methodData = [{ supportedMethods: BILLING_METHOD, data: { sku: productId, type: 'subs' } }];
          const details = { total: { label: 'Subscription', amount: { currency: 'EUR', value: '1.49' } } };
          try {
            const request = new PaymentRequest(methodData, details);
            const resp = await request.show();
            await resp.complete('success');
            await refreshEntitlement();
            return true;
          } catch (e) {
            try { console.warn('Play subscription failed:', e); } catch(_) {}
            // If purchase cannot be shown (e.g., SKU not published), direct user to Play subscription management
            openPlayManage();
            return false;
          }
        } else {
          // Web/PWA/non-native Android: Stripe pricing table
          try { if (window.openStripePricingModal) window.openStripePricingModal(); } catch(_) {}
          return false;
        }
      };

      const restore = async () => { return refreshEntitlement(); };
      const isSubscribed = () => { try { return JSON.parse(localStorage.getItem('subscriptionActive')||'false')===true; } catch(_) { return false; } };
      const onStatusChange = (cb) => { if (typeof cb !== 'function') return () => {}; const handler = (e)=>cb(!!(e&&e.detail&&e.detail.active)); window.addEventListener('subscription-status-changed', handler); return () => window.removeEventListener('subscription-status-changed', handler); };

      window.fitmateIAP = { subscribe, restore, refreshEntitlement, isSubscribed, onStatusChange, PRODUCT_ID };

      // Kick off entitlement check on load and when returning to the app
      refreshEntitlement();
      document.addEventListener('visibilitychange', () => { if (!document.hidden) refreshEntitlement(); });
    })();
    
    // PDF Generation Utility
    const generatePDF = (title, content, filename) => {
      const { jsPDF } = window.jspdf;
      const doc = new jsPDF();
      
      // Add title
      doc.setFontSize(18);
      doc.text(title, 20, 20);
      
      // Add content
      doc.setFontSize(12);
      let y = 30;
      
      // Split content into lines to fit page width
      const splitContent = doc.splitTextToSize(content, 170);
      
      // Calculate line height
      const lineHeight = 7;
      
      // Add content with pagination
      for (let i = 0; i < splitContent.length; i++) {
        // Check if we need a new page
        if (y > 280) { // A4 height is about 297mm, leaving margin
          doc.addPage();
          y = 20; // Reset y position for new page
        }
        
        // Add the line
        doc.text(splitContent[i], 20, y);
        y += lineHeight;
      }
      
      // Save the PDF
      doc.save(filename);
    };

    // Enhanced Speech Controller for granular control
    const speechController = {
      isPlaying: false,
      currentUtterance: null,
      activeButton: null,
      currentText: null,
      
      speak: function(text, buttonId) {
        if ('speechSynthesis' in window) {
          // If this button is currently playing, stop it
          if (this.isPlaying && this.activeButton === buttonId) {
            this.stop();
            return 'stop';
          }
          
          // Stop any other playing speech
          if (this.isPlaying) {
            this.stop();
          }
          
          // Start new speech
          this.currentText = text;
          const utterance = new SpeechSynthesisUtterance(text);
          utterance.rate = 0.9;
          
          // Mobile-optimized voice selection
          const voices = window.speechSynthesis.getVoices();
          const preferredVoice = voices.find(voice => 
            voice.lang.startsWith('en') && (voice.name.includes('Google') || voice.name.includes('Microsoft'))
          ) || voices.find(voice => voice.lang.startsWith('en'));
          if (preferredVoice) {
            utterance.voice = preferredVoice;
          }
          
          utterance.onstart = () => {
            this.isPlaying = true;
            this.activeButton = buttonId;
          };
          
          utterance.onend = () => {
            this.isPlaying = false;
            this.currentUtterance = null;
            this.activeButton = null;
            this.currentText = null;
          };
          
          utterance.onerror = (event) => {
            console.error('Speech synthesis error:', event);
            this.stop();
          };
          
          this.currentUtterance = utterance;
          window.speechSynthesis.speak(utterance);
          this.isPlaying = true;
          this.activeButton = buttonId;
          return 'play';
        } else {
          if (window.showToast) { showToast('Text-to-speech not supported in this browser', 'error'); } else { console.log('Text-to-speech not supported in this browser'); }
          return 'error';
        }
      },
      
      stop: function() {
        window.speechSynthesis.cancel();
        this.isPlaying = false;
        this.currentUtterance = null;
        this.activeButton = null;
        this.currentText = null;
      },
      
      isActuallyPlaying: function() {
        return this.isPlaying && window.speechSynthesis.speaking;
      }
    };

    // Simple Text-to-Speech Function (for backward compatibility)
    const speakText = (text) => {
      speechController.speak(text);
    };

    // --- Default Goal Data ---
    const defaultGoals = {
      calories: 2000,
      protein: 120,
      carbs: 250,
      fat: 60,
      activity: 30, // in minutes
      water: 8, // in glasses
    };

    // --- Helper Components ---


    // --- Main App Component ---
    function App() {
      const [screen, setScreen] = useState(() => {
        const urlParams = new URLSearchParams(window.location.search);
        const tab = urlParams.get('tab');
        const view = urlParams.get('view');
        
        // Handle workout detail redirection
        if (view === 'detail') {
          const completedWorkoutIndex = localStorage.getItem('completedWorkoutIndex');
          if (completedWorkoutIndex) {
            localStorage.removeItem('completedWorkoutIndex');
            // Redirect to workout.html detail view immediately
            window.location.replace(`workout.html?workout=${completedWorkoutIndex}&view=detail`);
            return null; // Prevent rendering while redirecting
          }
        }
        
        if (tab) {
          // Clear the URL parameter to prevent it from persisting on refresh
          window.history.replaceState({}, document.title, window.location.pathname);
          return tab;
        }
        const savedScreen = localStorage.getItem('fitmate-current-screen');
        return savedScreen || 'dashboard';
      }); // 'dashboard', 'scan', 'profile', 'planner', 'workout', 'coach', 'progress'

      // --- Clean Theme State Management ---
      const [isDarkMode, setIsDarkMode] = useState(() => {
        const saved = localStorage.getItem('fitmate-dark-mode');
        return saved === null ? true : saved === 'true'; // default to dark on first launch
      });

      // --- Global AI Thinking Indicator ---
      const [aiThinkingPending, setAiThinkingPending] = useState(0);
      useEffect(() => {
        const onThinking = (e) => {
          try {
            const pending = (e && e.detail && typeof e.detail.pending === 'number') ? e.detail.pending : 0;
            setAiThinkingPending(pending);
          } catch (_) {}
        };
        window.addEventListener('ai-thinking', onThinking);
        return () => window.removeEventListener('ai-thinking', onThinking);
      }, []);

      // --- Coach and Progress State Management ---
      const [coachMessages, setCoachMessages] = useState(() => {
        // For signed-in users, start with default message and let remote data load via useEffect
        if (user) {
          return [{ text: "Hello! I'm your AI Health Coach. Ask me anything about your nutrition or meals.", sender: 'ai' }];
        }
        const savedMessages = localStorage.getItem('coachMessages');
        return savedMessages ? JSON.parse(savedMessages) : [{ text: "Hello! I'm your AI Health Coach. Ask me anything about your nutrition or meals.", sender: 'ai' }];
      });
      const [habitAIAdvice, setHabitAIAdvice] = useState(() => {
        // For signed-in users, start with empty string and let remote data load via useEffect
        if (user) {
          return '';
        }
        const savedAdvice = localStorage.getItem('habitAIAdvice');
        return savedAdvice || '';
      });
      const [isLoadingAdvice, setIsLoadingAdvice] = useState(false);
      const [showResetModal, setShowResetModal] = useState(false);
      const [showSubscriptionModal, setShowSubscriptionModal] = useState(false);
      const [subActiveGlobal, setSubActiveGlobal] = useState(() => { try { return JSON.parse(localStorage.getItem('subscriptionActive')||'false'); } catch (_) { return false; } });
      const [aiRemainingGlobal, setAiRemainingGlobal] = useState({ count: 0, limit: 0 });

      // Add these new AI states:
      const [scanResult, setScanResult] = useState(() => {
        // For signed-in users, start with null and let remote data load via useEffect
        if (user) {
          return null;
        }
        const saved = localStorage.getItem('scanResult');
        return saved ? JSON.parse(saved) : null;
      });
      const [scanLoading, setScanLoading] = useState(false);
      const [scanError, setScanError] = useState(null);

      const [mealPlan, setMealPlan] = useState(() => {
        // For signed-in users, start with null and let remote data load via useEffect
        if (user) {
          return null;
        }
        const saved = localStorage.getItem('mealPlan');
        return saved ? JSON.parse(saved) : null;
      });
      const [mealPlanLoading, setMealPlanLoading] = useState(false);
      const [mealPlanError, setMealPlanError] = useState(null);

      const [workoutPlan, setWorkoutPlan] = useState(() => {
        // For signed-in users, start with null and let remote data load via useEffect
        if (user) {
          return null;
        }
        const saved = localStorage.getItem('workoutPlan');
        return saved ? JSON.parse(saved) : null;
      });
      const [workoutPlanLoading, setWorkoutPlanLoading] = useState(false);
      const [workoutPlanError, setWorkoutPlanError] = useState(null);

      const [formAnalysis, setFormAnalysis] = useState(() => {
        // For signed-in users, start with null and let remote data load via useEffect
        if (user) {
          return null;
        }
        const saved = localStorage.getItem('formAnalysis');
        return saved ? JSON.parse(saved) : null;
      });
      const [formAnalysisLoading, setFormAnalysisLoading] = useState(false);
      const [formAnalysisError, setFormAnalysisError] = useState(null);

      useEffect(() => {
        if (isDarkMode) {
          document.documentElement.classList.add('dark');
        } else {
          document.documentElement.classList.remove('dark');
        }
        localStorage.setItem('fitmate-dark-mode', isDarkMode.toString());
      }, [isDarkMode]);

      useEffect(() => {
        if ('Notification' in window && Notification.permission === 'default') {
          Notification.requestPermission();
        }
      }, []);

      // Simplified: no periodic rollover. Midnight reset is handled by the scheduled timer,
      // and if the app opens the next day, on-mount archiving will finalize the prior day.
      useEffect(() => { return () => {}; }, []);

      // Open reset modal if Supabase notifies PASSWORD_RECOVERY (fallback to event)
      useEffect(() => {
        const handler = () => setShowResetModal(true);
        window.addEventListener('supabase-password-recovery', handler);
        return () => window.removeEventListener('supabase-password-recovery', handler);
      }, []);

      const computeAiRemainingGlobal = React.useCallback(async () => {
        // Get user from auth session directly to avoid stale React state
        let uid = null;
        try {
          if (auth && auth.getSession) {
            const { data: { session } } = await auth.getSession();
            uid = session && session.user ? session.user.id : null;
          }
        } catch (_) {}
        
        const todayISO = typeof toLocalISODate === 'function' ? toLocalISODate(new Date()) : new Date().toISOString().slice(0,10);
        let usage = {};
        try { usage = JSON.parse(localStorage.getItem('aiUsage') || '{}') || {}; } catch (_) {}
        const key = uid || 'anon';
        const count = Number((usage[todayISO] && usage[todayISO][key]) || 0);
        let subscribed = false;
        try { subscribed = JSON.parse(localStorage.getItem('subscriptionActive') || 'false'); } catch (_) {}
        const limit = subscribed ? 15 : (uid ? 5 : 3);
        setAiRemainingGlobal({ count, limit });
      }, []);

      useEffect(() => {
        computeAiRemainingGlobal();
        const openSub = async () => {
          await computeAiRemainingGlobal();
          if (!user) {
            setShowSubscriptionModal(false);
            setScreen('profile');
            setTimeout(() => { try { window.dispatchEvent(new Event('open-account-modal')); } catch (_) {} }, 50);
          } else {
            try { window.dispatchEvent(new Event('close-account-modal')); } catch (_) {}
            try { setTimeout(() => { window.dispatchEvent(new Event('close-account-modal')); }, 0); } catch (_) {}
            try { setTimeout(() => { window.dispatchEvent(new Event('close-account-modal')); }, 150); } catch (_) {}
            setShowSubscriptionModal(true);
          }
        };
        const openOnQuota = async () => {
          // Same logic as forceOpenSub for consistency
          let uid = null;
          try {
            if (auth && auth.getSession) {
              const { data: { session } } = await auth.getSession();
              uid = session && session.user ? session.user.id : null;
            }
          } catch (_) {}
          
          const todayISO = typeof toLocalISODate === 'function' ? toLocalISODate(new Date()) : new Date().toISOString().slice(0,10);
          let usage = {};
          try { usage = JSON.parse(localStorage.getItem('aiUsage') || '{}') || {}; } catch (_) {}
          const key = uid || 'anon';
          const count = Number((usage[todayISO] && usage[todayISO][key]) || 0);
          let subscribed = false;
          try { subscribed = JSON.parse(localStorage.getItem('subscriptionActive') || 'false'); } catch (_) {}
          const limit = subscribed ? 15 : (uid ? 5 : 3);
          setAiRemainingGlobal({ count, limit });
          
          if (!user) {
            setShowSubscriptionModal(false);
            setScreen('profile');
            setTimeout(() => { try { window.dispatchEvent(new Event('open-account-modal')); } catch (_) {} }, 50);
          } else {
            try { window.dispatchEvent(new Event('close-account-modal')); } catch (_) {}
            setShowSubscriptionModal(true);
          }
        };
        const onVis = () => { if (!document.hidden) computeAiRemainingGlobal().catch(() => {}); };
        const forceOpenSub = async () => { 
          // Force immediate recompute before opening modal - must match AI limiter logic exactly
          let uid = null;
          try {
            if (auth && auth.getSession) {
              const { data: { session } } = await auth.getSession();
              uid = session && session.user ? session.user.id : null;
            }
          } catch (_) {}
          
          const todayISO = typeof toLocalISODate === 'function' ? toLocalISODate(new Date()) : new Date().toISOString().slice(0,10);
          let usage = {};
          try { usage = JSON.parse(localStorage.getItem('aiUsage') || '{}') || {}; } catch (_) {}
          const key = uid || 'anon';
          const count = Number((usage[todayISO] && usage[todayISO][key]) || 0);
          let subscribed = false;
          try { subscribed = JSON.parse(localStorage.getItem('subscriptionActive') || 'false'); } catch (_) {}
          const limit = subscribed ? 15 : (uid ? 5 : 3);
          
          console.log('üîç Force-open modal debug:', { uid, key, todayISO, count, limit, subscribed, usage: usage[todayISO] });
          
          setAiRemainingGlobal({ count, limit });
          try { window.dispatchEvent(new Event('close-account-modal')); } catch (_) {} try { setTimeout(() => { window.dispatchEvent(new Event('close-account-modal')); }, 0); } catch (_) {} try { setTimeout(() => { window.dispatchEvent(new Event('close-account-modal')); }, 150); } catch (_) {} setShowSubscriptionModal(true); 
        };
        window.addEventListener('open-subscription-modal', openSub);
        window.addEventListener('force-open-subscription-modal', forceOpenSub);
        window.addEventListener('ai-quota-exceeded', openOnQuota);
        const requestAccountModal = () => {
          try { window.dispatchEvent(new Event('close-account-modal')); } catch (_) {}
          setScreen('profile');
          setTimeout(() => { try { window.dispatchEvent(new Event('open-account-modal')); } catch (_) {} }, 50);
        };
        window.addEventListener('request-account-modal', requestAccountModal);
        document.addEventListener('visibilitychange', onVis);
        let off = null;
        if (window.fitmateIAP && typeof window.fitmateIAP.onStatusChange === 'function') {
          off = window.fitmateIAP.onStatusChange((active) => { 
            setSubActiveGlobal(!!active); 
            // Fire and forget - don't block the event handler
            computeAiRemainingGlobal().catch(() => {}); 
          });
        }
        return () => {
          window.removeEventListener('open-subscription-modal', openSub);
          window.removeEventListener('force-open-subscription-modal', forceOpenSub);
          window.removeEventListener('ai-quota-exceeded', openOnQuota);
          window.removeEventListener('request-account-modal', requestAccountModal);
          document.removeEventListener('visibilitychange', onVis);
          if (off) off();
        };
      }, [computeAiRemainingGlobal]);

      // Handle Supabase auth links (email confirmation and password recovery)
      useEffect(() => {
        if (!auth) return;
        const url = new URL(window.location.href);
        // Support both query (?code=) and hash (#access_token=) styles
        const hash = window.location.hash.startsWith('#') ? window.location.hash.slice(1) : window.location.hash;
        const hashParams = new URLSearchParams(hash);
        const searchParams = url.searchParams;

        const code = searchParams.get('code') || hashParams.get('code');
        const type = searchParams.get('type') || hashParams.get('type'); // 'recovery' when coming from reset email
        const accessToken = hashParams.get('access_token');
        const refreshToken = hashParams.get('refresh_token');

        (async () => {
          try {
            // For all Supabase auth links, establish a session
            if (code) {
              const { error } = await auth.exchangeCodeForSession({ code });
              if (error) console.error('exchangeCodeForSession error:', error.message);
              searchParams.delete('code');
            } else if (accessToken && refreshToken) {
              // Hash flow: set session directly
              const { error } = await auth.setSession({
                access_token: accessToken,
                refresh_token: refreshToken
              });
              if (error) console.error('setSession error:', error.message);
            }
          } finally {
            // If this was a password recovery link, open Reset modal
            if (type === 'recovery') {
              setShowResetModal(true);
              searchParams.delete('type');
            }
            // Clean URL (remove hash and processed params)
            const clean = url.origin + url.pathname + (searchParams.toString() ? `?${searchParams.toString()}` : '');
            window.history.replaceState({}, document.title, clean);
            if (window.location.hash) {
              window.location.hash = '';
            }
          }
        })();
      }, []);

      // Persist current screen state
      useEffect(() => {
        localStorage.setItem('fitmate-current-screen', screen);
      }, [screen]);

      // Listen for userDataSynced/remoteDataApplied events to refresh React state
      useEffect(() => {
        const handleUserDataSynced = (evt) => {
          console.log('üîÑ Refreshing React state after sync...');
          const payload = evt && evt.detail && evt.detail.userData ? evt.detail.userData : null;
          
          // Prefer event payload (freshest). Fallback to localStorage.
          if (payload && payload.goals) {
            setGoals(payload.goals);
            try { localStorage.setItem('goals', JSON.stringify(payload.goals)); } catch (_) {}
            console.log('‚úÖ Goals applied from event payload');
          } else {
            const savedGoals = localStorage.getItem('goals');
            if (savedGoals) {
              const goalsData = JSON.parse(savedGoals);
              setGoals(goalsData);
              console.log('‚úÖ Goals synced:', goalsData);
            }
          }
          
          if (payload && payload.daily_intake) {
            try {
              const todayISO = toLocalISODate(new Date());
              const remoteUpdateIsToday = !!payload.updated_at && toLocalISODate(new Date(payload.updated_at)) === todayISO;
              const remoteDayStamp = payload.daily_intake?.__day;
              const remoteDayMatchesToday = remoteDayStamp ? (remoteDayStamp === todayISO) : remoteUpdateIsToday;
              if (!remoteDayMatchesToday) {
                console.log('‚è≠Ô∏è Skipping remote daily_intake from event payload (day stamp mismatch)');
              } else {
                const localIntakeDate = localStorage.getItem('dailyIntakeDate');
                const lastSaved = localStorage.getItem('lastSavedDate');
                const rolledToToday = (localIntakeDate === todayISO && lastSaved === todayISO);
                const currentLocal = JSON.parse(localStorage.getItem('dailyIntake') || '{}') || {};
                const localIsZero = ['calories','protein','carbs','fat','activity','water'].every(k => Number(currentLocal[k]||0) === 0);
                const remoteHasNonZero = ['calories','protein','carbs','fat','activity','water'].some(k => Number(payload.daily_intake?.[k]||0) > 0);
                const localMeals = (() => { try { return JSON.parse(localStorage.getItem('recentMeals') || '[]') || []; } catch { return []; } })();
                const localHasStarted = !localIsZero || (Array.isArray(localMeals) && localMeals.length > 0);
                if (rolledToToday && !localHasStarted && remoteHasNonZero) {
                  console.log('‚è≠Ô∏è Skipping remote daily_intake from event payload until local day start');
                } else {
                  const remoteTs = payload && payload.updated_at ? new Date(payload.updated_at).getTime() : 0;
                  const lastSyncTs = parseInt(localStorage.getItem('lastSyncTimestamp') || '0');
                  const remoteOlderThanLocalWrite = !!lastSyncTs && !!remoteTs && remoteTs <= lastSyncTs;
                  if (remoteOlderThanLocalWrite) {
                    console.log('‚è≠Ô∏è Skipping remote daily_intake from event payload (local newer write)');
                  } else {
                    const merged = {
                      ...payload.daily_intake,
                      activity: Math.max(Number(payload.daily_intake?.activity || 0), Number(currentLocal.activity || 0)),
                      water: Math.max(Number(payload.daily_intake?.water || 0), Number(currentLocal.water || 0))
                    };
                    setDailyIntake(merged);
                    try { localStorage.setItem('dailyIntake', JSON.stringify(merged)); } catch (_) {}
                    console.log('‚úÖ Daily intake applied from event (activity remote-only):', merged.activity);
                  }
                }
              }
            } catch (_) {
              console.log('‚ö†Ô∏è Event payload intake merge failed; leaving local untouched');
            }
          } else {
            const savedIntake = localStorage.getItem('dailyIntake');
            if (savedIntake) {
              const intakeData = JSON.parse(savedIntake);
              setDailyIntake(intakeData);
              console.log('‚úÖ Daily intake synced from localStorage:', intakeData);
            }
          }
          
          if (payload && payload.recent_meals) {
            try {
              const todayISO = toLocalISODate(new Date());
              const remoteUpdateIsToday = !!payload.updated_at && toLocalISODate(new Date(payload.updated_at)) === todayISO;
              if (!remoteUpdateIsToday) {
                console.log('‚è≠Ô∏è Skipping remote recent_meals from event payload (updated_at not today)');
              } else {
                const localIntakeDate = localStorage.getItem('dailyIntakeDate');
                const lastSaved = localStorage.getItem('lastSavedDate');
                const rolledToToday = (localIntakeDate === todayISO && lastSaved === todayISO);
                const localMeals = (() => { try { return JSON.parse(localStorage.getItem('recentMeals') || '[]') || []; } catch { return []; } })();
                const localIsEmpty = !Array.isArray(localMeals) || localMeals.length === 0;
                const remoteHasMeals = Array.isArray(payload.recent_meals) && payload.recent_meals.length > 0;
                const remoteTs = payload && payload.updated_at ? new Date(payload.updated_at).getTime() : 0;
                const resetAt = parseInt(localStorage.getItem('midnightResetAt') || '0');
                const remoteOlderThanReset = resetAt && remoteTs && (remoteTs <= resetAt);
                if (rolledToToday && localIsEmpty && remoteHasMeals && remoteOlderThanReset) {
                  console.log('‚è≠Ô∏è Skipping remote recent_meals from event payload after local reset');
                } else {
                  const todaysMeals = (Array.isArray(payload.recent_meals) ? payload.recent_meals.filter(m => m && m.__day === todayISO) : []);
                  setRecentMeals(todaysMeals);
                  try { localStorage.setItem('recentMeals', JSON.stringify(todaysMeals)); } catch (_) {}
                  console.log('‚úÖ Recent meals applied from event payload');
                }
              }
            } catch (_) {
              const todayISO = toLocalISODate(new Date());
              const todaysMeals = (Array.isArray(payload.recent_meals) ? payload.recent_meals.filter(m => m && m.__day === todayISO) : []);
              setRecentMeals(todaysMeals);
              try { localStorage.setItem('recentMeals', JSON.stringify(todaysMeals)); } catch (__e) {}
              console.log('‚úÖ Recent meals applied from event payload');
            }
          } else {
            const savedMeals = localStorage.getItem('recentMeals');
            if (savedMeals) {
              const mealsData = JSON.parse(savedMeals);
              setRecentMeals(mealsData);
              console.log('‚úÖ Recent meals synced:', mealsData);
            }
          }
          
          const savedHistory = localStorage.getItem('dailyHistory');
          if (savedHistory) {
            let historyData = JSON.parse(savedHistory);
            setDailyHistory(historyData);
            console.log('‚úÖ Daily history synced:', historyData);
          }
          
          // Skip dark mode refresh - it's managed by its own useEffect
          // const savedDarkMode = localStorage.getItem('fitmate-dark-mode');
          // if (savedDarkMode) {
          //   setIsDarkMode(savedDarkMode === 'true');
          //   console.log('‚úÖ Dark mode setting synced');
          // }
          
          console.log('‚úÖ All React state refreshed after sync');
        };
        
        window.addEventListener('userDataSynced', handleUserDataSynced);
        window.addEventListener('remoteDataApplied', handleUserDataSynced);

        // If remote finished applying before this listener mounted, hydrate now
        try {
          if (localStorage.getItem('pendingUserDataSynced') === '1') {
            console.log('üîÅ Pending userDataSynced detected on mount; hydrating state now');
            handleUserDataSynced();
          }
          const rawPending = localStorage.getItem('pendingHydratePayload');
          if (rawPending) {
            try {
              const payload = JSON.parse(rawPending);
              console.log('üß© Found pendingHydratePayload; hydrating state now');
              if (window.fitmateHydrateFromRemote) {
                window.fitmateHydrateFromRemote(payload);
              } else {
                handleUserDataSynced({ detail: { userData: payload } });
              }
            } finally {
              localStorage.removeItem('pendingHydratePayload');
            }
          }
        } catch (_) {}
        
        return () => {
          window.removeEventListener('userDataSynced', handleUserDataSynced);
          window.removeEventListener('remoteDataApplied', handleUserDataSynced);
        };
      }, []);

      // Auth state changes are handled by AuthProvider context

      const toggleDarkMode = () => {
        setIsDarkMode(prev => !prev);
      };

      // --- State Initialization from localStorage ---
      const [goals, setGoals] = useState(() => {
        // For signed-in users, start with defaults and let remote data load via useEffect
        if (user) {
          return defaultGoals;
        }
        const savedGoals = localStorage.getItem('goals');
        return savedGoals ? JSON.parse(savedGoals) : defaultGoals;
      });

      const [dailyIntake, setDailyIntake] = useState(() => {
        try {
          const zero = { calories: 0, protein: 0, carbs: 0, fat: 0, activity: 0, water: 0 };
          const today = toLocalISODate(new Date());
          
          // Rollover disabled: load saved intake directly
          if (user) {
            return zero;
          }
          const savedIntake = localStorage.getItem('dailyIntake');
          return savedIntake ? JSON.parse(savedIntake) : zero;
        } catch (_) {
          return { calories: 0, protein: 0, carbs: 0, fat: 0, activity: 0, water: 0 };
        }
      });

      const [recentMeals, setRecentMeals] = useState(() => {
        // For signed-in users, start with empty array and let remote data load via useEffect
        if (user) {
          return [];
        }
        const savedMeals = localStorage.getItem('recentMeals');
        return savedMeals ? JSON.parse(savedMeals) : [];
      });

      const [dailyHistory, setDailyHistory] = useState(() => {
        // For signed-in users, start with empty object and let remote data load via useEffect
        if (user) {
          return {};
        }
        const savedHistory = localStorage.getItem('dailyHistory');
        return savedHistory ? JSON.parse(savedHistory) : {};
      });

      // Global hydrator: allows AuthProvider to hydrate UI directly from remote payload
      useEffect(() => {
        window.fitmateHydrateFromRemote = (payload) => {
          try {
            if (!payload || typeof payload !== 'object') return;
            if (payload.goals) {
              setGoals(payload.goals);
              try { localStorage.setItem('goals', JSON.stringify(payload.goals)); } catch (_) {}
            }
            if (payload.daily_intake) {
              try {
                const todayISO = toLocalISODate(new Date());
                const remoteUpdateIsToday = !!payload.updated_at && toLocalISODate(new Date(payload.updated_at)) === todayISO;
                const remoteDayStamp = payload.daily_intake?.__day;
                const remoteDayMatchesToday = remoteDayStamp ? (remoteDayStamp === todayISO) : remoteUpdateIsToday;
                const resetAt = parseInt(localStorage.getItem('midnightResetAt') || '0');
                const remoteTs = payload.updated_at ? new Date(payload.updated_at).getTime() : 0;
                const remoteOlderThanReset = resetAt && remoteTs && (remoteTs <= resetAt);
                if (!remoteDayMatchesToday || remoteOlderThanReset) {
                  console.log(remoteOlderThanReset ? '‚è≠Ô∏è Hydrate: skipping remote intake (stale vs midnight reset)' : '‚è≠Ô∏è Hydrate: skipping remote intake (day stamp mismatch)');
                  // Fallback: archive past-day intake into local history
                  try {
                    if (remoteDayStamp && remoteDayStamp !== todayISO) {
                      const remoteHasNonZero = ['calories','protein','carbs','fat','activity','water'].some(k => Number(payload.daily_intake?.[k]||0) > 0);
                      if (remoteHasNonZero) {
                        const dh = (() => { try { return JSON.parse(localStorage.getItem('dailyHistory')||'{}')||{}; } catch { return {}; } })();
                        const prev = dh[remoteDayStamp] || {};
                        const prevIntake = prev.intake || {};
                        dh[remoteDayStamp] = { ...prev, intake: { ...prevIntake, ...payload.daily_intake } };
                        localStorage.setItem('dailyHistory', JSON.stringify(dh));
                        console.log('üì¶ Hydrate: archived remote intake into history for past day', remoteDayStamp);
                      }
                    }
                  } catch (_) {}
                } else {
                  const localIntake = (() => { try { return JSON.parse(localStorage.getItem('dailyIntake')||'{}'); } catch { return {}; } })();
                  const localIsZero = ['calories','protein','carbs','fat','activity','water'].every(k => Number(localIntake[k]||0) === 0);
                  const remoteHasNonZero = ['calories','protein','carbs','fat','activity','water'].some(k => Number(payload.daily_intake?.[k]||0) > 0);
                  const localMeals = (() => { try { return JSON.parse(localStorage.getItem('recentMeals') || '[]') || []; } catch { return []; } })();
                  const localHasStarted = !localIsZero || (Array.isArray(localMeals) && localMeals.length > 0);
                  const shouldDeferIntake = !!resetAt && !localHasStarted && remoteHasNonZero;
                  const lastSyncTs = parseInt(localStorage.getItem('lastSyncTimestamp') || '0');
                  const remoteOlderThanLocalWrite = !!lastSyncTs && !!remoteTs && remoteTs <= lastSyncTs;
                  if (shouldDeferIntake) {
                    console.log('‚è≠Ô∏è Hydrate: deferring remote intake until local activity starts', { resetAt, localHasStarted, remoteHasNonZero });
                  } else if (remoteOlderThanLocalWrite) {
                    console.log('‚è≠Ô∏è Hydrate: skipping remote intake (local newer write)');
                  } else {
                    const merged = { 
                      ...payload.daily_intake, 
                      // Monotonic today-only merge: keep the higher values
                      activity: Math.max(Number(payload.daily_intake?.activity || 0), Number(localIntake.activity || 0)),
                      water: Math.max(Number(payload.daily_intake?.water || 0), Number(localIntake.water || 0))
                    };
                    setDailyIntake(merged);
                    try { localStorage.setItem('dailyIntake', JSON.stringify(merged)); } catch (_) {}
                    console.log('‚úÖ Hydrate: applied intake (activity/water monotonic merge)');
                  }
                }
              } catch (_e) {
                console.log('‚ö†Ô∏è Hydrate: intake merge failed; leaving local untouched');
              }
            }
            if (payload.recent_meals) {
              try {
                const todayISO = toLocalISODate(new Date());
                const remoteUpdateIsToday = !!payload.updated_at && toLocalISODate(new Date(payload.updated_at)) === todayISO;
                const resetAt = parseInt(localStorage.getItem('midnightResetAt') || '0');
                const remoteTs = payload.updated_at ? new Date(payload.updated_at).getTime() : 0;
                const lastSyncTs = parseInt(localStorage.getItem('lastSyncTimestamp') || '0');
                const remoteOlderThanReset = resetAt && remoteTs && (remoteTs <= resetAt);

                if (!remoteUpdateIsToday || remoteOlderThanReset) {
                  console.log(remoteOlderThanReset ? '‚è≠Ô∏è Hydrate: skipping recent_meals (stale vs midnight reset)' : '‚è≠Ô∏è Hydrate: skipping recent_meals (updated_at not today)');
                } else {
                  const localMeals = (() => { try { return JSON.parse(localStorage.getItem('recentMeals') || '[]') || []; } catch { return []; } })();
                  const localIsEmpty = !Array.isArray(localMeals) || localMeals.length === 0;
                  const remoteHasMeals = Array.isArray(payload.recent_meals) && payload.recent_meals.length > 0;
                  const shouldDeferMeals = !!resetAt && localIsEmpty && remoteHasMeals;
                  const remoteOlderThanLocalWrite = !!lastSyncTs && !!remoteTs && remoteTs <= lastSyncTs;
                  if (shouldDeferMeals) {
                    console.log('‚è≠Ô∏è Hydrate: deferring recent_meals until local activity starts', { resetAt, localIsEmpty, remoteHasMeals });
                  } else if (remoteOlderThanLocalWrite) {
                    console.log('‚è≠Ô∏è Hydrate: skipping recent_meals (local newer write)');
                  } else {
                    const todaysRemote = (Array.isArray(payload.recent_meals) ? payload.recent_meals.filter(m => m && m.__day === todayISO) : []);
                    const todaysLocal = (Array.isArray(localMeals) ? localMeals.filter(m => m && m.__day === todayISO) : []);
                    const seen = new Set();
                    const key = (m) => m && (m.id ? String(m.id) : `${m.name||''}|${m.calories||0}|${m.image||''}`);
                    const merged = [];
                    todaysLocal.forEach(m => { const k = key(m); if (!seen.has(k)) { merged.push(m); seen.add(k); } });
                    todaysRemote.forEach(m => { const k = key(m); if (!seen.has(k)) { merged.push(m); seen.add(k); } });
                    const capped = merged.slice(0, 10);
                    setRecentMeals(capped);
                    try { localStorage.setItem('recentMeals', JSON.stringify(capped)); } catch (_) {}
                  }
                }
              } catch (_) {
                console.log('‚ö†Ô∏è Hydrate: meals merge failed; leaving local untouched');
              }
            }
            if (payload.daily_history) {
              try {
                const localDH = JSON.parse(localStorage.getItem('dailyHistory') || '{}') || {};
                const merged = { ...payload.daily_history, ...localDH }; // prefer local for conflicts
                setDailyHistory(merged);
                try { localStorage.setItem('dailyHistory', JSON.stringify(merged)); } catch (_) {}
              } catch (_) {
                setDailyHistory(payload.daily_history);
                try { localStorage.setItem('dailyHistory', JSON.stringify(payload.daily_history)); } catch (_) {}
              }
            }
            try { window.dispatchEvent(new CustomEvent('userDataSynced', { detail: { userData: payload } })); } catch (_) {}
          } catch (e) {
            console.warn('fitmateHydrateFromRemote failed:', e);
          }
        };
        return () => { try { delete window.fitmateHydrateFromRemote; } catch (_) {} };
      }, []);
      

      // --- Enhanced Data Persistence with Supabase Sync ---
      const { user, updateUserData, syncDailyIntake, syncMealsData, syncDailyHistory, syncAIContent, forceNextRemoteOnlyRef, authInitialRemoteAppliedRef } = useAuth();
      const isRemoteSyncRef = useRef(false);
      // Track initial state to avoid overwriting remote with local defaults/stale data
      const hadDailyIntakeAtStartRef = useRef(!!localStorage.getItem('dailyIntake'));
      const hadGoalsAtStartRef = useRef(!!localStorage.getItem('goals'));
      const hadMealsAtStartRef = useRef((() => { try { return (JSON.parse(localStorage.getItem('recentMeals') || '[]') || []).length > 0; } catch { return false; } })());
      const hadHistoryAtStartRef = useRef((() => { try { return Object.keys(JSON.parse(localStorage.getItem('dailyHistory') || '{}') || {}).length > 0; } catch { return false; } })());
      const initialSyncCompletedRef = useRef(false);
const midnightTimerRef = useRef(null);

      // Day-Boundary Watcher: Archive previous day and reset today
      useEffect(() => {
        const finalizeIfDayChanged = () => {
          try {
            const todayISO = toLocalISODate(new Date());
            let lastSaved = localStorage.getItem('lastSavedDate') || '';
            let intakeDate = localStorage.getItem('dailyIntakeDate') || '';
            const currentIntake = (() => { try { return JSON.parse(localStorage.getItem('dailyIntake') || '{}') || {}; } catch { return {}; } })();
            const currentMeals = (() => { try { return JSON.parse(localStorage.getItem('recentMeals') || '[]') || []; } catch { return []; } })();
            const hasContent = ['calories','protein','carbs','fat','activity','water'].some(k => Number(currentIntake[k]||0) > 0) || (Array.isArray(currentMeals) && currentMeals.length > 0);
            const resetAt = parseInt(localStorage.getItem('midnightResetAt') || '0');
            const rolledToToday = (!!intakeDate && intakeDate === todayISO) && (!!lastSaved && lastSaved === todayISO);
            // Infer the actual content day from stamps if present; default to today
            const inferredDay = (() => {
              try {
                const diDay = typeof currentIntake.__day === 'string' ? currentIntake.__day : '';
                if (diDay) return diDay;
              } catch {}
              try {
                if (Array.isArray(currentMeals) && currentMeals.length > 0) {
                  const uniqueDays = Array.from(new Set(currentMeals.map(m => m && m.__day).filter(Boolean)));
                  if (uniqueDays.length === 1 && uniqueDays[0]) return uniqueDays[0];
                  if (uniqueDays.includes(todayISO)) return todayISO;
                }
              } catch {}
              return todayISO;
            })();
            // If guard keys are missing but we have content, set them to inferred day (usually today)
            if ((!intakeDate || !lastSaved) && hasContent) {
              intakeDate = intakeDate || inferredDay;
              lastSaved = lastSaved || inferredDay;
            }
            // Only treat as missed rollover if inferred content day is NOT today
            const needsFixForFalseToday = rolledToToday && !resetAt && hasContent && inferredDay !== todayISO;
            const dayChanged = needsFixForFalseToday || (!!intakeDate && intakeDate !== todayISO) || (!!lastSaved && lastSaved !== todayISO);
            if (dayChanged) {
              const prevDate = (intakeDate && intakeDate !== todayISO) ? intakeDate : ((lastSaved && lastSaved !== todayISO) ? lastSaved : inferredDay);
              // Safety: never archive/reset if we still infer content belongs to today
              if (prevDate === todayISO) {
                // Ensure guard keys are set and exit without resetting
                localStorage.setItem('dailyIntakeDate', todayISO);
                localStorage.setItem('lastSavedDate', todayISO);
                return;
              }
              const prevIntake = currentIntake;
              const prevMeals = currentMeals;
              const history = (() => { try { return JSON.parse(localStorage.getItem('dailyHistory') || '{}') || {}; } catch { return {}; } })();
              const scoreObj = computeHealthScoreForDate(prevIntake, goals, prevDate);
              const record = { intake: prevIntake, meals: prevMeals, score: scoreObj?.score, components: scoreObj?.components };
              history[prevDate] = { ...(history[prevDate] || {}), ...record, archivedAt: Date.now(), inProgress: false };
              localStorage.setItem('dailyHistory', JSON.stringify(history));
              try { setDailyHistory(history); } catch (_) {}

              const zero = { calories:0, protein:0, carbs:0, fat:0, activity:0, water:0 };
              localStorage.setItem('dailyIntake', JSON.stringify(zero));
              localStorage.setItem('recentMeals', JSON.stringify([]));
              try { setDailyIntake(zero); } catch (_) {}
              try { setRecentMeals([]); } catch (_) {}
              localStorage.removeItem('activityTimerState');

              localStorage.setItem('dailyIntakeDate', todayISO);
              localStorage.setItem('lastSavedDate', todayISO);
              localStorage.setItem('midnightResetAt', String(Date.now()));

              // Push reset to Supabase to mark today's zeroed intake/meals and persist archived daily_history
              if (user && supabase && !forceNextRemoteOnlyRef?.current && authInitialRemoteAppliedRef?.current) {
                const currentTimestamp = new Date().toISOString();
                const update = { 
                  daily_intake: { ...zero, __day: todayISO }, 
                  recent_meals: [], 
                  daily_history: history,
                  updated_at: currentTimestamp 
                };
                queueUserUpdate(user.id, update)
                  .then(() => {
                    try { localStorage.setItem('lastSyncTimestamp', Date.now().toString()); } catch (_) {}
                    console.log('üì§ Midnight reset: queued Supabase update with zeros, today timestamp, and archived daily_history');
                  })
                  .catch((pushErr) => {
                    console.warn('‚ö†Ô∏è Midnight reset: Supabase push failed; will rely on next sync', pushErr);
                  });
              } else {
                console.log('üì§ Midnight reset: skipped Supabase push (auth gating active)');
              }

              try { window.dispatchEvent(new CustomEvent('userDataSynced')); } catch (_) {}
              console.log(`üåô Midnight reset: archived ${prevDate} with score ${scoreObj?.score ?? 'n/a'} and reset to zero`);
            } else {
              // Initialize guard keys only when there is no content (fresh start)
              if ((!intakeDate || !lastSaved) && !hasContent) {
                localStorage.setItem('dailyIntakeDate', todayISO);
                localStorage.setItem('lastSavedDate', todayISO);
              }
            }
          } catch (e) {
            console.warn('Midnight reset check failed:', e);
          }
        };
        finalizeIfDayChanged();
        const intervalId = setInterval(finalizeIfDayChanged, 60 * 1000);
        const onVis = () => { if (!document.hidden) finalizeIfDayChanged(); };
        document.addEventListener('visibilitychange', onVis, true);
        return () => { clearInterval(intervalId); document.removeEventListener('visibilitychange', onVis, true); };
      }, [user]);
      const isDefaultIntake = (di) => !di || (
        Number(di.calories) === 0 &&
        Number(di.protein) === 0 &&
        Number(di.carbs) === 0 &&
        Number(di.fat) === 0 &&
        Number(di.activity) === 0 &&
        Number(di.water) === 0
      );

      // Realtime listener to reflect remote changes into UI/localStorage (Supabase)
      useEffect(() => {
        if (!user || !supabase || !USERS_REALTIME_ENABLED) return;
        
        const subscription = db.subscribe('users', (payload) => {
          if (payload.new && payload.new.id === user.id) {
            const userData = payload.new;
            if (!userData) return;

            // Update localStorage from remote (using Supabase column names)
            if (userData.goals) localStorage.setItem('goals', JSON.stringify(userData.goals));
            if (userData.profile_picture) localStorage.setItem('profilePicture', userData.profile_picture);
            if (userData.notifications_enabled !== undefined) localStorage.setItem('notificationsEnabled', JSON.stringify(userData.notifications_enabled));
            // Skip syncing dark_mode from remote - it's a local UI preference
              if (userData.daily_intake) {
                try {
                  const todayISO = toLocalISODate(new Date());
                  const remoteUpdateIsToday = !!userData.updated_at && toLocalISODate(new Date(userData.updated_at)) === todayISO;
                  const remoteDayStamp = userData.daily_intake?.__day;
                  const remoteDayMatchesToday = remoteDayStamp ? (remoteDayStamp === todayISO) : remoteUpdateIsToday;
                  const resetAt = parseInt(localStorage.getItem('midnightResetAt') || '0');
                  const remoteTs = userData.updated_at ? new Date(userData.updated_at).getTime() : 0;
                  const remoteOlderThanReset = resetAt && remoteTs && (remoteTs <= resetAt);
                if (!remoteDayMatchesToday || remoteOlderThanReset) {
                  console.log(remoteOlderThanReset ? '‚è≠Ô∏è Realtime(sub-2): skipping remote daily_intake (stale vs midnight reset)' : '‚è≠Ô∏è Realtime(sub-2): skipping remote daily_intake (day stamp mismatch)');
                  // Fallback: archive past-day intake into local history
                  try {
                    if (remoteDayStamp && remoteDayStamp !== todayISO) {
                      const remoteHasNonZero = ['calories','protein','carbs','fat','activity','water'].some(k => Number(userData.daily_intake?.[k]||0) > 0);
                      if (remoteHasNonZero) {
                        const dh = (() => { try { return JSON.parse(localStorage.getItem('dailyHistory')||'{}')||{}; } catch { return {}; } })();
                        const prev = dh[remoteDayStamp] || {};
                        const prevIntake = prev.intake || {};
                        dh[remoteDayStamp] = { ...prev, intake: { ...prevIntake, ...userData.daily_intake } };
                        localStorage.setItem('dailyHistory', JSON.stringify(dh));
                        console.log('üì¶ Realtime(sub-2): archived remote intake into history for past day', remoteDayStamp);
                      }
                    }
                  } catch (_) {}
                } else {
                  const lastSyncTs = parseInt(localStorage.getItem('lastSyncTimestamp') || '0');
                  const remoteOlderThanLocalWrite = !!lastSyncTs && !!remoteTs && remoteTs <= lastSyncTs;
                  if (remoteOlderThanLocalWrite) {
                    console.log('‚è≠Ô∏è Realtime(sub-2): skipping remote daily_intake (local newer write)');
                  } else {
                    const existingLocal = (() => { try { return JSON.parse(localStorage.getItem('dailyIntake') || '{}') || {}; } catch { return {}; } })();
                      const merged = {
                        ...userData.daily_intake,
                        // Monotonic merge: prefer higher values for today
                        activity: Math.max(Number(userData.daily_intake?.activity || 0), Number(existingLocal.activity || 0)),
                        water: Math.max(Number(userData.daily_intake?.water || 0), Number(existingLocal.water || 0))
                      };
                      localStorage.setItem('dailyIntake', JSON.stringify(merged));
                      try { setDailyIntake(merged); } catch (_) {}
                  }
                }
              } catch (_) {
                const existingLocal = (() => { try { return JSON.parse(localStorage.getItem('dailyIntake') || '{}') || {}; } catch { return {}; } })();
                const merged = { 
                  ...userData.daily_intake, 
                  activity: Math.max(Number(userData.daily_intake?.activity || 0), Number(existingLocal.activity || 0)),
                  water: Math.max(Number(userData.daily_intake?.water || 0), Number(existingLocal.water || 0)) 
                };
                localStorage.setItem('dailyIntake', JSON.stringify(merged));
                try { setDailyIntake(merged); } catch (_) {}
              }
            }
            if (userData.recent_meals) {
              const todayISO = toLocalISODate(new Date());
              const remoteUpdateIsToday = !!userData.updated_at && toLocalISODate(new Date(userData.updated_at)) === todayISO;
              const resetAt = parseInt(localStorage.getItem('midnightResetAt') || '0');
              const remoteTs = userData.updated_at ? new Date(userData.updated_at).getTime() : 0;
              const lastSyncTs = parseInt(localStorage.getItem('lastSyncTimestamp') || '0');
              const remoteOlderThanReset = resetAt && remoteTs && (remoteTs <= resetAt);
              const remoteOlderThanLocalWrite = !!lastSyncTs && !!remoteTs && remoteTs <= lastSyncTs;
              if (!remoteUpdateIsToday || remoteOlderThanReset) {
                console.log(remoteOlderThanReset ? '‚è≠Ô∏è Realtime(sub-2): skipping remote recent_meals (stale vs midnight reset)' : '‚è≠Ô∏è Realtime(sub-2): skipping remote recent_meals (updated_at not today)');
              } else if (remoteOlderThanLocalWrite) {
                console.log('‚è≠Ô∏è Realtime(sub-2): skipping remote recent_meals (local newer write)');
              } else {
                const localMeals = (() => { try { return JSON.parse(localStorage.getItem('recentMeals') || '[]') || []; } catch { return []; } })();
                const todaysRemote = (Array.isArray(userData.recent_meals) ? userData.recent_meals.filter(m => m && m.__day === todayISO) : []);
                const todaysLocal = (Array.isArray(localMeals) ? localMeals.filter(m => m && m.__day === todayISO) : []);
                const seen = new Set();
                const key = (m) => m && (m.id ? String(m.id) : `${m.name||''}|${m.calories||0}|${m.image||''}`);
                const merged = [];
                todaysLocal.forEach(m => { const k = key(m); if (!seen.has(k)) { merged.push(m); seen.add(k); } });
                todaysRemote.forEach(m => { const k = key(m); if (!seen.has(k)) { merged.push(m); seen.add(k); } });
                const capped = merged.slice(0, 10);
                localStorage.setItem('recentMeals', JSON.stringify(capped));
                try { setRecentMeals(capped); } catch (_) {}
              }
            }
            if (userData.daily_history) {
              // Merge remote history with local, but PREFER LOCAL for conflicting dates
              // to prevent remote from overwriting freshly archived local data.
              try {
                const localDH = JSON.parse(localStorage.getItem('dailyHistory') || '{}') || {};
                const mergedDH = { ...userData.daily_history, ...localDH };
                localStorage.setItem('dailyHistory', JSON.stringify(mergedDH));
              } catch (_) {
                localStorage.setItem('dailyHistory', JSON.stringify(userData.daily_history));
              }
            }
            // Subscription status from backend (Stripe/Play)
            if (userData.subscription) {
              try { localStorage.setItem('subscriptionActive', JSON.stringify(!!userData.subscription.active)); } catch (_) {}
              try { window.dispatchEvent(new CustomEvent('subscription-status-changed', { detail: { active: !!userData.subscription.active } })); } catch (_) {}
            }
            if (userData.coach_messages) localStorage.setItem('coachMessages', JSON.stringify(userData.coach_messages));
            if (userData.habit_ai_advice) localStorage.setItem('habitAIAdvice', userData.habit_ai_advice);
            if (userData.habits) localStorage.setItem('habits', JSON.stringify(userData.habits));
            if (userData.meal_plan) localStorage.setItem('mealPlan', JSON.stringify(userData.meal_plan));
            if (userData.workout_plan) localStorage.setItem('workoutPlan', JSON.stringify(userData.workout_plan));
            // AI usage: merge remote with local using MAX to prevent overwrites
            if (userData.ai_usage) {
              try {
                const remoteUsage = userData.ai_usage || {};
                const localUsage = JSON.parse(localStorage.getItem('aiUsage') || '{}') || {};
                const merged = { ...localUsage };
                // For each date in remote, take MAX of counts
                Object.keys(remoteUsage).forEach(date => {
                  if (!merged[date]) merged[date] = {};
                  Object.keys(remoteUsage[date]).forEach(uid => {
                    const remoteCount = Number(remoteUsage[date][uid] || 0);
                    const localCount = Number(merged[date][uid] || 0);
                    merged[date][uid] = Math.max(remoteCount, localCount);
                  });
                });
                localStorage.setItem('aiUsage', JSON.stringify(merged));
                console.log('‚úÖ AI usage synced from remote (MAX logic applied)');
              } catch (err) {
                console.error('Error syncing AI usage:', err);
              }
            }
            if (userData.scan_result) localStorage.setItem('scanResult', JSON.stringify(userData.scan_result));
            if (userData.form_analysis) localStorage.setItem('formAnalysis', JSON.stringify(userData.form_analysis));

            // Prevent feedback loop: mark update as remote, then refresh UI
            // Also directly notify UI with latest payload
            try { window.dispatchEvent(new CustomEvent('subscription-status-changed', { detail: { active: !!userData.subscription.active } })); } catch (_) {}
            try {
              localStorage.setItem('pendingHydratePayload', JSON.stringify(remoteData));
              if (window.fitmateHydrateFromRemote) window.fitmateHydrateFromRemote(remoteData);
            } catch (_) {}
            isRemoteSyncRef.current = true;
            try { localStorage.setItem('pendingUserDataSynced', '1'); } catch (_) {}
            window.dispatchEvent(new CustomEvent('userDataSynced', { detail: { userData: remoteData } }));
            // Also signal that remote data has been applied (for initial-sync gating)
            window.dispatchEvent(new CustomEvent('remoteDataApplied', { detail: { userData: remoteData } }));
            // Re-dispatch after short delays to catch listeners that mount slightly later
            setTimeout(() => { try { window.dispatchEvent(new CustomEvent('userDataSynced', { detail: { userData: remoteData } })); } catch (_) {} }, 300);
            setTimeout(() => { try { window.dispatchEvent(new CustomEvent('userDataSynced', { detail: { userData: remoteData } })); } catch (_) {} try { localStorage.removeItem('pendingUserDataSynced'); } catch (_) {} }, 800);
            setTimeout(() => { try { window.dispatchEvent(new CustomEvent('userDataSynced', { detail: { userData: remoteData } })); } catch (_) {} }, 1500);
            setTimeout(() => { isRemoteSyncRef.current = false; }, 300);
          }
        }, { filter: `id=eq.${user.id}` });

        return () => subscription.unsubscribe();
      }, [user]);

      // Helper: maintain a live dailyHistory entry for today
      const updateLiveDailyHistorySnapshot = React.useCallback(() => {
        try {
          const todayISO = toLocalISODate(new Date());
          const todaysMeals = Array.isArray(recentMeals) ? recentMeals.filter(m => m && m.__day === todayISO) : [];
          const { score, components } = computeHealthScoreForDate(dailyIntake, goals, todayISO);
          const prev = dailyHistory || {};
          const next = {
            ...prev,
            [todayISO]: {
              ...(prev[todayISO] || {}),
              intake: dailyIntake,
              meals: todaysMeals,
              score,
              components,
              inProgress: true,
              liveUpdatedAt: Date.now()
            }
          };
          setDailyHistory(next);
          try { localStorage.setItem('dailyHistory', JSON.stringify(next)); } catch (_) {}
        } catch (e) {
          console.warn('Live dailyHistory update failed:', e);
        }
      }, [dailyIntake, recentMeals, goals, dailyHistory]);

      // Seed today's live entry after initial remote apply or when signed-out
      useEffect(() => {
        const seedAfterRemote = () => {
          updateLiveDailyHistorySnapshot();
        };
        window.addEventListener('remoteDataApplied', seedAfterRemote);
        // If not signed in, seed immediately
        if (!user) {
          updateLiveDailyHistorySnapshot();
        }
        return () => window.removeEventListener('remoteDataApplied', seedAfterRemote);
      }, [user, updateLiveDailyHistorySnapshot]);

      // Real-time listener for workout_history table to sync workouts across devices
      useEffect(() => {
        if (!user || !supabase || !USERS_REALTIME_ENABLED) return;
        
        console.log('üèãÔ∏è Setting up real-time workout history listener for user:', user.id);
        
        const workoutSubscription = supabase
          .channel(`workout-history-${user.id}`)
          .on('postgres_changes', {
            event: '*',
            schema: 'public',
            table: 'workout_history',
            filter: `user_id=eq.${user.id}`
          }, async (payload) => {
            console.log('üèãÔ∏è Workout history change detected:', payload);
            
            try {
              // Fetch fresh workout history from database
              const { data: workouts, error } = await supabase
                .from('workout_history')
                .select('*')
                .eq('user_id', user.id)
                .order('timestamp', { ascending: false })
                .limit(100);
              
              if (error) throw error;
              
              if (workouts) {
                // Update localStorage with fresh workout data
                localStorage.setItem('workoutHistory', JSON.stringify(workouts));
                console.log(`‚úÖ Workout history synced: ${workouts.length} workouts`);
                
                // Trigger health score recalculation
                window.dispatchEvent(new Event('workout-history-updated'));
              }
            } catch (error) {
              console.error('Error syncing workout history:', error);
            }
          })
          .subscribe();
        
        // Initial fetch of workout history
        (async () => {
          try {
            const { data: workouts, error } = await supabase
              .from('workout_history')
              .select('*')
              .eq('user_id', user.id)
              .order('timestamp', { ascending: false })
              .limit(100);
            
            if (!error && workouts) {
              localStorage.setItem('workoutHistory', JSON.stringify(workouts));
              console.log(`‚úÖ Initial workout history loaded: ${workouts.length} workouts`);
            }
          } catch (error) {
            console.error('Error loading initial workout history:', error);
          }
        })();
        
        return () => {
          workoutSubscription.unsubscribe();
        };
      }, [user]);
      
      useEffect(() => { 
        localStorage.setItem('goals', JSON.stringify(goals));
        // Defer pushing goals until initial remote sync completes AND prevent overwriting remote data
        if (user && !isRemoteSyncRef.current && !forceNextRemoteOnlyRef?.current) {
          if (!initialSyncCompletedRef.current) return;
          // Additional guard: Don't sync if we just loaded remote data
          if (!authInitialRemoteAppliedRef.current) return;
          updateUserData({ goals });
        }
      }, [goals, user, updateUserData]);
      
      useEffect(() => { 
        localStorage.setItem('dailyIntake', JSON.stringify(dailyIntake));
        // DO NOT set dailyIntakeDate here - only finalize logic (on-mount & midnight) should set it.
        // Setting it on every change breaks the "intakeDate !== today" guard in finalize.
        // Maintain live dailyHistory entry for today
        try { updateLiveDailyHistorySnapshot(); } catch (_) {}
        // Defer pushing intake until initial remote sync completes AND prevent overwriting remote data
        if (user && !isRemoteSyncRef.current && !forceNextRemoteOnlyRef?.current) {
          if (!initialSyncCompletedRef.current) return;
          // Additional guard: Don't sync if we just loaded remote data
          if (!authInitialRemoteAppliedRef.current) return;
          syncDailyIntake(dailyIntake);
        }
      }, [dailyIntake, user, syncDailyIntake]);

      // Mark when initial remote sync completes to allow subsequent updates
      useEffect(() => {
        const onRemoteApplied = () => {
          initialSyncCompletedRef.current = true;
          console.log('‚úÖ Initial remote sync completed (flag set)');
        };
        window.addEventListener('remoteDataApplied', onRemoteApplied);
        return () => window.removeEventListener('remoteDataApplied', onRemoteApplied);
      }, []);
      
      useEffect(() => { 
        const todayISO = toLocalISODate(new Date());
        const todaysMeals = Array.isArray(recentMeals) ? recentMeals.filter(m => m && m.__day === todayISO) : [];
        localStorage.setItem('recentMeals', JSON.stringify(todaysMeals));
        // Maintain live dailyHistory entry for today
        try { updateLiveDailyHistorySnapshot(); } catch (_) {}
        // Defer pushing meals until initial remote sync completes AND prevent overwriting remote data
        if (user && !isRemoteSyncRef.current && !forceNextRemoteOnlyRef?.current) {
          if (!initialSyncCompletedRef.current) return;
          // Additional guard: Don't sync if we just loaded remote data
          if (!authInitialRemoteAppliedRef.current) return;
          syncMealsData(todaysMeals);
        }
      }, [recentMeals, user, syncMealsData]);
      
      useEffect(() => { 
        localStorage.setItem('dailyHistory', JSON.stringify(dailyHistory));
        // Defer pushing history until initial remote sync completes AND prevent overwriting remote data
        if (user && !isRemoteSyncRef.current && !forceNextRemoteOnlyRef?.current) {
          if (!initialSyncCompletedRef.current) return;
          // Additional guard: Don't sync if we just loaded remote data
          if (!authInitialRemoteAppliedRef.current) return;
          syncDailyHistory(dailyHistory);
        }
      }, [dailyHistory, user, syncDailyHistory]);
      
      useEffect(() => { 
        localStorage.setItem('coachMessages', JSON.stringify(coachMessages));
        // Prevent overwriting remote data during sign-in
        if (user && !forceNextRemoteOnlyRef?.current && authInitialRemoteAppliedRef.current) {
          updateUserData({ coach_messages: coachMessages });
        }
      }, [coachMessages, user, updateUserData]);
      
      useEffect(() => { 
        localStorage.setItem('habitAIAdvice', habitAIAdvice);
        // Prevent overwriting remote data during sign-in
        if (user && !forceNextRemoteOnlyRef?.current && authInitialRemoteAppliedRef.current) {
          updateUserData({ habit_ai_advice: habitAIAdvice });
        }
      }, [habitAIAdvice, user, updateUserData]);
      
      // --- AI State Persistence with Firebase Sync ---
      useEffect(() => {
        if (scanResult) {
          localStorage.setItem('scanResult', JSON.stringify(scanResult));
          // Prevent overwriting remote data during sign-in
          if (user && !forceNextRemoteOnlyRef?.current && authInitialRemoteAppliedRef.current) {
            syncAIContent('scanResult', scanResult);
          }
        }
      }, [scanResult, user, syncAIContent]);
      
      useEffect(() => {
        if (mealPlan) {
          localStorage.setItem('mealPlan', JSON.stringify(mealPlan));
          // Prevent overwriting remote data during sign-in
          if (user && !forceNextRemoteOnlyRef?.current && authInitialRemoteAppliedRef.current) {
            syncAIContent('mealPlan', mealPlan);
          }
        }
      }, [mealPlan, user, syncAIContent]);
      
      useEffect(() => {
        if (workoutPlan) {
          localStorage.setItem('workoutPlan', JSON.stringify(workoutPlan));
          // Prevent overwriting remote data during sign-in
          if (user && !forceNextRemoteOnlyRef?.current && authInitialRemoteAppliedRef.current) {
            syncAIContent('workoutPlan', workoutPlan);
          }
        }
      }, [workoutPlan, user, syncAIContent]);
      
      useEffect(() => {
        if (formAnalysis) {
          localStorage.setItem('formAnalysis', JSON.stringify(formAnalysis));
          // Prevent overwriting remote data during sign-in
          if (user && !forceNextRemoteOnlyRef?.current && authInitialRemoteAppliedRef.current) {
            syncAIContent('formAnalysis', formAnalysis);
          }
        }
      }, [formAnalysis, user, syncAIContent]);

      // Function to compress image to target size (in KB)
      const compressImageToSize = (base64Image, targetKB, quality = 0.7, maxWidth = 400) => {
        return new Promise((resolve) => {
          if (!base64Image || !base64Image.startsWith('data:image/')) {
            resolve(base64Image);
            return;
          }
          
          const img = new Image();
          img.onload = function() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // Calculate dimensions to fit within maxWidth while maintaining aspect ratio
            let width = img.width;
            let height = img.height;
            
            if (width > maxWidth) {
              height = (height * maxWidth) / width;
              width = maxWidth;
            }
            
            canvas.width = width;
            canvas.height = height;
            
            // Draw image with quality settings
            ctx.imageSmoothingQuality = 'medium';
            ctx.drawImage(img, 0, 0, width, height);
            
            // Function to compress with quality adjustment
            const compressWithQuality = (currentQuality) => {
              try {
                const compressed = canvas.toDataURL('image/jpeg', currentQuality);
                const sizeKB = Math.round(compressed.length / 1024);
                
                if (sizeKB <= targetKB || currentQuality <= 0.3) {
                  resolve(compressed);
                } else {
                  // Reduce quality and try again
                  setTimeout(() => compressWithQuality(currentQuality - 0.1), 10);
                }
              } catch (error) {
                console.warn('Compression error, using original:', error);
                resolve(base64Image);
              }
            };
            
            // Start compression with initial quality
            compressWithQuality(quality);
          };
          
          img.onerror = () => {
            console.warn('Image loading failed, using original');
            resolve(base64Image);
          };
          
          img.src = base64Image;
        });
      };

      // Function to add a new meal to the log - Mobile-optimized crash-resistant version
      const handleLogMeal = async (mealData) => {
        if (!user) {
          try { window.dispatchEvent(new Event('request-account-modal')); } catch (_) {}
          return;
        }
        try { localStorage.setItem('lastSyncTimestamp', Date.now().toString()); } catch (_) {}
        console.log('üìù Logging meal data (mobile-safe):', mealData);
        
        try {
          // Extract nutritional values with fallbacks
          const calories = Number(mealData.calories) || Number(mealData.total_calories) || 0;
          const protein = Number(mealData.protein) || Number(mealData.total_protein) || 0;
          const carbs = Number(mealData.carbs) || Number(mealData.total_carbs) || 0;
          const fat = Number(mealData.fat) || Number(mealData.total_fat) || 0;
          
          // Generate unique meal ID
          const mealId = Date.now();
          
          // Universal image handling - always use original image for both desktop and mobile
          let processedImage = mealData.image || 'https://placehold.co/100x100/cccccc/333333?text=Meal';
          
          if (mealData.image && mealData.image.startsWith('data:image/')) {
            // Client-side compression: Compress image to ~100KB before processing
            try {
              const compressedImage = await compressImageToSize(mealData.image, 100); // Target 100KB
              processedImage = compressedImage;
              console.log('‚úÖ Image compressed for mobile:', Math.round(compressedImage.length / 1024) + 'KB');
            } catch (error) {
              console.warn('Image compression failed, using original:', error);
              processedImage = mealData.image; // Fallback to original
            }
          }
          
          const newMeal = {
            id: mealId,
            name: mealData.name || mealData.food_name || 'Scanned Meal',
            calories: calories,
            image: processedImage,
            mood: mealData.mood || 'Neutral',
            __day: toLocalISODate(new Date())
          };
          
          // Batch state updates with proper error boundaries
          setTimeout(() => {
            try {
              // Update daily intake
              setDailyIntake(prevIntake => ({
                ...prevIntake,
                calories: prevIntake.calories + calories,
                protein: prevIntake.protein + protein,
                carbs: prevIntake.carbs + carbs,
                fat: prevIntake.fat + fat,
              }));
              
              // Add to recent meals (client will persist today-only)
              setRecentMeals(prevMeals => [newMeal, ...prevMeals.slice(0, 9)]); // Limit to 10 items
              
              console.log('üíæ Meal saved successfully:', newMeal);
              
              // Navigate to dashboard with safety delay
              setTimeout(() => {
                try {
                  setScreen('dashboard');
                } catch (navError) {
                  console.error('Navigation error:', navError);
                  // Fallback: reload the page if navigation fails
                  window.location.reload();
                }
              }, 200);
              
            } catch (stateError) {
              console.error('State update error:', stateError);
              // Emergency fallback: reload to recover from state corruption
              window.location.reload();
            }
          }, 50);
          
        } catch (mainError) {
          console.error('Critical error in handleLogMeal:', mainError);
          // Ultimate fallback: reload the entire application
          window.location.reload();
        }
      };

      // Function to log daily activity
      const handleLogActivity = (activity) => {
        const updatedIntake = {
          ...dailyIntake,
          activity: dailyIntake.activity + (activity.minutes || 0),
        };
        setDailyIntake(updatedIntake);
        try { localStorage.setItem('lastSyncTimestamp', Date.now().toString()); } catch (_) {}
        
        // Sync to server only after initial remote fetch completes AND prevent overwriting remote data
        if (user && initialSyncCompletedRef.current && !isRemoteSyncRef.current && !forceNextRemoteOnlyRef?.current && authInitialRemoteAppliedRef.current) {
          syncDailyIntake(updatedIntake);
        }
      };

      const handleLogWater = () => {
        const updatedIntake = {
          ...dailyIntake,
          water: dailyIntake.water + 1,
        };
        setDailyIntake(updatedIntake);
        try { localStorage.setItem('lastSyncTimestamp', Date.now().toString()); } catch (_) {}
        
        // Sync to server only after initial remote fetch completes AND prevent overwriting remote data
        if (user && initialSyncCompletedRef.current && !isRemoteSyncRef.current && !forceNextRemoteOnlyRef?.current && authInitialRemoteAppliedRef.current) {
          syncDailyIntake(updatedIntake);
        }
      };

      // Function to render the current screen based on state
      const renderScreen = () => {
        // Handle redirect state - don't render anything while redirecting
        if (screen === null) {
          return <div className="flex items-center justify-center min-h-screen">
            <div className="text-center">
              <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-pink-500 mx-auto"></div>
              <p className="mt-2 text-gray-600 dark:text-gray-400">Redirecting...</p>
            </div>
          </div>;
        }
        
        switch (screen) {
          case 'dashboard': return <Dashboard dailyIntake={dailyIntake} goals={goals} recentMeals={recentMeals} onLogActivity={handleLogActivity} onLogWater={handleLogWater} />;
          case 'scan': return <Scan 
            onLogMeal={handleLogMeal}
          />;
          case 'profile': return <Profile isDarkMode={isDarkMode} toggleDarkMode={toggleDarkMode} goals={goals} setGoals={setGoals} setDailyIntake={setDailyIntake} setRecentMeals={setRecentMeals} setDailyHistory={setDailyHistory} setScreen={setScreen} />;
          case 'workout': return <WorkoutPlanner 
            workoutPlan={workoutPlan}
            setWorkoutPlan={setWorkoutPlan}
            isLoading={workoutPlanLoading}
            setIsLoading={setWorkoutPlanLoading}
            error={workoutPlanError}
            setError={setWorkoutPlanError}
            setScreen={setScreen}
          />;
          case 'coach': return <Coach 
            dailyIntake={dailyIntake} 
            recentMeals={recentMeals} 
            goals={goals}
            messages={coachMessages}
            setMessages={setCoachMessages}
            isDarkMode={isDarkMode}
          />;
          case 'progress': return <Progress 
            dailyHistory={dailyHistory} 
            goals={goals} 
            dailyIntake={dailyIntake}
            habitAIAdvice={habitAIAdvice}
            setHabitAIAdvice={setHabitAIAdvice}
            isLoadingAdvice={isLoadingAdvice}
            setIsLoadingAdvice={setIsLoadingAdvice}
          />;
          case 'planner': return <MealPlanner goals={goals} mealPlan={mealPlan} setMealPlan={setMealPlan} isLoading={mealPlanLoading} setIsLoading={setMealPlanLoading} error={mealPlanError} setError={setMealPlanError} setScreen={setScreen} />;

          default: return <Dashboard dailyIntake={dailyIntake} goals={goals} recentMeals={recentMeals} onLogActivity={handleLogActivity} onLogWater={handleLogWater} />;
        }
      };

      return (
        <div className="bg-gray-50 dark:bg-gray-900 min-h-screen font-sans flex flex-col">
          <main className="flex-grow">
            {renderScreen()}
          </main>
          {screen !== null && <BottomNavBar screen={screen} setScreen={setScreen} />}
          {aiThinkingPending > 0 && (
            <div className="fixed bottom-24 left-1/2 -translate-x-1/2 transform z-50 bg-white/90 dark:bg-gray-800/90 border border-gray-200 dark:border-gray-700 rounded-full px-3 py-1 shadow-lg flex items-center gap-2 pointer-events-none">
              <span className="inline-block w-2 h-2 bg-pink-500 rounded-full animate-pulse" aria-hidden="true"></span>
              <span className="text-sm font-medium text-gray-800 dark:text-gray-200" role="status" aria-live="polite">Thinking‚Ä¶</span>
            </div>
          )}
          {showSubscriptionModal && (
            <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
              <div className="bg-white dark:bg-gray-800 rounded-2xl shadow-2xl max-w-md w-full">
                <div className="flex justify-between items-center p-6 border-b border-gray-200 dark:border-gray-700">
                  <h2 className="text-2xl font-bold text-gray-800 dark:text-gray-200">{subActiveGlobal ? 'Subscribed' : 'Upgrade'}</h2>
                  <button onClick={() => setShowSubscriptionModal(false)} className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 text-2xl font-bold">√ó</button>
                </div>
                <div className="p-6 space-y-3">
                  <div className="text-gray-800 dark:text-gray-200">AI quota: {aiRemainingGlobal.count}/{aiRemainingGlobal.limit} today</div>
                  {subActiveGlobal ? (
                    <div className="text-sm text-gray-600 dark:text-gray-400">You've used your daily AI quota. It resets at midnight.</div>
                  ) : (
                    <div className="text-sm text-gray-600 dark:text-gray-400">Subscribed users get 15 prompts per day and ads are removed.</div>
                  )}
                </div>
                <div className="p-6 pt-0 flex items-center justify-between">
                  {subActiveGlobal ? (
                    <div className="flex items-center gap-3">
                      <button
                        onClick={async ()=>{ const openPlay=()=>{ const sku=(window.fitmateIAP&&window.fitmateIAP.PRODUCT_ID)?window.fitmateIAP.PRODUCT_ID:'fitnessmate_monthly'; const pkg='app.netlify.fitnessmate.twa'; const manageUrl=`https://play.google.com/store/account/subscriptions?sku=${encodeURIComponent(sku)}&package=${encodeURIComponent(pkg)}`; try{window.open(manageUrl,'_blank');}catch(_){} }; const openStripeLogin=()=>{ try{ window.open('https://billing.stripe.com/p/login/28E14o3tE3dP9Uhfnc3sI00','_blank'); }catch(_){} }; try { if (supabase && supabase.functions) { const { data, error } = await supabase.functions.invoke('stripe-webhook', { body: { action: 'create_portal_session' } }); if (!error && data && data.url) { window.location.assign(data.url); return; } } } catch(_){} if (window.__hasAndroidBridge) { openPlay(); } else { openStripeLogin(); } }}
                        className="bg-gray-800 hover:bg-gray-900 text-white text-sm px-4 py-2 rounded-lg shadow"
                      >
                        Manage
                      </button>
                      <span className="text-xs bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-200 px-2 py-1 rounded-full">Subscribed</span>
                    </div>
                  ) : (
                    <div className="flex items-center gap-3">
                      {/* Stripe button (web) */}
                      <button
                        onClick={()=>{ try { if (window.openStripePricingModal) window.openStripePricingModal(); } catch(_) {} }}
                        className={(window.__hasAndroidBridge ? 'hidden ' : '') + 'bg-pink-500 hover:bg-pink-600 text-white text-sm px-4 py-2 rounded-lg shadow whitespace-nowrap leading-tight'}
                      >
                        Subscribe via Stripe
                      </button>
                      {/* Play Store button (native Android app) */}
                      <button
                        onClick={async ()=>{ try { if (!user) { setShowSubscriptionModal(false); setScreen('profile'); setTimeout(()=>{ try { window.dispatchEvent(new Event('open-account-modal')); } catch(_) {} }, 50); return; } const ok = await (window.FitnessMateBilling && window.FitnessMateBilling.subscribe ? window.FitnessMateBilling.subscribe() : Promise.resolve(false)); if (ok) { setShowSubscriptionModal(false); } } catch(_){} }}
                        className={(window.__hasAndroidBridge ? '' : 'hidden ') + 'bg-blue-500 hover:bg-blue-600 text-white text-sm px-4 py-2 rounded-lg shadow whitespace-nowrap leading-tight'}
                      >
                        Subscribe via Play Store
                      </button>
                      <button onClick={async ()=>{ try { await (window.FitnessMateBilling && window.FitnessMateBilling.restore ? window.FitnessMateBilling.restore() : Promise.resolve(false)); } catch(_){} }} className="text-xs text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 underline">Restore</button>
                    </div>
                  )}
                  <button onClick={()=> setShowSubscriptionModal(false)} className="text-sm text-gray-600 dark:text-gray-300">Not now</button>
                </div>
              </div>
            </div>
          )}
          {showResetModal && (
            <ResetPasswordModal onClose={() => setShowResetModal(false)} />
          )}
        </div>
      );
    }

    // Shared utilities for health score and dates (hoisted function declarations)
    function toLocalISODate(date) {
      // Timezone-aware local date string (YYYY-MM-DD) for archiving and day grouping
      // Priority: user-selected timezone in localStorage ('userTimeZone') > device timezone
      try {
        const tz = localStorage.getItem('userTimeZone') || Intl.DateTimeFormat().resolvedOptions().timeZone;
        const parts = new Intl.DateTimeFormat('en-CA', {
          timeZone: tz,
          year: 'numeric',
          month: '2-digit',
          day: '2-digit'
        }).formatToParts(date);
        const year = parts.find(p => p.type === 'year')?.value || String(date.getFullYear());
        const month = parts.find(p => p.type === 'month')?.value || String(date.getMonth() + 1).padStart(2, '0');
        const day = parts.find(p => p.type === 'day')?.value || String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
      } catch (e) {
        // Fallback: original local computation
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
      }
    }

    // Compute health score for a specific date using unified weights:
    // Nutrition 40% = Calories 25% + Protein 5% + Carbs 5% + Fat 5% (¬±10% tolerance earns full points; calories beyond ¬±10% apply 25% penalty)
    // Activity up to 15 pts: 10m=5, 20m=10, 30m+=15 (capped). Workouts do NOT add activity minutes.
    // Workouts up to 30 pts: 1 pt per 10% completion (max 10 per workout), cap at 30 total per day
    // Hydration 15 pts
    function computeHealthScoreForDate(intake, goals, dateString, workoutHistoryOpt) {
      const safeNum = (v) => (Number.isFinite(Number(v)) ? Number(v) : 0);
      const gCalories = safeNum(goals?.calories);
      const gProtein  = safeNum(goals?.protein);
      const gCarbs    = safeNum(goals?.carbs);
      const gFat      = safeNum(goals?.fat);
      const gActivity = safeNum(goals?.activity);
      const gWater    = safeNum(goals?.water);

      const cals  = safeNum(intake?.calories);
      const prot  = safeNum(intake?.protein);
      const crbs  = safeNum(intake?.carbs);
      const ft    = safeNum(intake?.fat);
      const act   = safeNum(intake?.activity);
      const water = safeNum(intake?.water);

      // Tolerance-based accuracy: within ¬±10% of goal earns full 100%;
      // beyond that, linearly decreases toward 0 up to extreme deviations.
      const toleranceScorePct = (actual, goal, tol = 0.10) => {
        if (!goal || goal <= 0) return 0;
        const deviation = Math.abs((actual / goal) - 1); // relative deviation
        if (deviation <= tol) return 100;
        // Scale remaining deviation portion (beyond tol) to 0..100 using (1 - tol) span
        const pct = 100 - Math.min(100, ((deviation - tol) / (1 - tol)) * 100);
        return Math.max(0, pct);
      };

      const caloriesPct  = toleranceScorePct(cals, gCalories); // up to 100
      const proteinPct   = toleranceScorePct(prot, gProtein);
      const carbsPct     = toleranceScorePct(crbs, gCarbs);
      const fatPct       = toleranceScorePct(ft, gFat);
      const activityScore = gActivity > 0 ? Math.min(100, (act / gActivity) * 100) : 0; // kept for legacy display if needed
      const waterScore    = gWater > 0 ? Math.min(100, (water / gWater) * 100) : 0;

      let workoutHistory = workoutHistoryOpt;
      if (!Array.isArray(workoutHistory)) {
        try {
          workoutHistory = JSON.parse(localStorage.getItem('workoutHistory') || '[]');
          if (!Array.isArray(workoutHistory)) workoutHistory = [];
        } catch (e) { workoutHistory = []; }
      }
      // For today's date, only include workouts if an explicit flag is set (prevents accidental carry-ins)
      let allowTodayWorkouts = false;
      try {
        const todayISO = toLocalISODate(new Date());
        if (dateString === todayISO) {
          allowTodayWorkouts = (localStorage.getItem(`workoutScoreEnabled:${todayISO}`) === '1');
        }
      } catch (_) {}

      const workouts = workoutHistory.filter(w => {
        try { return toLocalISODate(new Date(w.timestamp)) === dateString; } catch { return false; }
      });
      const effectiveWorkouts = (dateString && allowTodayWorkouts) ? workouts : (dateString === toLocalISODate(new Date()) ? [] : workouts);

      // Legacy workout quality no longer used for scoring; retained for potential analytics
      let workoutQualityScore = 0;

      // Activity points: 10m=5, 20m=10, 30m+=15 (capped at 15)
      const activityPoints = Math.min(15, Math.floor(act / 10) * 5);

      // Workout points: 1 point per 10% completion (max 10 per workout), cap at 30 total
      const workoutPoints = Math.min(30, effectiveWorkouts.reduce((sum, w) => {
        const completion = safeNum(w.completionRate);
        return sum + Math.min(10, Math.floor(completion / 10));
      }, 0));
      // Nutrition = 25% calories + 5% protein + 5% carbs + 5% fat
      let nutritionPoints = (caloriesPct * 0.25) + (proteinPct * 0.05) + (carbsPct * 0.05) + (fatPct * 0.05); // max 40
      // Penalty: if calories deviate beyond ¬±10%, reduce nutrition total by 25%
      const calTolExceeded = gCalories > 0 ? Math.abs((cals / gCalories) - 1) > 0.10 : false;
      if (calTolExceeded) nutritionPoints *= 0.75;
      const hydrationPoints = waterScore * 0.15; // max 15

      const total = Math.round(Math.min(100, nutritionPoints + activityPoints + workoutPoints + hydrationPoints));
      return {
        score: total,
        components: {
          nutrition: Math.round(nutritionPoints),
          activity: Math.round(activityPoints),
          workout: Math.round(workoutPoints),
          hydration: Math.round(hydrationPoints),
        }
      };
    }

    // --- Screens ---

    // Dashboard Screen Component
    const Dashboard = ({ dailyIntake, recentMeals, goals, onLogActivity, onLogWater }) => {
      // UI-only stabilization for Calories bar and value (prevents brief backtracks)
      const [displayCalories, setDisplayCalories] = useState(() => Math.round(Number(dailyIntake.calories) || 0));
      const calFreezeRef = useRef(null);
      const lastCaloriesRef = useRef(displayCalories);
      useEffect(() => {
        const cals = Math.round(Number(dailyIntake.calories) || 0);
        if (cals >= lastCaloriesRef.current) {
          setDisplayCalories(cals);
          lastCaloriesRef.current = cals;
          if (calFreezeRef.current) clearTimeout(calFreezeRef.current);
          calFreezeRef.current = setTimeout(() => { calFreezeRef.current = null; }, 1200);
          return;
        }
        if (calFreezeRef.current) {
          return; // ignore short backtrack during freeze window
        }
        setDisplayCalories(cals);
        lastCaloriesRef.current = cals;
        return () => { if (calFreezeRef.current) { clearTimeout(calFreezeRef.current); calFreezeRef.current = null; } };
      }, [dailyIntake.calories]);

      const rawCalorieProgress = goals.calories > 0 ? (Number(displayCalories) / Number(goals.calories)) * 100 : 0;
      const calorieProgress = Math.min(100, Math.max(0, isFinite(rawCalorieProgress) ? rawCalorieProgress : 0));
      const [quote, setQuote] = useState('');
      const { setLocalStorageWithSync, user } = useAuth();
      const isSignedIn = !!user;

      // Fetch motivational quote (static list to avoid API calls)
      useEffect(() => {
        const today = new Date().toISOString().split('T')[0];
        // Disable daily cache reuse so the quote changes on each load
        // const lastFetchDate = localStorage.getItem('lastQuoteFetchDate');
        // const cachedQuote = localStorage.getItem('dailyQuote');
        // if (lastFetchDate === today && cachedQuote) {
        //   setQuote(cachedQuote);
        //   return;
        // }

        const fetchQuote = async () => {
          try {
            // COMMENTED OUT: Gemini/OpenRouter API call to save requests
            // const payload = { model: OPENROUTER_QWEN_MODEL, messages: [{ role: 'user', content: prompt }] };
            // const response = await fetch(getDirectGeminiConfig().url, { method: 'POST', headers: { ...getDirectGeminiConfig().headers, 'X-Fitmate-Ignore-Quota': 'true' }, body: JSON.stringify(payload), signal: AbortSignal.timeout(10000) });
            // ... consume response and set quote

            // Static motivational quotes; rotates randomly on each load
            const STATIC_QUOTES = [
              "Progress over perfection, every single day.",
              "Small steps, big changes.",
              "Consistency beats intensity.",
              "Sweat today, strength tomorrow.",
              "One more rep, one more win.",
              "Start now, not later.",
              "Your future self is watching.",
              "Earn your energy.",
              "Discipline builds confidence.",
              "Strong body, strong mind.",
              "Show up, even tired.",
              "You are your best investment.",
              "Make habits, not excuses.",
              "Motion creates motivation.",
              "Train like you mean it.",
              "Keep going; momentum follows.",
              "Storms pass; grit stays.",
              "Do hard things daily.",
              "Choose health, choose you.",
              "Win the morning, win the day.",
              "Better than yesterday.",
              "Focus, breathe, move.",
              "No zero days.",
              "Turn pain into power.",
              "Finish what you start.",
              "Strength is earned, never given.",
              "Practice progress, not perfection.",
              "Your body loves consistency.",
              "Sweat is your signature.",
              "Make it a lifestyle.",
              "A little daily goes far.",
              "Push limits, build resilience.",
              "Train for life, not looks.",
              "Strong starts with one step.",
              "Confidence is a side effect.",
              "Routine is the cheat code.",
              // Added more short fitness quotes
              "Progress compounds; keep stacking days.",
              "Your effort writes your story.",
              "Fit is a feeling; chase it.",
              "Strength begins with showing up.",
              "Train smart, recover hard.",
              "Move with intention.",
              "Own the next minute.",
              "Health is the best habit.",
              "Make hard things normal.",
              "Your pace, your race.",
              "Energy in, energy out.",
              "Sculpt your discipline.",
              "Confidence loves consistency.",
              "Win tiny battles daily.",
              "Build the athlete within.",
              "Your body deserves effort.",
              "Sweat the excuses away.",
              "Practice patience and effort.",
              "Better form, better you.",
              "Strong starts at home.",
              "Results follow routines.",
              "Keep promises to yourself.",
              "Five minutes beats zero.",
              "Turn pressure into practice.",
              "Show up for you.",
              "Fuel well, train well.",
              "Every rep has purpose.",
              "Be the most consistent.",
              "Find your resilient self.",
              "Stack reps, stack wins.",
              "Make movement your default.",
              "Start simple, stay steady.",
              "You‚Äôre capable of more.",
              "Balance effort and rest.",
              "Consistency is courage repeated.",
              "Build endurance of mind.",
              "Less talk, more reps.",
              "One set at a time.",
              "Make sweat your reminder.",
              "Celebrate tiny progress.",
              "Track it, improve it.",
              "Train today for tomorrow.",
              "Muscles grow from moments.",
              "Stay kind, stay strong.",
              "Body follows the mind.",
              "Cut the noise, move.",
              "Rise, move, repeat.",
              "Your discipline is freedom.",
              "Commit and don‚Äôt quit.",
              "Make fitness non-negotiable.",
              "Routine fuels resilience.",
              "Ownership beats motivation.",
              "Hard now, easy later.",
              "Strong choices, strong results.",
              "Practice wins, performance follows.",
              "Keep it sustainable.",
              "Breathe; you‚Äôre progressing.",
              "Turn intent into action.",
              "Lift your standards daily.",
              "Start where you are.",
              "Move through the doubts.",
              "Earn your rest.",
              "Hustle for health.",
              "Momentum loves consistency.",
              "Make training time sacred.",
              "Strength is a lifestyle.",
              "Tiny steps, mighty outcomes.",
              "Be proud of effort.",
              "Train with gratitude.",
              "Your body remembers.",
              "Show up and simplify.",
              "Build the habit first.",
              "Motion beats hesitation.",
              "Finish the session strong.",
              "Your health is priority.",
              "Power up your day.",
              "Let discipline lead.",
              "Keep stacking clean days.",
              "Form first, then intensity.",
              "Respect rest and recovery.",
              "Repeat the basics.",
              "Choose effort over excuses.",
              "Make routine your coach.",
              "Every day is a chance.",
              "Build strength you can use.",
              "Train safe, train smart.",
              "Play the long game.",
              "Consistency makes champions.",
              "Progress loves patience.",
              "Move well, live well.",
              "Confidence comes from reps."
            ];

            const randomQuote = STATIC_QUOTES[Math.floor(Math.random() * STATIC_QUOTES.length)];
            setQuote(randomQuote);
            setLocalStorageWithSync('dailyQuote', randomQuote);
            setLocalStorageWithSync('lastQuoteFetchDate', today);
          } catch (_) {
            // As a safety net, keep a minimal default quote
            setQuote("The only bad workout is the one that didn't happen.");
          }
        };

        fetchQuote();
      }, []);

      // On mount: enable workout scoring if today already has workouts
      useEffect(() => {
        try {
          const todayISO = toLocalISODate(new Date());
          const wh = JSON.parse(localStorage.getItem('workoutHistory') || '[]');
          if (Array.isArray(wh)) {
            const todayWorkouts = wh.filter(w => {
              try {
                const wDate = toLocalISODate(new Date(w.timestamp));
                return wDate === todayISO;
              } catch { return false; }
            });
            if (todayWorkouts.length > 0) {
              localStorage.setItem(`workoutScoreEnabled:${todayISO}`, '1');
              console.log('‚úÖ Workout scoring enabled on mount (found', todayWorkouts.length, 'workouts for today)');
            }
          }
        } catch (_) {}
      }, []);

      // Calculate Health Score using shared utility (for today)
      const [healthScore, setHealthScore] = useState(() => {
        const todayStr = toLocalISODate(new Date());
        return computeHealthScoreForDate(dailyIntake, goals, todayStr).score;
      });

      // UI-only stabilization: prevent brief backtracks while async sync completes.
      // This does NOT change app data or logic; it only smooths the displayed number.
      const [displayScore, setDisplayScore] = useState(() => {
        const todayStr = toLocalISODate(new Date());
        return computeHealthScoreForDate(dailyIntake, goals, todayStr).score;
      });
      const lastScoreRef = useRef(healthScore);
      const freezeRef = useRef(null);
      useEffect(() => {
        // If score increases, show immediately and start short freeze window.
        if (healthScore >= lastScoreRef.current) {
          setDisplayScore(healthScore);
          lastScoreRef.current = healthScore;
          if (freezeRef.current) clearTimeout(freezeRef.current);
          freezeRef.current = setTimeout(() => { freezeRef.current = null; }, 1200);
          return;
        }
        // For brief dips during the freeze window, keep the higher value to avoid flicker.
        if (freezeRef.current) {
          return; // ignore short backtrack
        }
        // Outside freeze window, reflect the lower score normally.
        setDisplayScore(healthScore);
        lastScoreRef.current = healthScore;
        return () => { if (freezeRef.current) { clearTimeout(freezeRef.current); freezeRef.current = null; } };
      }, [healthScore]);

      // Recalculate health score when dailyIntake or goals change
      useEffect(() => {
        const todayStr = toLocalISODate(new Date());
        const newScore = computeHealthScoreForDate(dailyIntake, goals, todayStr).score;
        setHealthScore(newScore);
      }, [dailyIntake, goals]);

      // Listen for workout history updates from real-time sync
      useEffect(() => {
        const handleWorkoutUpdate = () => {
          const todayStr = toLocalISODate(new Date());
          const newScore = computeHealthScoreForDate(dailyIntake, goals, todayStr).score;
          setHealthScore(newScore);
          // Maintain live dailyHistory entry for today whenever workout data changes
          try { updateLiveDailyHistorySnapshot(); } catch (_) {}
          console.log('üèãÔ∏è Health score recalculated after workout update:', newScore);
        };

        window.addEventListener('workout-history-updated', handleWorkoutUpdate);
        return () => window.removeEventListener('workout-history-updated', handleWorkoutUpdate);
      }, [dailyIntake, goals]);

      // Recalculate score when returning from background/screen lock
      useEffect(() => {
        const handleVisibilityChange = () => {
          if (!document.hidden) {
            const todayStr = toLocalISODate(new Date());
            const newScore = computeHealthScoreForDate(dailyIntake, goals, todayStr).score;
            setHealthScore(newScore);
            console.log('üëÅÔ∏è Health score recalculated after returning from background:', newScore);
          }
        };

        document.addEventListener('visibilitychange', handleVisibilityChange);
        return () => document.removeEventListener('visibilitychange', handleVisibilityChange);
      }, [dailyIntake, goals]);

      return (
        <div className="p-6 pb-24">
          <header className="mb-6 bg-white dark:bg-gray-800 p-4 rounded-2xl shadow-md">
            <div className="flex flex-col sm:flex-row sm:items-center justify-between gap-3">
              <div className="flex items-center flex-shrink-0">
              <img src="logo.png" alt="FitnessMate logo" className="w-8 h-8 sm:w-9 sm:h-9 md:w-10 md:h-10 mr-3 object-contain"/>
              <div>
                <h1 className="truncate text-lg sm:text-2xl md:text-3xl font-bold leading-tight text-gray-800 dark:text-gray-200">FitnessMate - AI Workout Hub</h1>
                <p className="truncate text-xs sm:text-base text-gray-500 dark:text-gray-400">Personalized AI Workout & Nutrition Health</p>
              </div>
              </div>
              <div className="merch-teaser starry blink text-gray-900 dark:text-white text-xs sm:text-sm md:text-base text-center sm:text-right w-full sm:w-auto sm:max-w-[60%] md:max-w-[50%] whitespace-normal md:whitespace-nowrap leading-tight mt-1 sm:mt-0 mx-auto sm:mx-0 self-center sm:self-auto">
                Merch coming soon
              </div>
            </div>
            {quote && <p className="text-gray-600 dark:text-gray-300 italic mt-2 text-center bg-gray-100 dark:bg-gray-700 p-2 rounded-lg">"{quote}"</p>}
          </header>

          <div className="grid md:grid-cols-2 gap-6 mb-6">
            {/* Health Score Card - Fixed light gradient */}
            <div className="bg-white dark:bg-gray-800 p-6 rounded-2xl shadow-md text-center h-full flex flex-col">
              <h2 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-4">Health Score</h2>
              <div className="flex-grow flex flex-col justify-center">
                <div className="relative w-32 h-32 mx-auto">
                  <svg className="w-full h-full" viewBox="0 0 36 36">
                    <path className="text-gray-200 dark:text-gray-700" strokeWidth="3" fill="none" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831" />
                    <path className="text-green-500" strokeWidth="3" strokeLinecap="round" fill="none" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831" strokeDasharray={`${isSignedIn ? displayScore : 0}, 100`} />
                  </svg>
                  <div className="absolute inset-0 flex items-center justify-center">
                    <span className="text-3xl font-bold text-green-500">{isSignedIn ? displayScore : '‚Äî'}</span>
                  </div>
                </div>
                <p className="text-gray-600 dark:text-gray-400 mt-2">Today's Score / 100 <span id="midnight-sync-badge" className="ml-2 inline-flex items-center rounded-full bg-yellow-500/20 text-yellow-700 dark:text-yellow-300 text-[11px] px-2 py-0.5" style={{display:'none'}}>Syncing‚Ä¶ ~60s</span></p>
                <div className="text-xs text-gray-500 dark:text-gray-400 mt-2 space-y-1">
                  <p><span className="font-bold text-pink-500">40%</span> Nutrition</p>
                  <p><span className="font-bold text-purple-500">15%</span> Activity</p>
                  <p><span className="font-bold text-purple-500">30%</span> Workout</p>
                  <p><span className="font-bold text-blue-500">15%</span> Hydration</p>
                  <p className="opacity-75">Calories beyond ¬±10% tolerance applies a 25% penalty to total Nutrition points. After midnight, today's score may take up to 60 seconds to reset and sync.</p>
                </div>
              </div>
            </div>

            {/* Activity & Water Tracker Card - Fixed light gradient */}
            <div className="bg-white dark:bg-gray-800 p-4 sm:p-6 rounded-2xl shadow-md h-full flex flex-col">
              <h2 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-2 text-center">Activity & Hydration</h2>
              <p className="text-xs text-gray-500 dark:text-gray-400 text-center mb-2">
                <span className="font-semibold">Activity</span> = general movement like walking, brisk walk, cardio, steps (logged with this timer). 
                 <span className="font-semibold"> Workouts</span> are separate.
              </p>
              <div className="flex-grow flex flex-col justify-center space-y-4">
                <ActivityTimer onLogActivity={onLogActivity} />
                <WaterTracker onLogWater={onLogWater} dailyIntake={dailyIntake} goals={goals} masked={!isSignedIn} />
              </div>
            </div>
          </div>

          <div className="bg-gradient-to-br from-cyan-400 to-pink-500 rounded-2xl p-6 mb-6 text-white shadow-lg">
            <p className="font-semibold">Calories</p>
            <div className="flex items-end my-2">
              <p className="text-5xl font-bold">{isSignedIn ? displayCalories : '‚Äî'}</p>
              <p className="ml-2 mb-1">/ {isSignedIn ? goals.calories : '‚Äî'} kcal</p>
            </div>
            <div className="w-full bg-white/30 rounded-full h-2.5 overflow-hidden">
              <div className="bg-white h-2.5 rounded-full max-w-full" style={{ width: `${isSignedIn ? calorieProgress : 0}%` }}></div>
            </div>
          </div>

          <div className="grid grid-cols-3 gap-4 mb-6">
            <MacroCard title="Protein" value={dailyIntake.protein} goal={goals.protein} unit="g" color="text-blue-500" masked={!isSignedIn} />
            <MacroCard title="Carbs" value={dailyIntake.carbs} goal={goals.carbs} unit="g" color="text-yellow-500" masked={!isSignedIn} />
            <MacroCard title="Fat" value={dailyIntake.fat} goal={goals.fat} unit="g" color="text-red-500" masked={!isSignedIn} />
          </div>

          <div>
            <h2 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-4">Recent Meals</h2>
            {isSignedIn ? (
              recentMeals.length > 0 ? (
                <div className="space-y-3">
                  {recentMeals.map((meal) => (
                    <MealCard key={meal.id} meal={meal} />
                  ))}
                </div>
              ) : (
                <div className="text-center text-gray-500 dark:text-gray-400 bg-white dark:bg-gray-800 p-6 rounded-2xl shadow-md">
                  <p>No meals logged yet.</p>
                  <p>Tap the 'Cal' button to scan your first meal!</p>
                </div>
              )
            ) : (
              <div className="text-center text-gray-500 dark:text-gray-400 bg-white dark:bg-gray-800 p-6 rounded-2xl shadow-md">
                <p>Sign in to view your meal history.</p>
                <button
                  onClick={() => { try { window.dispatchEvent(new Event('request-account-modal')); } catch (_) {} }}
                  className="mt-3 inline-block bg-blue-500 text-white font-bold py-2 px-4 rounded-xl"
                >
                  Sign in
                </button>
              </div>
            )}
          </div>
        </div>
      );
    };

    // Profile Screen Component
    const Profile = ({ isDarkMode, toggleDarkMode, goals, setGoals, setDailyIntake, setRecentMeals, setDailyHistory, setScreen }) => {
      const { user, signOut, updateUserData } = useAuth();
      const [profilePicture, setProfilePicture] = useState(() => {
        // Initialize from localStorage for both signed-in and guest users to avoid placeholder flicker
        const saved = localStorage.getItem('profilePicture');
        return saved || "/icon-192.png";
      });
      const [isGeneratingAvatar, setIsGeneratingAvatar] = useState(false);
      const [notificationsEnabled, setNotificationsEnabled] = useState(() => {
        // For signed-in users, start with default and let remote data load via useEffect
        if (user) {
          return true;
        }
        const saved = localStorage.getItem('notificationsEnabled');
        return saved ? JSON.parse(saved) : true;
      });
      const [backgroundMusicEnabled, setBackgroundMusicEnabled] = useState(() => {
        // For signed-in users, start with default and let remote data load via useEffect
        if (user) {
          return false;
        }
        const saved = localStorage.getItem('backgroundMusicEnabled');
        return saved ? JSON.parse(saved) : false;
      });
      const [showPrivacyModal, setShowPrivacyModal] = useState(false);
      const [showSupportModal, setShowSupportModal] = useState(false);
      const [showAccountModal, setShowAccountModal] = useState(false);
      const [subActive, setSubActive] = useState(() => { try { return JSON.parse(localStorage.getItem('subscriptionActive')||'false'); } catch (_) { return false; } });
      const [aiRemaining, setAiRemaining] = useState({ count: 0, limit: 0 });
      const [supportForm, setSupportForm] = useState({
        fullName: '',
        email: '',
        subject: '',
        message: ''
      });
      const [isSubmittingSupport, setIsSubmittingSupport] = useState(false);
      const [supportSubmissionStatus, setSupportSubmissionStatus] = useState(null);
      const [showBookingModal, setShowBookingModal] = useState(false);
  const [bookingStep, setBookingStep] = useState(1);
  const [selectedDate, setSelectedDate] = useState(null);
  const [selectedTimeSlot, setSelectedTimeSlot] = useState(null);
  const [selectedPackage, setSelectedPackage] = useState(null);
  const [currentMonth, setCurrentMonth] = useState('');
  const [currentYear, setCurrentYear] = useState(2023);
  const [calendarDays, setCalendarDays] = useState([]);
  const [availableTimeSlots, setAvailableTimeSlots] = useState([]);
  
  // Booking History State
  const [bookingHistory, setBookingHistory] = useState([]);
  const [isLoadingBookings, setIsLoadingBookings] = useState(false);
  const [showBookingHistory, setShowBookingHistory] = useState(false);
  const [showMeetingModal, setShowMeetingModal] = useState(false);
  const [currentMeetingLink, setCurrentMeetingLink] = useState('');
  const [bookedSlots, setBookedSlots] = useState([]);
  const [slotsCache, setSlotsCache] = useState({});
  const [isLoadingSlots, setIsLoadingSlots] = useState(false);
  const [confirmationMessage, setConfirmationMessage] = useState(null);
  const [debounceTimer, setDebounceTimer] = useState(null);
  const [abortController, setAbortController] = useState(null);

  // Track if we've already fetched remote AI usage for today in this session
  const aiUsageFetchedForDateRef = useRef(null);

      const computeAiRemaining = React.useCallback(async () => {
        // Get user from auth session directly to avoid stale React state
        let uid = null;
        try {
          if (auth && auth.getSession) {
            const { data: { session } } = await auth.getSession();
            uid = session && session.user ? session.user.id : null;
          }
        } catch (_) {}
        
        const todayISO = typeof toLocalISODate === 'function' ? toLocalISODate(new Date()) : new Date().toISOString().slice(0,10);
        
        // Start from localStorage
        let usage = {};
        try { usage = JSON.parse(localStorage.getItem('aiUsage') || '{}') || {}; } catch (_) {}
        if (!usage[todayISO]) usage[todayISO] = {};
        
        const key = uid || 'anon';
        let count = Number(usage[todayISO][key] || 0);

        // If signed in and we have an 'anon' entry, re-key it to the user and persist (MAX logic)
        if (uid) {
          const anonCount = Number(usage[todayISO]['anon'] || 0);
          const userCount = Number(usage[todayISO][uid] || 0);
          const maxLocal = Math.max(userCount, anonCount);
          if (anonCount > 0 && maxLocal !== userCount) {
            usage[todayISO][uid] = maxLocal;
            try { localStorage.setItem('aiUsage', JSON.stringify(usage)); } catch (_) {}
            // Persist this reconciliation to the backend once
            try { if (typeof db !== 'undefined' && db.updateUser) await db.updateUser(uid, { ai_usage: usage }); } catch (_) {}
            count = maxLocal;
          }
        }

        // Remote fetch once per day when signed in (remote-first; uses MAX with local)
        if (uid && supabase && aiUsageFetchedForDateRef.current !== todayISO) {
          try {
            const { data, error } = await supabase
              .from('users')
              .select('ai_usage')
              .eq('id', uid)
              .single();
            if (!error && data && data.ai_usage) {
              const remote = data.ai_usage || {};
              const dayObj = remote[todayISO] || {};
              let remoteCount = 0;
              if (dayObj && typeof dayObj === 'object') {
                remoteCount = Number(dayObj[uid] || 0);
                if (!remoteCount) {
                  // Fallback to max across keys (handles older 'anon' writes)
                  remoteCount = Math.max(0, ...Object.values(dayObj).map(v => Number(v || 0)));
                }
              }
              const maxCount = Math.max(count, remoteCount);
              if (maxCount !== count) {
                usage[todayISO][uid] = maxCount;
                try { localStorage.setItem('aiUsage', JSON.stringify(usage)); } catch (_) {}
                // Persist authoritative merged value back to DB
                try { if (uid && typeof db !== 'undefined' && db.updateUser) await db.updateUser(uid, { ai_usage: usage }); } catch (_) {}
                count = maxCount;
              }
            }
          } catch (_) { /* ignore network errors */ }
          aiUsageFetchedForDateRef.current = todayISO;
        }

        let isSub = false;
        try { isSub = !!uid && JSON.parse(localStorage.getItem('subscriptionActive') || 'false') === true; } catch (_) { isSub = false; }
        const limit = isSub ? 15 : (uid ? 5 : 3);
        setAiRemaining({ count, limit });
      }, []);

      useEffect(() => {
        computeAiRemaining();
        let off = null;
        if (window.fitmateIAP && typeof window.fitmateIAP.onStatusChange === 'function') {
          off = window.fitmateIAP.onStatusChange((active) => { setSubActive(!!active); computeAiRemaining().catch(() => {}); });
        }
        const onQuota = () => computeAiRemaining().catch(() => {});
        window.addEventListener('ai-quota-exceeded', onQuota);
        const onRemoteSync = () => {
          console.log('üîÑ AI quota: userDataSynced event received, recomputing...');
          computeAiRemaining().catch(() => {});
        };
        window.addEventListener('userDataSynced', onRemoteSync);
        // AI usage now syncs via database (realtime listener handles remote updates)
        const onVis = () => { if (!document.hidden) computeAiRemaining().catch(() => {}); };
        document.addEventListener('visibilitychange', onVis);
        const onOpenAccount = () => { try { setShowAccountModal(true); } catch (_) {} };
        const onCloseAccount = () => { try { setShowAccountModal(false); } catch (_) {} };
        window.addEventListener('open-account-modal', onOpenAccount);
        window.addEventListener('close-account-modal', onCloseAccount);
        return () => {
          if (off) off();
          window.removeEventListener('ai-quota-exceeded', onQuota);
          window.removeEventListener('userDataSynced', onRemoteSync);
          document.removeEventListener('visibilitychange', onVis);
          window.removeEventListener('open-account-modal', onOpenAccount);
          window.removeEventListener('close-account-modal', onCloseAccount);
        };
      }, [computeAiRemaining]);

      const fileInputRef = useRef(null);

      // Save profile picture to localStorage whenever it changes (with quota handling)
      useEffect(() => {
        // Only save to localStorage for non-signed-in users
        if (profilePicture && !user) {
          try {
            setLocalStorageWithSync('profilePicture', profilePicture);
          } catch (error) {
            if (error.name === 'QuotaExceededError') {
              console.warn('Profile picture too large for localStorage, skipping storage');
            }
          }
        }
      }, [profilePicture, user]);

      // Sync profile picture only on explicit user actions (upload/generate avatar)
      // Removed automatic syncing effect to prevent overwriting remote data with placeholders
      // useEffect(() => {
      //   if (user && profilePicture) {
      //     updateUserData({ profile_picture: profilePicture });
      //   }
      // }, [profilePicture, user]);

      // Listen for remote data sync and update profile picture
      useEffect(() => {
        const handleUserDataSync = (event) => {
          // For signed-in users, only use remote data from the event payload
          if (user && event?.detail?.userData?.profile_picture) {
            const remoteProfilePicture = event.detail.userData.profile_picture;
            if (remoteProfilePicture !== profilePicture) {
              setProfilePicture(remoteProfilePicture);
              console.log('‚úÖ Profile picture synced from remote data');
            }
          } else if (!user) {
            // For non-signed-in users, use localStorage as before
            const syncedProfilePicture = localStorage.getItem('profilePicture');
            if (syncedProfilePicture && syncedProfilePicture !== profilePicture) {
              setProfilePicture(syncedProfilePicture);
              console.log('‚úÖ Profile picture synced from localStorage');
            }
          }
        };

        window.addEventListener('userDataSynced', handleUserDataSync);
        return () => window.removeEventListener('userDataSynced', handleUserDataSync);
      }, [profilePicture, user]);

      // Listen for remote data sync and update notifications setting
      useEffect(() => {
        const handleUserDataSync = () => {
          const syncedNotifications = localStorage.getItem('notificationsEnabled');
          if (syncedNotifications) {
            const notificationsData = JSON.parse(syncedNotifications);
            if (notificationsData !== notificationsEnabled) {
              setNotificationsEnabled(notificationsData);
              console.log('‚úÖ Notifications setting synced in Profile component');
            }
          }
        };

        window.addEventListener('userDataSynced', handleUserDataSync);
        return () => window.removeEventListener('userDataSynced', handleUserDataSync);
      }, [notificationsEnabled]);

      // Listen for remote data sync and update background music setting
      useEffect(() => {
        const handleUserDataSync = () => {
          const syncedBackgroundMusic = localStorage.getItem('backgroundMusicEnabled');
          if (syncedBackgroundMusic) {
            const backgroundMusicData = JSON.parse(syncedBackgroundMusic);
            if (backgroundMusicData !== backgroundMusicEnabled) {
              setBackgroundMusicEnabled(backgroundMusicData);
              console.log('‚úÖ Background music setting synced in Profile component');
            }
          }
        };

        window.addEventListener('userDataSynced', handleUserDataSync);
        return () => window.removeEventListener('userDataSynced', handleUserDataSync);
      }, [backgroundMusicEnabled]);

      // Load profile picture from localStorage only for non-signed-in users
      useEffect(() => {
        if (!user) {
          const savedProfilePicture = localStorage.getItem('profilePicture');
          if (savedProfilePicture && savedProfilePicture !== profilePicture) {
            setProfilePicture(savedProfilePicture);
          }
        }
      }, [user, profilePicture]);

      // Save notifications setting to localStorage
      useEffect(() => {
        localStorage.setItem('notificationsEnabled', JSON.stringify(notificationsEnabled));
      }, [notificationsEnabled]);

      // Save background music setting to localStorage
      useEffect(() => {
        localStorage.setItem('backgroundMusicEnabled', JSON.stringify(backgroundMusicEnabled));
      }, [backgroundMusicEnabled]);

      // Initialize background music on component mount
      useEffect(() => {
        const audio = document.getElementById('background-music');
        if (audio && backgroundMusicEnabled) {
          // Set volume to a reasonable level
          audio.volume = 0.3;
          audio.play().catch(e => console.log('Audio autoplay failed:', e));
        }
      }, []);

      // Control background music when setting changes
      useEffect(() => {
        const audio = document.getElementById('background-music');
        if (audio) {
          audio.volume = 0.3;
          if (backgroundMusicEnabled) {
            // Try to play, but don't force it on mobile without user interaction
            audio.play().catch(e => {
              console.log('Audio autoplay prevented:', e);
              // On mobile, we'll wait for user interaction instead of showing alert here
            });
          } else {
            audio.pause();
          }
        }
      }, [backgroundMusicEnabled]);

      const toggleNotifications = () => {
        setNotificationsEnabled(prev => {
          const newValue = !prev;
          // Update Firebase if user is authenticated
          if (user) {
            updateUserData({ notificationsEnabled: newValue });
          }
          // Show user feedback
          if (newValue) {
            if (window.showToast) { showToast("‚úÖ Notifications enabled! You'll receive fitness reminders and updates.", 'success'); } else { console.log("‚úÖ Notifications enabled! You'll receive fitness reminders and updates."); }
          } else {
            if (window.showToast) { showToast("üîï Notifications disabled. You won't receive any alerts.", 'info'); } else { console.log("üîï Notifications disabled. You won't receive any alerts."); }
          }
          return newValue;
        });      };

      const toggleBackgroundMusic = () => {
        setBackgroundMusicEnabled(prev => {
          const newValue = !prev;
          // Background music setting is stored locally only (no database sync needed)
          // Control background music
          const audio = document.getElementById('background-music');
          if (audio) {
            if (newValue) {
              // For mobile browsers, we need user interaction to play audio
              audio.play().catch(e => {
                console.log('Audio play failed (likely due to autoplay policy):', e);
                // Show user-friendly message for mobile
                if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
                  if (window.showToast) { showToast('üéµ Tap anywhere on the screen to start background music!', 'info', { duration: 3000 }); } else { console.log('üéµ Tap anywhere on the screen to start background music!'); }
                  // Add click listener to start music on next user interaction
                  const startMusicOnClick = () => {
                    audio.play().catch(e => console.log('Audio play still failed:', e));
                    document.removeEventListener('click', startMusicOnClick);
                    document.removeEventListener('touchstart', startMusicOnClick);
                  };
                  document.addEventListener('click', startMusicOnClick, { once: true });
                  document.addEventListener('touchstart', startMusicOnClick, { once: true });
                }
              });
            } else {
              audio.pause();
            }
          }
          return newValue;
        });
      };

      const handleGoalChange = (key, value) => {
        const newGoals = { ...goals, [key]: Number(value) };
        setGoals(newGoals);
        // Update Firebase if user is authenticated
        if (user) {
          updateUserData({ goals: newGoals });
        }
      };

      const handleImageUpload = (event) => {
        const file = event.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (e) => {
            // Compress image before storing
            const img = new Image();
            img.onload = () => {
              // Create canvas for compression
              const canvas = document.createElement('canvas');
              // Set max dimensions (reduce size)
              const MAX_WIDTH = 400;
              const MAX_HEIGHT = 400;
              let width = img.width;
              let height = img.height;
              
              // Calculate new dimensions while maintaining aspect ratio
              if (width > height) {
                if (width > MAX_WIDTH) {
                  height *= MAX_WIDTH / width;
                  width = MAX_WIDTH;
                }
              } else {
                if (height > MAX_HEIGHT) {
                  width *= MAX_HEIGHT / height;
                  height = MAX_HEIGHT;
                }
              }
              
              // Set canvas dimensions and draw resized image
              canvas.width = width;
              canvas.height = height;
              const ctx = canvas.getContext('2d');
              ctx.drawImage(img, 0, 0, width, height);
              
              // Convert to compressed data URL (0.7 quality)
              const compressedDataUrl = canvas.toDataURL('image/jpeg', 0.7);
              setProfilePicture(compressedDataUrl);
              
              // Sync to remote if user is signed in
              if (user) {
                updateUserData({ profile_picture: compressedDataUrl });
              }
            };
            img.src = e.target.result;
          };
          reader.readAsDataURL(file);
        }
      };

      const handleSignOut = async () => {
        try {
          await signOut();
          // Close modal - user state will be cleared by AuthProvider's auth listener
          setShowAccountModal(false);
          // Clear any additional local storage data if needed
          localStorage.removeItem('userPreferences');
          localStorage.removeItem('recentMeals');
          localStorage.removeItem('dailyIntake');
          localStorage.removeItem('fitmate_user');
          localStorage.removeItem('fitmate_user_data');
          if (window.showToast) { showToast('‚úÖ Successfully signed out!', 'success'); } else { console.log('‚úÖ Successfully signed out!'); }
        } catch (error) {
          if (window.showToast) { showToast('‚ùå Error signing out: ' + error.message, 'error'); } else { console.error('‚ùå Error signing out: ' + error.message); }
        }
      };

      // Booking History Functions
      // Check if a time slot is available across all users
      const checkSlotAvailability = async (date, timeSlot) => {
        if (!supabase) {
          console.log('Database not available');
          return false;
        }
        
        try {
          // Use Supabase to get global bookings for the date
          const globalBookings = await db.getGlobalBookings(date);
          
          if (!globalBookings || globalBookings.length === 0) {
            return true; // No bookings exist, slot is available
          }
          
          // Check if the time slot is already booked
          const isBooked = globalBookings.some(booking => 
            booking.time === timeSlot && booking.status !== 'cancelled'
          );
          
          return !isBooked; // Return true if not booked, false if booked
        } catch (error) {
          console.error('Error checking slot availability:', error);
          return false; // Assume unavailable on error for safety
        }
      };

      // Fetch booked slots for a specific date
      // Memoization cache for Supabase requests
      const requestCache = new Map();
      const CACHE_DURATION = 30000; // 30 seconds
      
      const fetchBookedSlotsForDate = async (date, signal = null) => {
        if (!db) {
          console.log('Database not available, using fallback');
          // Return mock data for testing when Firebase is unavailable
          return [];
        }
        
        // Check cache first
        const cacheKey = `booked-slots-${date}`;
        const cached = requestCache.get(cacheKey);
        if (cached && Date.now() - cached.timestamp < CACHE_DURATION) {
          return cached.data;
        }
        
        try {
          // Check if request was cancelled
          if (signal && signal.aborted) {
            throw new Error('Request cancelled');
          }
          
          // Use Supabase to get global bookings for the date
          const bookedTimes = [];
          
          try {
            // Add timeout to prevent infinite loading
            const timeoutPromise = new Promise((_, reject) => {
              setTimeout(() => reject(new Error('Supabase query timeout')), 10000);
            });
            
            const bookingsPromise = db.getGlobalBookings(date);
            
            const globalBookings = await Promise.race([
              bookingsPromise,
              timeoutPromise
            ]);
            
            // Check again after async operation
            if (signal && signal.aborted) {
              throw new Error('Request cancelled');
            }
            
            if (globalBookings && globalBookings.length > 0) {
              // Use global bookings for faster lookup
              globalBookings.forEach(booking => {
                if (booking.status !== 'cancelled') {
                  bookedTimes.push(booking.time);
                }
              });
            }
          } catch (queryError) {
            console.warn('Error querying global bookings:', queryError);
            // Continue with empty booked times if query fails
          }
          
          // Cache the result
          requestCache.set(cacheKey, {
            data: bookedTimes,
            timestamp: Date.now()
          });
          
          return bookedTimes;
        } catch (error) {
          if (error.message.includes('timeout')) {
            console.warn('Supabase query timed out, using empty slots');
          } else {
            console.error('Error fetching booked slots:', error);
          }
          return [];
        }
      };

      const fetchBookingHistory = async (retryCount = 0) => {
        if (!user || !db) {
          console.log('User not authenticated or database not available');
          return;
        }
        
        setIsLoadingBookings(true);
        try {
          const bookingsData = await db.getBookings(user.id);
          
          if (bookingsData && bookingsData.length > 0) {
            // Process bookings and sort by creation date (newest first)
            const bookingsArray = bookingsData.map(booking => {
              // Replace old Jitsi or Daily.co links with new Whereby URL
              if (booking.meeting_link && (booking.meeting_link.includes('jit.si') || booking.meeting_link.includes('daily.co'))) {
                booking.meeting_link = 'https://fitness-mate.whereby.com/meeting410ee91d-38a8-4636-bcc8-5b9b86035b45';
              }
              
              return booking;
            }).sort((a, b) => new Date(b.created_at || 0) - new Date(a.created_at || 0));
            
            setBookingHistory(bookingsArray);
          } else {
            setBookingHistory([]);
          }
        } catch (error) {
          console.error('Error fetching booking history:', error);
          
          // Retry logic for network errors
          if (retryCount < 2 && (error.message?.includes('NetworkError') || error.message?.includes('fetch'))) {
            console.log(`üîÑ Retrying booking history fetch (attempt ${retryCount + 1}/3)...`);
            setTimeout(() => {
              fetchBookingHistory(retryCount + 1);
            }, 1000 * (retryCount + 1)); // Exponential backoff
            return;
          }
          
          // Only show error alert if all retries failed
          if (retryCount >= 2) {
            if (window.showToast) { showToast('‚ùå Error loading booking history. Please try again.', 'error'); } else { console.error('‚ùå Error loading booking history. Please try again.'); }
          }
        } finally {
          // Always stop loading, regardless of retry count
          setIsLoadingBookings(false);
        }
      };
      
      // Load booking history when user changes or component mounts
      useEffect(() => {
        if (user) {
          fetchBookingHistory();
        } else {
          setBookingHistory([]);
        }
      }, [user]);
      
      const toggleBookingHistory = () => {
        setShowBookingHistory(prev => !prev);
        if (!showBookingHistory && bookingHistory.length === 0) {
          fetchBookingHistory();
        }
      };


      const openAccountModal = () => setShowAccountModal(true);
      const closeAccountModal = () => setShowAccountModal(false);

      const openPrivacyModal = () => {
        setShowPrivacyModal(true);
      };

      const closePrivacyModal = () => {
        setShowPrivacyModal(false);
      };

      const openSupportModal = () => {
        setShowSupportModal(true);
        setSupportSubmissionStatus(null);
      };

      const closeSupportModal = () => {
        setShowSupportModal(false);
        setSupportForm({ fullName: '', email: '', subject: '', message: '' });
        setSupportSubmissionStatus(null);
      };

      const handleSupportFormChange = (field, value) => {
        setSupportForm(prev => ({ ...prev, [field]: value }));
      };

      const openBookingModal = () => {
    setBookingStep(1);
    setSelectedDate(null);
    setSelectedTimeSlot(null);
    setSelectedPackage(null);
    initializeCalendar();
    setShowBookingModal(true);
  };
  
  const closeBookingModal = () => {
    setShowBookingModal(false);
    setBookingStep(1);
    setSelectedDate(null);
    setSelectedTimeSlot(null);
    setSelectedPackage(null);
  };
  
  const initializeCalendar = () => {
    const today = new Date();
    const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
    
    setCurrentMonth(monthNames[today.getMonth()]);
    setCurrentYear(today.getFullYear());
    
    generateCalendarDays(today.getMonth(), today.getFullYear());
  };
  
  const generateCalendarDays = (month, year) => {
    const firstDay = new Date(year, month, 1).getDay();
    const daysInMonth = new Date(year, month + 1, 0).getDate();
    const daysInPrevMonth = new Date(year, month, 0).getDate();
    
    const days = [];
    
    // Previous month days
    for (let i = firstDay - 1; i >= 0; i--) {
      days.push({
        dayOfMonth: daysInPrevMonth - i,
        isCurrentMonth: false,
        isAvailable: false,
        date: new Date(year, month - 1, daysInPrevMonth - i)
      });
    }
    
    // Current month days
    for (let i = 1; i <= daysInMonth; i++) {
      const date = new Date(year, month, i);
      const isAvailable = date >= new Date(); // Available if not in the past (including Sundays)
      
      days.push({
        dayOfMonth: i,
        isCurrentMonth: true,
        isAvailable,
        date,
        dayName: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][date.getDay()],
        monthName: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'][date.getMonth()],
        year: date.getFullYear()
      });
    }
    
    // Next month days
    const remainingDays = 42 - days.length; // 6 rows of 7 days
    for (let i = 1; i <= remainingDays; i++) {
      days.push({
        dayOfMonth: i,
        isCurrentMonth: false,
        isAvailable: false,
        date: new Date(year, month + 1, i)
      });
    }
    
    setCalendarDays(days);
  };
  
  const changeMonth = (direction) => {
    const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
    let newMonthIndex = monthNames.indexOf(currentMonth) + direction;
    let newYear = currentYear;
    
    if (newMonthIndex < 0) {
      newMonthIndex = 11;
      newYear--;
    } else if (newMonthIndex > 11) {
      newMonthIndex = 0;
      newYear++;
    }
    
    setCurrentMonth(monthNames[newMonthIndex]);
    setCurrentYear(newYear);
    generateCalendarDays(newMonthIndex, newYear);
    
    // Preload data for adjacent months
    preloadAdjacentMonths(newMonthIndex, newYear, monthNames);
  };
  
  const preloadAdjacentMonths = async (monthIndex, year, monthNames) => {
    // Preload previous month
    let prevMonthIndex = monthIndex - 1;
    let prevYear = year;
    if (prevMonthIndex < 0) {
      prevMonthIndex = 11;
      prevYear--;
    }
    
    // Preload next month
    let nextMonthIndex = monthIndex + 1;
    let nextYear = year;
    if (nextMonthIndex > 11) {
      nextMonthIndex = 0;
      nextYear++;
    }
    
    // Preload first few days of each adjacent month
    const preloadDays = [1, 2, 3, 15]; // Sample key dates
    
    for (const day of preloadDays) {
      // Previous month
      const prevDateString = `${monthNames[prevMonthIndex]} ${day}, ${prevYear}`;
      if (!slotsCache[prevDateString]) {
        try {
          await fetchBookedSlotsForDate(prevDateString);
        } catch (e) {
          // Silently fail preloading
        }
      }
      
      // Next month
      const nextDateString = `${monthNames[nextMonthIndex]} ${day}, ${nextYear}`;
      if (!slotsCache[nextDateString]) {
        try {
          await fetchBookedSlotsForDate(nextDateString);
        } catch (e) {
          // Silently fail preloading
        }
      }
    }
  };
  
  const selectDate = async (day) => {
    setSelectedDate(day);
    
    // Cancel any ongoing request
    if (abortController) {
      abortController.abort();
    }
    
    // Clear existing timer
    if (debounceTimer) {
      clearTimeout(debounceTimer);
    }
    
    // Set new timer for debounced slot generation
    const timer = setTimeout(async () => {
      await generateTimeSlots(day);
    }, 300);
    
    setDebounceTimer(timer);
  };
  
  const generateTimeSlots = async (day) => {
    const dateString = `${day.monthName} ${day.dayOfMonth}, ${day.year}`;
    
    // Create new AbortController for this request
    const controller = new AbortController();
    setAbortController(controller);
    
    // Clear ALL cached slots to ensure changes apply to all dates
    Object.keys(localStorage).forEach(key => {
      if (key.startsWith('fitmate-slots-')) {
        localStorage.removeItem(key);
      }
    });
    
    // Check localStorage cache first
    const localCacheKey = `fitmate-slots-${dateString}`;
    const localCache = localStorage.getItem(localCacheKey);
    
    if (localCache) {
      try {
        const cached = JSON.parse(localCache);
        // Check if cache is still valid (1 hour expiration)
        if (Date.now() - cached.timestamp < 3600000) {
          setAvailableTimeSlots(cached.slots);
          setBookedSlots(cached.bookedTimes);
          // Update memory cache too
          setSlotsCache(prev => ({
            ...prev,
            [dateString]: { slots: cached.slots, bookedTimes: cached.bookedTimes }
          }));
          return;
        } else {
          // Remove expired cache
          localStorage.removeItem(localCacheKey);
        }
      } catch (e) {
        localStorage.removeItem(localCacheKey);
      }
    }
    
    // Check memory cache
    if (slotsCache[dateString]) {
      setAvailableTimeSlots(slotsCache[dateString].slots);
      setBookedSlots(slotsCache[dateString].bookedTimes);
      return;
    }
    
    setIsLoadingSlots(true);
    
    try {
      // Generate rolling 45-minute slots from 6:00 to before 21:00
      const slots = [];
      const startHour = 6;
      const endHour = 21; // end boundary (exclusive)
      let minutes = startHour * 60;
      const endMinutes = endHour * 60;
      while (minutes < endMinutes) {
        const hour24 = Math.floor(minutes / 60);
        const mins = minutes % 60;
        const period = hour24 >= 12 ? 'PM' : 'AM';
        const hour12 = hour24 % 12 === 0 ? 12 : hour24 % 12;
        const minsStr = String(mins).padStart(2, '0');
        slots.push(`${hour12}:${minsStr} ${period} EST/EDT`);
        minutes += 45;
      }
      
      // Fetch booked slots for this date
      const bookedTimes = await fetchBookedSlotsForDate(dateString, controller.signal);
      
      // Cache the results in memory and localStorage
      const cacheData = { slots, bookedTimes, timestamp: Date.now() };
      
      setSlotsCache(prev => ({
        ...prev,
        [dateString]: { slots, bookedTimes }
      }));
      
      // Save to localStorage with expiration
      try {
        setLocalStorageWithSync(`fitmate-slots-${dateString}`, JSON.stringify(cacheData));
      } catch (e) {
        console.warn('Failed to save to localStorage:', e);
      }
      
      setBookedSlots(bookedTimes);
      setAvailableTimeSlots(slots);
    } catch (error) {
      // Don't log errors for cancelled requests
      if (error.message !== 'Request cancelled') {
        console.error('Error generating time slots:', error);
      }
    } finally {
      // Only update loading state if request wasn't cancelled
      if (!controller.signal.aborted) {
        setIsLoadingSlots(false);
      }
    }
  };
  
  const selectTimeSlot = (slot) => {
    setSelectedTimeSlot(slot);
  };
  
  const selectPackage = (packageType) => {
    setSelectedPackage(packageType);
  };
  
  const handleBookingSubmit = async () => {
    if (!selectedDate || !selectedTimeSlot || !selectedPackage) {
      if (window.showToast) { showToast('Please complete all booking steps', 'error'); } else { console.log('Please complete all booking steps'); }
      return;
    }
    
    // Check slot availability before proceeding
    const dateString = `${selectedDate.monthName} ${selectedDate.dayOfMonth}, ${selectedDate.year}`;
    const isAvailable = await checkSlotAvailability(dateString, selectedTimeSlot);
    
    if (!isAvailable) {
      if (window.showToast) { showToast('‚ùå Sorry, this time slot is already booked. Please select a different time.', 'error'); } else { console.log('‚ùå Sorry, this time slot is already booked. Please select a different time.'); }
      return;
    }
    
    if (selectedPackage === 'free') {
      // Handle free session booking
      handleFreeSessionBooking();
    } else {
      // Handle paid session booking
      handlePaidSessionBooking();
    }
  };
  
  const handleFreeSessionBooking = () => {
    // Prepare booking details
    const bookingDetails = {
      date: `${selectedDate.monthName} ${selectedDate.dayOfMonth}, ${selectedDate.year}`,
      time: selectedTimeSlot,
      package: 'Free Trial Session',
      email: user?.email || prompt('Please enter your email address:') || 'user@example.com',
      type: 'free',
      sessions: 1,
      price: 0
    };
    
    console.log('Free session booking:', bookingDetails);
    
    // Use the single Whereby meeting room for all sessions
       const meetingId = `FitmateFree${Date.now()}${Math.random().toString(36).substr(2, 9)}`;
       const wherebyLink = `https://fitness-mate.whereby.com/meeting410ee91d-38a8-4636-bcc8-5b9b86035b45`;
    
    // Store booking in Supabase
    if (user && db) {
      const bookingData = {
        date: bookingDetails.date,
        time: bookingDetails.time,
        service: bookingDetails.package,
        duration: 45, // 45-minute sessions
        price: bookingDetails.price,
        status: 'confirmed',
        meeting_link: wherebyLink
      };
      
      // Save to user's bookings in Supabase
      db.addBooking(user.id, bookingData)
        .then(() => {
          console.log('Free booking saved to Supabase successfully');
          // Clear slots cache to ensure fresh data on next load
          setSlotsCache({});
        })
        .catch((error) => {
          console.error('Error saving free booking to Supabase:', error);
        });
    }
    
    // Send confirmation email using EmailJS
    const templateParams = {
      to_email: bookingDetails.email,
      to_name: user?.displayName || 'Fitness Enthusiast',
      session_date: bookingDetails.date,
      session_time: bookingDetails.time,
      session_type: bookingDetails.package,
      meeting_link: wherebyLink
    };
    
    // Show immediate confirmation while email is being sent
    setConfirmationMessage({
      type: 'success',
      title: 'Booking Confirmed!',
      message: `Your free session has been booked for ${bookingDetails.date} at ${bookingDetails.time}. Confirmation email is being sent...`
    });
    closeBookingModal();
    
    // Send the email using EmailJS with timeout
    const emailTimeout = new Promise((_, reject) => {
      setTimeout(() => reject(new Error('Email timeout')), 15000);
    });
    
    Promise.race([
      emailjs.send(
        'service_94q9wl7', // Replace with your EmailJS service ID
        'template_3oqo92k', // Replace with your EmailJS template ID
        templateParams
      ),
      emailTimeout
    ]).then(function(response) {
      console.log('Invoice email sent successfully:', response);
      // Update confirmation message to show email was sent
      setConfirmationMessage({
        type: 'success',
        title: 'Booking Confirmed!',
        message: `Your free session has been booked for ${bookingDetails.date} at ${bookingDetails.time}. Confirmation email sent successfully!`
      });
    }).catch(function(error) {
      console.error('Email sending failed or timed out:', error);
      // Update confirmation message to show email issue
      setConfirmationMessage({
        type: 'warning',
        title: 'Booking Confirmed',
        message: 'Your session was booked successfully, but there was an issue sending the confirmation email. Please contact support if needed.'
      });
    });
    
    // Log what is being sent
    console.log('Email being sent with session details:', {
      to: bookingDetails.email,
      subject: 'Your Free Fitness Session is Confirmed!',
      body: `
        Hi there,
        
        Your free fitness session is confirmed for ${bookingDetails.date} at ${bookingDetails.time}.
        
        Join link: ${wherebyLink}
        
        We look forward to seeing you!
        
        The Fitmate Team
      `
    });
  };
  
  const handlePaidSessionBooking = () => {
    // Set up the bundle based on the selected package
    const bundle = selectedPackage === 'basic' ? 
      { sessions: 5, price: 100 } : 
      { sessions: 10, price: 150 };
    
    // Prepare booking details
    const bookingDetails = {
      date: `${selectedDate.monthName} ${selectedDate.dayOfMonth}, ${selectedDate.year}`,
      time: selectedTimeSlot,
      package: selectedPackage === 'basic' ? 'Basic Package' : 'Premium Package',
      sessions: bundle.sessions,
      price: bundle.price,
      email: user?.email || prompt('Please enter your email address:') || 'user@example.com',
      type: 'paid'
    };
    
    // Use the single Whereby meeting room for all sessions
       const meetingId = `FitmatePaid${Date.now()}${Math.random().toString(36).substr(2, 9)}`;
       const wherebyLink = `https://fitness-mate.whereby.com/meeting410ee91d-38a8-4636-bcc8-5b9b86035b45`;
    
    // Store booking in Firebase
    if (user && db) {
      const bookingData = {
        date: bookingDetails.date,
        time: bookingDetails.time,
        service: bookingDetails.package,
        duration: 45, // 45-minute sessions
        price: bookingDetails.price,
        status: 'Reserved',
        meeting_link: wherebyLink
      };
      
      // Save to user's bookings in Supabase
      db.addBooking(user.id, bookingData)
        .then(() => {
          console.log('Paid booking saved to Supabase successfully');
          // Clear slots cache to ensure fresh data on next load
          setSlotsCache({});
        })
        .catch((error) => {
          console.error('Error saving paid booking to Supabase:', error);
        });
    }
    
    // Prepare email template parameters with invoice details
    const invoiceNumber = `INV-${Date.now()}`;
    const dueDate = new Date();
    dueDate.setDate(dueDate.getDate() + 7); // 7 days from now
    
    const templateParams = {
      to_email: bookingDetails.email,
      to_name: user?.displayName || 'Fitness Enthusiast',
      session_date: bookingDetails.date,
      session_time: bookingDetails.time,
      session_type: bookingDetails.package,
      sessions_count: bookingDetails.sessions,
      amount_due: bookingDetails.price,
      invoice_number: invoiceNumber,
      due_date: dueDate.toLocaleDateString(),
      meeting_link: wherebyLink,
      payment_instructions: 'Please send payment via bank transfer (SEPA domestic or international Swift transfer). Contact us for other payment options if needed. Your session will be confirmed once payment is received.',
      bank_details: 'Name: Dhannani | IBAN: BE45 9670 9853 5289 | Swift/BIC: TRWIBEB1XXX | Bank: Wise, Rue du Tr√¥ne 100, 3rd floor, Brussels, 1050, Belgium',
     
    };
    
    // Show immediate confirmation while email is being sent
  setConfirmationMessage({
      type: 'success',
      title: 'Invoice Generated!',
      message: `Booking reserved! You've selected ${bookingDetails.sessions} sessions for ‚Ç¨${bookingDetails.price}. Invoice and payment instructions are being sent...`
    });
    closeBookingModal();
    
    // Send the email using EmailJS with timeout
    const paidEmailTimeout = new Promise((_, reject) => {
      setTimeout(() => reject(new Error('Email timeout')), 15000);
    });
    
    Promise.race([
      emailjs.send(
        'service_94q9wl7', // Replace with your EmailJS service ID
        'template_3oqo92k', // Replace with your EmailJS template ID
        templateParams
      ),
      paidEmailTimeout
    ]).then(function(response) {
      console.log('Invoice email sent successfully:', response);
      // Update confirmation message to show email was sent
      setConfirmationMessage({
        type: 'success',
        title: 'Invoice Sent!',
        message: `Booking reserved! You've selected ${bookingDetails.sessions} sessions for ‚Ç¨${bookingDetails.price}. Invoice and payment instructions sent successfully!`,
        paymentDetails: {
          amount: bookingDetails.price,
          sessions: bookingDetails.sessions,
          invoiceNumber: invoiceNumber,
          bankDetails: 'Name: Dhannani | IBAN: BE45 9670 9853 5289 | Swift/BIC: TRWIBEB1XXX',
          bankAddress: 'Bank: Wise, Rue du Tr√¥ne 100, 3rd floor, Brussels, 1050, Belgium',
          
        }
      });
    }).catch(function(error) {
      console.error('Email sending failed or timed out:', error);
      // Update confirmation message to show email issue
      setConfirmationMessage({
        type: 'warning',
        title: 'Booking Reserved',
        message: 'Your booking was reserved successfully, but there was an issue sending the invoice email. Please contact support for payment instructions.'
      });
    });
  };
      

      


      const validateEmail = (email) => {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
      };

      const handleSupportSubmit = async (e) => {
        e.preventDefault();
        
        // Validation
        if (!supportForm.fullName.trim()) {
          if (window.showToast) { showToast('Please enter your full name.', 'error'); } else { console.log('Please enter your full name.'); }
          return;
        }
        
        if (!supportForm.email.trim() || !validateEmail(supportForm.email)) {
          if (window.showToast) { showToast('Please enter a valid email address.', 'error'); } else { console.log('Please enter a valid email address.'); }
          return;
        }
        
        if (!supportForm.subject.trim()) {
          if (window.showToast) { showToast('Please enter a subject.', 'error'); } else { console.log('Please enter a subject.'); }
          return;
        }
        
        if (!supportForm.message.trim()) {
          if (window.showToast) { showToast('Please enter your message.', 'error'); } else { console.log('Please enter your message.'); }
          return;
        }

        setIsSubmittingSupport(true);
        
        try {
          // Create URLSearchParams directly for Netlify form submission
          const formData = new URLSearchParams();
          formData.append('form-name', 'support-form');
          formData.append('full-name', supportForm.fullName);
          formData.append('email', supportForm.email);
          formData.append('subject', supportForm.subject);
          formData.append('message', supportForm.message);
          
          const response = await fetch('/', {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: formData.toString()
          });
          
          if (response.ok) {
            setSupportSubmissionStatus('success');
            setSupportForm({ fullName: '', email: '', subject: '', message: '' });
          } else {
            throw new Error('Form submission failed');
          }
        } catch (error) {
          console.error('Support form submission error:', error);
          setSupportSubmissionStatus('error');
        } finally {
          setIsSubmittingSupport(false);
        }
      };

      // In-app modal to collect avatar preferences (replaces native prompt)
      const showAvatarModal = () => new Promise(resolve => {
        const overlay = document.createElement('div');
        overlay.className = 'fixed inset-0 z-50 bg-black/50 backdrop-blur-sm flex items-center justify-center p-4';
        overlay.innerHTML = `
          <div class="bg-white dark:bg-gray-800 rounded-2xl shadow-2xl border border-white/20 dark:border-gray-700 w-full max-w-md">
            <div class="px-5 py-4 border-b border-gray-100 dark:border-gray-700 flex items-center justify-between">
              <div class="text-lg font-semibold text-gray-800 dark:text-gray-200">AI Avatar Preferences</div>
              <button class="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 text-xl" data-close>&times;</button>
            </div>
            <div class="px-5 pt-4 pb-2 space-y-4">
              <div>
                <label class="text-sm font-semibold text-gray-700 dark:text-gray-300">Gender</label>
                <select class="mt-1 w-full p-3 rounded-xl border border-gray-200 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 focus:outline-none focus:ring-2 focus:ring-purple-500" data-field="gender">
                  <option value="male">Male</option>
                  <option value="female">Female</option>
                  <option value="non-binary">Non-binary</option>
                </select>
              </div>
              <div>
                <label class="text-sm font-semibold text-gray-700 dark:text-gray-300">Style</label>
                <select class="mt-1 w-full p-3 rounded-xl border border-gray-200 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 focus:outline-none focus:ring-2 focus:ring-purple-500" data-field="style">
                  <option value="professional">Professional</option>
                  <option value="casual">Casual</option>
                  <option value="sporty" selected>Sporty</option>
                  <option value="artistic">Artistic</option>
                </select>
              </div>
              <div>
                <label class="text-sm font-semibold text-gray-700 dark:text-gray-300">Hair color</label>
                <select class="mt-1 w-full p-3 rounded-xl border border-gray-200 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 focus:outline-none focus:ring-2 focus:ring-purple-500" data-field="hairColor">
                  <option value="brown" selected>Brown</option>
                  <option value="black">Black</option>
                  <option value="blonde">Blonde</option>
                  <option value="red">Red</option>
                  <option value="gray">Gray</option>
                  <option value="other">Other</option>
                </select>
              </div>
            </div>
            <div class="px-5 pb-4 pt-2 flex items-center justify-end gap-2">
              <button class="px-4 py-2 rounded-lg bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200" data-cancel>Cancel</button>
              <button class="px-4 py-2 rounded-lg bg-purple-500 hover:bg-purple-600 text-white font-semibold" data-ok>Generate</button>
            </div>
          </div>`;
        document.body.appendChild(overlay);
        const close = () => { try { overlay.remove(); } catch(_) {} };
        overlay.addEventListener('click', (e) => { if (e.target === overlay) { close(); resolve(null); } });
        overlay.querySelector('[data-close]')?.addEventListener('click', () => { close(); resolve(null); });
        overlay.querySelector('[data-cancel]')?.addEventListener('click', () => { close(); resolve(null); });
        overlay.querySelector('[data-ok]')?.addEventListener('click', () => {
          const gender = overlay.querySelector('[data-field="gender"]').value;
          const style = overlay.querySelector('[data-field="style"]').value;
          const hairColor = overlay.querySelector('[data-field="hairColor"]').value;
          close();
          resolve({ gender, style, hairColor });
        });
      });

      const generateAIAvatar = async () => {
        const prefs = await showAvatarModal();
        if (!prefs) return; // User cancelled
        const { gender, style, hairColor } = prefs;
        
        setIsGeneratingAvatar(true);
        try {
          const prompt = `Create a professional, friendly avatar for a fitness app user with these specifications:
          - Gender: ${gender}
          - Style: ${style} 
          - Hair color: ${hairColor}
          - Clean, modern design
          - Suitable for a health and fitness application
          - Colorful but professional
          - Square format, suitable for profile picture
          - Cartoon or illustrated style, not photorealistic
          - Should look healthy, fit, and approachable
          - Age range: 25-35 years old
          
          Generate a detailed description for an avatar that represents health, fitness, and wellness with the specified characteristics.`;

            const response = await fetch(getDirectGeminiConfig().url, {
            method: 'POST',
            headers: getDirectGeminiConfig().headers,
            body: JSON.stringify({
              model: OPENROUTER_QWEN_MODEL,
              messages: [{ role: 'user', content: prompt }]
            })
          });

          if (!response.ok) {
            throw new Error(`API Error: ${response.status}`);
          }

          const result = await response.json();
          const description = (result.choices?.[0]?.message?.content || '');
          
          // Use the AI description with user preferences as seed for avatar generation
          const seed = `${gender}-${style}-${hairColor}-${description.substring(0, 30)}`;
          const avatarUrl = `https://api.dicebear.com/7.x/avataaars/svg?seed=${encodeURIComponent(seed)}&backgroundColor=b6e3f4,c0aede,d1d4f9,ffd5dc,ffdfbf&hair=${hairColor === 'blonde' ? 'blonde' : hairColor === 'red' ? 'red' : 'brown'}`;
          
          setProfilePicture(avatarUrl);
          
          // Sync to remote if user is signed in
          if (user) {
            updateUserData({ profile_picture: avatarUrl });
          }
        } catch (error) {
          console.error('Avatar generation error:', error);
          if (window.showToast) { showToast('Failed to generate avatar. Please try again.', 'error'); } else { console.log('Failed to generate avatar. Please try again.'); }
        } finally {
          setIsGeneratingAvatar(false);
        }
      };

      return (
        <div className="p-6 pb-24">
          {showBookingModal && (
            <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4">
              <div className="bg-white dark:bg-gray-900 rounded-2xl shadow-2xl w-full max-w-4xl max-h-[90vh] flex flex-col transform transition-all opacity-100 scale-100">
                <div className="flex justify-between items-center p-4 border-b border-gray-200 dark:border-gray-700 flex-shrink-0">
                  <h3 className="text-2xl font-bold text-gray-800 dark:text-gray-200">Book Your Session</h3>
                  <button onClick={closeBookingModal} className="text-gray-500 hover:text-gray-800 dark:text-gray-400 dark:hover:text-gray-200 p-2 rounded-full bg-gray-100 dark:bg-gray-800">
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" /></svg>
                  </button>
                </div>
                <div className="p-2 md:p-6 flex-1 overflow-y-auto">
                  {/* Custom Booking Calendar */}
                  <div className="booking-calendar-container">
                    {/* Step 1: Date Selection */}
                    {bookingStep === 1 && (
                      <div className="booking-step">
                        <h3 className="text-xl font-semibold text-gray-800 dark:text-gray-200 mb-4">Select a Date</h3>
                        <div className="calendar-container">
                          <div className="calendar-header flex justify-between items-center mb-4">
                            <button 
                              onClick={() => changeMonth(-1)} 
                              className="p-2 rounded-full bg-gray-100 dark:bg-gray-800 text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-700"
                            >
                              <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fillRule="evenodd" d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z" clipRule="evenodd" />
                              </svg>
                            </button>
                            <h4 className="text-lg font-medium text-gray-800 dark:text-gray-200">{currentMonth} {currentYear}</h4>
                            <button 
                              onClick={() => changeMonth(1)} 
                              className="p-2 rounded-full bg-gray-100 dark:bg-gray-800 text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-700"
                            >
                              <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fillRule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clipRule="evenodd" />
                              </svg>
                            </button>
                          </div>
                          
                          <div className="calendar-grid grid grid-cols-7 gap-1 mb-6">
                            {['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].map((day, index) => (
                              <div key={index} className="calendar-day-header text-center text-sm font-medium text-gray-500 dark:text-gray-400 py-2">
                                {day}
                              </div>
                            ))}
                            
                            {calendarDays.map((day, index) => (
                              <div 
                                key={index} 
                                className={`
                                  calendar-day text-center py-2 rounded-lg cursor-pointer
                                  ${day.isCurrentMonth ? 'text-gray-800 dark:text-gray-200' : 'text-gray-400 dark:text-gray-600'} 
                                  ${day.isAvailable ? 'hover:bg-pink-100 dark:hover:bg-pink-900' : 'opacity-50 cursor-not-allowed'}
                                  ${selectedDate && day.date.toDateString() === selectedDate.date.toDateString() ? 'bg-pink-500 text-white' : ''}
                                `}
                                onClick={() => day.isAvailable ? selectDate(day) : null}
                              >
                                {day.dayOfMonth}
                              </div>
                            ))}
                          </div>
                          
                          <button 
                            className={`
                              w-full py-3 rounded-lg font-medium text-white
                              ${selectedDate ? 'bg-pink-500 hover:bg-pink-600' : 'bg-gray-300 dark:bg-gray-700 cursor-not-allowed'}
                            `}
                            disabled={!selectedDate} 
                            onClick={() => setBookingStep(2)}
                          >
                            Next: Select Time
                          </button>
                        </div>
                      </div>
                    )}
                    
                    {/* Step 2: Time Selection */}
                    {bookingStep === 2 && (
                      <div className="booking-step">
                        <h3 className="text-xl font-semibold text-gray-800 dark:text-gray-200 mb-2">Select a Time</h3>
                        <p className="text-gray-600 dark:text-gray-400 mb-4">
                          {selectedDate ? `${selectedDate.dayName}, ${selectedDate.monthName} ${selectedDate.dayOfMonth}, ${selectedDate.year}` : ''}
                        </p>
                        
                        <div className="time-slots-container grid grid-cols-3 gap-3 mb-6">
                          {isLoadingSlots ? (
                            // Skeleton loading for time slots
                            Array.from({ length: 12 }).map((_, index) => (
                              <div key={index} className="animate-pulse">
                                <div className="bg-gray-200 dark:bg-gray-700 rounded-lg h-12 w-full"></div>
                              </div>
                            ))
                          ) : availableTimeSlots.map((slot, index) => {
                            const isBooked = bookedSlots.includes(slot);
                            const isSelected = selectedTimeSlot === slot;
                            
                            return (
                              <div 
                                key={index} 
                                className={`
                                  time-slot text-center py-3 rounded-lg border relative
                                  ${isBooked 
                                    ? 'bg-red-100 dark:bg-red-900 text-red-600 dark:text-red-300 border-red-300 dark:border-red-700 cursor-not-allowed opacity-60' 
                                    : isSelected 
                                      ? 'bg-pink-500 text-white border-pink-500 cursor-pointer' 
                                      : 'bg-white dark:bg-gray-800 text-gray-800 dark:text-gray-200 border-gray-200 dark:border-gray-700 hover:border-pink-500 dark:hover:border-pink-500 cursor-pointer'
                                  }
                                `}
                                onClick={() => !isBooked && selectTimeSlot(slot)}
                              >
                                {slot}
                                {isBooked && (
                                  <div className="absolute inset-0 flex items-center justify-center">
                                    <span className="text-xs font-semibold bg-red-500 text-white px-2 py-1 rounded-full">Booked</span>
                                  </div>
                                )}
                              </div>
                            );
                          })}
                        
                        </div>
                        
                        <div className="flex space-x-3">
                          <button 
                            className="flex-1 py-3 rounded-lg font-medium text-gray-700 dark:text-gray-300 bg-gray-100 dark:bg-gray-800 hover:bg-gray-200 dark:hover:bg-gray-700"
                            onClick={() => setBookingStep(1)}
                          >
                            Back
                          </button>
                          <button 
                            className={`
                              flex-1 py-3 rounded-lg font-medium text-white
                              ${selectedTimeSlot ? 'bg-pink-500 hover:bg-pink-600' : 'bg-gray-300 dark:bg-gray-700 cursor-not-allowed'}
                            `}
                            disabled={!selectedTimeSlot} 
                            onClick={() => setBookingStep(3)}
                          >
                            Next: Select Package
                          </button>
                        </div>
                      </div>
                    )}
                    
                    {/* Step 3: Package Selection */}
                    {bookingStep === 3 && (
                      <div className="booking-step">
                        <h3 className="text-xl font-semibold text-gray-800 dark:text-gray-200 mb-2">Select a Package</h3>
                        <p className="text-gray-600 dark:text-gray-400 mb-4">
                          {selectedDate ? `${selectedDate.dayName}, ${selectedDate.monthName} ${selectedDate.dayOfMonth}, ${selectedDate.year} at ${selectedTimeSlot}` : ''}
                        </p>
                        
                        <div className="package-options grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                          <div 
                            className={`
                              package-card p-4 rounded-lg border cursor-pointer
                              ${selectedPackage === 'free' ? 'bg-pink-50 dark:bg-pink-900/20 border-pink-500' : 'bg-white dark:bg-gray-800 border-gray-200 dark:border-gray-700 hover:border-pink-500 dark:hover:border-pink-500'}
                            `}
                            onClick={() => selectPackage('free')}
                          >
                            <h4 className="text-lg font-semibold text-gray-800 dark:text-gray-200 mb-2">Free Trial Session</h4>
                            <p className="text-2xl font-bold text-pink-500 mb-3">‚Ç¨0</p>
                            <ul className="text-sm text-gray-600 dark:text-gray-400 space-y-2">
                              <li>‚úì 25-minute introduction session</li>
                              <li>‚úì Fitness assessment</li>
                              <li>‚úì Goal setting consultation</li>
                            </ul>
                          </div>
                          
                          <div 
                            className={`
                              package-card p-4 rounded-lg border cursor-pointer
                              ${selectedPackage === 'basic' ? 'bg-pink-50 dark:bg-pink-900/20 border-pink-500' : 'bg-white dark:bg-gray-800 border-gray-200 dark:border-gray-700 hover:border-pink-500 dark:hover:border-pink-500'}
                            `}
                            onClick={() => selectPackage('basic')}
                          >
                            <h4 className="text-lg font-semibold text-gray-800 dark:text-gray-200 mb-2">Basic Package</h4>
                            <p className="text-2xl font-bold text-pink-500 mb-3">‚Ç¨100</p>
                            <ul className="text-sm text-gray-600 dark:text-gray-400 space-y-2">
                              <li>‚úì 5 training sessions</li>
                              <li>‚úì Personalized workout plan</li>
                              <li>‚úì Nutrition guidance</li>
                            </ul>
                          </div>
                          
                          <div 
                            className={`
                              package-card p-4 rounded-lg border cursor-pointer
                              ${selectedPackage === 'premium' ? 'bg-pink-50 dark:bg-pink-900/20 border-pink-500' : 'bg-white dark:bg-gray-800 border-gray-200 dark:border-gray-700 hover:border-pink-500 dark:hover:border-pink-500'}
                            `}
                            onClick={() => selectPackage('premium')}
                          >
                            <h4 className="text-lg font-semibold text-gray-800 dark:text-gray-200 mb-2">Premium Package</h4>
                            <p className="text-2xl font-bold text-pink-500 mb-3">‚Ç¨150</p>
                            <ul className="text-sm text-gray-600 dark:text-gray-400 space-y-2">
                              <li>‚úì 10 training sessions</li>
                              <li>‚úì Comprehensive fitness plan</li>
                              <li>‚úì Detailed nutrition program</li>
                              <li>‚úì 24/7 support</li>
                            </ul>
                          </div>
                        </div>
                        
                        <div className="flex space-x-3">
                          <button 
                            className="flex-1 py-3 rounded-lg font-medium text-gray-700 dark:text-gray-300 bg-gray-100 dark:bg-gray-800 hover:bg-gray-200 dark:hover:bg-gray-700"
                            onClick={() => setBookingStep(2)}
                          >
                            Back
                          </button>
                          <button 
                            className={`
                              flex-1 py-3 rounded-lg font-medium text-white text-sm sm:text-base
                              ${selectedPackage ? 'bg-pink-500 hover:bg-pink-600' : 'bg-gray-300 dark:bg-gray-700 cursor-not-allowed'}
                            `}
                            disabled={!selectedPackage} 
                            onClick={handleBookingSubmit}
                          >
                            {selectedPackage === 'free' ? 'Book Free Session' : 'Generate Invoice & Book'}
                          </button>
                        </div>
                      </div>
                    )}
                  </div>
                </div>
              </div>
            </div>
           )}
           
           {/* Optimized Confirmation Message Modal */}
           {confirmationMessage && (
             <div className="fixed inset-0 bg-black/75 flex items-center justify-center z-50 p-4 will-change-transform">
               <div className="bg-white dark:bg-gray-900 rounded-2xl shadow-2xl w-full max-w-md mx-auto transform transition-transform duration-200 scale-100 will-change-transform">
                 <div className="p-6 text-center">
                   <div className={`mx-auto mb-4 w-12 h-12 rounded-full flex items-center justify-center will-change-transform ${
                     confirmationMessage.type === 'success' ? 'bg-green-100 dark:bg-green-900/20' : 'bg-yellow-100 dark:bg-yellow-900/20'
                   }`}>
                     {confirmationMessage.type === 'success' ? (
                       <svg className="w-6 h-6 text-green-600 dark:text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" style={{willChange: 'transform'}}>
                         <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
                       </svg>
                     ) : (
                       <svg className="w-6 h-6 text-yellow-600 dark:text-yellow-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" style={{willChange: 'transform'}}>
                         <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z" />
                       </svg>
                     )}
                   </div>
                   <h3 className="text-lg font-semibold text-gray-800 dark:text-gray-200 mb-2 will-change-contents">
                     {confirmationMessage.title}
                   </h3>
                   <p className="text-gray-600 dark:text-gray-400 mb-4 will-change-contents">
                     {confirmationMessage.message}
                   </p>
                   
                   {/* Payment Details Section */}
                   {confirmationMessage.paymentDetails && (
                     <div className="bg-gray-50 dark:bg-gray-800 rounded-lg p-4 mb-4 text-left">
                       <h4 className="font-semibold text-gray-800 dark:text-gray-200 mb-3 text-center">üí≥ Payment Details</h4>
                       <div className="space-y-2 text-sm">
                         <div className="flex justify-between">
                           <span className="text-gray-600 dark:text-gray-400">Amount:</span>
                           <span className="font-medium text-gray-800 dark:text-gray-200">‚Ç¨{confirmationMessage.paymentDetails.amount}</span>
                         </div>
                         <div className="flex justify-between">
                           <span className="text-gray-600 dark:text-gray-400">Sessions:</span>
                           <span className="font-medium text-gray-800 dark:text-gray-200">{confirmationMessage.paymentDetails.sessions}</span>
                         </div>
                         <div className="flex justify-between">
                           <span className="text-gray-600 dark:text-gray-400">Invoice #:</span>
                           <span className="font-medium text-gray-800 dark:text-gray-200">{confirmationMessage.paymentDetails.invoiceNumber}</span>
                         </div>
                         <hr className="border-gray-200 dark:border-gray-700 my-3" />
                         <div className="mb-2">
                           <span className="text-gray-600 dark:text-gray-400 block mb-1">üè¶ Bank Transfer:</span>
                           <div className="text-xs text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-700 p-2 rounded border">
                             <div>{confirmationMessage.paymentDetails.bankDetails}</div>
                             <div className="mt-1">{confirmationMessage.paymentDetails.bankAddress}</div>
                           </div>
                         </div>
                         {/* PayPal payment method removed */}
                       </div>
                     </div>
                   )}
                   <button
                     onClick={() => setConfirmationMessage(null)}
                     className="w-full bg-pink-500 active:bg-pink-600 text-white font-medium py-3 px-4 rounded-lg transition-colors duration-150 will-change-transform touch-manipulation"
                   >
                     OK
                   </button>
                 </div>
               </div>
             </div>
           )}

           <header className="mb-6 flex justify-between items-center">
            <h1 className="text-3xl font-bold text-gray-800 dark:text-gray-200">My Profile</h1>
            {user && (
              <button 
                onClick={openSupportModal}
                className="flex items-center gap-2 bg-gradient-to-r from-purple-500 to-pink-500 text-white px-3 py-2 rounded-full shadow-lg hover:scale-105 transition-transform text-sm md:text-base md:px-4"
              >
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M2 5a2 2 0 012-2h7a2 2 0 012 2v4a2 2 0 01-2 2H9l-3 3v-3H4a2 2 0 01-2-2V5z"/><path d="M15 7v2a2 2 0 012 2v5a2 2 0 01-2 2H9a2 2 0 01-2-2v-2h6V7z"/></svg>
                <span>Virtual Trainer</span>
              </button>
            )}
          </header>

          <div className="flex flex-col items-center mb-6 bg-white dark:bg-gray-800 p-6 rounded-2xl shadow-md">
            <div className="relative mb-4">
              <img 
                src={profilePicture} 
                alt="User profile" 
                className="w-24 h-24 rounded-full object-cover border-4 border-pink-200 dark:border-pink-400" 
              />
              <button
                onClick={() => fileInputRef.current?.click()}
                className="absolute -bottom-2 -right-2 bg-pink-500 text-white p-2 rounded-full shadow-lg hover:bg-pink-600 transition-colors"
                title="Upload Photo"
              >
                üì∑
              </button>
            </div>
            
            <div className="flex gap-2 mb-4">
              <button
                onClick={() => fileInputRef.current?.click()}
                className="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-lg text-sm font-medium transition-colors"
              >
                üìÅ Upload Photo
              </button>
              <button
                onClick={generateAIAvatar}
                disabled={isGeneratingAvatar}
                className="bg-purple-500 hover:bg-purple-600 disabled:bg-gray-400 text-white px-4 py-2 rounded-lg text-sm font-medium transition-colors flex items-center gap-1"
              >
                {isGeneratingAvatar ? '‚è≥ Generating...' : 'ü§ñ AI Avatar'}
              </button>
            </div>

            <input
              type="file"
              ref={fileInputRef}
              onChange={handleImageUpload}
              accept="image/*"
              className="hidden"
            />
            
            <h2 className="text-2xl font-bold text-gray-800 dark:text-gray-200">
              {user ? (user.user_metadata?.display_name || 'User') : 'John Doe'}
            </h2>
            <p className="text-gray-500 dark:text-gray-400">
              {user ? user.email : 'john.doe@example.com'}
            </p>
          </div>

          <div className="mb-6">
            <h3 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-4">My Goals</h3>
            <div className="bg-white dark:bg-gray-800 rounded-2xl shadow-md p-4 space-y-3">
              <div className="p-2">
                <label className="font-semibold mb-2 block text-gray-800 dark:text-gray-200">Daily Calories: {goals.calories} kcal</label>
                <input type="range" min="1200" max="4000" step="50" value={goals.calories} onChange={e => handleGoalChange('calories', e.target.value)} className="w-full" />
              </div>
              <div className="flex justify-between items-center p-2">
                <p className="text-gray-600 dark:text-gray-300">Protein</p>
                <p className="font-bold text-gray-800 dark:text-gray-200">{goals.protein} g</p>
              </div>
              <div className="flex justify-between items-center p-2">
                <p className="text-gray-600 dark:text-gray-300">Carbs</p>
                <p className="font-bold text-gray-800 dark:text-gray-200">{goals.carbs} g</p>
              </div>
              <div className="flex justify-between items-center p-2">
                <p className="text-gray-600 dark:text-gray-300">Fat</p>
                <p className="font-bold text-gray-800 dark:text-gray-200">{goals.fat} g</p>
              </div>
            </div>
          </div>

          {/* Virtual Trainer Section (temporarily hidden) */}
          {false && (
          <div id="virtual-trainer-card" className="mb-6">
            <h3 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-4">Virtual Trainer</h3>
            <div className="bg-white dark:bg-gray-800 rounded-2xl shadow-md p-6">
              <div className="flex flex-col md:flex-row items-center gap-6">
                <div className="flex-shrink-0">
                  <img src={user ? "naim.png" : "icon-512.png"} alt="Virtual Trainer" className="w-32 h-32 rounded-full object-cover object-center border-4 border-pink-200 dark:border-pink-400"/>
                </div>
                <div className="flex-grow">
                  <h4 className="text-2xl font-bold text-gray-800 dark:text-gray-200">Book a Personal Session</h4>
                  <p className="text-gray-600 dark:text-gray-400 mt-2">
                    Get one-on-one guidance from a certified trainer. Your first 25-minute session is <strong>FREE</strong>!
                  </p>
                  <div className="mt-4 space-y-3">
                    <div className="flex justify-between items-center p-3 bg-gray-50 dark:bg-gray-700 rounded-lg">
                      <div>
                        <p className="text-gray-700 dark:text-gray-300"><span className="font-bold text-pink-500">5 Sessions:</span> ‚Ç¨100</p>
                        <p className="text-xs text-gray-500 dark:text-gray-400">Save ‚Ç¨25 compared to individual sessions</p>
                      </div>
                      {user && (
                        <button 
                          onClick={() => {
                            setSelectedPackage('basic');
                            openBookingModal();
                          }}
                          className="bg-pink-500 hover:bg-pink-600 text-white px-4 py-2 rounded-lg text-sm font-medium transition-colors"
                        >
                          Buy Now
                        </button>
                      )}
                    </div>
                    <div className="flex justify-between items-center p-3 bg-gray-50 dark:bg-gray-700 rounded-lg">
                      <div>
                        <p className="text-gray-700 dark:text-gray-300"><span className="font-bold text-pink-500">10 Sessions:</span> ‚Ç¨150</p>
                        <p className="text-xs text-gray-500 dark:text-gray-400">Best value - Save ‚Ç¨50!</p>
                      </div>
                      {user && (
                        <button 
                          onClick={() => {
                            setSelectedPackage('premium');
                            openBookingModal();
                          }}
                          className="bg-pink-500 hover:bg-pink-600 text-white px-4 py-2 rounded-lg text-sm font-medium transition-colors"
                        >
                          Buy Now
                        </button>
                      )}
                    </div>
                  </div>
                  <div className="mt-6 flex flex-col md:flex-row gap-3">
                    {user ? (
                      <>
                        <button 
                          onClick={openBookingModal}
                          className="w-full md:w-auto bg-gradient-to-r from-green-500 to-blue-500 text-white px-6 py-3 rounded-lg shadow-lg hover:scale-105 transition-transform font-semibold"
                        >
                          Book a Session
                        </button>
                      </>
                    ) : (
                      <button 
                        onClick={openAccountModal}
                        className="w-full md:w-auto bg-gradient-to-r from-purple-500 to-pink-500 text-white px-6 py-3 rounded-lg shadow-lg hover:scale-105 transition-transform font-semibold"
                      >
                        Sign In to Explore
                      </button>
                    )}
                  </div>
                </div>
              </div>
            </div>
          </div>
          )}

          <div>
            <h3 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-4">Settings</h3>
            <div className="bg-white dark:bg-gray-800 rounded-2xl shadow-md p-4 space-y-1">
              <button 
                onClick={openAccountModal}
                className="w-full text-left p-3 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-300 transition-colors flex justify-between items-center"
              >
                <span>Account</span>
                {user && (
                  <span className="text-xs bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-200 px-2 py-1 rounded-full">
                    Signed In
                  </span>
                )}
              </button>

              <div className="w-full p-3 rounded-lg border border-gray-200 dark:border-gray-700">
                <div className="flex justify-between items-start mb-2">
                  <div>
                    <div className="text-gray-700 dark:text-gray-300 font-medium">Subscription</div>
                    <div className="text-xs text-gray-500 dark:text-gray-400 mt-0.5">
                      {aiRemaining.count}/{aiRemaining.limit} prompts today
                    </div>
                  </div>
                  {subActive && (
                    <span className="text-xs bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-200 px-2 py-1 rounded-full whitespace-nowrap">
                      ‚úì Active
                    </span>
                  )}
                </div>
                {subActive ? (
                  <div className="flex flex-col gap-2 mt-3 pt-3 border-t border-gray-100 dark:border-gray-700">
                    <button
                      onClick={async ()=>{ const openPlay=()=>{ const sku=(window.fitmateIAP&&window.fitmateIAP.PRODUCT_ID)?window.fitmateIAP.PRODUCT_ID:'fitnessmate_monthly'; const pkg='app.netlify.fitnessmate.twa'; const manageUrl=`https://play.google.com/store/account/subscriptions?sku=${encodeURIComponent(sku)}&package=${encodeURIComponent(pkg)}`; try{window.open(manageUrl,'_blank');}catch(_){} }; const openStripeLogin=()=>{ try{ window.open('https://billing.stripe.com/p/login/28E14o3tE3dP9Uhfnc3sI00','_blank'); }catch(_){} }; try { if (supabase && supabase.functions) { const { data, error } = await supabase.functions.invoke('stripe-webhook', { body: { action: 'create_portal_session' } }); if (!error && data && data.url) { window.location.assign(data.url); return; } } } catch(_){} if (window.__hasAndroidBridge) { openPlay(); } else { openStripeLogin(); } }}
                      className="w-full bg-gray-800 hover:bg-gray-900 text-white text-sm font-medium px-4 py-2.5 rounded-lg shadow-sm transition-colors"
                    >
                      Manage subscription
                    </button>
                  </div>
                ) : (
                  <div className="flex flex-col gap-2 mt-3 pt-3 border-t border-gray-100 dark:border-gray-700">
                    <div className={"grid gap-2 justify-items-center " + (window.__isNativeAndroidApp ? "grid-cols-1 sm:grid-cols-2" : "grid-cols-1")}>
                      <button
                        onClick={()=>{ try { if (!user) { openAccountModal(); return; } if (window.openStripePricingModal) window.openStripePricingModal(); } catch(_){} }}
                        className={(window.__hasAndroidBridge ? 'hidden ' : '') + 'w-full max-w-[340px] mx-auto bg-pink-500 hover:bg-pink-600 text-white text-sm font-medium px-4 py-2.5 rounded-lg shadow-sm transition-colors whitespace-nowrap leading-tight'}
                      >
                        Subscribe via Stripe
                      </button>
                      <button
                        onClick={async ()=>{ try { if (!user) { openAccountModal(); return; } await (window.FitnessMateBilling && window.FitnessMateBilling.subscribe ? window.FitnessMateBilling.subscribe() : Promise.resolve(false)); } catch(_){} }}
                        className={(window.__hasAndroidBridge ? '' : 'hidden ') + 'w-full max-w-[340px] mx-auto bg-blue-500 hover:bg-blue-600 text-white text-sm font-medium px-4 py-2.5 rounded-lg shadow-sm transition-colors whitespace-nowrap leading-tight'}
                      >
                        Subscribe via Play Store
                      </button>
                    </div>
                    <button
                      onClick={async ()=>{ try { await (window.FitnessMateBilling && window.FitnessMateBilling.restore ? window.FitnessMateBilling.restore() : Promise.resolve(false)); } catch(_){} }}
                      className="text-xs text-center text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200"
                    >
                      Already subscribed? Restore
                    </button>
                  </div>
                )}
              </div>
              
              {/* Booking History Button - Only show when user is signed in */}
              {user && (
                <button 
                  onClick={toggleBookingHistory}
                  className="w-full text-left p-3 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-300 transition-colors flex justify-between items-center"
                >
                  <span className="flex items-center gap-2">
                    <span>üìÖ</span>
                    <span>Booking History</span>
                  </span>
                  {bookingHistory.length > 0 && (
                    <span className="text-xs bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200 px-2 py-1 rounded-full">
                      {bookingHistory.length}
                    </span>
                  )}
                </button>
              )}
              
              
              {/* Manual Cloud Sync (hidden by default; auto-sync is active) */}
              {user && SHOW_MANUAL_CLOUD_SYNC && (
                <div className="space-y-2">
                  <div className="space-y-2">
                    <button 
                      onClick={async () => {
                        console.log('üß™ Testing manual upload...');
                        try {
                          // Force sync all current data to Supabase
                          const allLocalData = {
                            goals: JSON.parse(localStorage.getItem('goals') || '{}'),
                            // profile_picture intentionally excluded to avoid overwriting remote value during remote-only mode,
                            notifications_enabled: JSON.parse(localStorage.getItem('notificationsEnabled') || 'true'),
                            daily_intake: JSON.parse(localStorage.getItem('dailyIntake') || '{}'),
                            recent_meals: (() => { try { const meals = JSON.parse(localStorage.getItem('recentMeals') || '[]') || []; const todayISO = toLocalISODate(new Date()); return Array.isArray(meals) ? meals.filter(m => m && m.__day === todayISO) : []; } catch { return []; } })(),
                            daily_history: JSON.parse(localStorage.getItem('dailyHistory') || '{}'),
                            coach_messages: JSON.parse(localStorage.getItem('coachMessages') || '[]'),
                            habit_ai_advice: localStorage.getItem('habitAIAdvice') || '',
                            habits: JSON.parse(localStorage.getItem('habits') || '[]'),
                            dark_mode: JSON.parse(localStorage.getItem('fitmate-dark-mode') || 'false'),
                            meal_plan: JSON.parse(localStorage.getItem('mealPlan') || 'null'),
                            workout_plan: JSON.parse(localStorage.getItem('workoutPlan') || 'null'),
                            scan_result: JSON.parse(localStorage.getItem('scanResult') || 'null'),
                            form_analysis: JSON.parse(localStorage.getItem('formAnalysis') || 'null'),
                            updated_at: new Date().toISOString()
                          };
                          // Ensure day stamp is present for safe same-day remote sync
                          try {
                            const di = JSON.parse(localStorage.getItem('dailyIntake') || '{}') || {};
                            allLocalData.daily_intake = { ...di, __day: toLocalISODate(new Date()) };
                          } catch {
                            allLocalData.daily_intake = { __day: toLocalISODate(new Date()) };
                          }
                          
                          await queueUserUpdate(user.id, allLocalData);
                          console.log('‚úÖ Manual upload queued and will be sent shortly!');
                          if (window.showToast) { showToast('‚úÖ Data uploaded successfully! Check another device to see if it appears.', 'success'); } else { console.log('‚úÖ Data uploaded successfully! Check another device to see if it appears.'); }
                        } catch (error) {
                          console.error('‚ùå Manual upload failed:', error);
                          if (window.showToast) { showToast('‚ùå Upload failed: ' + error.message, 'error'); } else { console.error('‚ùå Upload failed: ' + error.message); }
                        }
                      }}
                      className="w-full text-left p-3 rounded-lg hover:bg-blue-100 dark:hover:bg-blue-900 text-blue-700 dark:text-blue-300 transition-colors flex items-center gap-2"
                    >
                      <span>üì§</span>
                      <span>Upload Data to Cloud</span>
                    </button>
                    
                    <button 
                      onClick={async () => {
                        console.log('üß™ Testing manual download...');
                        try {
                          // Force download data from Supabase
                          const userData = await db.getUser(user.id);
                          if (userData) {
                            // Update localStorage with remote data
                            if (userData.goals) localStorage.setItem('goals', JSON.stringify(userData.goals));
                            if (userData.profile_picture) localStorage.setItem('profilePicture', userData.profile_picture);
                            if (userData.notifications_enabled !== undefined) localStorage.setItem('notificationsEnabled', JSON.stringify(userData.notifications_enabled));
                            if (userData.daily_intake) {
                              try {
                                const localIntake = (() => { try { return JSON.parse(localStorage.getItem('dailyIntake') || '{}') || {}; } catch { return {}; } })();
                                const merged = { 
                                  ...userData.daily_intake, 
                                  activity: Math.max(Number(userData.daily_intake?.activity || 0), Number(localIntake.activity || 0)),
                                  water: Math.max(Number(userData.daily_intake?.water || 0), Number(localIntake.water || 0))
                                };
                                localStorage.setItem('dailyIntake', JSON.stringify(merged));
                                console.log('‚úÖ Manual download: synced daily_intake (activity/water monotonic)');
                              } catch (_) {
                                const merged = { 
                                  ...userData.daily_intake, 
                                  activity: Number(userData.daily_intake?.activity || 0),
                                  water: Number(userData.daily_intake?.water || 0)
                                };
                                localStorage.setItem('dailyIntake', JSON.stringify(merged));
                                console.log('‚úÖ Manual download: synced daily_intake (remote values used)');
                              }
                            }
                            if (userData.recent_meals) {
                              const todayISO = toLocalISODate(new Date());
                              const todaysMeals = Array.isArray(userData.recent_meals) ? userData.recent_meals.filter(m => m && m.__day === todayISO) : [];
                              localStorage.setItem('recentMeals', JSON.stringify(todaysMeals));
                            }
                            if (userData.daily_history) {
                              try {
                                const localDH = JSON.parse(localStorage.getItem('dailyHistory') || '{}') || {};
                                const mergedDH = { ...userData.daily_history, ...localDH };
                                localStorage.setItem('dailyHistory', JSON.stringify(mergedDH));
                                console.log('‚úÖ Manual download: merged daily_history (prefer local)');
                              } catch (_) {
                                localStorage.setItem('dailyHistory', JSON.stringify(userData.daily_history));
                                console.log('‚úÖ Manual download: set daily_history from remote');
                              }
                            }
                            if (userData.coach_messages) localStorage.setItem('coachMessages', JSON.stringify(userData.coach_messages));
                            if (userData.habit_ai_advice) localStorage.setItem('habitAIAdvice', userData.habit_ai_advice);
                            if (userData.habits) localStorage.setItem('habits', JSON.stringify(userData.habits));
                            // Skip syncing dark_mode from remote - it's a local UI preference
                            if (userData.meal_plan) localStorage.setItem('mealPlan', JSON.stringify(userData.meal_plan));
                            if (userData.workout_plan) localStorage.setItem('workoutPlan', JSON.stringify(userData.workout_plan));
                            if (userData.scan_result) localStorage.setItem('scanResult', JSON.stringify(userData.scan_result));
                            if (userData.form_analysis) localStorage.setItem('formAnalysis', JSON.stringify(userData.form_analysis));
                            
                            // Trigger React state update
                            window.dispatchEvent(new CustomEvent('userDataSynced'));
                            
                            console.log('‚úÖ Manual download completed successfully!');
                            if (window.showToast) { showToast('‚úÖ Data downloaded successfully! Check if your data updated.', 'success'); } else { console.log('‚úÖ Data downloaded successfully! Check if your data updated.'); }
                          } else {
                            if (window.showToast) { showToast('‚ùå No data found in cloud.', 'info'); } else { console.log('‚ùå No data found in cloud.'); }
                          }
                        } catch (error) {
                          console.error('‚ùå Manual download failed:', error);
                          if (window.showToast) { showToast('‚ùå Download failed: ' + error.message, 'error'); } else { console.error('‚ùå Download failed: ' + error.message); }
                        }
                      }}
                      className="w-full text-left p-3 rounded-lg hover:bg-green-100 dark:hover:bg-green-900 text-green-700 dark:text-green-300 transition-colors flex items-center gap-2"
                    >
                      <span>üì•</span>
                      <span>Download Data from Cloud</span>
                    </button>
                  </div>
                </div>
              )}

              {/* Updated Notifications with toggle */}
              <div className="flex justify-between items-center p-3">
                <span className="text-gray-700 dark:text-gray-300">Notifications</span>
                <button 
                  onClick={toggleNotifications}
                  className={`relative w-14 h-7 rounded-full p-1 transition-colors duration-200 focus:outline-none ${
                    notificationsEnabled ? 'bg-green-500' : 'bg-gray-300'
                  }`}
                  title={notificationsEnabled ? 'Notifications ON' : 'Notifications OFF'}
                >
                  <div className={`w-5 h-5 bg-white rounded-full shadow-md transform transition-transform duration-200 ${
                    notificationsEnabled ? 'translate-x-7' : 'translate-x-0'
                  }`}></div>
                </button>
              </div>
              
              {/* Background Music toggle */}
              <div className="p-3">
                <div className="flex justify-between items-center">
                  <span className="text-gray-700 dark:text-gray-300">Background Music</span>
                  <button 
                    onClick={toggleBackgroundMusic}
                    className={`relative w-14 h-7 rounded-full p-1 transition-colors duration-200 focus:outline-none ${
                      backgroundMusicEnabled ? 'bg-pink-500' : 'bg-gray-300'
                    }`}
                    title={backgroundMusicEnabled ? 'Background Music ON' : 'Background Music OFF'}
                  >
                    <div className={`w-5 h-5 bg-white rounded-full shadow-md transform transition-transform duration-200 ${
                      backgroundMusicEnabled ? 'translate-x-7' : 'translate-x-0'
                    }`}></div>
                  </button>
                </div>
                {backgroundMusicEnabled && (
                  <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">
                    üì± On mobile: Tap anywhere to start music
                  </p>
                )}
              </div>
              
              <button 
                onClick={openPrivacyModal}
                className="w-full text-left p-3 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-300 transition-colors"
              >
                Privacy
              </button>
              
              {/* New Support Button (only visible when signed in) */}
              {user && (
                <button 
                  onClick={openSupportModal}
                  className="w-full text-left p-3 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-300 transition-colors"
                >
                  Support
                </button>
              )}
              
              {/* Theme toggle: defaults to dark; switch enables Light Mode */}
              <div className="flex justify-between items-center p-3">
                <span className="text-gray-700 dark:text-gray-300">Light Mode</span>
                <button 
                  onClick={toggleDarkMode} 
                  className={`relative w-14 h-7 rounded-full p-1 transition-colors duration-200 focus:outline-none ${
                    isDarkMode ? 'bg-gray-300' : 'bg-pink-500'
                  }`}
                >
                  <div className={`w-5 h-5 bg-white rounded-full shadow-md transform transition-transform duration-200 ${
                    isDarkMode ? 'translate-x-0' : 'translate-x-7'
                  }`}></div>
                </button>
              </div>
            </div>
          </div>

          {/* Privacy Modal */}
          {showPrivacyModal && (
            <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
              <div className="bg-white dark:bg-gray-800 rounded-2xl shadow-2xl max-w-md w-full max-h-[80vh] overflow-y-auto">
                {/* Modal Header */}
                <div className="flex justify-between items-center p-6 border-b border-gray-200 dark:border-gray-700">
                  <h2 className="text-2xl font-bold text-gray-800 dark:text-gray-200 flex items-center">
                    üîí Privacy Policy
                  </h2>
                  <button 
                    onClick={closePrivacyModal}
                    className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 text-2xl font-bold transition-colors"
                  >
                    √ó
                  </button>
                </div>
                
                {/* Modal Content */}
                <div className="p-6 space-y-4">
                  <div className="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-4">
                    <h3 className="font-semibold text-blue-800 dark:text-blue-200 mb-2 flex items-center">
                      üì± Local Storage & Minimal Cloud Sync
                    </h3>
                    <p className="text-blue-700 dark:text-blue-300 text-sm">
                      By default, your data is stored locally on your device. When you sign in, FitnessMate uses Supabase to securely sync a minimal set of data required for core functionality (for example: profile, goals, workout/activity history). We do not sell or share your data with third parties.
                    </p>
                  </div>
                  
                  <div className="space-y-3 text-gray-700 dark:text-gray-300">
                    <div>
                      <h4 className="font-semibold mb-1">üõ°Ô∏è Data Security</h4>
                      <p className="text-sm">
                        Your information remains on your device and, if signed in, in Supabase where it is transmitted over HTTPS and stored securely. Access is restricted to your account, and we only keep what is needed to make the app work.
                      </p>
                    </div>
                    
                    <div>
                      <h4 className="font-semibold mb-1">üîÑ Data Control</h4>
                      <p className="text-sm">
                        You control your data. Clearing your browser data removes local information. If signed in, you can stop sync by signing out, and you may request deletion of synced data associated with your account at any time.
                      </p>
                    </div>
                    
                    <div>
                      <h4 className="font-semibold mb-1">ü§ñ AI Interactions</h4>
                      <p className="text-sm">
                        AI coaching features may send anonymized queries to external services for responses, but no personal data is retained.
                      </p>
                    </div>
                    
                    <div>
                      <h4 className="font-semibold mb-1">üì∏ Image Processing</h4>
                      <p className="text-sm">
                        Food scanning and image analysis are processed temporarily and not stored permanently.
                      </p>
                    </div>
                  </div>
                  
                  <div className="bg-green-50 dark:bg-green-900/20 border border-green-200 dark:border-green-800 rounded-lg p-4">
                    <p className="text-green-800 dark:text-green-200 text-sm font-medium">
                      ‚úÖ Your privacy is our priority. This app is designed with privacy-first principles.
                    </p>
                  </div>

                  <div className="text-center pt-1">
                    <a href="/privacy.html" className="text-blue-600 dark:text-blue-400 hover:underline text-sm font-medium">
                      View full Privacy Policy / Terms of Service ‚Üí
                    </a>
                  </div>
                </div>
                
                {/* Modal Footer */}
                <div className="p-6 border-t border-gray-200 dark:border-gray-700">
                  <button 
                    onClick={closePrivacyModal}
                    className="w-full bg-gradient-to-r from-purple-500 to-pink-500 text-white py-3 px-4 rounded-xl font-semibold hover:from-purple-600 hover:to-pink-600 transition-all duration-200 shadow-lg"
                  >
                    Got it!
                  </button>
                </div>
              </div>
            </div>
          )}

          {/* Account Modal */}
          {showAccountModal && (
            <AccountModal 
              user={user}
              onClose={closeAccountModal}
              onSignOut={handleSignOut}
            />
          )}

          {/* Booking History Modal */}
          {showBookingHistory && (
            <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
              <div className="bg-white dark:bg-gray-800 rounded-2xl shadow-2xl max-w-2xl w-full max-h-[80vh] overflow-y-auto">
                {/* Modal Header */}
                <div className="flex justify-between items-center p-6 border-b border-gray-200 dark:border-gray-700">
                  <h2 className="text-2xl font-bold text-gray-800 dark:text-gray-200 flex items-center">
                    üìÖ Booking History
                  </h2>
                  <button 
                    onClick={toggleBookingHistory}
                    className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 text-2xl font-bold transition-colors"
                  >
                    √ó
                  </button>
                </div>
                
                {/* Modal Content */}
                <div className="p-6">
                  {isLoadingBookings ? (
                    <div className="text-center py-8">
                      <div className="animate-spin text-4xl mb-4">‚è≥</div>
                      <p className="text-gray-600 dark:text-gray-400">Loading your booking history...</p>
                    </div>
                  ) : bookingHistory.length === 0 ? (
                    <div className="text-center py-8">
                      <div className="text-6xl mb-4">üìÖ</div>
                      <h3 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-2">No Bookings Yet</h3>
                      <p className="text-gray-600 dark:text-gray-400 mb-4">
                        You haven't made any bookings yet. Book your first session to get started!
                      </p>
                      <button 
                         onClick={() => {
                           toggleBookingHistory();
                           openBookingModal();
                         }}
                         className="bg-gradient-to-r from-pink-500 to-purple-600 text-white py-2 px-6 rounded-xl font-semibold hover:from-pink-600 hover:to-purple-700 transition-all duration-200 shadow-lg"
                       >
                         Book Now
                       </button>
                    </div>
                  ) : (
                    <div className="space-y-4">
                      <div className="flex justify-between items-center mb-4">
                        <p className="text-gray-600 dark:text-gray-400">
                          Total bookings: <span className="font-semibold text-gray-800 dark:text-gray-200">{bookingHistory.length}</span>
                        </p>
                        <button 
                          onClick={fetchBookingHistory}
                          className="text-blue-600 dark:text-blue-400 hover:text-blue-700 dark:hover:text-blue-300 text-sm font-medium"
                        >
                          üîÑ Refresh
                        </button>
                      </div>
                      
                      {bookingHistory.map((booking) => (
                        <div key={booking.id} className="bg-gray-50 dark:bg-gray-700 rounded-xl p-4 border border-gray-200 dark:border-gray-600">
                          <div className="flex justify-between items-start mb-3">
                            <div>
                              <h4 className="font-semibold text-gray-800 dark:text-gray-200">
                                {booking.package || 'Session'}
                              </h4>
                              <p className="text-sm text-gray-600 dark:text-gray-400">
                                {booking.date} at {booking.time}
                              </p>
                            </div>
                            <div className="text-right">
                              <span className={`inline-block px-2 py-1 rounded-full text-xs font-medium ${
                                booking.type === 'free' 
                                  ? 'bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-200'
                                  : 'bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200'
                              }`}>
                                {booking.type === 'free' ? 'Free Trial' : `‚Ç¨${booking.price}`}
                              </span>
                            </div>
                          </div>
                          
                          <div className="grid grid-cols-2 gap-4 text-sm">
                            <div>
                              <span className="text-gray-500 dark:text-gray-400">Sessions:</span>
                              <span className="ml-2 font-medium text-gray-800 dark:text-gray-200">{booking.sessions || 1}</span>
                            </div>
                            <div>
                              <span className="text-gray-500 dark:text-gray-400">Status:</span>
                              <span className="ml-2 font-medium text-green-600 dark:text-green-400">{booking.status || 'Confirmed'}</span>
                            </div>
                          </div>
                          
                          {booking.createdAt && (
                            <div className="mt-2 text-xs text-gray-500 dark:text-gray-400">
                              Booked: {new Date(booking.createdAt).toLocaleDateString()} at {new Date(booking.createdAt).toLocaleTimeString()}
                            </div>
                          )}
                          
                          {(booking.meeting_link || booking.meetingLink) && (
                            <div className="mt-3">
                              <button 
                                onClick={() => {
                                  const meetingUrl = booking.meeting_link || booking.meetingLink;
                                  setCurrentMeetingLink(meetingUrl);
                                  setShowMeetingModal(true);
                                }}
                                className="inline-flex items-center gap-2 text-blue-600 dark:text-blue-400 hover:text-blue-700 dark:hover:text-blue-300 text-sm font-medium bg-transparent border-none cursor-pointer"
                              >
                                üé• Join Session
                              </button>
                            </div>
                          )}
                        </div>
                      ))}
                    </div>
                  )}
                </div>
              </div>
            </div>
          )}

          {/* Support Modal (only when signed in) */}
          {showSupportModal && user && (
            <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
              <div className="bg-white dark:bg-gray-800 rounded-2xl shadow-2xl max-w-md w-full max-h-[80vh] overflow-y-auto">
                {/* Modal Header */}
                <div className="flex justify-between items-center p-6 border-b border-gray-200 dark:border-gray-700">
                  <h2 className="text-2xl font-bold text-gray-800 dark:text-gray-200 flex items-center">
                    üéß Support
                  </h2>
                  <button 
                    onClick={closeSupportModal}
                    className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 text-2xl font-bold transition-colors"
                  >
                    √ó
                  </button>
                </div>
                
                {/* Modal Content */}
                <div className="p-6">
                  {supportSubmissionStatus === 'success' ? (
                    <div className="text-center space-y-4">
                      <div className="text-6xl">‚úÖ</div>
                      <h3 className="text-xl font-bold text-green-600 dark:text-green-400">Message Sent!</h3>
                      <p className="text-gray-600 dark:text-gray-400">
                        Thank you for contacting us. We'll get back to you within 24 hours.
                      </p>
                      <button 
                        onClick={closeSupportModal}
                        className="w-full bg-gradient-to-r from-green-500 to-green-600 text-white py-3 px-4 rounded-xl font-semibold hover:from-green-600 hover:to-green-700 transition-all duration-200 shadow-lg"
                      >
                        Close
                      </button>
                    </div>
                  ) : (
                    <form onSubmit={handleSupportSubmit} className="space-y-4">
                      {/* Hidden Netlify form field */}
                      <input type="hidden" name="form-name" value="support-form" />
                      
                      {/* Full Name */}
                      <div>
                        <label className="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-2">
                          Full Name *
                        </label>
                        <input
                          type="text"
                          name="full-name"
                          value={supportForm.fullName}
                          onChange={(e) => handleSupportFormChange('fullName', e.target.value)}
                          className="w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-xl focus:ring-2 focus:ring-pink-500 focus:border-transparent bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 transition-all"
                          placeholder="Enter your full name"
                          required
                        />
                      </div>
                      
                      {/* Email */}
                      <div>
                        <label className="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-2">
                          Email Address *
                        </label>
                        <input
                          type="email"
                          name="email"
                          value={supportForm.email}
                          onChange={(e) => handleSupportFormChange('email', e.target.value)}
                          className="w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-xl focus:ring-2 focus:ring-pink-500 focus:border-transparent bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 transition-all"
                          placeholder="Enter your email address"
                          required
                        />
                      </div>
                      
                      {/* Subject */}
                      <div>
                        <label className="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-2">
                          Subject *
                        </label>
                        <input
                          type="text"
                          name="subject"
                          value={supportForm.subject}
                          onChange={(e) => handleSupportFormChange('subject', e.target.value)}
                          className="w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-xl focus:ring-2 focus:ring-pink-500 focus:border-transparent bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 transition-all"
                          placeholder="Brief description of your issue"
                          required
                        />
                      </div>
                      
                      {/* Message */}
                      <div>
                        <label className="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-2">
                          Message *
                        </label>
                        <textarea
                          name="message"
                          value={supportForm.message}
                          onChange={(e) => handleSupportFormChange('message', e.target.value)}
                          rows={4}
                          className="w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-xl focus:ring-2 focus:ring-pink-500 focus:border-transparent bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 transition-all resize-none"
                          placeholder="Please describe your issue or question in detail..."
                          required
                        ></textarea>
                      </div>
                      
                      {supportSubmissionStatus === 'error' && (
                        <div className="bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg p-4">
                          <p className="text-red-800 dark:text-red-200 text-sm font-medium">
                            ‚ùå Failed to send message. Please try again or contact us directly.
                          </p>
                        </div>
                      )}
                      
                      {/* Submit Button */}
                      <button 
                        type="submit"
                        disabled={isSubmittingSupport}
                        className="w-full bg-gradient-to-r from-purple-500 to-pink-500 text-white py-3 px-4 rounded-xl font-semibold hover:from-purple-600 hover:to-pink-600 disabled:from-gray-400 disabled:to-gray-500 disabled:cursor-not-allowed transition-all duration-200 shadow-lg"
                      >
                        {isSubmittingSupport ? 'üì§ Sending...' : 'üì§ Send Message'}
                      </button>
                    </form>
                  )}
                </div>
              </div>
            </div>
          )}

          {/* Meeting Modal */}
          {showMeetingModal && (
            <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
              <div className="bg-white dark:bg-gray-800 rounded-2xl shadow-2xl max-w-6xl w-full max-h-[90vh] overflow-hidden">
                {/* Modal Header with FitnessMate Branding */}
                <div className="flex justify-between items-center p-4 border-b border-gray-200 dark:border-gray-700 bg-gradient-to-r from-purple-500 to-pink-500">
                  <div className="flex items-center space-x-3">
                    <div className="text-2xl">üí™</div>
                    <div>
                      <h2 className="text-xl font-bold text-white">FitnessMate Meeting</h2>
                      <p className="text-purple-100 text-sm">Your personal fitness session</p>
                    </div>
                  </div>
                  <button 
                    onClick={() => {
                      setShowMeetingModal(false);
                      setCurrentMeetingLink('');
                    }}
                    className="text-white hover:text-purple-200 text-2xl font-bold transition-colors bg-white bg-opacity-20 rounded-full w-8 h-8 flex items-center justify-center"
                  >
                    √ó
                  </button>
                </div>
                
                {/* Modal Content - Embedded Whereby Meeting */}
                <div className="relative h-[70vh]">
                  {currentMeetingLink && (
                    <iframe 
                      src={currentMeetingLink}
                      className="w-full h-full border-0"
                      title="FitnessMate Meeting Session"
                      allow="camera; microphone; fullscreen; display-capture; autoplay; clipboard-write"
                      allowFullScreen
                      sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-popups-to-escape-sandbox allow-presentation"
                      referrerPolicy="no-referrer-when-downgrade"
                    />
                  )}
                  

                </div>
                

              </div>
            </div>
          )}
        </div>
      );
    };



    // Reset Password Modal Component
    const ResetPasswordModal = ({ onClose }) => {
      const [password, setPassword] = React.useState('');
      const [confirm, setConfirm] = React.useState('');
      const [error, setError] = React.useState('');
      const [loading, setLoading] = React.useState(false);
      const [done, setDone] = React.useState(false);

      // Dynamic password rules status
      const rules = React.useMemo(() => {
        const length = password.length >= 8;
        const upper = /[A-Z]/.test(password);
        const lower = /[a-z]/.test(password);
        const number = /[0-9]/.test(password);
        const special = /[^A-Za-z0-9]/.test(password);
        return { length, upper, lower, number, special, valid: length && upper && lower && number && special };
      }, [password]);

      // Proactively verify we have a valid recovery session
      React.useEffect(() => {
        (async () => {
          try {
            const { data: { session } } = await auth.getSession();
            if (!session) {
              setError('Auth session missing! Please open the password reset link from your email again.');
            }
          } catch (_) {
            // ignore
          }
        })();
      }, []);

      const handleSubmit = async (e) => {
        e.preventDefault();
        setError('');
        if (!rules.valid) {
          setError('Password must include at least 8 characters, one uppercase letter, one lowercase letter, one number, and one special character.');
          return;
        }
        if (password !== confirm) {
          setError('Passwords do not match.');
          return;
        }
        setLoading(true);
        try {
          // Ensure we have a valid session from the recovery link
          const { data: { session } } = await auth.getSession();
          if (!session) throw new Error('Auth session missing! Please open the password reset link from your email again.');
          const { error } = await auth.updateUser({ password });
          if (error) throw error;
          setDone(true);
          setTimeout(onClose, 1500);
        } catch (err) {
          setError(err?.message || 'Failed to update password.');
        } finally {
          setLoading(false);
        }
      };

      return (
        <div className="fixed inset-0 bg-black/60 flex items-center justify-center z-50 p-4">
          <div className="bg-white dark:bg-gray-800 rounded-2xl shadow-2xl w-full max-w-md p-6">
            <div className="flex justify-between items-center mb-4">
              <h3 className="text-xl font-bold text-gray-800 dark:text-gray-200">Reset Password</h3>
              <button onClick={onClose} className="text-gray-500 hover:text-gray-800 dark:text-gray-400 dark:hover:text-gray-200 text-2xl font-bold">√ó</button>
            </div>

            {done ? (
              <div className="text-center">
                <div className="text-4xl mb-2">‚úÖ</div>
                <p className="text-gray-700 dark:text-gray-300">Password updated. You're signed in.</p>
              </div>
            ) : (
              <form onSubmit={handleSubmit} className="space-y-4">
                <div>
                  <label className="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-1">New password</label>
                  <input
                    type="password"
                    className="w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-xl bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200"
                    value={password}
                    onChange={(e) => setPassword(e.target.value)}
                    placeholder="At least 8 characters"
                    required
                  />
                </div>
                {/* Password rules prompt */}
                <div className="text-xs text-gray-600 dark:text-gray-400 -mt-1">
                  <p className="font-medium">Password must contain:</p>
                  <ul className="mt-1 space-y-0.5">
                    <li className={rules.length ? 'text-green-600' : ''}>{rules.length ? '‚úì' : '‚Ä¢'} At least 8 characters</li>
                    <li className={rules.upper ? 'text-green-600' : ''}>{rules.upper ? '‚úì' : '‚Ä¢'} One uppercase letter</li>
                    <li className={rules.lower ? 'text-green-600' : ''}>{rules.lower ? '‚úì' : '‚Ä¢'} One lowercase letter</li>
                    <li className={rules.number ? 'text-green-600' : ''}>{rules.number ? '‚úì' : '‚Ä¢'} One number</li>
                    <li className={rules.special ? 'text-green-600' : ''}>{rules.special ? '‚úì' : '‚Ä¢'} One special character</li>
                  </ul>
                </div>
                <div>
                  <label className="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-1">Confirm password</label>
                  <input
                    type="password"
                    className="w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-xl bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200"
                    value={confirm}
                    onChange={(e) => setConfirm(e.target.value)}
                    required
                  />
                </div>
                {error && (
                  <div className="bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg p-3 text-sm text-red-700 dark:text-red-300">
                    {error}
                  </div>
                )}
                <button
                  type="submit"
                  disabled={loading}
                  className="w-full bg-pink-500 hover:bg-pink-600 disabled:bg-gray-400 text-white font-semibold py-3 rounded-xl"
                >
                  {loading ? 'Updating...' : 'Update Password'}
                </button>
              </form>
            )}
          </div>
        </div>
      );
    };

    // Account Modal Component
    const AccountModal = ({ user, onClose, onSignOut }) => {
      const { signIn, signUp, authError, setAuthError, validatePassword, resetPassword } = useAuth();
      const [isSignUp, setIsSignUp] = useState(false);
      const [formData, setFormData] = useState({
        email: '',
        password: '',
        confirmPassword: '',
        displayName: ''
      });
      const [isLoading, setIsLoading] = useState(false);
      const [isDeleting, setIsDeleting] = useState(false);
      const [deleteError, setDeleteError] = useState('');
      const [showDeleteConfirm, setShowDeleteConfirm] = useState(false);
      const [typedDelete, setTypedDelete] = useState('');

      const handleInputChange = (field, value) => {
        setFormData(prev => ({ ...prev, [field]: value }));
        if (authError) setAuthError(null);
      };

      const handleSubmit = async (e) => {
        e.preventDefault();
        setIsLoading(true);

        try {
          if (isSignUp) {
            if (formData.password !== formData.confirmPassword) {
              throw new Error('Passwords do not match');
            }
            if (formData.password.length < 6) {
              throw new Error('Password must be at least 6 characters');
            }
            await signUp(formData.email, formData.password, formData.displayName);
            if (window.showToast) { showToast('‚úÖ Account created successfully! Confirm your email', 'success'); } else { console.log('‚úÖ Account created successfully! Confirm your email'); }
          } else {
            await signIn(formData.email, formData.password);
            if (window.showToast) { showToast('‚úÖ Successfully signed in!', 'success'); } else { console.log('‚úÖ Successfully signed in!'); }
          }
          onClose();
        } catch (error) {
          console.error('Auth error:', error);
        } finally {
          setIsLoading(false);
        }
      };

      if (user) {
        // Authenticated user view
        return (
          <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
            <div className="bg-white dark:bg-gray-800 rounded-2xl shadow-2xl max-w-md w-full">
              {/* Modal Header */}
              <div className="flex justify-between items-center p-6 border-b border-gray-200 dark:border-gray-700">
                <h2 className="text-2xl font-bold text-gray-800 dark:text-gray-200 flex items-center">
                  üë§ Account
                </h2>
                <button 
                  onClick={onClose}
                  className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 text-2xl font-bold transition-colors"
                >
                  √ó
                </button>
              </div>
              
              {/* User Info */}
              <div className="p-6 space-y-4">
                <div className="text-center">
                  <div className="w-20 h-20 bg-gradient-to-r from-pink-500 to-purple-600 rounded-full flex items-center justify-center text-white text-2xl font-bold mx-auto mb-4">
                    {user.user_metadata?.display_name ? user.user_metadata.display_name.charAt(0).toUpperCase() : user.email.charAt(0).toUpperCase()}
                  </div>
                  <h3 className="text-xl font-semibold text-gray-800 dark:text-gray-200">
                    {user.user_metadata?.display_name || 'User'}
                  </h3>
                  <p className="text-gray-600 dark:text-gray-400">{user.email}</p>
                </div>
                
                <div className="bg-green-50 dark:bg-green-900/20 border border-green-200 dark:border-green-800 rounded-lg p-4">
                  <p className="text-green-800 dark:text-green-200 text-sm font-medium flex items-center">
                    ‚úÖ Account verified
                  </p>
                </div>
                
                <div className="space-y-2 text-sm text-gray-600 dark:text-gray-400">
                  <p><strong>Account created:</strong> {user.created_at ? new Date(user.created_at).toLocaleDateString() : 'Unknown'}</p>
                  <p><strong>Last sign in:</strong> {user.last_sign_in_at ? new Date(user.last_sign_in_at).toLocaleDateString() : 'Unknown'}</p>
                </div>
                
                <button 
                  onClick={onSignOut}
                  className="w-full bg-red-500 hover:bg-red-600 text-white py-3 px-4 rounded-xl font-semibold transition-colors"
                >
                  Sign Out
                </button>

                {/* Delete Account */}
                <div className="pt-2">
                  <button
                    onClick={() => { if (!user || isDeleting) return; setDeleteError(''); setTypedDelete(''); setShowDeleteConfirm(true); }}
                    className={`w-full ${isDeleting ? 'bg-gray-400' : 'bg-gray-800 hover:bg-gray-900'} text-white py-3 px-4 rounded-xl font-semibold transition-colors`}
                    disabled={isDeleting}
                  >
                    {isDeleting ? 'Deleting‚Ä¶' : 'Delete My Account'}
                  </button>
                  {deleteError && (
                    <p className="mt-2 text-sm text-red-500">{deleteError}</p>
                  )}

                  {/* Branded Confirm Modal (replaces browser confirm/prompt) */}
                  {showDeleteConfirm && (
                    <div className="fixed inset-0 z-[60] bg-black/60 flex items-center justify-center p-4">
                      <div className="w-full max-w-md bg-white dark:bg-gray-800 rounded-2xl shadow-2xl overflow-hidden">
                        <div className="bg-gradient-to-r from-pink-500 to-purple-600 px-6 py-4">
                          <h3 className="text-white text-lg font-semibold">Delete Account</h3>
                        </div>
                        <div className="p-6 space-y-4">
                          <p className="text-gray-700 dark:text-gray-300">
                            This will permanently delete your account and all synced data.
                          </p>
                          <div>
                            <label className="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-2">Type DELETE to confirm</label>
                            <input
                              autoFocus
                              type="text"
                              value={typedDelete}
                              onChange={(e)=>setTypedDelete(e.target.value)}
                              className="w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-xl focus:ring-2 focus:ring-pink-500 focus:border-transparent bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200"
                              placeholder="DELETE"
                            />
                          </div>
                          <div className="flex items-center justify-end gap-3 pt-2">
                            <button
                              onClick={()=>{ setShowDeleteConfirm(false); setTypedDelete(''); }}
                              className="px-4 py-2 rounded-xl bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200 hover:bg-gray-300 dark:hover:bg-gray-600"
                            >
                              Cancel
                            </button>
                            <button
                              onClick={async ()=>{
                                if (typedDelete.toUpperCase() !== 'DELETE' || isDeleting) return;
                                setIsDeleting(true);
                                try {
                                  // Ensure we have the current session and user id
                                  let uid = user.id;
                                  let token = '';
                                  try {
                                    const { data: { session } } = await auth.getSession();
                                    uid = session?.user?.id || uid;
                                    token = session?.access_token || '';
                                  } catch (_) {}

                                  // Invoke secure delete Edge Function (preferred path)
                                  let edgeOk = false;
                                  try {
                                    if (supabase && supabase.functions) {
                                      const { data, error } = await supabase.functions.invoke('delete-account', {
                                        headers: token ? { Authorization: `Bearer ${token}` } : undefined,
                                        body: { user_id: uid }
                                      });
                                      edgeOk = !!(data && (data.ok === true));
                                      if (error) throw error;
                                    }
                                  } catch (e) {
                                    // If SDK invocation fails, try direct fetch to the provided endpoint
                                    try {
                                      if (supabaseConfig && supabaseConfig.url) {
                                        const res = await fetch(`${supabaseConfig.url}/functions/v1/delete-account`, {
                                          method: 'POST',
                                          headers: {
                                            ...(token ? { Authorization: `Bearer ${token}` } : {}),
                                            'Content-Type': 'application/json',
                                            apikey: supabaseConfig.anonKey
                                          },
                                          body: JSON.stringify({ user_id: uid })
                                        });
                                        if (res.ok) {
                                          const json = await res.json().catch(() => ({}));
                                          edgeOk = !!json?.ok || res.status === 200;
                                        }
                                      }
                                    } catch (_) {}
                                    console.warn('Edge delete-account invocation failed; falling back to client cleanup:', e);
                                  }

                                  // Best-effort client-side data cleanup (guarded by RLS; harmless if denied)
                                  try { await supabase.from('workout_history').delete().eq('user_id', uid); } catch (_) {}
                                  try { await supabase.from('bookings').delete().eq('user_id', uid); } catch (_) {}
                                  try { await supabase.from('users').delete().eq('id', uid); } catch (_) {}

                                  // Sign the user out and redirect
                                  try { await auth.signOut({ scope: 'local' }); } catch (_) {}
                                  try { localStorage.setItem('subscriptionActive', JSON.stringify(false)); } catch (_) {}
                                  try { window.dispatchEvent(new CustomEvent('subscription-status-changed', { detail: { active: false } })); } catch (_) {}
                                  
                                  // Show success notification before redirect
                                  try { 
                                    window.fmToast('Account Deleted', { type: 'success', duration: 2500 }); 
                                  } catch (_) {}
                                  
                                  // Delay redirect slightly to show the toast
                                  setTimeout(() => {
                                    window.location.assign('/');
                                  }, 1500);
                                } catch (err) {
                                  console.error('Delete account failed:', err);
                                  setDeleteError(err?.message || 'Failed to delete account');
                                } finally {
                                  setIsDeleting(false);
                                  setShowDeleteConfirm(false);
                                  setTypedDelete('');
                                }
                              }}
                              className={`px-4 py-2 rounded-xl ${typedDelete.toUpperCase()==='DELETE' && !isDeleting ? 'bg-red-600 hover:bg-red-700 text-white' : 'bg-gray-300 dark:bg-gray-600 text-gray-600 dark:text-gray-300 cursor-not-allowed'}`}
                              disabled={typedDelete.toUpperCase()!=='DELETE' || isDeleting}
                            >
                              {isDeleting ? 'Deleting‚Ä¶' : 'Confirm Deletion'}
                            </button>
                          </div>
                        </div>
                      </div>
                    </div>
                  )}
                </div>
              </div>
            </div>
          </div>
        );
      }

      // Sign in/up form
      return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
          <div className="bg-white dark:bg-gray-800 rounded-2xl shadow-2xl max-w-md w-full">
            {/* Modal Header */}
            <div className="flex justify-between items-center p-6 border-b border-gray-200 dark:border-gray-700">
              <h2 className="text-2xl font-bold text-gray-800 dark:text-gray-200 flex items-center">
                üîê {isSignUp ? 'Create Account' : 'Sign In'}
              </h2>
              <button 
                onClick={onClose}
                className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 text-2xl font-bold transition-colors"
              >
                √ó
              </button>
            </div>
            
            {/* Form */}
            <form onSubmit={handleSubmit} className="p-6 space-y-4">
              {isSignUp && (
                <div>
                  <label className="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-2">
                    Full Name
                  </label>
                  <input
                    type="text"
                    value={formData.displayName}
                    onChange={(e) => handleInputChange('displayName', e.target.value)}
                    className="w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-xl focus:ring-2 focus:ring-pink-500 focus:border-transparent bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 transition-all"
                    placeholder="Enter your full name"
                    required
                  />
                </div>
              )}
              
              <div>
                <label className="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-2">
                  Email Address
                </label>
                <input
                  type="email"
                  value={formData.email}
                  onChange={(e) => handleInputChange('email', e.target.value)}
                  className="w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-xl focus:ring-2 focus:ring-pink-500 focus:border-transparent bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 transition-all"
                  placeholder="Enter your email"
                  required
                />
              </div>
              
              <div>
                <label className="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-2">
                  Password
                </label>
                <input
                  type="password"
                  value={formData.password}
                  onChange={(e) => handleInputChange('password', e.target.value)}
                  className="w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-xl focus:ring-2 focus:ring-pink-500 focus:border-transparent bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 transition-all"
                  placeholder="Enter your password"
                  required
                />
                {isSignUp && formData.password && (
                  <div className="mt-2 text-xs space-y-1">
                    {(() => {
                      const validation = validatePassword(formData.password);
                      return (
                        <div className="space-y-1">
                          <div className={`flex items-center ${formData.password.length >= 8 ? 'text-green-600' : 'text-red-500'}`}>
                            <span className="mr-1">{formData.password.length >= 8 ? '‚úì' : '‚úó'}</span>
                            At least 8 characters
                          </div>
                          <div className={`flex items-center ${/[A-Z]/.test(formData.password) ? 'text-green-600' : 'text-red-500'}`}>
                            <span className="mr-1">{/[A-Z]/.test(formData.password) ? '‚úì' : '‚úó'}</span>
                            One uppercase letter
                          </div>
                          <div className={`flex items-center ${/[a-z]/.test(formData.password) ? 'text-green-600' : 'text-red-500'}`}>
                            <span className="mr-1">{/[a-z]/.test(formData.password) ? '‚úì' : '‚úó'}</span>
                            One lowercase letter
                          </div>
                          <div className={`flex items-center ${/[0-9]/.test(formData.password) ? 'text-green-600' : 'text-red-500'}`}>
                            <span className="mr-1">{/[0-9]/.test(formData.password) ? '‚úì' : '‚úó'}</span>
                            One number
                          </div>
                          <div className={`flex items-center ${/[!@#$%^&*(),.?":{}|<>]/.test(formData.password) ? 'text-green-600' : 'text-red-500'}`}>
                            <span className="mr-1">{/[!@#$%^&*(),.?":{}|<>]/.test(formData.password) ? '‚úì' : '‚úó'}</span>
                            One special character
                          </div>
                        </div>
                      );
                    })()
                    }
                  </div>
                )}
              </div>
              
              {isSignUp && (
                <div>
                  <label className="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-2">
                    Confirm Password
                  </label>
                  <input
                    type="password"
                    value={formData.confirmPassword}
                    onChange={(e) => handleInputChange('confirmPassword', e.target.value)}
                    className={`w-full px-4 py-3 border rounded-xl focus:ring-2 focus:ring-pink-500 focus:border-transparent bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 transition-all ${
                      formData.confirmPassword && formData.password !== formData.confirmPassword 
                        ? 'border-red-500 dark:border-red-500' 
                        : 'border-gray-300 dark:border-gray-600'
                    }`}
                    placeholder="Confirm your password"
                    required
                  />
                  {formData.confirmPassword && formData.password !== formData.confirmPassword && (
                    <div className="mt-2 text-xs text-red-500 flex items-center">
                      <span className="mr-1">‚úó</span>
                      Passwords do not match
                    </div>
                  )}
                  {formData.confirmPassword && formData.password === formData.confirmPassword && formData.confirmPassword.length > 0 && (
                    <div className="mt-2 text-xs text-green-600 flex items-center">
                      <span className="mr-1">‚úì</span>
                      Passwords match
                    </div>
                  )}
                </div>
              )}
              
              {authError && (
                <div className="bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg p-4">
                  <p className="text-red-800 dark:text-red-200 text-sm font-medium">
                    ‚ùå {authError}
                  </p>
                </div>
              )}
              
              <button 
                type="submit"
                disabled={isLoading}
                className="w-full bg-gradient-to-r from-pink-500 to-purple-600 text-white py-3 px-4 rounded-xl font-semibold hover:from-pink-600 hover:to-purple-700 transition-all duration-200 shadow-lg disabled:opacity-50 disabled:cursor-not-allowed"
              >
                {isLoading ? '‚è≥ Processing...' : (isSignUp ? 'Create Account' : 'Sign In')}
              </button>
              
              {!isSignUp && (
                <div className="text-center">
                  <button 
                    type="button"
                    onClick={async () => {
                      if (!formData.email) {
                        setAuthError('Please enter your email address first.');
                        return;
                      }
                      try {
                        await resetPassword(formData.email);
                        setAuthError('');
                    if (window.showToast) { showToast('Reset email sent! It may take a minute or two to appear in your inbox. Check spam too', 'success'); } else { console.log('Reset email sent! It may take a minute or two to appear in your inbox. Check spam too'); }
                      } catch (error) {
                        // Error is already handled in resetPassword function
                      }
                    }}
                    className="text-sm text-gray-600 dark:text-gray-400 hover:text-pink-500 transition-colors"
                  >
                    Forgot your password?
                  </button>
                </div>
              )}
              
              <div className="text-center">
                <button 
                  type="button"
                  onClick={() => setIsSignUp(!isSignUp)}
                  className="text-pink-500 hover:text-pink-600 font-medium transition-colors"
                >
                  {isSignUp ? 'Already have an account? Sign In' : 'Need an account? Sign Up'}
                </button>
              </div>
              
              <div className="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-4">
                <p className="text-blue-800 dark:text-blue-200 text-sm">
                  üí° <strong>Benefits of creating an account:</strong><br/>
                  ‚Ä¢ Sync data across all devices<br/>
                  ‚Ä¢ Never lose your progress<br/>
                  ‚Ä¢ Access from any browser
                </p>
              </div>
            </form>
          </div>
        </div>
      );
    };

    // Scan Screen Component with OpenRouter (Qwen VL) Integration
    const Scan = ({ onLogMeal }) => {
      const [isLoading, setIsLoading] = useState(false);
      const [scanResult, setScanResult] = useState(() => {
        try {
          const saved = localStorage.getItem('foodScanner_scanResult');
          return saved ? JSON.parse(saved) : null;
        } catch {
          return null;
        }
      });
      const [error, setError] = useState(null);
      const [imagePreview, setImagePreview] = useState(() => {
        try {
          return localStorage.getItem('foodScanner_imagePreview') || null;
        } catch {
          return null;
        }
      });
      const [selectedMood, setSelectedMood] = useState(() => {
        try {
          return localStorage.getItem('foodScanner_selectedMood') || null;
        } catch {
          return null;
        }
      });
      const [portionSize, setPortionSize] = useState(() => {
        try {
          return localStorage.getItem('foodScanner_portionSize') || '';
        } catch {
          return '';
        }
      });
      const [portionUnit, setPortionUnit] = useState(() => {
        try {
          return localStorage.getItem('foodScanner_portionUnit') || 'grams';
        } catch {
          return 'grams';
        }
      });
      const fileInputRef = useRef(null);

      const fileToBase64 = (file) => new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = () => resolve(reader.result.split(',')[1]);
        reader.onerror = error => reject(error);
      });


      const handleImageChange = (event) => {
        const file = event.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = async (e) => {
            const dataUrl = e.target.result;
            setImagePreview(dataUrl);
            
            // Store compressed image in localStorage like Menu Decoder does
            try {
              const compress = (dataUrl) => new Promise(resolve => {
                try {
                  const img = new Image();
                  img.onload = () => {
                    try {
                      const canvas = document.createElement('canvas');
                      const ctx = canvas.getContext('2d');
                      const maxWidth = 800;
                      const maxHeight = 600;
                      let { width, height } = img;
                      if (width > height) {
                        if (width > maxWidth) { height *= maxWidth / width; width = maxWidth; }
                      } else {
                        if (height > maxHeight) { width *= maxHeight / height; height = maxHeight; }
                      }
                      canvas.width = width; canvas.height = height;
                      ctx.drawImage(img, 0, 0, width, height);
                      resolve(canvas.toDataURL('image/jpeg', 0.6));
                    } catch (e) { resolve(dataUrl); }
                  };
                  img.onerror = () => resolve(dataUrl);
                  img.src = dataUrl;
                } catch (e) { resolve(dataUrl); }
              });
              const compressedImage = await compress(dataUrl);
              localStorage.setItem('foodScanner_imagePreview', compressedImage);
            } catch (error) {
              console.warn('Failed to store compressed image:', error);
            }
          };
          reader.readAsDataURL(file);
          setScanResult(null);
          setError(null);
          setSelectedMood(null);
          handleScan(file);
        }
      };

      const handleScan = async (file) => {
        setIsLoading(true);
        setError(null);
        try {
          const base64ImageData = await fileToBase64(file);
          const dataUrl = `data:${file.type};base64,${base64ImageData}`;
          // Prefer compressed preview for upload to reduce size
          const previewDataUrl = (() => { try { return localStorage.getItem('foodScanner_imagePreview'); } catch { return null; } })();
          const uploadDataUrl = previewDataUrl || dataUrl;
          const uploadedUrl = await uploadImageDataUrlToPublic(uploadDataUrl, file.type);
          const imageUrlToSend = uploadedUrl || dataUrl;
          
          // Build the prompt with portion information if provided
          let prompt = `Analyze the food in this image.
1. Identify the main dish.
2. Break it down into primary ingredients and estimate calories for each.
3. Provide a total nutritional summary (calories, protein, carbs, fat).`;

          // Add portion size information to the prompt if provided
          if (portionSize && portionSize.trim() !== '') {
            prompt += `
4. IMPORTANT: The user has specified that this portion weighs ${portionSize} ${portionUnit}. Please adjust ALL nutritional values (calories, protein, carbs, fat) based on this specific portion size.`;
          }

          prompt += `
5. Offer a single, actionable, and encouraging "health_tip" to make this meal healthier next time.
Respond ONLY with a valid JSON object in this format:
{
  "name": "Overall Dish Name",
  "total_calories": 550,
  "total_protein": 30.5,
  "total_carbs": 45.2,
  "total_fat": 25.8,
  "ingredients": [
    {"name": "Ingredient 1", "calories": 200},
    {"name": "Ingredient 2", "calories": 150}
  ],
  "health_tip": "A short, encouraging tip to improve the meal."
}`;

          const payload = {
            model: OPENROUTER_QWEN_VL_MODEL,
            messages: [
              {
                role: 'user',
                content: [
                  { type: 'text', text: prompt },
                  { type: 'image_url', image_url: imageUrlToSend }
                ]
              }
            ]
          };

          const response = await fetch(getDirectGeminiConfig().url, {
            method: 'POST',
            headers: getDirectGeminiConfig().headers,
            body: JSON.stringify(payload)
          });

          if (!response.ok) {
            throw new Error(`API Error: ${response.status} ${response.statusText}`);
          }

          const result = await response.json();
          const textResponse = (result.choices?.[0]?.message?.content || '');
          const jsonString = textResponse.replace(/```json|```/g, '').trim();
          const data = JSON.parse(jsonString);
          data.image = imageUrlToSend;
          setScanResult(data);
          
          // Save to localStorage for persistence
          try {
            localStorage.setItem('foodScanner_scanResult', JSON.stringify(data));
            // imagePreview is already saved in handleImageChange
            if (portionSize) localStorage.setItem('foodScanner_portionSize', portionSize);
            if (portionUnit) localStorage.setItem('foodScanner_portionUnit', portionUnit);
          } catch (err) {
            console.warn('Failed to save scan result to localStorage:', err);
          }
        } catch (err) {
          console.error("OpenRouter API call failed:", err);
          setError('Couldn‚Äôt analyze the image or prompt limit reached. Try again, or sign in, or subscribe to continue.');
        } finally {
          setIsLoading(false);
        }
      };

      const resetScan = () => {
        setImagePreview(null);
        setScanResult(null);
        setError(null);
        setSelectedMood(null);
        setPortionSize('');
        setPortionUnit('grams');
        
        // Clear localStorage when resetting
        try {
          localStorage.removeItem('foodScanner_scanResult');
          localStorage.removeItem('foodScanner_imagePreview');
          localStorage.removeItem('foodScanner_selectedMood');
          localStorage.removeItem('foodScanner_portionSize');
          localStorage.removeItem('foodScanner_portionUnit');
        } catch (err) {
          console.warn('Failed to clear localStorage:', err);
        }
        
        if (fileInputRef.current) {
          fileInputRef.current.value = '';
        }
        console.log('Scan reset');
      };



      return (
        <div className="p-6 pb-24 flex flex-col items-center">
          <header className="mb-6 text-center">
            <h1 className="text-3xl font-bold text-gray-800 dark:text-gray-200">AI Food Scanner</h1>
            <p className="text-gray-500 dark:text-gray-400">Get instant nutritional info and health tips</p>
          </header>

          <div className="w-full max-w-md mx-auto">
            {/* Portion Input Section */}
            <div className="bg-white dark:bg-gray-800 p-4 rounded-2xl shadow-md mb-4">
              <h3 className="text-lg font-semibold text-gray-800 dark:text-gray-200 mb-3 text-center">Portion Size (Optional)</h3>
              <div className="flex items-center gap-2 sm:gap-3 w-full">
                <input
                  type="number"
                  placeholder="Enter quantity"
                  value={portionSize}
                  onChange={(e) => {
                    setPortionSize(e.target.value);
                    try {
                      localStorage.setItem('foodScanner_portionSize', e.target.value);
                    } catch (err) {
                      console.warn('Failed to save portion size to localStorage:', err);
                    }
                  }}
                  className="flex-1 min-w-0 p-3 border border-gray-300 dark:border-gray-600 rounded-xl bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 focus:outline-none focus:ring-2 focus:ring-purple-500"
                />
                <div className="flex bg-gray-100 dark:bg-gray-700 rounded-xl p-1 flex-shrink-0 whitespace-nowrap">
                  <button
                    onClick={() => {
                      setPortionUnit('grams');
                      try {
                        localStorage.setItem('foodScanner_portionUnit', 'grams');
                      } catch (err) {
                        console.warn('Failed to save portion unit to localStorage:', err);
                      }
                    }}
                    className={`px-2 sm:px-3 py-2 rounded-lg text-xs sm:text-sm font-medium transition-colors ${
                      portionUnit === 'grams' 
                        ? 'bg-purple-500 text-white' 
                        : 'text-gray-600 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-600'
                    }`}
                  >
                    g
                  </button>
                  <button
                    onClick={() => {
                      setPortionUnit('ml');
                      try {
                        localStorage.setItem('foodScanner_portionUnit', 'ml');
                      } catch (err) {
                        console.warn('Failed to save portion unit to localStorage:', err);
                      }
                    }}
                    className={`px-2 sm:px-3 py-2 rounded-lg text-xs sm:text-sm font-medium transition-colors ${
                      portionUnit === 'ml' 
                        ? 'bg-purple-500 text-white' 
                        : 'text-gray-600 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-600'
                    }`}
                  >
                    ml
                  </button>
                </div>
              </div>
              <p className="text-xs text-gray-500 dark:text-gray-400 mt-2 text-center">
                Add portion size for more accurate nutritional values
              </p>
            </div>

            {!imagePreview && (
              <div className="bg-white dark:bg-gray-800 p-8 rounded-2xl shadow-md text-center">
                <div className="mb-6">
                  <div className="w-24 h-24 mx-auto mb-4 bg-gradient-to-br from-purple-400 to-pink-500 rounded-full flex items-center justify-center">
                    <span className="text-4xl">üì∑</span>
                  </div>
                  <h3 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-2">Scan Your Food</h3>
                  <p className="text-gray-600 dark:text-gray-400 mb-6">Take a photo of your meal and get instant nutritional analysis with personalized health tips!</p>
                </div>
                
                <button
                  onClick={() => fileInputRef.current.click()}
                  className="w-full bg-gradient-to-r from-purple-500 to-pink-500 text-white font-bold py-4 rounded-2xl shadow-lg hover:from-purple-600 hover:to-pink-600 transition-all transform hover:scale-105"
                >
                  üì∑ Scan Your Meal
                </button>
                
                <div className="mt-6 p-4 bg-purple-50 dark:bg-purple-900/20 rounded-xl">
                  <h4 className="font-semibold text-purple-800 dark:text-purple-200 mb-2">üí° Pro Tips:</h4>
                  <ul className="text-sm text-purple-700 dark:text-purple-300 space-y-1">
                    <li>‚Ä¢ Ensure good lighting for best results</li>
                    <li>‚Ä¢ Include labels and packaging when visible</li>
                    <li>‚Ä¢ Multiple ingredients in one photo work great!</li>
                  </ul>
                </div>
              </div>
            )}

            {imagePreview && !scanResult && (
              <div className="bg-white dark:bg-gray-800 rounded-2xl shadow-md overflow-hidden">
                <img src={imagePreview} alt="Meal preview" className="w-full h-64 object-cover" />
                
                {!isLoading && (
                  <div className="p-6">
                    <div className="mb-4 p-4 bg-purple-50 dark:bg-purple-900/20 rounded-xl">
                      <h4 className="font-semibold text-purple-800 dark:text-purple-200 mb-2">üí° Pro Tips:</h4>
                      <ul className="text-sm text-purple-700 dark:text-purple-300 space-y-1">
                        <li>‚Ä¢ Ensure good lighting for best results</li>
                        <li>‚Ä¢ Include labels and packaging when visible</li>
                        <li>‚Ä¢ Multiple ingredients in one photo work great!</li>
                      </ul>
                    </div>
                    
                    <p className="text-gray-600 dark:text-gray-400 mb-4 text-center">Image loaded. Ready to analyze.</p>
                    <div className="flex gap-3 justify-center">
                      <button 
                        onClick={() => {
                          const storedImage = localStorage.getItem('foodScanner_imagePreview');
                          if (storedImage) {
                            fetch(storedImage)
                              .then(res => res.blob())
                              .then(blob => {
                                const file = new File([blob], 'image.jpg', { type: 'image/jpeg' });
                                handleScan(file);
                              })
                              .catch(err => {
                                console.error('Failed to analyze:', err);
                                setError('Could not analyze the image. Please try scanning again.');
                              });
                          }
                        }}
                        className="bg-purple-500 hover:bg-purple-600 text-white px-6 py-3 rounded-xl font-semibold transition-colors"
                      >
                        Analyse
                      </button>
                      <button 
                        onClick={resetScan}
                        className="bg-gray-500 hover:bg-gray-600 text-white px-6 py-3 rounded-xl font-semibold transition-colors"
                      >
                        Scan New
                      </button>
                    </div>
                  </div>
                )}
                
                {isLoading && (
                  <div className="p-6 text-center">
                    <div className="animate-spin w-8 h-8 border-4 border-purple-500 border-t-transparent rounded-full mx-auto mb-4"></div>
                    <p className="text-gray-600 dark:text-gray-400">Analyzing your meal...</p>
                  </div>
                )}
              </div>
            )}
            
            <input
              type="file"
              accept="image/*"
              capture="environment"
              ref={fileInputRef}
              onChange={handleImageChange}
              className="hidden"
            />

            {error && <div className="my-4 text-center text-red-500 bg-red-100 p-3 rounded-lg">{error}</div>}

            {scanResult && (
              <div className="mt-6 bg-white dark:bg-gray-800 p-6 rounded-2xl shadow-md animate-fade-in">
                <div className="flex justify-between items-center mb-4">
                  <div>
                    <h2 className="text-2xl font-bold text-gray-800 dark:text-gray-200">{scanResult.name}</h2>
                    <p className="text-lg font-semibold text-gray-600 dark:text-gray-300">{scanResult.total_calories} kcal</p>
                  </div>
                  <button
                    onClick={resetScan}
                    className="text-purple-500 font-semibold text-sm hover:text-purple-600 transition-colors"
                  >
                    ‚Üê Scan New
                  </button>
                </div>

                {scanResult.health_tip && (
                  <div className="mb-4 p-4 bg-yellow-100 text-yellow-800 rounded-lg flex items-start">
                    <span className="text-2xl mr-3">üí°</span>
                    <div>
                      <h3 className="font-bold">Plate Perfecter Tip</h3>
                      <p>{scanResult.health_tip}</p>
                    </div>
                  </div>
                )}

                {/* Mindful Journal Section */}
                <div className="my-4">
                  <h3 className="font-bold text-gray-700 dark:text-gray-300 mb-2 text-center">How do you feel after this meal?</h3>
                  <div className="flex justify-around">
                    {['Energized', 'Happy', 'Sluggish', 'Bloated'].map(mood => (
                      <button
                        key={mood}
                        onClick={() => {
                          setSelectedMood(mood);
                          try {
                            localStorage.setItem('foodScanner_selectedMood', mood);
                          } catch (err) {
                            console.warn('Failed to save mood to localStorage:', err);
                          }
                        }}
                        className={`p-2 rounded-lg border-2 ${selectedMood === mood ? 'border-pink-500' : 'border-transparent'}`}
                      >
                        <span className="text-3xl">{{ Energized: '‚ö°Ô∏è', Happy: 'üòä', Sluggish: 'üò¥', Bloated: 'ü§¢' }[mood]}</span>
                      </button>
                    ))}
                  </div>
                </div>

                <div className="space-y-3 mb-4 text-gray-800 dark:text-gray-200">
                  <h3 className="font-bold text-gray-700 dark:text-gray-300">Nutritional Summary:</h3>
                  <p><strong>Protein:</strong> {scanResult.total_protein} g</p>
                  <p><strong>Carbs:</strong> {scanResult.total_carbs} g</p>
                  <p><strong>Fat:</strong> {scanResult.total_fat} g</p>
                </div>

                {scanResult.ingredients && scanResult.ingredients.length > 0 && (
                  <div className="space-y-3 mb-4 text-gray-800 dark:text-gray-200">
                    <h3 className="font-bold text-gray-700 dark:text-gray-300">Ingredient Breakdown:</h3>
                    {scanResult.ingredients.map((item, index) => (
                      <div key={index} className="flex justify-between">
                        <span>{item.name}</span>
                        <span>{item.calories} kcal</span>
                      </div>
                    ))}
                  </div>
                )}

                <button
                  onClick={() => onLogMeal({
                    ...scanResult,
                    calories: scanResult.total_calories,
                    protein: scanResult.total_protein,
                    carbs: scanResult.total_carbs,
                    fat: scanResult.total_fat,
                    image: scanResult.image,
                    mood: selectedMood
                  })}
                  className="w-full mt-4 bg-green-500 text-white font-bold py-3 rounded-xl hover:bg-green-600 transition-colors"
                >
                  Log this Meal
                </button>
              </div>
            )}
          </div>
        </div>
      );

    };

    // Menu Decoder Component
    const MenuDecoder = ({ goals, menuState, setMenuState }) => {
      const { imagePreview, isLoading, menuItems, recommendations, error, userGoals } = menuState;
      
      const setIsLoading = (value) => setMenuState(prev => ({ ...prev, isLoading: value }));
      const setImagePreview = (value) => {
        setMenuState(prev => ({ ...prev, imagePreview: value }));
        // Do not store raw image here; compressed version will be stored after processing
      };
      const setMenuItems = (value) => {
        setMenuState(prev => ({ ...prev, menuItems: value }));
        localStorage.setItem('menuDecoder_menuItems', JSON.stringify(value));
      };
      const setRecommendations = (value) => {
        setMenuState(prev => ({ ...prev, recommendations: value }));
        localStorage.setItem('menuDecoder_recommendations', JSON.stringify(value));
      };
      const setError = (value) => setMenuState(prev => ({ ...prev, error: value }));
      const setUserGoals = (value) => {
        setMenuState(prev => ({ ...prev, userGoals: value }));
        localStorage.setItem('menuDecoder_userGoals', value);
      };
      const fileInputRef = useRef(null);

      const fileToBase64 = (file) => new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = () => resolve(reader.result.split(',')[1]);
        reader.onerror = error => reject(error);
      });

      // Rebuild a File from stored data URL to resume analysis after a stale preview in Menu Decoder
      const dataURLtoFile = (dataUrl, fileName = 'menu.jpg') => {
        try {
          const [meta, base64] = dataUrl.split(',');
          const match = /data:(.*?);/i.exec(meta);
          const mime = match ? match[1] : 'image/jpeg';
          const binary = atob(base64);
          const len = binary.length;
          const bytes = new Uint8Array(len);
          for (let i = 0; i < len; i++) bytes[i] = binary.charCodeAt(i);
          return new File([bytes], fileName, { type: mime });
        } catch (e) { return null; }
      };

      const resumeMenuScanFromSaved = async () => {
        try {
          let dataUrl = localStorage.getItem('menuDecoder_imagePreview');
          if (!dataUrl && typeof imagePreview === 'string' && imagePreview.startsWith('data:')) {
            dataUrl = imagePreview;
          }
          if (dataUrl) {
            const file = dataURLtoFile(dataUrl, 'menu.jpg');
            if (file) { await handleScan(file); return; }
          }
          if (fileInputRef.current) fileInputRef.current.click();
        } catch (err) { setError('Could not resume analysis. Please try again.'); }
      };

      const resetScan = () => {
        setImagePreview(null);
        localStorage.removeItem('menuDecoder_imagePreview');
        setMenuItems(null);
        localStorage.removeItem('menuDecoder_menuItems');
        setRecommendations(null);
        localStorage.removeItem('menuDecoder_recommendations');
        setError(null);
      };

      const handleImageChange = (e) => {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = async (e) => {
            setImagePreview(e.target.result);
            try {
              const compress = async (dataUrl) => {
                if (typeof compressImageForMobile !== 'undefined') return await compressImageForMobile(dataUrl, 300, 0.6);
                if (typeof window !== 'undefined' && window.compressImageForMobile) return await window.compressImageForMobile(dataUrl, 300, 0.6);
                return await new Promise((resolve) => {
                  try {
                    const img = new Image();
                    img.onload = () => {
                      try {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        let width = img.width, height = img.height;
                        const maxWidth = 300;
                        if (width > maxWidth) { height = height * (maxWidth / width); width = maxWidth; }
                        canvas.width = width; canvas.height = height;
                        ctx.drawImage(img, 0, 0, width, height);
                        resolve(canvas.toDataURL('image/jpeg', 0.6));
                      } catch (e) { resolve(dataUrl); }
                    };
                    img.onerror = () => resolve(dataUrl);
                    img.src = dataUrl;
                  } catch (e) { resolve(dataUrl); }
                });
              };
              const compressedImage = await compress(e.target.result);
              setLocalStorageWithSync('menuDecoder_imagePreview', compressedImage);
            } catch (error) {
              console.warn('Failed to store compressed image:', error);
            }
          };
          reader.readAsDataURL(file);
          setMenuItems(null);
          localStorage.removeItem('menuDecoder_menuItems');
          setRecommendations(null);
          localStorage.removeItem('menuDecoder_recommendations');
          setError(null);
          handleScan(file);
        }
      };

      const handleScan = async (file) => {
        setIsLoading(true);
        setError(null);
        try {
          const base64ImageData = await fileToBase64(file);
          const prompt = `Analyze this restaurant menu image and provide personalized recommendations.

1. Extract all visible menu items with their names, descriptions, and prices (if visible).
2. Based on the user's dietary goals: "${userGoals}" and daily calorie target of ${goals.calories} calories, analyze each item.
3. Provide specific recommendations with explanations.

Respond ONLY with a valid JSON object in this format:
{
  "menu_items": [
    {
      "name": "Item Name",
      "description": "Item description from menu",
      "price": "$X.XX or null if not visible",
      "estimated_calories": 000,
      "health_score": 1-10,
      "recommendation_reason": "Why this fits or doesn't fit user goals"
    }
  ],
  "top_recommendations": [
    {
      "item_name": "Best Item Name",
      "why_recommended": "Detailed explanation",
      "modification_tip": "Optional suggestion to make it healthier"
    }
  ],
  "items_to_avoid": [
    {
      "item_name": "Item to avoid",
      "why_avoid": "Reason why it doesn't fit goals"
    }
  ]
}`;

          const payload = {
            contents: [
              {
                parts: [
                  { text: prompt },
                  { inlineData: { mimeType: file.type, data: base64ImageData } }
                ]
              }
            ],
          };

          // Use Direct OpenRouter (Qwen)
          const previewDataUrl = (() => { try { return localStorage.getItem('menuDecoder_imagePreview'); } catch { return null; } })();
          const dataUrl = `data:${file.type};base64,${base64ImageData}`;
          const uploadDataUrl = previewDataUrl || dataUrl;
          const uploadedUrl = await uploadImageDataUrlToPublic(uploadDataUrl, file.type);
          const imageUrlToSend = uploadedUrl || dataUrl;

          const response = await fetch(getDirectGeminiConfig().url, {
            method: 'POST',
            headers: getDirectGeminiConfig().headers,
            body: JSON.stringify({
              model: OPENROUTER_QWEN_VL_MODEL,
              messages: [{
                role: 'user',
                content: [
                  { type: 'text', text: prompt },
                  { type: 'image_url', image_url: imageUrlToSend }
                ]
              }]
            })
          });

          if (!response.ok) {
            throw new Error(`API Error: ${response.status} ${response.statusText}`);
          }

          const result = await response.json();
          const textResponse = (result.choices?.[0]?.message?.content || '');
          const jsonString = textResponse.replace(/```json|```/g, '').trim();
          const data = JSON.parse(jsonString);
          setMenuItems(data.menu_items);
          localStorage.setItem('menuDecoder_menuItems', JSON.stringify(data.menu_items));
          setRecommendations({
            top: data.top_recommendations,
            avoid: data.items_to_avoid
          });
          localStorage.setItem('menuDecoder_recommendations', JSON.stringify({
            top: data.top_recommendations,
            avoid: data.items_to_avoid
          }));
        } catch (err) {
          console.error("Menu analysis failed:", err);
          setError('Couldn‚Äôt analyze the menu or prompt limit reached. Try again, or sign in, or subscribe to continue.');
        } finally {
          setIsLoading(false);
        }
      };

      return (
        <div className="p-6 pb-24">
          <header className="mb-6 text-center">
            <h1 className="text-2xl font-bold text-gray-800 dark:text-gray-200">üçΩÔ∏è Menu Decoder</h1>
            <p className="text-gray-500 dark:text-gray-400">Smart dining choices made easy!</p>
          </header>

          {!imagePreview && (
            <div className="max-w-md mx-auto">
              {/* Goals Input */}
              <div className="bg-white dark:bg-gray-800 p-4 rounded-2xl shadow-md mb-4">
                <h3 className="font-semibold text-gray-800 dark:text-gray-200 mb-2">Your Dining Goals:</h3>
                <input
                  type="text"
                  value={userGoals}
                  onChange={(e) => {
                    setUserGoals(e.target.value);
                    localStorage.setItem('menuDecoder_userGoals', e.target.value);
                  }}
                  placeholder="e.g., high protein, low carb, heart healthy"
                  className="w-full p-3 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200"
                />
              </div>

              <div className="bg-white dark:bg-gray-800 p-8 rounded-2xl shadow-md text-center">
                <div className="mb-6">
                  <div className="w-24 h-24 mx-auto mb-4 bg-gradient-to-br from-orange-400 to-red-500 rounded-full flex items-center justify-center">
                    <span className="text-4xl">üçΩÔ∏è</span>
                  </div>
                  <h3 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-2">Scan Restaurant Menu</h3>
                  <p className="text-gray-600 dark:text-gray-400 mb-6">Take a photo of any restaurant menu and I'll highlight the healthiest options for your goals!</p>
                </div>
                
                <input
                  type="file"
                  accept="image/*"
                  capture="environment"
                  onChange={handleImageChange}
                  ref={fileInputRef}
                  className="hidden"
                />
                
                <button
                  onClick={() => fileInputRef.current?.click()}
                  className="w-full bg-gradient-to-r from-orange-500 to-red-500 text-white font-bold py-4 rounded-2xl shadow-lg hover:from-orange-600 hover:to-red-600 transition-all transform hover:scale-105"
                >
                  üì∑ Scan Menu
                </button>
                
                <div className="mt-6 p-4 bg-orange-50 dark:bg-orange-900/20 rounded-xl">
                  <h4 className="font-semibold text-orange-800 dark:text-orange-200 mb-2">üí° Pro Tips:</h4>
                  <ul className="text-sm text-orange-700 dark:text-orange-300 space-y-1">
                    <li>‚Ä¢ Ensure menu text is clearly visible</li>
                    <li>‚Ä¢ Include item descriptions when possible</li>
                    <li>‚Ä¢ Works with any restaurant menu!</li>
                  </ul>
                </div>
              </div>
            </div>
          )}

          {imagePreview && (
            <div className="max-w-md mx-auto">
              <div className="bg-white dark:bg-gray-800 rounded-2xl shadow-md overflow-hidden">
                <img src={imagePreview} alt="Restaurant menu" className="w-full h-64 object-cover" />
                
                {!isLoading && !error && !recommendations && !menuItems && (
                  <div className="p-6 text-center">
                    <p className="text-gray-600 dark:text-gray-400 mb-4">Image loaded. Ready to analyze.</p>
                    <div className="flex gap-3 justify-center">
                      <button onClick={resumeMenuScanFromSaved} className="bg-orange-500 hover:bg-orange-600 text-white px-4 py-2 rounded-lg">Analyze Now</button>
                      <button onClick={resetScan} className="bg-gray-500 hover:bg-gray-600 text-white px-4 py-2 rounded-lg">Choose Different Image</button>
                    </div>
                  </div>
                )}
                
                {isLoading && (
                  <div className="p-6 text-center">
                    <div className="animate-spin w-8 h-8 border-4 border-orange-500 border-t-transparent rounded-full mx-auto mb-4"></div>
                    <p className="text-gray-600 dark:text-gray-400">Analyzing menu options...</p>
                  </div>
                )}

                {error && (
                  <div className="p-6 text-center">
                    <p className="text-red-500 mb-4">{error}</p>
                    <button onClick={resetScan} className="bg-gray-500 text-white px-4 py-2 rounded-lg">
                      Try Again
                    </button>
                  </div>
                )}

                {recommendations && (
                  <div className="p-6">
                    <div className="flex justify-between items-center mb-4">
                      <h3 className="font-bold text-gray-800 dark:text-gray-200">üéØ Smart Recommendations</h3>
                      <button onClick={resetScan} className="text-orange-500 font-semibold text-sm">
                        ‚Üê New Menu
                      </button>
                    </div>
                    
                    {/* Top Recommendations */}
                    {recommendations.top && recommendations.top.length > 0 && (
                      <div className="mb-6">
                        <h4 className="font-semibold text-green-600 dark:text-green-400 mb-3">‚úÖ Best Choices for You:</h4>
                        <div className="space-y-3">
                          {recommendations.top.map((rec, index) => (
                            <div key={index} className="bg-green-50 dark:bg-green-900/20 p-4 rounded-lg border-l-4 border-green-500">
                              <h5 className="font-bold text-gray-800 dark:text-gray-200">{rec.item_name}</h5>
                              <p className="text-sm text-gray-600 dark:text-gray-400 mt-1">{rec.why_recommended}</p>
                              {rec.modification_tip && (
                                <p className="text-sm text-green-700 dark:text-green-300 mt-2 font-medium">
                                  üí° Tip: {rec.modification_tip}
                                </p>
                              )}
                            </div>
                          ))}
                        </div>
                      </div>
                    )}

                    {/* Items to Avoid */}
                    {recommendations.avoid && recommendations.avoid.length > 0 && (
                      <div className="mb-6">
                        <h4 className="font-semibold text-red-600 dark:text-red-400 mb-3">‚ö†Ô∏è Consider Avoiding:</h4>
                        <div className="space-y-3">
                          {recommendations.avoid.map((avoid, index) => (
                            <div key={index} className="bg-red-50 dark:bg-red-900/20 p-4 rounded-lg border-l-4 border-red-500">
                              <h5 className="font-bold text-gray-800 dark:text-gray-200">{avoid.item_name}</h5>
                              <p className="text-sm text-gray-600 dark:text-gray-400 mt-1">{avoid.why_avoid}</p>
                            </div>
                          ))}
                        </div>
                      </div>
                    )}

                    {/* All Menu Items */}
                    {menuItems && menuItems.length > 0 && (
                      <div>
                        <h4 className="font-semibold text-gray-800 dark:text-gray-200 mb-3">üìã All Menu Items:</h4>
                        <div className="space-y-2">
                          {menuItems.map((item, index) => (
                            <div key={index} className="bg-gray-50 dark:bg-gray-700 p-3 rounded-lg">
                              <div className="flex justify-between items-start">
                                <div className="flex-1">
                                  <h5 className="font-semibold text-gray-800 dark:text-gray-200">{item.name}</h5>
                                  {item.description && (
                                    <p className="text-sm text-gray-600 dark:text-gray-400 mt-1">{item.description}</p>
                                  )}
                                  <p className="text-xs text-gray-500 dark:text-gray-500 mt-1">{item.recommendation_reason}</p>
                                </div>
                                <div className="text-right ml-3">
                                  {item.price && (
                                    <p className="font-semibold text-gray-800 dark:text-gray-200">{item.price}</p>
                                  )}
                                  <div className="flex items-center mt-1">
                                    <span className={`text-xs px-2 py-1 rounded-full ${
                                      item.health_score >= 8 ? 'bg-green-200 text-green-800 dark:bg-green-800 dark:text-green-200' :
                                      item.health_score >= 6 ? 'bg-yellow-200 text-yellow-800 dark:bg-yellow-800 dark:text-yellow-200' :
                                      'bg-red-200 text-red-800 dark:bg-red-800 dark:text-red-200'
                                    }`}>
                                      {item.health_score}/10
                                    </span>
                                  </div>
                                  <p className="text-xs text-gray-500 dark:text-gray-500 mt-1">~{item.estimated_calories} cal</p>
                                </div>
                              </div>
                            </div>
                          ))}
                        </div>
                      </div>
                    )}
                  </div>
                )}
              </div>
            </div>
          )}
        </div>
      );
    };

    // Smart Pantry Chef Component
    const SmartPantryChef = ({ goals, pantryState, setPantryState }) => {
      const { isLoading, ingredients, recipes, error, imagePreview } = pantryState;
      
      const setIsLoading = (value) => setPantryState(prev => ({ ...prev, isLoading: value }));
      const setIngredients = (value) => {
        setPantryState(prev => ({ ...prev, ingredients: value }));
        localStorage.setItem('pantryChef_ingredients', JSON.stringify(value));
      };
      const setRecipes = (value) => {
        setPantryState(prev => ({ ...prev, recipes: value }));
        localStorage.setItem('pantryChef_recipes', JSON.stringify(value));
      };
      const setError = (value) => setPantryState(prev => ({ ...prev, error: value }));
      const setImagePreview = (value) => {
        setPantryState(prev => ({ ...prev, imagePreview: value }));
        // Do not store raw image here; compressed version will be stored after processing
      };
      const fileInputRef = useRef(null);

      const fileToBase64 = (file) => new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = () => resolve(reader.result.split(',')[1]);
        reader.onerror = error => reject(error);
      });

      // Rebuild a File from stored data URL to resume analysis after a stale preview
      const dataURLtoFile = (dataUrl, fileName = 'pantry.jpg') => {
        try {
          const [meta, base64] = dataUrl.split(',');
          const match = /data:(.*?);/i.exec(meta);
          const mime = match ? match[1] : 'image/jpeg';
          const binary = atob(base64);
          const len = binary.length;
          const bytes = new Uint8Array(len);
          for (let i = 0; i < len; i++) bytes[i] = binary.charCodeAt(i);
          return new File([bytes], fileName, { type: mime });
        } catch (e) { return null; }
      };

      const resumePantryScanFromSaved = async () => {
        try {
          let dataUrl = localStorage.getItem('pantryChef_imagePreview');
          if (!dataUrl && typeof imagePreview === 'string' && imagePreview.startsWith('data:')) {
            dataUrl = imagePreview;
          }
          if (dataUrl) {
            const file = dataURLtoFile(dataUrl, 'pantry.jpg');
            if (file) { await handleScan(file); return; }
          }
          if (fileInputRef.current) fileInputRef.current.click();
        } catch (err) { setError('Could not resume analysis. Please try again.'); }
      };

      const handleImageChange = (event) => {
        const file = event.target.files[0];
        if (file) {
          const previewUrl = URL.createObjectURL(file);
          setImagePreview(previewUrl);
          
          // Store compressed image data for persistence across refreshes
          const reader = new FileReader();
          reader.onload = async (e) => {
            try {
              const compress = async (dataUrl) => {
                if (typeof compressImageForMobile !== 'undefined') return await compressImageForMobile(dataUrl, 300, 0.6);
                if (typeof window !== 'undefined' && window.compressImageForMobile) return await window.compressImageForMobile(dataUrl, 300, 0.6);
                return await new Promise((resolve) => {
                  try {
                    const img = new Image();
                    img.onload = () => {
                      try {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        let width = img.width, height = img.height;
                        const maxWidth = 300;
                        if (width > maxWidth) { height = height * (maxWidth / width); width = maxWidth; }
                        canvas.width = width; canvas.height = height;
                        ctx.drawImage(img, 0, 0, width, height);
                        resolve(canvas.toDataURL('image/jpeg', 0.6));
                      } catch (e) { resolve(dataUrl); }
                    };
                    img.onerror = () => resolve(dataUrl);
                    img.src = dataUrl;
                  } catch (e) { resolve(dataUrl); }
                });
              };
              const compressedImage = await compress(e.target.result);
              setLocalStorageWithSync('pantryChef_imagePreview', compressedImage);
            } catch (error) {
              console.warn('Failed to store compressed image:', error);
            }
          };
          reader.readAsDataURL(file);
          
          setIngredients(null);
          localStorage.removeItem('pantryChef_ingredients');
          setRecipes(null);
          localStorage.removeItem('pantryChef_recipes');
          setError(null);
          handleScan(file);
        }
      };

      const handleScan = async (file) => {
        // Safety check - if already loading, don't start again
        if (isLoading) return;
        
        setIsLoading(true);
        setError(null);
        
        // Add manual timeout to prevent freezing
        const timeoutId = setTimeout(() => {
          console.warn('Scan timeout triggered - resetting component');
          setIsLoading(false);
          setError('Request timed out. Please try scanning again.');
          // Force clear any stuck state
          localStorage.removeItem('pantryChef_ingredients');
          localStorage.removeItem('pantryChef_recipes');
        }, 30000); // 30 second backup timeout
        
        try {
          const base64ImageData = await fileToBase64(file);
          const dataUrl = `data:${file.type};base64,${base64ImageData}`;
          const previewDataUrl = (() => { try { return localStorage.getItem('pantryChef_imagePreview'); } catch { return null; } })();
          const uploadDataUrl = previewDataUrl || dataUrl;
          const uploadedUrl = await uploadImageDataUrlToPublic(uploadDataUrl, file.type);
          const imageUrlToSend = uploadedUrl || dataUrl;
          const prompt = `Analyze this image of pantry/fridge ingredients.
1. Identify all visible food items and ingredients.
2. List them clearly with estimated quantities if visible.
3. Respond ONLY with a valid JSON object in this format:
{
  "ingredients": [
    {"name": "Ingredient Name", "quantity": "estimated amount or 'available'"},
    {"name": "Another Ingredient", "quantity": "estimated amount or 'available'"}
  ]
}`;

          const payload = {
            contents: [
              {
                parts: [
                  { text: prompt },
                  { inlineData: { mimeType: file.type, data: base64ImageData } }
                ]
              }
            ],
          };

          const response = await fetch(getDirectGeminiConfig().url, {
            method: 'POST',
            headers: getDirectGeminiConfig().headers,
            body: JSON.stringify({
              model: OPENROUTER_QWEN_VL_MODEL,
              messages: [{
                role: 'user',
                content: [
                  { type: 'text', text: prompt },
                  { type: 'image_url', image_url: imageUrlToSend }
                ]
              }]
            }),
            signal: AbortSignal.timeout(25000) // 25 second timeout
          });

          if (!response.ok) {
            throw new Error(`API Error: ${response.status} ${response.statusText}`);
          }

          const result = await response.json();
          const textResponse = (result.choices?.[0]?.message?.content || '');
          const jsonString = textResponse.replace(/```json|```/g, '').trim();
          const data = JSON.parse(jsonString);
          setIngredients(data.ingredients);
          localStorage.setItem('pantryChef_ingredients', JSON.stringify(data.ingredients));
          clearTimeout(timeoutId); // Clear timeout on success
        } catch (err) {
          console.error("Ingredient recognition failed:", err);
          setError('Couldn‚Äôt analyze the ingredients or prompt limit reached. Try again, or sign in, or subscribe to continue.');
          clearTimeout(timeoutId); // Clear timeout on error
        } finally {
          setIsLoading(false);
        }
      };

      const generateRecipes = async () => {
        if (!ingredients || ingredients.length === 0) return;
        
        // Safety check - if already loading, don't start again
        if (isLoading) return;
        
        setIsLoading(true);
        setError(null);
        
        // Add manual timeout to prevent freezing
        const timeoutId = setTimeout(() => {
          console.warn('Recipe generation timeout triggered - resetting component');
          setIsLoading(false);
          setError('Recipe generation timed out. Please try again.');
          // Force clear any stuck state
          localStorage.removeItem('pantryChef_recipes');
        }, 30000); // 30 second backup timeout
        
        try {
          const ingredientList = ingredients.map(ing => ing.name).join(', ');
          const prompt = `Create 3 quick recipes using: ${ingredientList}. Keep under ${goals.calories} calories. JSON only: {"recipes":[{"name":"Recipe","prep_time":"15 min","cook_time":"20 min","servings":2,"calories_per_serving":350,"ingredients_used":["ingredient1"],"instructions":["Step 1"],"nutrition":{"protein":25,"carbs":30,"fat":15}}]}`;

          const response = await fetch(getDirectGeminiConfig().url, {
            method: 'POST',
            headers: getDirectGeminiConfig().headers,
            body: JSON.stringify({
              model: OPENROUTER_QWEN_MODEL,
              messages: [{ role: 'user', content: prompt }]
            })
          });

          if (!response.ok) {
            throw new Error(`API Error: ${response.status} ${response.statusText}`);
          }

          const result = await response.json();
          const textResponse = (result.choices?.[0]?.message?.content || '');
          const jsonString = textResponse.replace(/```json|```/g, '').trim();
          const data = JSON.parse(jsonString);
          setRecipes(data.recipes);
          localStorage.setItem('pantryChef_recipes', JSON.stringify(data.recipes));
          clearTimeout(timeoutId); // Clear timeout on success
        } catch (err) {
          console.error("Recipe generation failed:", err);
          setError('Could not generate recipes. Please try again.');
          clearTimeout(timeoutId); // Clear timeout on error
        } finally {
          setIsLoading(false);
        }
      };

      const resetScan = () => {
        setImagePreview(null);
        localStorage.removeItem('pantryChef_imagePreview');
        setIngredients(null);
        localStorage.removeItem('pantryChef_ingredients');
        setRecipes(null);
        localStorage.removeItem('pantryChef_recipes');
        setError(null);
        if (fileInputRef.current) {
          fileInputRef.current.value = '';
        }
      };

      return (
        <div className="p-6 pb-24">
          <header className="mb-6 text-center">
            <h1 className="text-2xl font-bold text-gray-800 dark:text-gray-200">üßë‚Äçüç≥ Smart Pantry Chef</h1>
            <p className="text-gray-500 dark:text-gray-400">Snap your ingredients, get instant recipes!</p>
          </header>

          {!imagePreview && (
            <div className="max-w-md mx-auto">
              <div className="bg-white dark:bg-gray-800 p-8 rounded-2xl shadow-md text-center">
                <div className="mb-6">
                  <div className="w-24 h-24 mx-auto mb-4 bg-gradient-to-br from-green-400 to-blue-500 rounded-full flex items-center justify-center">
                    <span className="text-4xl">üì∏</span>
                  </div>
                  <h3 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-2">Scan Your Pantry</h3>
                  <p className="text-gray-600 dark:text-gray-400 mb-6">Take a photo of your fridge or pantry ingredients and I'll suggest recipes you can make right now!</p>
                </div>
                
                <input
                  type="file"
                  accept="image/*"
                  capture="environment"
                  onChange={handleImageChange}
                  ref={fileInputRef}
                  className="hidden"
                />
                
                <button
                  onClick={() => fileInputRef.current?.click()}
                  className="w-full bg-gradient-to-r from-green-500 to-blue-500 text-white font-bold py-4 rounded-2xl shadow-lg hover:from-green-600 hover:to-blue-600 transition-all transform hover:scale-105"
                >
                  üì∑ Scan Ingredients
                </button>
                
                <div className="mt-6 p-4 bg-blue-50 dark:bg-blue-900/20 rounded-xl">
                  <h4 className="font-semibold text-blue-800 dark:text-blue-200 mb-2">üí° Pro Tips:</h4>
                  <ul className="text-sm text-blue-700 dark:text-blue-300 space-y-1">
                    <li>‚Ä¢ Ensure good lighting for best results</li>
                    <li>‚Ä¢ Include labels and packaging when visible</li>
                    <li>‚Ä¢ Multiple ingredients in one photo work great!</li>
                  </ul>
                </div>
              </div>
            </div>
          )}

          {imagePreview && (
            <div className="max-w-md mx-auto">
              <div className="bg-white dark:bg-gray-800 rounded-2xl shadow-md overflow-hidden">
                <img src={imagePreview} alt="Scanned ingredients" className="w-full h-64 object-cover" />
                
                {!isLoading && !error && !ingredients && !recipes && (
                  <div className="p-6 text-center">
                    <p className="text-gray-600 dark:text-gray-400 mb-4">Image loaded. Ready to analyze.</p>
                    <div className="flex gap-3 justify-center">
                      <button onClick={resumePantryScanFromSaved} className="bg-pink-500 hover:bg-pink-600 text-white px-4 py-2 rounded-lg">Analyze Now</button>
                      <button onClick={resetScan} className="bg-gray-500 hover:bg-gray-600 text-white px-4 py-2 rounded-lg">Choose Different Image</button>
                    </div>
                  </div>
                )}
                
                {isLoading && (
                  <div className="p-6 text-center">
                    <div className="animate-spin w-8 h-8 border-4 border-pink-500 border-t-transparent rounded-full mx-auto mb-4"></div>
                    <p className="text-gray-600 dark:text-gray-400 mb-4">
                      {!ingredients ? 'Identifying ingredients...' : 'Generating recipes...'}
                    </p>
                    <button 
                      onClick={() => {
                        setIsLoading(false);
                        setError('Process cancelled. You can try again.');
                      }}
                      className="text-sm bg-red-500 text-white px-4 py-2 rounded-lg hover:bg-red-600 transition-colors"
                    >
                      Cancel & Reset
                    </button>
                  </div>
                )}

                {error && (
                  <div className="p-6 text-center">
                    <p className="text-red-500 mb-4">{error}</p>
                    <button onClick={resetScan} className="bg-gray-500 text-white px-4 py-2 rounded-lg">
                      Try Again
                    </button>
                  </div>
                )}

                {ingredients && !recipes && !isLoading && (
                  <div className="p-6">
                    <h3 className="font-bold text-gray-800 dark:text-gray-200 mb-4">ü•ò Ingredients Found:</h3>
                    <div className="space-y-2 mb-6">
                      {ingredients.map((ingredient, index) => (
                        <div key={index} className="flex justify-between items-center p-2 bg-gray-50 dark:bg-gray-700 rounded-lg">
                          <span className="text-gray-800 dark:text-gray-200">{ingredient.name}</span>
                          <span className="text-sm text-gray-500 dark:text-gray-400">{ingredient.quantity}</span>
                        </div>
                      ))}
                    </div>
                    
                    <div className="space-y-3">
                      <button
                        onClick={generateRecipes}
                        className="w-full bg-green-500 text-white font-bold py-3 rounded-xl hover:bg-green-600 transition-colors"
                      >
                        üç≥ Get Recipe Ideas
                      </button>
                      
                      <button
                        onClick={resetScan}
                        className="w-full bg-gray-500 text-white font-bold py-2 rounded-xl hover:bg-gray-600 transition-colors"
                      >
                        üì∏ Scan Different Ingredients
                      </button>
                    </div>
                  </div>
                )}

                {recipes && (
                  <div className="p-6">
                    <div className="flex justify-between items-center mb-4">
                      <h3 className="font-bold text-gray-800 dark:text-gray-200">üçΩÔ∏è Recipe Suggestions</h3>
                      <button onClick={resetScan} className="text-pink-500 font-semibold text-sm">
                        ‚Üê New Scan
                      </button>
                    </div>
                    
                    <div className="space-y-4">
                      {recipes.map((recipe, index) => (
                        <RecipeCard key={index} recipe={recipe} />
                      ))}
                    </div>
                  </div>
                )}
              </div>
            </div>
          )}
        </div>
      );
    };

    // Recipe Card Component for Smart Pantry Chef
    const RecipeCard = ({ recipe }) => {
      const [isExpanded, setIsExpanded] = useState(false);
      
      return (
        <div className="border border-gray-200 dark:border-gray-700 rounded-xl overflow-hidden">
          <div className="p-4 bg-gradient-to-r from-green-50 to-blue-50 dark:from-green-900/20 dark:to-blue-900/20">
            <div className="flex justify-between items-start mb-2">
              <h4 className="font-bold text-gray-800 dark:text-gray-200">{recipe.name}</h4>
              <span className="text-sm bg-green-100 dark:bg-green-800 text-green-800 dark:text-green-200 px-2 py-1 rounded-full">
                {recipe.calories_per_serving} cal
              </span>
            </div>
            
            <div className="flex gap-4 text-sm text-gray-600 dark:text-gray-400 mb-3">
              <span>‚è±Ô∏è Prep: {recipe.prep_time}</span>
              <span>üî• Cook: {recipe.cook_time}</span>
              <span>üçΩÔ∏è Serves: {recipe.servings}</span>
            </div>
            
            <div className="mb-3">
              <p className="text-sm font-semibold text-gray-700 dark:text-gray-300 mb-1">Using your ingredients:</p>
              <div className="flex flex-wrap gap-1">
                {recipe.ingredients_used.map((ing, i) => (
                  <span key={i} className="text-xs bg-green-200 dark:bg-green-700 text-green-800 dark:text-green-200 px-2 py-1 rounded-full">
                    {ing}
                  </span>
                ))}
              </div>
            </div>
            
            {recipe.additional_needed && recipe.additional_needed.length > 0 && (
              <div className="mb-3">
                <p className="text-sm font-semibold text-gray-700 dark:text-gray-300 mb-1">You might need:</p>
                <div className="flex flex-wrap gap-1">
                  {recipe.additional_needed.map((item, i) => (
                    <span key={i} className="text-xs bg-yellow-200 dark:bg-yellow-700 text-yellow-800 dark:text-yellow-200 px-2 py-1 rounded-full">
                      {item}
                    </span>
                  ))}
                </div>
              </div>
            )}
            
            <button
              onClick={() => setIsExpanded(!isExpanded)}
              className="w-full bg-white dark:bg-gray-800 text-gray-800 dark:text-gray-200 font-semibold py-2 rounded-lg border border-gray-200 dark:border-gray-600 hover:bg-gray-50 dark:hover:bg-gray-700 transition-colors"
            >
              {isExpanded ? '‚ñ≤ Hide Details' : '‚ñº View Recipe'}
            </button>
          </div>
          
          {isExpanded && (
            <div className="p-4 border-t border-gray-200 dark:border-gray-700">
              <div className="grid md:grid-cols-2 gap-4 mb-4">
                <div>
                  <h5 className="font-semibold text-gray-800 dark:text-gray-200 mb-2">Instructions:</h5>
                  <ol className="list-decimal list-inside text-sm text-gray-600 dark:text-gray-400 space-y-1">
                    {recipe.instructions.map((step, i) => (
                      <li key={i}>{step}</li>
                    ))}
                  </ol>
                </div>
                
                <div>
                  <h5 className="font-semibold text-gray-800 dark:text-gray-200 mb-2">Nutrition per serving:</h5>
                  <div className="text-sm text-gray-600 dark:text-gray-400 space-y-1">
                    <p>ü•© Protein: {recipe.nutrition.protein}g</p>
                    <p>üçû Carbs: {recipe.nutrition.carbs}g</p>
                    <p>ü•ë Fat: {recipe.nutrition.fat}g</p>
                  </div>
                </div>
              </div>
              
              {recipe.health_tip && (
                <div className="bg-blue-50 dark:bg-blue-900/20 p-3 rounded-lg">
                  <h5 className="font-semibold text-blue-800 dark:text-blue-200 mb-1">üí° Health Tip:</h5>
                  <p className="text-sm text-blue-700 dark:text-blue-300">{recipe.health_tip}</p>
                </div>
              )}
            </div>
          )}
        </div>
      );
    };

    // Reusable Voice Button Component (hidden)
    const VoiceButton = ({ text, buttonId, label, className = "" }) => {
      return null;
    };

    // Individual Meal Voice Button Component (hidden)
    const MealVoiceButton = ({ meal, mealType, buttonId }) => {
      return null;
    };

    // Full Meal Plan Voice Button Component (hidden)
    const MealPlanVoiceButton = ({ mealPlan }) => {
      return null;
    };

    // Individual Exercise Voice Button Component (hidden)
    const ExerciseVoiceButton = ({ exercise, index }) => {
      return null;
    };

    // Full Workout Plan Voice Button Component (hidden)
    const WorkoutPlanVoiceButton = ({ workoutPlan }) => {
      return null;
    };

    // Meal Planner Screen Component
    const MealPlanner = ({ goals, mealPlan, setMealPlan, isLoading, setIsLoading, error, setError, setScreen }) => {
      const [activeTab, setActiveTab] = useState(() => localStorage.getItem('mealPlanner_activeTab') || 'planner'); // 'planner', 'pantry', or 'menu'
      const [preferences, setPreferences] = useState({ cuisine: '', diet: '', calories: goals.calories, allergies: [] });
      
      // Persist active tab to localStorage so we remember last selected tab
      useEffect(() => {
        try {
          if (typeof setLocalStorageWithSync === 'function') {
            setLocalStorageWithSync('mealPlanner_activeTab', activeTab);
          } else {
            localStorage.setItem('mealPlanner_activeTab', activeTab);
          }
        } catch (e) {
          // ignore storage errors
        }
      }, [activeTab]);
      
      // State to persist Smart Pantry Chef and Menu Decoder data
      const [pantryState, setPantryState] = useState(() => {
        const savedIngredients = localStorage.getItem('pantryChef_ingredients');
        const savedRecipes = localStorage.getItem('pantryChef_recipes');
        const savedImagePreview = localStorage.getItem('pantryChef_imagePreview');
        return {
          isLoading: false,
          ingredients: savedIngredients ? JSON.parse(savedIngredients) : null,
          recipes: savedRecipes ? JSON.parse(savedRecipes) : null,
          error: null,
          imagePreview: savedImagePreview || null
        };
      });
      
      const [menuState, setMenuState] = useState(() => {
        const savedMenuItems = localStorage.getItem('menuDecoder_menuItems');
        const savedRecommendations = localStorage.getItem('menuDecoder_recommendations');
        const savedImagePreview = localStorage.getItem('menuDecoder_imagePreview');
        const savedUserGoals = localStorage.getItem('menuDecoder_userGoals');
        return {
          isLoading: false,
          menuItems: savedMenuItems ? JSON.parse(savedMenuItems) : null,
          recommendations: savedRecommendations ? JSON.parse(savedRecommendations) : null,
          error: null,
          imagePreview: savedImagePreview || null,
          userGoals: savedUserGoals || 'high protein, low carb'
        };
      });

      const handlePreferenceChange = (key, value) => {
        setPreferences(prev => ({ ...prev, [key]: value }));
      };

      const handleAllergyChange = (allergy) => {
        setPreferences(prev => {
          const newAllergies = prev.allergies.includes(allergy)
            ? prev.allergies.filter(a => a !== allergy)
            : [...prev.allergies, allergy];
          return { ...prev, allergies: newAllergies };
        });
      };

      const generateMealPlan = async () => {
        setIsLoading(true);
        setError(null);
        setMealPlan(null);
        try {
          const prompt = `Create a ${preferences.diet || 'Standard'} ${preferences.cuisine || 'Any'} meal plan for ${preferences.calories} calories.
Allergies: ${preferences.allergies.join(', ') || 'None'}

Respond ONLY with a valid JSON object in this exact format:
{
  "breakfast": {"name": "Meal Name", "ingredients": ["ingredient1", "ingredient2"], "instructions": ["step1", "step2"]},
  "lunch": {"name": "Meal Name", "ingredients": ["ingredient1", "ingredient2"], "instructions": ["step1", "step2"]},
  "dinner": {"name": "Meal Name", "ingredients": ["ingredient1", "ingredient2"], "instructions": ["step1", "step2"]}
}`;

          const response = await fetch(getDirectGeminiConfig().url, {
            method: 'POST',
            headers: getDirectGeminiConfig().headers,
            body: JSON.stringify({
              model: OPENROUTER_QWEN_MODEL,
              messages: [{ role: 'user', content: prompt }]
            }),
            signal: AbortSignal.timeout(25000) // 25 second timeout
          });

          if (!response.ok) {
            throw new Error(`API Error: ${response.status} ${response.statusText}`);
          }

          const result = await response.json();
          const textResponse = (result.choices?.[0]?.message?.content || '');
          
          // Better JSON extraction and validation
          let jsonString = textResponse.replace(/```json|```/g, '').trim();
          
          // Remove any text before the first { and after the last }
          const firstBrace = jsonString.indexOf('{');
          const lastBrace = jsonString.lastIndexOf('}');
          
          if (firstBrace !== -1 && lastBrace !== -1) {
            jsonString = jsonString.substring(firstBrace, lastBrace + 1);
          }
          
          const data = JSON.parse(jsonString);
          
          // Validate the structure
          if (!data.breakfast || !data.lunch || !data.dinner) {
            throw new Error('Invalid meal plan structure');
          }
          
          setMealPlan(data);
        } catch (err) {
          console.error("Meal plan generation failed:", err);
          setError("Could not generate a meal plan. ry again, or sign in, or subscribe to continue.");
        } finally {
          setIsLoading(false);
        }
      };

      return (
        <div className="p-6 pb-24 bg-gradient-to-br from-purple-50 via-pink-50 to-blue-50 dark:from-gray-900 dark:via-purple-900/20 dark:to-blue-900/20 min-h-screen">
          <header className="mb-6 text-center">
            <h1 className="text-3xl font-bold bg-gradient-to-r from-purple-600 to-pink-600 bg-clip-text text-transparent">Meal Planning</h1>
            <p className="text-gray-500 dark:text-gray-400">Plan meals, use ingredients, or decode menus</p>
          </header>

          {/* Tab Navigation */}
          <div className="flex mb-6 bg-gray-100 dark:bg-gray-800 rounded-2xl p-1 max-w-lg mx-auto">
            <button
              onClick={() => setActiveTab('planner')}
              className={`flex-1 py-3 px-2 rounded-xl font-semibold transition-all text-sm ${
                activeTab === 'planner'
                  ? 'bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 shadow-md'
                  : 'text-gray-600 dark:text-gray-400'
              }`}
            >
              üìã Planner
            </button>
            <button
              onClick={() => setActiveTab('pantry')}
              className={`flex-1 py-3 px-2 rounded-xl font-semibold transition-all text-sm ${
                activeTab === 'pantry'
                  ? 'bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 shadow-md'
                  : 'text-gray-600 dark:text-gray-400'
              }`}
            >
              üßë‚Äçüç≥ Pantry
            </button>
            <button
              onClick={() => setActiveTab('menu')}
              className={`flex-1 py-3 px-2 rounded-xl font-semibold transition-all text-sm ${
                activeTab === 'menu'
                  ? 'bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 shadow-md'
                  : 'text-gray-600 dark:text-gray-400'
              }`}
            >
              üçΩÔ∏è Menu
            </button>
          </div>

          {/* Tab Content */}
          {activeTab === 'planner' && (
            <div>
              {!mealPlan && (
                <div className="max-w-md mx-auto">
                  <div className="bg-white dark:bg-gray-800 p-6 rounded-2xl shadow-md space-y-4">
                    <div>
                      <h3 className="font-semibold mb-2 text-gray-800 dark:text-gray-200">Cuisine Type</h3>
                      <div className="grid grid-cols-2 sm:grid-cols-3 gap-2">
                        {['International', 'Indian', 'Mediterranean', 'Asian', 'Mexican', 'Italian'].map(c => (
                          <button
                            key={c}
                            onClick={() => handlePreferenceChange('cuisine', c)}
                            className={`p-2 rounded-lg border dark:border-gray-700 text-xs sm:text-sm font-medium min-h-[2.5rem] flex items-center justify-center ${
                              preferences.cuisine === c ? 'bg-pink-500 text-white' : 'bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200'
                            }`}
                          >
                            <span className="text-center leading-tight">{c}</span>
                          </button>
                        ))}
                      </div>
                    </div>

                    <div>
                      <h3 className="font-semibold mb-2 text-gray-800 dark:text-gray-200">Diet Type</h3>
                      <div className="grid grid-cols-3 gap-2">
                        {['Veg', 'Non-Veg', 'Vegan'].map(d => (
                          <button
                            key={d}
                            onClick={() => handlePreferenceChange('diet', d)}
                            className={`p-2 rounded-lg border dark:border-gray-700 ${preferences.diet === d ? 'bg-pink-500 text-white' : 'bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200'}`}
                          >
                            {d}
                          </button>
                        ))}
                      </div>
                    </div>

                    <div>
                      <h3 className="font-semibold mb-2 text-gray-800 dark:text-gray-200">Daily Calorie Target: {preferences.calories} kcal</h3>
                      <input type="range" min="1200" max="4000" step="50" value={preferences.calories} onChange={e => handlePreferenceChange('calories', e.target.value)} className="w-full" />
                    </div>

                    <div>
                      <h3 className="font-semibold mb-2 text-gray-800 dark:text-gray-200">Allergies & Restrictions</h3>
                      <div className="grid grid-cols-3 gap-2">
                        {['Nuts', 'Dairy', 'Gluten', 'Eggs', 'Seafood', 'Soy'].map(a => (
                          <button
                            key={a}
                            onClick={() => handleAllergyChange(a)}
                            className={`p-2 rounded-lg border dark:border-gray-700 ${preferences.allergies.includes(a) ? 'bg-pink-500 text-white' : 'bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200'}`}
                          >
                            {a}
                          </button>
                        ))}
                      </div>
                    </div>
                  </div>

                  <button
                    onClick={generateMealPlan}
                    disabled={isLoading}
                    className="w-full mt-6 bg-green-500 text-white font-bold py-4 rounded-2xl shadow-lg hover:bg-green-600 transition-colors disabled:bg-gray-400"
                  >
                    {isLoading ? 'Generating...' : 'Generate Meal Plan'}
                  </button>

                  {error && <div className="mt-4 text-center text-red-500">{error}</div>}
                </div>
              )}

              {mealPlan && (
                <div className="animate-fade-in">
                  <button onClick={() => setMealPlan(null)} className="mb-4 text-pink-500 font-semibold">&larr; Back to Preferences</button>
                  
                  {/* Download Button moved to top (responsive) */}
                  <button
                    onClick={async () => {
                      // Require sign-in before allowing PDF download
                      let signedIn = false;
                      try {
                        if (auth && auth.getSession) {
                          const { data: { session } } = await auth.getSession();
                          signedIn = !!(session && session.user && session.user.id);
                        }
                      } catch (_) {}
                      if (!signedIn) {
                        try { if (typeof setScreen === 'function') setScreen('profile'); } catch (_) {}
                        setTimeout(() => { try { window.dispatchEvent(new Event('open-account-modal')); } catch (_) {} }, 50);
                        return;
                      }
                      // Format meal plan for PDF
                      const title = "Your Personalized Meal Plan";
                      let content = "";
                      
                      // Add meal plan details
                      content += "BREAKFAST\n";
                      content += `${mealPlan.breakfast.name}\n\n`;
                      content += "Ingredients:\n";
                      mealPlan.breakfast.ingredients.forEach(ing => {
                        content += `- ${ing}\n`;
                      });
                      content += "\nInstructions:\n";
                      mealPlan.breakfast.instructions.forEach((inst, i) => {
                        content += `${i+1}. ${inst}\n`;
                      });
                      
                      content += "\n\nLUNCH\n";
                      content += `${mealPlan.lunch.name}\n\n`;
                      content += "Ingredients:\n";
                      mealPlan.lunch.ingredients.forEach(ing => {
                        content += `- ${ing}\n`;
                      });
                      content += "\nInstructions:\n";
                      mealPlan.lunch.instructions.forEach((inst, i) => {
                        content += `${i+1}. ${inst}\n`;
                      });
                      
                      content += "\n\nDINNER\n";
                      content += `${mealPlan.dinner.name}\n\n`;
                      content += "Ingredients:\n";
                      mealPlan.dinner.ingredients.forEach(ing => {
                        content += `- ${ing}\n`;
                      });
                      content += "\nInstructions:\n";
                      mealPlan.dinner.instructions.forEach((inst, i) => {
                        content += `${i+1}. ${inst}\n`;
                      });
                      
                      // Generate and download PDF
                      generatePDF(title, content, "meal-plan.pdf");
                    }}
                    className="mb-4 w-auto block mx-auto bg-pink-500 text-white font-bold py-2 sm:py-3 px-4 sm:px-6 text-sm sm:text-base rounded-xl shadow-lg hover:bg-pink-600 transition-colors"
                  >
                    üì• Download Meal Plan PDF
                  </button>

                  {/* Voice Button with Pause/Resume - REMOVED */}
                  
                  <MealPlanDisplay mealPlan={mealPlan} />
                  
                  {/* Download Button moved from bottom */}
                </div>
              )}
            </div>
          )}

          {activeTab === 'pantry' && (
            <SmartPantryChef 
              goals={goals} 
              pantryState={pantryState}
              setPantryState={setPantryState}
            />
          )}

          {activeTab === 'menu' && (
            <MenuDecoder 
              goals={goals}
              menuState={menuState}
              setMenuState={setMenuState}
            />
          )}
        </div>
      );
    };

    // AI Workout Form Coach Component
    const WorkoutFormCoach = () => {
      const [videoPreview, setVideoPreview] = useState(null);
      const [isRecording, setIsRecording] = useState(false);
      const [isLoading, setIsLoading] = useState(false);
      const [formAnalysis, setFormAnalysis] = useState(() => {
        const saved = localStorage.getItem('formAnalysis');
        return saved ? JSON.parse(saved) : null;
      });
      const [error, setError] = useState(null);
      const [selectedExercise, setSelectedExercise] = useState('squat');
      const [mediaRecorder, setMediaRecorder] = useState(null);
      const [recordedChunks, setRecordedChunks] = useState([]);
      const [recordingTime, setRecordingTime] = useState(0);
      const videoRef = useRef(null);
      const fileInputRef = useRef(null);
      const recordingTimerRef = useRef(null);
      // Access auth helpers to sync latest analysis to remote immediately
      const { user, syncAIContent } = useAuth();

      // Keep formAnalysis in sync with localStorage/remote updates across navigation/refresh
      useEffect(() => {
        const hydrate = () => {
          try {
            const saved = localStorage.getItem('formAnalysis');
            if (saved) {
              const parsed = JSON.parse(saved);
              // Avoid unnecessary rerenders if identical
              const prev = formAnalysis ? JSON.stringify(formAnalysis) : null;
              const next = parsed ? JSON.stringify(parsed) : null;
              if (prev !== next) setFormAnalysis(parsed);
            } else if (formAnalysis) {
              // If storage cleared, mirror it in state
              setFormAnalysis(null);
            }
          } catch (_) {}
        };
        const handleStorage = (e) => {
          if (!e || e.key === 'formAnalysis') hydrate();
        };
        window.addEventListener('userDataSynced', hydrate);
        window.addEventListener('remoteDataApplied', hydrate);
        window.addEventListener('storage', handleStorage);
        // Hydrate immediately on mount
        hydrate();
        return () => {
          window.removeEventListener('userDataSynced', hydrate);
          window.removeEventListener('remoteDataApplied', hydrate);
          window.removeEventListener('storage', handleStorage);
        };
      }, []);

      const exercises = [
      // Strength Training - Upper Body
      { id: 'pushup', name: 'üí™ Push-up', tips: 'Maintain straight line from head to heels, lower chest to ground' },
      { id: 'pullup', name: 'üî• Pull-up', tips: 'Full range of motion, control the movement, engage lats' },
      { id: 'dips', name: 'üí∫ Dips', tips: 'Lower until shoulders below elbows, push up with control' },
      { id: 'overhead_press', name: 'üèãÔ∏è Overhead Press', tips: 'Press straight up, keep core tight, full lockout' },
      { id: 'bench_press', name: 'üèãÔ∏è‚Äç‚ôÇÔ∏è Bench Press', tips: 'Lower bar to chest, press up explosively, maintain arch' },
      { id: 'rows', name: 'üö£ Bent-Over Row', tips: 'Hinge at hips, pull to lower chest, squeeze shoulder blades' },
      
      // Strength Training - Lower Body
      { id: 'squat', name: 'üèãÔ∏è Squat', tips: 'Keep back straight, knees track over toes, hip hinge' },
      { id: 'deadlift', name: 'üèãÔ∏è‚Äç‚ôÄÔ∏è Deadlift', tips: 'Hinge at hips, keep bar close to body, drive through heels' },
      { id: 'lunge', name: 'ü¶µ Lunge', tips: 'Step forward, lower back knee toward ground, push back up' },
      { id: 'bulgarian_split_squat', name: 'ü¶µ Bulgarian Split Squat', tips: 'Rear foot elevated, lower into lunge, drive through front heel' },
      { id: 'hip_thrust', name: 'üçë Hip Thrust', tips: 'Squeeze glutes at top, maintain neutral spine, full hip extension' },
      { id: 'calf_raise', name: 'ü¶µ Calf Raise', tips: 'Rise onto toes, pause at top, control the descent' },
      
      // Core & Stability
      { id: 'plank', name: 'ü§∏ Plank', tips: 'Engage core, avoid sagging or arching, breathe normally' },
      { id: 'side_plank', name: 'ü§∏‚Äç‚ôÄÔ∏è Side Plank', tips: 'Stack shoulders and hips, lift hips up, hold straight line' },
      { id: 'mountain_climbers', name: '‚õ∞Ô∏è Mountain Climbers', tips: 'Keep hips level, drive knees to chest, maintain plank position' },
      { id: 'russian_twists', name: 'üå™Ô∏è Russian Twists', tips: 'Lean back slightly, rotate torso, keep feet off ground' },
      { id: 'bicycle_crunches', name: 'üö¥ Bicycle Crunches', tips: 'Bring opposite elbow to knee, extend other leg, control movement' },
      { id: 'dead_bug', name: 'üêõ Dead Bug', tips: 'Keep lower back pressed down, move opposite arm and leg' },
      
      // Cardio & Conditioning
      { id: 'burpees', name: 'üí• Burpees', tips: 'Jump back to plank, push-up, jump forward, jump up with arms overhead' },
      { id: 'jumping_jacks', name: 'ü§∏‚Äç‚ôÇÔ∏è Jumping Jacks', tips: 'Jump feet apart while raising arms, return to start position' },
      { id: 'high_knees', name: 'üèÉ‚Äç‚ôÄÔ∏è High Knees', tips: 'Drive knees up to waist level, pump arms, stay on balls of feet' },
      { id: 'butt_kicks', name: 'ü¶µ Butt Kicks', tips: 'Kick heels to glutes, keep knees pointing down, quick tempo' },
      { id: 'jump_squats', name: 'ü¶ò Jump Squats', tips: 'Squat down, explode up into jump, land softly, repeat' },
      
      // Functional Movement
      { id: 'bear_crawl', name: 'üêª Bear Crawl', tips: 'Keep knees just off ground, move opposite hand and foot together' },
      { id: 'crab_walk', name: 'ü¶Ä Crab Walk', tips: 'Keep hips up, move opposite hand and foot, face up' },
      { id: 'turkish_getup', name: 'üáπüá∑ Turkish Get-up', tips: 'Slow controlled movement, keep weight overhead, step by step' },
      { id: 'farmers_walk', name: 'üöú Farmer\'s Walk', tips: 'Keep shoulders back, core tight, walk with heavy weights' },
      
      // Flexibility & Mobility
      { id: 'downward_dog', name: 'üßò‚Äç‚ôÄÔ∏è Downward Dog', tips: 'Form inverted V, press hands down, lengthen spine' },
      { id: 'cat_cow', name: 'üê±üêÑ Cat-Cow Stretch', tips: 'Arch and round spine slowly, coordinate with breathing' },
      { id: 'pigeon_pose', name: 'üïäÔ∏è Pigeon Pose', tips: 'Hip opener, keep front knee at 90 degrees, square hips' },
      { id: 'child_pose', name: 'üßò Child\'s Pose', tips: 'Sit back on heels, reach arms forward, relax and breathe' },
      
      // Olympic Lifts (Advanced)
      { id: 'clean_and_press', name: 'üèãÔ∏è‚Äç‚ôÄÔ∏è Clean & Press', tips: 'Explosive hip drive, catch in front rack, press overhead' },
      { id: 'snatch', name: 'üèãÔ∏è Snatch', tips: 'Wide grip, explosive pull, catch overhead in squat position' },
      { id: 'clean_and_jerk', name: 'üèãÔ∏è‚Äç‚ôÇÔ∏è Clean & Jerk', tips: 'Clean to front rack, dip and drive, split or squat jerk' }
    ];

      // Persist formAnalysis to localStorage
      useEffect(() => {
        if (formAnalysis) {
          localStorage.setItem('formAnalysis', JSON.stringify(formAnalysis));
        }
      }, [formAnalysis]);

      const resetAnalysis = () => {
        setVideoPreview(null);
        setFormAnalysis(null);
        setError(null);
        setRecordedChunks([]);
        setRecordingTime(0);
        localStorage.removeItem('formAnalysis');
        if (recordingTimerRef.current) {
          clearInterval(recordingTimerRef.current);
        }
      };

      const startCamera = async () => {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ 
            video: { facingMode: 'user' }, 
            audio: false 
          });
          if (videoRef.current) {
            videoRef.current.srcObject = stream;
          }
        } catch (err) {
          console.error('Camera access failed:', err);
          setError('Camera access denied. Please use file upload instead.');
        }
      };

      const startRecording = async () => {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ 
            video: { facingMode: 'user' }, 
            audio: false 
          });
          
          setIsRecording(true);
          
          // Wait for the video element to be rendered, then set the stream
          setTimeout(async () => {
            if (videoRef.current) {
              videoRef.current.srcObject = stream;
              try {
                await videoRef.current.play();
                console.log('Video preview started successfully');
              } catch (playError) {
                console.error('Video play failed:', playError);
              }
            }
          }, 100);
          
          const recorder = new MediaRecorder(stream);
          const chunks = [];
          
          recorder.ondataavailable = (event) => {
            if (event.data.size > 0) {
              chunks.push(event.data);
            }
          };
          
          recorder.onstop = () => {
            const blob = new Blob(chunks, { type: 'video/webm' });
            const videoUrl = URL.createObjectURL(blob);
            setVideoPreview(videoUrl);
            setRecordedChunks(chunks);
            stream.getTracks().forEach(track => track.stop());
            // Clear live preview
            if (videoRef.current) {
              videoRef.current.srcObject = null;
            }
            clearInterval(recordingTimerRef.current);
            analyzeForm(blob);
          };
          
          setMediaRecorder(recorder);
          recorder.start();
          
          // Start 10-second timer
          let timeLeft = 10;
          setRecordingTime(timeLeft);
          recordingTimerRef.current = setInterval(() => {
            timeLeft--;
            setRecordingTime(timeLeft);
            if (timeLeft <= 0) {
              stopRecording();
            }
          }, 1000);
          
        } catch (err) {
          console.error('Recording failed:', err);
          setError('Recording failed. Please try file upload instead.');
          setIsRecording(false);
        }
      };

      const stopRecording = () => {
        if (mediaRecorder && mediaRecorder.state === 'recording') {
          mediaRecorder.stop();
          setIsRecording(false);
          clearInterval(recordingTimerRef.current);
        }
      };

      // Enhanced multi-frame analysis defined within component scope
      const enhancedAnalyzeForm = async (videoBlob) => {
        setIsLoading(true);
        setError(null);
        try {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d', { willReadFrequently: true });
          const video = document.createElement('video');
          video.src = URL.createObjectURL(videoBlob);
          video.muted = true;
          video.playsInline = true;

          const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error('Video processing timeout')), 30000));

          const loadMeta = new Promise((resolve, reject) => {
            video.onloadedmetadata = () => resolve(true);
            video.onerror = () => reject(new Error('Failed to load video metadata'));
            try { video.load(); } catch (_) {}
          });

          await Promise.race([loadMeta, timeoutPromise]);
          if (!video.videoWidth || !video.videoHeight) throw new Error('Invalid video dimensions');

          const duration = Math.max(0.5, isFinite(video.duration) ? video.duration : 3);
          const times = Array.from({ length: 4 }, (_, i) => Math.min(duration - 0.1, Math.max(0.1, ((i + 1) / 5) * duration)));

          const seekTo = (t) => new Promise((resolve, reject) => {
            const onSeeked = () => { video.removeEventListener('seeked', onSeeked); resolve(true); };
            const onError = () => { video.removeEventListener('error', onError); reject(new Error('Failed to seek video')); };
            video.addEventListener('seeked', onSeeked, { once: true });
            video.addEventListener('error', onError, { once: true });
            try { video.currentTime = t; } catch (_) { reject(new Error('Seek failed')); }
          });

          const computeMetrics = (imageData, w, h) => {
            const data = imageData.data;
            const step = Math.max(1, Math.floor(Math.min(w, h) / 160));
            let sumL = 0, count = 0;
            const gray = new Float32Array(w * h);
            for (let y = 0; y < h; y += step) {
              for (let x = 0; x < w; x += step) {
                const idx = (y * w + x) * 4;
                const r = data[idx], g = data[idx + 1], b = data[idx + 2];
                const l = 0.299 * r + 0.587 * g + 0.114 * b;
                gray[y * w + x] = l;
                sumL += l; count++;
              }
            }
            const meanL = sumL / Math.max(1, count) / 255;
            let sharpSum = 0, sCount = 0;
            for (let y = step; y < h - step; y += step) {
              for (let x = step; x < w - step; x += step) {
                const rx = gray[y * w + (x + step)] - gray[y * w + (x - step)];
                const ry = gray[(y + step) * w + x] - gray[(y - step) * w + x];
                const mag = Math.abs(rx) + Math.abs(ry);
                sharpSum += mag; sCount++;
              }
            }
            const sharpness = (sharpSum / Math.max(1, sCount)) / 255;
            return { brightness: meanL, sharpness };
          };

          const captureFrame = () => {
            const maxSide = 640;
            const scale = Math.min(1, maxSide / Math.max(video.videoWidth, video.videoHeight));
            const w = Math.max(1, Math.floor(video.videoWidth * scale));
            const h = Math.max(1, Math.floor(video.videoHeight * scale));
            canvas.width = w; canvas.height = h;
            ctx.drawImage(video, 0, 0, w, h);
            const imgData = ctx.getImageData(0, 0, w, h);
            const { brightness, sharpness } = computeMetrics(imgData, w, h);
            const base64 = canvas.toDataURL('image/jpeg', 0.7).split(',')[1];
            return { base64, brightness, sharpness, w, h };
          };

          const frames = [];
          for (const t of times) {
            try {
              await Promise.race([seekTo(t), timeoutPromise]);
              frames.push({ t, ...captureFrame() });
            } catch (e) { console.warn('Frame capture failed at', t, e); }
          }
          if (frames.length === 0) {
            await Promise.race([seekTo(Math.min(duration / 2, duration - 0.1)), timeoutPromise]);
            frames.push({ t: duration / 2, ...captureFrame() });
          }

          const scored = frames.map(f => ({
            ...f,
            quality: f.sharpness * 0.8 + (1 - Math.abs(f.brightness - 0.55)) * 0.2
          }))
          .sort((a, b) => b.quality - a.quality)
          .slice(0, Math.min(3, frames.length));

          const selectedExerciseData = exercises.find(ex => ex.id === selectedExercise);
          if (!selectedExerciseData) throw new Error('No exercise selected');

          const prompt = `You will analyze multiple frames from a video of a ${selectedExerciseData.name} exercise.\n\nUse the sequence to judge posture, joint angles, and safety across the movement. Do not penalize for limited visible motion per frame; consider consistency across frames. If visibility is partial or lighting is poor, avoid overly low scores‚Äîprovide constructive feedback instead.\n\nFocus on:\n1. Body alignment and posture\n2. Joint positioning and angles\n3. Common mistakes to avoid\n4. Specific improvements for better form\n5. Safety considerations\n6. Reference relevant FitMate features (e.g., Workout Planner videos for ${selectedExerciseData.name})\n\nRespond ONLY with a valid JSON object in this exact format:\n{\n  "exercise_detected": "${selectedExerciseData.name}",\n  "overall_score": 1-10,\n  "form_analysis": {\n    "posture": "...",\n    "technique": "...",\n    "safety": "..."\n  },\n  "feedback": {\n    "positive_points": ["..."],\n    "improvements": ["..."],\n    "tips": ["..."]\n  },\n  "next_steps": "..."\n}`;

          const contentImages = scored.map(s => ({ type: 'image_url', image_url: `data:image/jpeg;base64,${s.base64}` }));

          const response = await fetch(getDirectGeminiConfig().url, {
            method: 'POST',
            headers: getDirectGeminiConfig().headers,
            body: JSON.stringify({
              model: OPENROUTER_QWEN_VL_MODEL,
              messages: [{
                role: 'user',
                content: [
                  { type: 'text', text: prompt },
                  ...contentImages
                ]
              }]
            })
          });
          if (!response.ok) {
            const errorText = await response.text();
            console.error('API Error Response:', errorText);
            throw new Error(`API Error: ${response.status} ${response.statusText}`);
          }
          const result = await response.json();
          const textResponse = (result.choices?.[0]?.message?.content || '');
          if (!textResponse) throw new Error('Invalid API response format');

          let jsonString = textResponse.replace(/```json|```/g, '').trim();
          if (jsonString.includes('```')) {
            const jsonMatchMd = jsonString.match(/```(?:json)?\s*({[\s\S]*?})\s*```/);
            if (jsonMatchMd) jsonString = jsonMatchMd[1];
          }
          const jsonMatch = jsonString.match(/{[\s\S]*}/);
          if (jsonMatch) jsonString = jsonMatch[0];
          const data = JSON.parse(jsonString);

          if (!data.overall_score && data.overall_score !== 0) data.overall_score = 3;
          if (!data.form_analysis) {
            data.form_analysis = {
              posture: data.posture || 'Unable to analyze posture from this video.',
              technique: data.technique || 'Unable to assess technique from this video.',
              safety: data.safety || 'Please ensure proper form and safety when exercising.'
            };
          }
          if (!data.feedback) {
            data.feedback = {
              positive_points: data.positive_points || [],
              improvements: data.improvements || ['Please upload a clearer video showing the full exercise movement'],
              tips: data.tips || ['Ensure good lighting and clear view of your full body', 'Upload from a side or slightly angled perspective']
            };
          }
          if (data.exercise_detected && data.exercise_detected.toLowerCase().includes('no ') && data.exercise_detected.toLowerCase().includes('detected')) {
            const sel = exercises.find(ex => ex.id === selectedExercise);
            data.exercise_detected = sel ? sel.name : 'Exercise';
            data.overall_score = 2;
            data.feedback.improvements = [
              'The selected exercise was not clearly visible in the video',
              'Please ensure your full body is visible in the frame',
              'Use a side angle for clearer joint visibility',
              'Ensure adequate lighting and a clear background'
            ];
            data.feedback.tips = [
              'Place camera 6-8 feet away to capture full body',
              'Avoid backlighting; face the light source',
              'Perform the movement slowly with full range of motion',
              'Keep the camera stable at chest height'
            ];
            data.next_steps = 'Please upload another video with better positioning and lighting for accurate form analysis.';
          }
          if (!data.next_steps) data.next_steps = 'Continue practicing with proper form and consider uploading from different angles for comprehensive analysis.';
          setFormAnalysis(data);
          try { localStorage.setItem('formAnalysis', JSON.stringify(data)); } catch (_) {}
          try { if (user && syncAIContent) await syncAIContent('formAnalysis', data); } catch (e) { console.warn('Sync formAnalysis failed:', e); }
        } catch (err) {
          console.error('Enhanced form analysis failed, falling back to single-frame:', err);
          try {
            await analyzeForm(videoBlob);
            return;
          } catch (fallbackErr) {
            console.error('Fallback analyzeForm also failed:', fallbackErr);
            setError('Could not analyze form. Please upload a clearer video.');
          }
        } finally {
          setIsLoading(false);
        }
      };

      const handleVideoUpload = (e) => {
        const file = e.target.files[0];
        if (file) {
          const videoUrl = URL.createObjectURL(file);
          setVideoPreview(videoUrl);
          setFormAnalysis(null);
          setError(null);
          enhancedAnalyzeForm(file);
        }
      };

      const analyzeForm = async (videoBlob) => {
        setIsLoading(true);
        setError(null);
        
        try {
          // For video analysis, we'll extract a frame and analyze it
          const canvas = document.createElement('canvas');
          const video = document.createElement('video');
          
          // Add timeout promise to prevent hanging
          const timeoutPromise = new Promise((_, reject) => {
            setTimeout(() => reject(new Error('Video processing timeout')), 30000);
          });
          
          const processVideo = new Promise((resolve, reject) => {
            video.src = URL.createObjectURL(videoBlob);
            video.muted = true; // Ensure video can play
            
            video.onloadedmetadata = async () => {
              try {
                console.log('Video metadata loaded:', {
                  duration: video.duration,
                  width: video.videoWidth,
                  height: video.videoHeight
                });
                
                // Validate video dimensions
                if (!video.videoWidth || !video.videoHeight) {
                  throw new Error('Invalid video dimensions');
                }
                
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                
                // Seek to middle of video for analysis
                const seekTime = Math.min(video.duration / 2, 5); // Max 5 seconds in
                video.currentTime = seekTime;
                
                video.onseeked = async () => {
                  try {
                    const ctx = canvas.getContext('2d', { willReadFrequently: true });
                    ctx.drawImage(video, 0, 0);
                    
                    // Validate canvas has content
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const hasContent = imageData.data.some(pixel => pixel !== 0);
                    
                    if (!hasContent) {
                      throw new Error('Failed to capture video frame');
                    }
                    
                    // Convert canvas to base64
                    const base64ImageData = canvas.toDataURL('image/jpeg', 0.8).split(',')[1];
                    
                    if (!base64ImageData) {
                      throw new Error('Failed to convert image to base64');
                    }
                    
                    const selectedExerciseData = exercises.find(ex => ex.id === selectedExercise);
                    
                    if (!selectedExerciseData) {
                      throw new Error('No exercise selected');
                    }
                    
                    console.log('Sending analysis request for:', selectedExerciseData.name);
                    
                    const prompt = `Analyze this image of someone performing a ${selectedExerciseData.name} exercise. You are an AI Form Coach with comprehensive knowledge of the FitMate app and all its features.

Even if the exercise is not clearly visible or the person is not performing the expected exercise, provide constructive feedback and guide them to relevant app features.

**APP CONTEXT AWARENESS:**
üìä Dashboard: Users can track workout progress and health scores
üèãÔ∏è Workout Planner: 15+ exercises with video guides (Burpee, Inchworm, Jumping Jack, Military Push Ups, Reverse Crunches, etc.)
üé• Exercise Videos: Reference specific exercises from the workout database for comparison
ü§ñ AI Health Coach: Available for additional fitness guidance and motivation
üë§ Profile: Users can adjust fitness goals and track improvements

Provide detailed form analysis and feedback. Focus on:
1. Body alignment and posture (if visible)
2. Joint positioning and angles (if visible) 
3. Common mistakes to avoid
4. Specific improvements for better form
5. Safety considerations
6. **Reference relevant app features** (e.g., "Check the ${selectedExerciseData.name} video in Workout Planner")

If the exercise is not clearly visible, focus on video recording tips and guide them to the Workout Planner for proper exercise demonstrations.

Respond ONLY with a valid JSON object in this format:
{
  "exercise_detected": "${selectedExerciseData.name}",
  "overall_score": 1-10,
  "form_analysis": {
    "posture": "Analysis of overall posture and alignment or recording feedback with app feature references",
    "technique": "Assessment of exercise technique with references to Workout Planner videos",
    "safety": "Safety considerations and injury prevention tips"
  },
  "feedback": {
    "positive_points": ["What they're doing well or encouraging notes"],
    "improvements": ["Specific areas to improve with app feature suggestions"],
    "tips": ["Actionable tips referencing app features like exercise videos or AI Coach"]
  },
  "next_steps": "Recommendations for progression, modification, or app feature usage (Dashboard tracking, Workout Planner, etc.)"
}`;

                    const payload = {
                      contents: [
                        {
                          parts: [
                            { text: prompt },
                            { inlineData: { mimeType: 'image/jpeg', data: base64ImageData } }
                          ]
                        }
                      ],
                    };

                    const response = await fetch(getDirectGeminiConfig().url, {
                      method: 'POST',
                      headers: getDirectGeminiConfig().headers,
                      body: JSON.stringify({
                        model: OPENROUTER_QWEN_VL_MODEL,
                        messages: [{
                          role: 'user',
                          content: [
                            { type: 'text', text: prompt },
                            { type: 'image_url', image_url: `data:image/jpeg;base64,${base64ImageData}` }
                          ]
                        }]
                      })
                    });

                    if (!response.ok) {
                      const errorText = await response.text();
                      console.error('API Error Response:', errorText);
                      throw new Error(`API Error: ${response.status} ${response.statusText}`);
                    }

                    const result = await response.json();
                    console.log('API Response:', result);
                    
                    const textResponse = (result.choices?.[0]?.message?.content || '');
                    if (!textResponse) {
                      throw new Error('Invalid API response format');
                    }
                    
                    console.log('Raw AI Response:', textResponse);
                    
                    // Clean and parse JSON response
                    let jsonString = textResponse.replace(/```json|```/g, '').trim();
                    
                    // Handle potential markdown formatting
                    if (jsonString.includes('```')) {
                      const jsonMatch = jsonString.match(/```(?:json)?\s*({[\s\S]*?})\s*```/);
                      if (jsonMatch) {
                        jsonString = jsonMatch[1];
                      }
                    }
                    
                    // Find JSON object if wrapped in text
                    const jsonMatch = jsonString.match(/{[\s\S]*}/);
                    if (jsonMatch) {
                      jsonString = jsonMatch[0];
                    }
                    
                    console.log('Parsed JSON String:', jsonString);
                    
                    const data = JSON.parse(jsonString);
                    
                    // Updated validation - more flexible for "no exercise detected" cases
                    if (!data.overall_score && data.overall_score !== 0) {
                      // If no score provided, set a default low score
                      data.overall_score = 3;
                    }

                    // Ensure form_analysis exists with defaults
                    if (!data.form_analysis) {
                      data.form_analysis = {
                        posture: data.posture || "Unable to analyze posture from this video.",
                        technique: data.technique || "Unable to assess technique from this video.", 
                        safety: data.safety || "Please ensure proper form and safety when exercising."
                      };
                    }

                    // Ensure feedback exists with defaults
                    if (!data.feedback) {
                      data.feedback = {
                        positive_points: data.positive_points || [],
                        improvements: data.improvements || ["Please record a clearer video showing the full exercise movement"],
                        tips: data.tips || ["Ensure good lighting and clear view of your full body", "Record from a side or slightly angled perspective"]
                      };
                    }

                    // Handle "No [Exercise] Detected" cases
                    if (data.exercise_detected && data.exercise_detected.toLowerCase().includes('no ') && data.exercise_detected.toLowerCase().includes('detected')) {
                      const selectedExerciseData = exercises.find(ex => ex.id === selectedExercise);
                      data.exercise_detected = selectedExerciseData ? selectedExerciseData.name : 'Exercise';
                      data.overall_score = 2; // Low score for undetected exercise
                      
                      // Provide helpful feedback for undetected exercises
                      data.feedback.improvements = [
                        "The selected exercise was not clearly visible in the video",
                        "Please ensure your full body is visible in the frame", 
                        "Record from a side angle for better form analysis",
                        "Make sure lighting is adequate and background is clear"
                      ];
                      
                      data.feedback.tips = [
                        "Position camera 6-8 feet away to capture full body",
                        "Use good lighting - avoid backlighting",
                        "Perform the exercise slowly and with full range of motion",
                        "Ensure the camera is stable and at chest height"
                      ];
                      
                      data.next_steps = "Please re-record the video with better positioning and lighting for accurate form analysis.";
                    }

                    // Ensure next_steps exists
                    if (!data.next_steps) {
                      data.next_steps = "Continue practicing with proper form and consider recording from different angles for comprehensive analysis.";
                    }
                    
                    console.log('Analysis completed successfully:', data);
                    setFormAnalysis(data);
                    try { localStorage.setItem('formAnalysis', JSON.stringify(data)); } catch (_) {}
                    try { if (user && syncAIContent) await syncAIContent('formAnalysis', data); } catch (e) { console.warn('Sync formAnalysis failed:', e); }
                    resolve(data);
                    
                  } catch (seekError) {
                    console.error('Seek error:', seekError);
                    reject(seekError);
                  }
                };
                
                video.onerror = (e) => {
                  console.error('Video seek error:', e);
                  reject(new Error('Failed to seek video'));
                };
                
              } catch (metadataError) {
                console.error('Metadata error:', metadataError);
                reject(metadataError);
              }
            };
            
            video.onerror = (e) => {
              console.error('Video load error:', e);
              reject(new Error('Failed to load video'));
            };
            
            // Ensure video loads
            video.load();
          });
          
          // Race between processing and timeout
          await Promise.race([processVideo, timeoutPromise]);
          
        } catch (err) {
          console.error('Form analysis failed:', err);
          
          // Provide specific error messages
          let errorMessage = 'Could not analyze the form or prompt limit reached. ';
          
          if (err.message.includes('timeout')) {
            errorMessage += 'Video processing timed out. Please try a shorter video.';
          } else if (err.message.includes('dimensions')) {
            errorMessage += 'Invalid video format. Please upload a new video.';
          } else if (err.message.includes('API Error')) {
            errorMessage += 'Try again, or sign in, or subscribe to continue.';
          } else if (err.message.includes('JSON')) {
            errorMessage += 'Analysis failed to complete. Please try again.';
          } else {
            errorMessage += 'Please try again with a clearer video.';
          }
          
          setError(errorMessage);
        } finally {
          setIsLoading(false);
        }
      };

      return (
        <div className="p-6 pb-24">
          <header className="mb-6 text-center">
            <h1 className="text-2xl font-bold text-gray-800 dark:text-gray-200">üèãÔ∏è AI Form Coach</h1>
            <p className="text-gray-500 dark:text-gray-400">Perfect your technique with AI feedback</p>
          </header>

          {!videoPreview && (
            <div className="max-w-md mx-auto">
              {/* Exercise Selection */}
              <div className="bg-white dark:bg-gray-800 p-4 rounded-2xl shadow-md mb-4">
                <h3 className="font-semibold text-gray-800 dark:text-gray-200 mb-3">Select Exercise:</h3>
                <div className="grid grid-cols-2 gap-2">
                  {exercises.map(exercise => (
                    <button
                      key={exercise.id}
                      onClick={() => setSelectedExercise(exercise.id)}
                      className={`p-3 rounded-lg border text-sm ${
                        selectedExercise === exercise.id
                          ? 'bg-purple-500 text-white border-purple-500'
                          : 'bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200 border-gray-300 dark:border-gray-600'
                      }`}
                    >
                      {exercise.name}
                    </button>
                  ))}
                </div>
                {selectedExercise && (
                  <div className="mt-3 p-3 bg-purple-50 dark:bg-purple-900/20 rounded-lg">
                    <p className="text-sm text-purple-700 dark:text-purple-300">
                      üí° {exercises.find(ex => ex.id === selectedExercise)?.tips}
                    </p>
                  </div>
                )}
              </div>

              <div className="bg-white dark:bg-gray-800 p-8 rounded-2xl shadow-md text-center">
                <div className="mb-6">
                  <div className="w-24 h-24 mx-auto mb-4 bg-gradient-to-br from-purple-400 to-pink-500 rounded-full flex items-center justify-center">
                    <span className="text-4xl">üé•</span>
                  </div>
                  <h3 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-2">Upload Your Form</h3>
                 <p className="text-gray-600 dark:text-gray-400 mb-6">Upload a short video of your exercise and get instant AI feedback on your form!</p>
                </div>
                
                {/* Upload Controls (Recording temporarily disabled) */}
                <div className="space-y-4">
                  <input
                    type="file"
                    accept="video/*"
                    onChange={handleVideoUpload}
                    ref={fileInputRef}
                    className="hidden"
                  />
                  <button
                    onClick={() => fileInputRef.current?.click()}
                    className="w-full bg-gray-500 text-white font-bold py-3 rounded-2xl shadow-lg hover:bg-gray-600 transition-all"
                  >
                    üìÅ Upload Video
                  </button>
                </div>
                
                <div className="mt-6 p-4 bg-purple-50 dark:bg-purple-900/20 rounded-xl">
                  <h4 className="font-semibold text-purple-800 dark:text-purple-200 mb-2">üìã Uploading Tips:</h4>
                  <ul className="text-sm text-purple-700 dark:text-purple-300 space-y-1">
                    <li>‚Ä¢ Position camera to show full body</li>
                    <li>‚Ä¢ Perform 2-3 reps of the exercise</li>
                    <li>‚Ä¢ Ensure good lighting and clear view</li>
                    <li>‚Ä¢ Keep movements slow and controlled</li>
                  </ul>
                </div>
              </div>
            </div>
          )}

          {!videoPreview && formAnalysis && (
            <div className="max-w-md mx-auto mt-6">
              <div className="bg-white dark:bg-gray-800 rounded-2xl shadow-md overflow-hidden">
                <div className="p-6">
                  <div className="flex justify-between items-center mb-4">
                    <h3 className="font-bold text-gray-800 dark:text-gray-200">üéØ Last Form Analysis</h3>
                    <button onClick={resetAnalysis} className="text-purple-500 font-semibold text-sm">Clear</button>
                  </div>

                  <div className="mb-6 text-center">
                    <div className={`inline-flex items-center justify-center w-20 h-20 rounded-full text-2xl font-bold ${
                      formAnalysis.overall_score >= 8
                        ? 'bg-green-100 text-green-600 dark:bg-green-900/20 dark:text-green-400'
                        : formAnalysis.overall_score >= 6
                        ? 'bg-yellow-100 text-yellow-600 dark:bg-yellow-900/20 dark:text-yellow-400'
                        : 'bg-red-100 text-red-600 dark:bg-red-900/20 dark:text-red-400'
                    }`}>
                      {formAnalysis.overall_score}/10
                    </div>
                    <p className="text-sm text-gray-600 dark:text-gray-400 mt-2">Form Score</p>
                  </div>

                  <div className="space-y-4 mb-6">
                    <div className="bg-blue-50 dark:bg-blue-900/20 p-4 rounded-lg">
                      <h4 className="font-semibold text-blue-800 dark:text-blue-200 mb-2">üìê Posture Analysis</h4>
                      <p className="text-sm text-blue-700 dark:text-blue-300">{formAnalysis.form_analysis.posture}</p>
                    </div>

                    <div className="bg-purple-50 dark:bg-purple-900/20 p-4 rounded-lg">
                      <h4 className="font-semibold text-purple-800 dark:text-purple-200 mb-2">‚ö° Technique</h4>
                      <p className="text-sm text-purple-700 dark:text-purple-300">{formAnalysis.form_analysis.technique}</p>
                    </div>

                    <div className="bg-orange-50 dark:bg-orange-900/20 p-4 rounded-lg">
                      <h4 className="font-semibold text-orange-800 dark:text-orange-200 mb-2">üõ°Ô∏è Safety</h4>
                      <p className="text-sm text-orange-700 dark:text-orange-300">{formAnalysis.form_analysis.safety}</p>
                    </div>
                  </div>

                  {formAnalysis.feedback?.positive_points?.length > 0 && (
                    <div className="mb-4">
                      <h4 className="font-semibold text-green-600 dark:text-green-400 mb-2">‚úÖ What You're Doing Well:</h4>
                      <ul className="space-y-1">
                        {formAnalysis.feedback.positive_points.map((point, index) => (
                          <li key={index} className="text-sm text-gray-600 dark:text-gray-400 flex items-start">
                            <span className="text-green-500 mr-2">‚Ä¢</span>
                            {point}
                          </li>
                        ))}
                      </ul>
                    </div>
                  )}

                  {formAnalysis.feedback?.improvements?.length > 0 && (
                    <div className="mb-4">
                      <h4 className="font-semibold text-yellow-600 dark:text-yellow-400 mb-2">üéØ Areas to Improve:</h4>
                      <ul className="space-y-1">
                        {formAnalysis.feedback.improvements.map((improvement, index) => (
                          <li key={index} className="text-sm text-gray-600 dark:text-gray-400 flex items-start">
                            <span className="text-yellow-500 mr-2">‚Ä¢</span>
                            {improvement}
                          </li>
                        ))}
                      </ul>
                    </div>
                  )}

                  {formAnalysis.feedback?.tips?.length > 0 && (
                    <div className="mb-4">
                      <h4 className="font-semibold text-purple-600 dark:text-purple-400 mb-2">üí° Pro Tips:</h4>
                      <ul className="space-y-1">
                        {formAnalysis.feedback.tips.map((tip, index) => (
                          <li key={index} className="text-sm text-gray-600 dark:text-gray-400 flex items-start">
                            <span className="text-purple-500 mr-2">‚Ä¢</span>
                            {tip}
                          </li>
                        ))}
                      </ul>
                    </div>
                  )}

                  {formAnalysis.next_steps && (
                    <div className="bg-gray-50 dark:bg-gray-700 p-4 rounded-lg">
                      <h4 className="font-semibold text-gray-800 dark:text-gray-200 mb-2">üöÄ Next Steps:</h4>
                      <p className="text-sm text-gray-600 dark:text-gray-400">{formAnalysis.next_steps}</p>
                    </div>
                  )}
                </div>
              </div>
            </div>
          )}

          {videoPreview && (
            <div className="max-w-md mx-auto">
              <div className="bg-white dark:bg-gray-800 rounded-2xl shadow-md overflow-hidden">
                <video 
                  src={videoPreview} 
                  controls 
                  className="w-full h-64 object-cover"
                  poster="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='100' height='100'%3E%3Crect width='100' height='100' fill='%23f3f4f6'/%3E%3Ctext x='50%25' y='50%25' text-anchor='middle' dy='.3em' fill='%236b7280'%3EVideo%3C/text%3E%3C/svg%3E"
                />
                
                {isLoading && (
                  <div className="p-6 text-center">
                    <div className="animate-spin w-8 h-8 border-4 border-purple-500 border-t-transparent rounded-full mx-auto mb-4"></div>
                    <p className="text-gray-600 dark:text-gray-400">Analyzing your form...</p>
                  </div>
                )}

                {error && (
                  <div className="p-6 text-center">
                    <p className="text-red-500 mb-4">{error}</p>
                    <button onClick={resetAnalysis} className="bg-gray-500 text-white px-4 py-2 rounded-lg">
                      Try Again
                    </button>
                  </div>
                )}

                {formAnalysis && (
                  <div className="p-6">
                    <div className="flex justify-between items-center mb-4">
                      <h3 className="font-bold text-gray-800 dark:text-gray-200">üéØ Form Analysis</h3>
                      <button onClick={resetAnalysis} className="text-purple-500 font-semibold text-sm">
                        ‚Üê New Video
                      </button>
                    </div>
                    
                    {/* Overall Score */}
                    <div className="mb-6 text-center">
                      <div className={`inline-flex items-center justify-center w-20 h-20 rounded-full text-2xl font-bold ${
                        formAnalysis.overall_score >= 8 ? 'bg-green-100 text-green-600 dark:bg-green-900/20 dark:text-green-400' :
                        formAnalysis.overall_score >= 6 ? 'bg-yellow-100 text-yellow-600 dark:bg-yellow-900/20 dark:text-yellow-400' :
                        'bg-red-100 text-red-600 dark:bg-red-900/20 dark:text-red-400'
                      }`}>
                        {formAnalysis.overall_score}/10
                      </div>
                      <p className="text-sm text-gray-600 dark:text-gray-400 mt-2">Form Score</p>
                    </div>

                    {/* Form Analysis */}
                    <div className="space-y-4 mb-6">
                      <div className="bg-blue-50 dark:bg-blue-900/20 p-4 rounded-lg">
                        <h4 className="font-semibold text-blue-800 dark:text-blue-200 mb-2">üìê Posture Analysis</h4>
                        <p className="text-sm text-blue-700 dark:text-blue-300">{formAnalysis.form_analysis.posture}</p>
                      </div>
                      
                      <div className="bg-purple-50 dark:bg-purple-900/20 p-4 rounded-lg">
                        <h4 className="font-semibold text-purple-800 dark:text-purple-200 mb-2">‚ö° Technique</h4>
                        <p className="text-sm text-purple-700 dark:text-purple-300">{formAnalysis.form_analysis.technique}</p>
                      </div>
                      
                      <div className="bg-orange-50 dark:bg-orange-900/20 p-4 rounded-lg">
                        <h4 className="font-semibold text-orange-800 dark:text-orange-200 mb-2">üõ°Ô∏è Safety</h4>
                        <p className="text-sm text-orange-700 dark:text-orange-300">{formAnalysis.form_analysis.safety}</p>
                      </div>
                    </div>

                    {/* Positive Feedback */}
                    {formAnalysis.feedback.positive_points && formAnalysis.feedback.positive_points.length > 0 && (
                      <div className="mb-4">
                        <h4 className="font-semibold text-green-600 dark:text-green-400 mb-2">‚úÖ What You're Doing Well:</h4>
                        <ul className="space-y-1">
                          {formAnalysis.feedback.positive_points.map((point, index) => (
                            <li key={index} className="text-sm text-gray-600 dark:text-gray-400 flex items-start">
                              <span className="text-green-500 mr-2">‚Ä¢</span>
                              {point}
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}

                    {/* Improvements */}
                    {formAnalysis.feedback.improvements && formAnalysis.feedback.improvements.length > 0 && (
                      <div className="mb-4">
                        <h4 className="font-semibold text-yellow-600 dark:text-yellow-400 mb-2">üéØ Areas to Improve:</h4>
                        <ul className="space-y-1">
                          {formAnalysis.feedback.improvements.map((improvement, index) => (
                            <li key={index} className="text-sm text-gray-600 dark:text-gray-400 flex items-start">
                              <span className="text-yellow-500 mr-2">‚Ä¢</span>
                              {improvement}
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}

                    {/* Tips */}
                    {formAnalysis.feedback.tips && formAnalysis.feedback.tips.length > 0 && (
                      <div className="mb-4">
                        <h4 className="font-semibold text-purple-600 dark:text-purple-400 mb-2">üí° Pro Tips:</h4>
                        <ul className="space-y-1">
                          {formAnalysis.feedback.tips.map((tip, index) => (
                            <li key={index} className="text-sm text-gray-600 dark:text-gray-400 flex items-start">
                              <span className="text-purple-500 mr-2">‚Ä¢</span>
                              {tip}
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}

                    {/* Next Steps */}
                    {formAnalysis.next_steps && (
                      <div className="bg-gray-50 dark:bg-gray-700 p-4 rounded-lg">
                        <h4 className="font-semibold text-gray-800 dark:text-gray-200 mb-2">üöÄ Next Steps:</h4>
                        <p className="text-sm text-gray-600 dark:text-gray-400">{formAnalysis.next_steps}</p>
                      </div>
                    )}
                  </div>
                )}
              </div>
            </div>
          )}
        </div>
      );
    };

    // Workout Planner Screen Component
    const WorkoutPlanner = ({ workoutPlan, setWorkoutPlan, isLoading, setIsLoading, error, setError, setScreen }) => {
      const [activeTab, setActiveTab] = useState(() => localStorage.getItem('workoutPlanner_activeTab') || 'planner'); // 'planner', 'coach', or 'exercises'
      const [exercisesMode, setExercisesMode] = useState('cards');
      const [pendingWorkoutIndex, setPendingWorkoutIndex] = useState(null);
      // Persist active tab to localStorage so we remember last selected tab
      useEffect(() => {
        try {
          if (typeof setLocalStorageWithSync === 'function') {
            setLocalStorageWithSync('workoutPlanner_activeTab', activeTab);
          } else {
            localStorage.setItem('workoutPlanner_activeTab', activeTab);
          }
        } catch (e) {
          // ignore storage errors
        }
      }, [activeTab]);

      useEffect(() => {
        if (activeTab !== 'exercises') setExercisesMode('cards');
      }, [activeTab]);
      const [preferences, setPreferences] = useState({ goal: '', type: '', level: '', equipment: [] });
      const [selectedExercise, setSelectedExercise] = useState(null);
      const [currentSet, setCurrentSet] = useState(1);
      const [completedSets, setCompletedSets] = useState({});
      
      // Workout Session State Management
      const [workoutSession, setWorkoutSession] = useState({
        isActive: false,
        isPaused: false,
        currentExerciseIndex: 0,
        currentSet: 1,
        exerciseTime: 0,
        restTime: 0,
        totalTime: 0,
        isResting: false,
        completedExercises: [],
        sessionExercises: []
      });
      const [workoutTimer, setWorkoutTimer] = useState(null);
      const [audioEnabled, setAudioEnabled] = useState(true);
      const [voiceInstructions, setVoiceInstructions] = useState(true);
      const videoRef = useRef(null);
      const speechSynthesis = window.speechSynthesis;

      // Size the exercises iframe to the remaining viewport
      // (viewport height - wrapper top - bottom nav height) and lock outer scroll.
      useEffect(() => {
        const updateHeight = () => {
          try {
            const iframe = document.getElementById('workout-iframe');
            const wrapper = document.getElementById('exercises-wrapper');
            const nav = document.getElementById('bottom-nav');
            if (!iframe || !wrapper) return;
            const rect = wrapper.getBoundingClientRect();
            const navHeight = (nav && nav.offsetHeight) ? nav.offsetHeight : 80;
            const available = Math.max(240, Math.floor(window.innerHeight - rect.top - navHeight));
            iframe.style.height = `${available}px`;
          } catch (_) {}
        };

        if (activeTab === 'exercises' && exercisesMode === 'iframe') {
          try {
            const host = document.getElementById('exercises-host');
            let iframe = document.getElementById('workout-iframe');
            if (!iframe) {
              const preload = document.getElementById('workout-preload');
              if (preload) {
                iframe = preload;
                iframe.id = 'workout-iframe';
                iframe.removeAttribute('style');
              } else {
                iframe = document.createElement('iframe');
                iframe.loading = 'eager';
                iframe.id = 'workout-iframe';
              }
              iframe.className = 'w-full border-0';
              try { iframe.setAttribute('allow','autoplay'); } catch(_) {}
              if (!iframe.src) iframe.src = './workout.html';
            }
            if (host && iframe.parentElement !== host) host.appendChild(iframe);

            if (pendingWorkoutIndex !== null && pendingWorkoutIndex !== undefined) {
              const idx = Number(pendingWorkoutIndex);
              if (Number.isFinite(idx) && idx >= 0) {
                let handled = false;
                try {
                  const href = iframe.contentWindow && iframe.contentWindow.location ? String(iframe.contentWindow.location.href || '') : '';
                  if (/workout\.html/i.test(href)) {
                    iframe.contentWindow.location.hash = `#workout=${idx}`;
                    handled = true;
                  }
                } catch (_) {}
                if (!handled) {
                  try { iframe.src = `./workout.html#workout=${idx}`; } catch (_) {}
                }
              }
              try { setPendingWorkoutIndex(null); } catch (_) {}
            }
          } catch (_) {}

          updateHeight();
          window.addEventListener('resize', updateHeight);
          window.addEventListener('orientationchange', updateHeight);
          try {
            document.documentElement.style.overflow = 'hidden';
            document.body.style.overflow = 'hidden';
          } catch (_) {}
        } else {
          try {
            document.documentElement.style.overflow = '';
            document.body.style.overflow = '';
          } catch (_) {}
        }

        return () => {
          window.removeEventListener('resize', updateHeight);
          window.removeEventListener('orientationchange', updateHeight);
          try {
            document.documentElement.style.overflow = '';
            document.body.style.overflow = '';
          } catch (_) {}
        };
      }, [activeTab, exercisesMode, pendingWorkoutIndex]);

      // Exercise database with video files from animations folder
      const exerciseDatabase = [
        {
          id: 1,
          name: 'Burpee and Jump',
          category: 'Full Body',
          difficulty: 'Advanced',
          sets: 3,
          reps: '8-12',
          duration: '45s',
          video: './animations/Burpee and Jump Exercise (1).mp4',
          muscles: ['Full Body', 'Cardio'],
          instructions: 'Start in standing position, drop to squat, kick back to plank, do push-up, jump feet back to squat, then jump up with arms overhead.'
        },
        {
          id: 2,
          name: 'Inchworm',
          category: 'Core',
          difficulty: 'Intermediate',
          sets: 3,
          reps: '10-15',
          duration: '30s',
          video: './animations/Inchworm.mp4',
          muscles: ['Core', 'Shoulders', 'Hamstrings'],
          instructions: 'Stand with feet hip-width apart, bend forward and walk hands out to plank position, then walk feet toward hands.'
        },
        {
          id: 3,
          name: 'Jumping Jack',
          category: 'Cardio',
          difficulty: 'Beginner',
          sets: 3,
          reps: '20-30',
          duration: '30s',
          video: './animations/Jumping Jack.mp4',
          muscles: ['Full Body', 'Cardio'],
          instructions: 'Jump feet apart while raising arms overhead, then jump back to starting position with arms at sides.'
        },
        {
          id: 4,
          name: 'Military Push Ups',
          category: 'Upper Body',
          difficulty: 'Intermediate',
          sets: 3,
          reps: '8-15',
          duration: '45s',
          video: './animations/Military Push Ups.mp4',
          muscles: ['Chest', 'Triceps', 'Shoulders'],
          instructions: 'Start in plank position with hands shoulder-width apart, lower body until chest nearly touches ground, push back up.'
        },
        {
          id: 5,
          name: 'Reverse Crunches',
          category: 'Core',
          difficulty: 'Beginner',
          sets: 3,
          reps: '12-20',
          duration: '30s',
          video: './animations/Reverse Crunches.mp4',
          muscles: ['Lower Abs', 'Core'],
          instructions: 'Lie on back with knees bent, lift hips off ground by contracting abs, slowly lower back down.'
        },
        {
          id: 6,
          name: 'Seated Abs Circles',
          category: 'Core',
          difficulty: 'Beginner',
          sets: 3,
          reps: '10 each direction',
          duration: '30s',
          video: './animations/Seated abs circles.mp4',
          muscles: ['Core', 'Obliques'],
          instructions: 'Sit with knees bent, lean back slightly, make circular motions with your torso while keeping core engaged.'
        },
        {
          id: 7,
          name: 'Single Leg Hip Rotation',
          category: 'Lower Body',
          difficulty: 'Beginner',
          sets: 3,
          reps: '10 each leg',
          duration: '30s',
          video: './animations/Single Leg Hip Rotation.mp4',
          muscles: ['Hips', 'Glutes', 'Balance'],
          instructions: 'Stand on one leg, rotate the other leg in circular motions, focusing on hip mobility and balance.'
        },
        {
          id: 8,
          name: 'Split Jump',
          category: 'Lower Body',
          difficulty: 'Advanced',
          sets: 3,
          reps: '10-15',
          duration: '45s',
          video: './animations/Split Jump Exercise.mp4',
          muscles: ['Legs', 'Glutes', 'Cardio'],
          instructions: 'Start in lunge position, jump up and switch leg positions in mid-air, land softly in opposite lunge.'
        },
        {
          id: 9,
          name: 'Squat Reach',
          category: 'Lower Body',
          difficulty: 'Beginner',
          sets: 3,
          reps: '12-20',
          duration: '30s',
          video: './animations/Squat Reach.mp4',
          muscles: ['Quads', 'Glutes', 'Core'],
          instructions: 'Perform a squat while reaching arms forward for balance, return to standing with arms at sides.'
        },
        {
          id: 10,
          name: 'Squat Kicks',
          category: 'Lower Body',
          difficulty: 'Intermediate',
          sets: 3,
          reps: '10-15',
          duration: '45s',
          video: './animations/Squat kicks.mp4',
          muscles: ['Quads', 'Glutes', 'Core'],
          instructions: 'Perform a squat, then as you stand up, kick one leg forward, alternate legs with each rep.'
        }
      ];

      // Workout Session Management Functions
      const speakInstruction = (text) => {
        if (voiceInstructions && speechSynthesis) {
          speechSynthesis.cancel();
          const utterance = new SpeechSynthesisUtterance(text);
          utterance.rate = 0.9;
          utterance.pitch = 1;
          utterance.volume = 0.8;
          speechSynthesis.speak(utterance);
        }
      };

      const startWorkoutSession = (exercises) => {
        const sessionExercises = exercises.length > 0 ? exercises : exerciseDatabase.slice(0, 5);
        setWorkoutSession({
          isActive: true,
          isPaused: false,
          currentExerciseIndex: 0,
          currentSet: 1,
          exerciseTime: 0,
          restTime: 0,
          totalTime: 0,
          isResting: false,
          completedExercises: [],
          sessionExercises
        });
        speakInstruction(`Starting workout with ${sessionExercises.length} exercises. First exercise: ${sessionExercises[0].name}`);
        startTimer();
      };

      const pauseWorkoutSession = () => {
        setWorkoutSession(prev => {
          const newPaused = !prev.isPaused;
          
          // Handle video controls
          if (videoRef.current) {
            if (newPaused) {
              videoRef.current.pause();
            } else {
              videoRef.current.play();
            }
          }
          
          if (newPaused) {
            clearInterval(workoutTimer);
            speakInstruction('Workout paused');
          } else {
            startTimer();
            speakInstruction('Workout resumed');
          }
          
          return { ...prev, isPaused: newPaused };
        });
      };

      const nextExercise = () => {
        const { currentExerciseIndex, sessionExercises, currentSet } = workoutSession;
        const currentExercise = sessionExercises[currentExerciseIndex];
        
        if (currentSet < currentExercise.sets) {
          // Next set of current exercise
          setWorkoutSession(prev => ({
            ...prev,
            currentSet: prev.currentSet + 1,
            isResting: true,
            restTime: 0
          }));
          speakInstruction(`Set ${currentSet + 1} of ${currentExercise.sets}. Rest for 30 seconds`);
        } else if (currentExerciseIndex < sessionExercises.length - 1) {
          // Next exercise
          const nextExerciseIndex = currentExerciseIndex + 1;
          const nextExercise = sessionExercises[nextExerciseIndex];
          setWorkoutSession(prev => ({
            ...prev,
            currentExerciseIndex: nextExerciseIndex,
            currentSet: 1,
            exerciseTime: 0,
            isResting: false,
            completedExercises: [...prev.completedExercises, currentExerciseIndex]
          }));
          speakInstruction(`Next exercise: ${nextExercise.name}. ${nextExercise.instructions}`);
        } else {
          // Workout complete
          endWorkoutSession();
        }
      };

      const previousExercise = () => {
        const { currentExerciseIndex, sessionExercises, currentSet } = workoutSession;
        
        if (currentSet > 1) {
          // Previous set of current exercise
          setWorkoutSession(prev => ({
            ...prev,
            currentSet: prev.currentSet - 1,
            isResting: false
          }));
        } else if (currentExerciseIndex > 0) {
          // Previous exercise
          const prevExerciseIndex = currentExerciseIndex - 1;
          const prevExercise = sessionExercises[prevExerciseIndex];
          setWorkoutSession(prev => ({
            ...prev,
            currentExerciseIndex: prevExerciseIndex,
            currentSet: prevExercise.sets,
            exerciseTime: 0,
            isResting: false,
            completedExercises: prev.completedExercises.filter(i => i !== prevExerciseIndex)
          }));
          speakInstruction(`Previous exercise: ${prevExercise.name}`);
        }
      };

      const endWorkoutSession = async () => {
        clearInterval(workoutTimer);
        
        // Calculate workout metrics for health score integration
        const workoutData = {
          duration: Math.round(workoutSession.totalTime / 60), // Convert to minutes
          exercisesCompleted: workoutSession.completedExercises.length,
          totalExercises: workoutSession.sessionExercises.length,
          completionRate: (workoutSession.completedExercises.length / workoutSession.sessionExercises.length) * 100,
          timestamp: new Date().toISOString(),
          type: 'structured_workout'
        };
        
        // Log workout as activity minutes
        if (workoutData.duration > 0) {
          // handleLogActivity({ minutes: workoutData.duration }); // removed: workouts do not add activity points
          
          // Add timestamp to workout data
          const workoutWithTimestamp = {
            ...workoutData,
            timestamp: new Date().toISOString(),
            workout_title: workoutData.workoutTitle || 'Custom Workout',
            calories_burned: workoutData.caloriesBurned || 0,
            completion_rate: Math.round((workoutData.exercisesCompleted / workoutData.totalExercises) * 100) || 0
          };
          
          // Store workout history in local storage
          let workoutHistory;
          try {
            workoutHistory = JSON.parse(localStorage.getItem('workoutHistory') || '[]');
            if (!Array.isArray(workoutHistory)) {
              workoutHistory = [];
            }
          } catch (error) {
            console.warn('Error parsing workoutHistory in workout completion, resetting to empty array:', error);
            workoutHistory = [];
          }
          
          // Add new workout to the beginning of the array (most recent first)
          workoutHistory.unshift(workoutWithTimestamp);
          
          // Keep only last 100 workouts
          if (workoutHistory.length > 100) {
            workoutHistory = workoutHistory.slice(0, 100);
          }
          
          // Update local storage and state
          localStorage.setItem('workoutHistory', JSON.stringify(workoutHistory));
          if (setWorkoutHistory) {
            setWorkoutHistory(workoutHistory);
          }
          
          // Enable workout points for today's health score
          try {
            const todayISO = toLocalISODate(new Date());
            localStorage.setItem(`workoutScoreEnabled:${todayISO}`, '1');
            console.log('‚úÖ Workout points enabled for today:', todayISO);
          } catch (_) {}
          
          // Trigger health score recalculation
          window.dispatchEvent(new Event('workout-history-updated'));
          
          // Sync workout data to Supabase if user is logged in
          if (user && supabase) {
            try {
              const { error } = await supabase
                .from('workout_history')
                .upsert([{
                  ...workoutWithTimestamp,
                  user_id: user.id,
                  created_at: workoutWithTimestamp.timestamp
                }], { onConflict: 'user_id,timestamp' });
                
              if (error) throw error;
              console.log('‚úÖ Workout synced to Supabase');
            } catch (error) {
              console.error('Error syncing workout to Supabase:', error);
              // If sync fails, we'll try again on next sync
            }
          }
        }
        
        setWorkoutSession({
          isActive: false,
          isPaused: false,
          currentExerciseIndex: 0,
          currentSet: 1,
          exerciseTime: 0,
          restTime: 0,
          totalTime: 0,
          isResting: false,
          completedExercises: [],
          sessionExercises: []
        });
        
        const completionMessage = workoutData.completionRate === 100 
          ? `Workout completed! Great job! You completed all ${workoutData.totalExercises} exercises in ${workoutData.duration} minutes.`
          : `Workout session ended. You completed ${workoutData.exercisesCompleted} out of ${workoutData.totalExercises} exercises in ${workoutData.duration} minutes.`;
        
        speakInstruction(completionMessage);
      };

      const startTimer = () => {
        const timer = setInterval(() => {
          setWorkoutSession(prev => {
            if (prev.isPaused) return prev;
            
            const newState = { ...prev, totalTime: prev.totalTime + 1 };
            
            if (prev.isResting) {
              newState.restTime = prev.restTime + 1;
              const restDuration = 30; // 30 second rest between sets
              
              // Countdown for last 5 seconds of rest
              const restTimeLeft = restDuration - prev.restTime;
              if (restTimeLeft <= 5 && restTimeLeft > 0 && prev.restTime > 0) {
                speakInstruction(`${restTimeLeft}`);
              }
              
              if (prev.restTime >= restDuration) {
                newState.isResting = false;
                newState.restTime = 0;
                const currentExercise = prev.sessionExercises[prev.currentExerciseIndex];
                speakInstruction(`Set ${prev.currentSet} of ${currentExercise.sets}. Begin!`);
                // Resume video after rest
                if (videoRef.current) {
                  videoRef.current.currentTime = 0;
                  videoRef.current.play();
                }
              }
            } else {
              newState.exerciseTime = prev.exerciseTime + 1;
              const currentExercise = prev.sessionExercises[prev.currentExerciseIndex];
              const exerciseDuration = parseInt(currentExercise.duration) || 45;
              
              // Voice counting every 5 seconds during exercise
              if (prev.exerciseTime > 0 && prev.exerciseTime % 5 === 0 && prev.exerciseTime <= exerciseDuration - 10) {
                const count = Math.floor(prev.exerciseTime / 5);
                speakInstruction(`${count * 5}`);
              }
              
              // Countdown for last 10 seconds
              const timeLeft = exerciseDuration - prev.exerciseTime;
              if (timeLeft <= 10 && timeLeft > 0) {
                speakInstruction(`${timeLeft}`);
              }
              
              // Ensure video is playing during exercise
              if (videoRef.current && videoRef.current.paused && !prev.isPaused) {
                videoRef.current.play();
              }
              
              if (prev.exerciseTime >= exerciseDuration) {
                // Auto-advance to next set/exercise
                if (prev.currentSet < currentExercise.sets) {
                  newState.currentSet = prev.currentSet + 1;
                  newState.isResting = true;
                  newState.exerciseTime = 0;
                  newState.restTime = 0;
                  speakInstruction(`Set complete. Rest for 30 seconds`);
                  // Pause video during rest
                  if (videoRef.current) {
                    videoRef.current.pause();
                  }
                } else {
                  // Move to next exercise
                  if (prev.currentExerciseIndex < prev.sessionExercises.length - 1) {
                    const nextIndex = prev.currentExerciseIndex + 1;
                    const nextExercise = prev.sessionExercises[nextIndex];
                    newState.currentExerciseIndex = nextIndex;
                    newState.currentSet = 1;
                    newState.exerciseTime = 0;
                    newState.isResting = true;
                    newState.restTime = 0;
                    newState.completedExercises = [...prev.completedExercises, prev.currentExerciseIndex];
                    speakInstruction(`Exercise complete. Next: ${nextExercise.name}. Get ready in 10 seconds`);
                    // Pause video during transition
                    if (videoRef.current) {
                      videoRef.current.pause();
                    }
                    // Set shorter transition time (10 seconds instead of 30)
                    setTimeout(() => {
                      setWorkoutSession(current => ({
                        ...current,
                        isResting: false,
                        restTime: 0
                      }));
                      speakInstruction(`Begin ${nextExercise.name}`);
                      if (videoRef.current) {
                        videoRef.current.currentTime = 0;
                        videoRef.current.play();
                      }
                    }, 10000);
                  } else {
                    // Workout completed
                    newState.isActive = false;
                    newState.completedExercises = [...prev.completedExercises, prev.currentExerciseIndex];
                    clearInterval(timer);
                    speakInstruction('Workout completed! Excellent work!');
                    if (videoRef.current) {
                      videoRef.current.pause();
                    }
                    return newState; // Exit early to prevent further timer execution
                  }
                }
              }
            }
            
            return newState;
          });
        }, 1000);
        
        setWorkoutTimer(timer);
      };

      useEffect(() => {
        return () => {
          if (workoutTimer) {
            clearInterval(workoutTimer);
          }
        };
      }, [workoutTimer]);

      // Ensure page scroll remains enabled across tabs (iframe auto-sizes instead)
      useEffect(() => {
        try {
          document.documentElement.style.overflow = '';
          document.body.style.overflow = '';
        } catch (_) {}
      }, [activeTab]);

      const handlePreferenceChange = (key, value) => {
        setPreferences(prev => ({ ...prev, [key]: value }));
      };

      const handleEquipmentChange = (item) => {
        setPreferences(prev => {
          const newEquipment = prev.equipment.includes(item)
            ? prev.equipment.filter(e => e !== item)
            : [...prev.equipment, item];
          return { ...prev, equipment: newEquipment };
        });
      };

      const generateWorkoutPlan = async () => {
        setIsLoading(true);
        setError(null);
        setWorkoutPlan(null);
        try {
          const prompt = `Create a ${preferences.type || 'Full Body'} workout for ${preferences.goal || 'General Fitness'}.
Level: ${preferences.level || 'Beginner'}
Equipment: ${preferences.equipment.join(', ') || 'Bodyweight'}

Respond ONLY with a valid JSON object in this exact format:
{
  "plan_name": "Workout Plan Name",
  "exercises": [
    {"name": "Exercise Name", "sets": "3", "reps": "10-12", "instructions": "How to perform this exercise"}
  ]
}`;

          // Use OpenRouter API (Qwen) with obfuscated key
          const geminiConfig = getDirectGeminiConfig();
          const response = await fetch(geminiConfig.url, {
            method: 'POST',
            headers: geminiConfig.headers,
            body: JSON.stringify({
              model: OPENROUTER_QWEN_MODEL,
              messages: [{ role: 'user', content: prompt }]
            }),
            signal: AbortSignal.timeout(25000) // 25 second timeout
          });

          if (!response.ok) {
            throw new Error(`API Error: ${response.status} ${response.statusText}`);
          }

          const result = await response.json();
          const textResponse = (result.choices?.[0]?.message?.content || '');
          
          // Better JSON extraction and validation
          let jsonString = textResponse.replace(/```json|```/g, '').trim();
          
          // Remove any text before the first { and after the last }
          const firstBrace = jsonString.indexOf('{');
          const lastBrace = jsonString.lastIndexOf('}');
          
          if (firstBrace !== -1 && lastBrace !== -1) {
            jsonString = jsonString.substring(firstBrace, lastBrace + 1);
          }
          
          const data = JSON.parse(jsonString);
          
          // Validate the structure
          if (!data.plan_name || !data.exercises || !Array.isArray(data.exercises)) {
            throw new Error('Invalid workout plan structure');
          }
          
          setWorkoutPlan(data);
        } catch (err) {
          console.error("Workout plan generation failed:", err);
          setError("Could not generate a workout plan. Try again, or sign in, or subscribe to continue.");
        } finally {
          setIsLoading(false);
        }
      };

      return (
        <div className={`${activeTab === 'exercises' 
          ? 'pt-4 sm:pt-6 px-0 pb-0 m-0 min-h-screen flex flex-col bg-gradient-to-br from-blue-50 via-cyan-50 to-indigo-50 dark:from-gray-900 dark:via-blue-900/20 dark:to-cyan-900/20'
          : 'p-4 sm:p-6 pb-24 mb-20 min-h-screen flex flex-col bg-gradient-to-br from-blue-50 via-cyan-50 to-indigo-50 dark:from-gray-900 dark:via-blue-900/20 dark:to-cyan-900/20'}`}>
          <header className="mb-4 sm:mb-6 text-center px-2">
            <h1 className="text-2xl sm:text-3xl font-bold bg-gradient-to-r from-blue-600 to-cyan-500 bg-clip-text text-transparent">Workout Hub</h1>
            <p className="text-sm sm:text-base text-gray-500 dark:text-gray-400">Plan workouts or perfect your form</p>
          </header>

          {/* Tab Navigation - Mobile Optimized */}
          <div className="flex mb-6 bg-gray-100 dark:bg-gray-800 rounded-2xl p-1 max-w-lg mx-auto mx-4 sm:mx-auto">
            <button
              onClick={() => setActiveTab('planner')}
              className={`flex-1 py-3 px-2 sm:px-4 rounded-xl font-semibold transition-all text-xs sm:text-sm ${
                activeTab === 'planner'
                  ? 'bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 shadow-md'
                  : 'text-gray-600 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-200'
              }`}
            >
              üìã Planner
            </button>
            <button
              onClick={() => setActiveTab('coach')}
              className={`flex-1 py-3 px-2 sm:px-4 rounded-xl font-semibold transition-all text-xs sm:text-sm ${
                activeTab === 'coach'
                  ? 'bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 shadow-md'
                  : 'text-gray-600 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-200'
              }`}
            >
              üèãÔ∏è Form Coach
            </button>
            <button
              onClick={() => setActiveTab('exercises')}
              className={`flex-1 py-3 px-2 sm:px-4 rounded-xl font-semibold transition-all text-xs sm:text-sm ${
                activeTab === 'exercises'
                  ? 'bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 shadow-md'
                  : 'text-gray-600 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-200'
              }`}
            >
              üí™ Exercises
            </button>
          </div>

          {/* Tab Content */}
          {activeTab === 'planner' && (
            <div>
              {!workoutPlan && (
                <div className="max-w-md mx-auto px-4 sm:px-0">
                  <div className="bg-white dark:bg-gray-800 p-4 sm:p-6 rounded-2xl shadow-md space-y-4 sm:space-y-6">
                    {/* Fitness Goal */}
                    <div>
                      <h3 className="font-semibold mb-2 text-gray-800 dark:text-gray-200 text-sm sm:text-base">Fitness Goal</h3>
                      <div className="grid grid-cols-1 sm:grid-cols-3 gap-2">
                        {['Weight Loss', 'Muscle Gain', 'Endurance'].map(g => (
                          <button
                            key={g}
                            onClick={() => handlePreferenceChange('goal', g)}
                            className={`p-3 sm:p-2 rounded-lg border dark:border-gray-700 text-sm sm:text-base font-medium transition-colors ${preferences.goal === g ? 'bg-pink-500 text-white' : 'bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200 hover:bg-gray-200 dark:hover:bg-gray-600'}`}
                          >
                            {g}
                          </button>
                        ))}
                      </div>
                    </div>

                    {/* Workout Type */}
                    <div>
                      <h3 className="font-semibold mb-2 text-gray-800 dark:text-gray-200 text-sm sm:text-base">Workout Type</h3>
                      <div className="grid grid-cols-1 sm:grid-cols-3 gap-2">
                        {['Full Body', 'Upper Body', 'Lower Body'].map(t => (
                          <button
                            key={t}
                            onClick={() => handlePreferenceChange('type', t)}
                            className={`p-3 sm:p-2 rounded-lg border dark:border-gray-700 text-sm sm:text-base font-medium transition-colors ${preferences.type === t ? 'bg-pink-500 text-white' : 'bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200 hover:bg-gray-200 dark:hover:bg-gray-600'}`}
                          >
                            {t}
                          </button>
                        ))}
                      </div>
                    </div>

                    {/* Experience Level */}
                    <div>
                      <h3 className="font-semibold mb-2 text-gray-800 dark:text-gray-200 text-sm sm:text-base">Experience Level</h3>
                      <div className="grid grid-cols-1 sm:grid-cols-3 gap-2">
                        {['Beginner', 'Intermediate', 'Advanced'].map(l => (
                          <button
                            key={l}
                            onClick={() => handlePreferenceChange('level', l)}
                            className={`p-3 sm:p-2 rounded-lg border dark:border-gray-700 text-sm sm:text-base font-medium transition-colors ${preferences.level === l ? 'bg-pink-500 text-white' : 'bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200 hover:bg-gray-200 dark:hover:bg-gray-600'}`}
                          >
                            {l}
                          </button>
                        ))}
                      </div>
                    </div>

                    {/* Equipment */}
                    <div>
                      <h3 className="font-semibold mb-2 text-gray-800 dark:text-gray-200 text-sm sm:text-base">Available Equipment</h3>
                      <div className="grid grid-cols-2 sm:grid-cols-3 gap-2">
                        {['Bodyweight', 'Dumbbells', 'Barbell', 'Kettlebell', 'Bands', 'Machine'].map(e => (
                          <button
                            key={e}
                            onClick={() => handleEquipmentChange(e)}
                            className={`p-3 sm:p-2 rounded-lg border dark:border-gray-700 text-xs sm:text-sm font-medium transition-colors ${preferences.equipment.includes(e) ? 'bg-pink-500 text-white' : 'bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200 hover:bg-gray-200 dark:hover:bg-gray-600'}`}
                          >
                            {e}
                          </button>
                        ))}
                      </div>
                    </div>
                  </div>

                  <button
                    onClick={generateWorkoutPlan}
                    disabled={isLoading}
                    className="w-full mt-4 sm:mt-6 bg-green-500 text-white font-bold py-4 px-6 rounded-2xl shadow-lg hover:bg-green-600 transition-colors disabled:bg-gray-400 text-base sm:text-lg"
                  >
                    {isLoading ? 'Generating...' : 'Generate Workout Plan'}
                  </button>

                  {error && <div className="mt-4 text-center text-red-500">{error}</div>}
                </div>
              )}

              {workoutPlan && (
                <div className="animate-fade-in">
                  <button onClick={() => setWorkoutPlan(null)} className="mb-4 text-pink-500 font-semibold">&larr; Back to Preferences</button>
                  
                  {/* Download Button moved to top (responsive) */}
                  <button
                    onClick={async () => {
                      // Require sign-in before allowing PDF download
                      let signedIn = false;
                      try {
                        if (auth && auth.getSession) {
                          const { data: { session } } = await auth.getSession();
                          signedIn = !!(session && session.user && session.user.id);
                        }
                      } catch (_) {}
                      if (!signedIn) {
                        try { if (typeof setScreen === 'function') setScreen('profile'); } catch (_) {}
                        setTimeout(() => { try { window.dispatchEvent(new Event('open-account-modal')); } catch (_) {} }, 50);
                        return;
                      }
                      // Format workout plan for PDF
                      const title = workoutPlan.plan_name;
                      let content = "";
                      
                      // Add workout details
                      workoutPlan.exercises.forEach((ex, i) => {
                        content += `${i+1}. ${ex.name}\n`;
                        content += `Sets: ${ex.sets} | Reps: ${ex.reps}\n`;
                        content += `Instructions: ${ex.instructions}\n\n`;
                      });
                      
                      // Generate and download PDF
                      generatePDF(title, content, "workout-plan.pdf");
                    }}
                    className="mb-4 w-auto block mx-auto bg-pink-500 text-white font-bold py-2 sm:py-3 px-4 sm:px-6 text-sm sm:text-base rounded-xl shadow-lg hover:bg-pink-600 transition-colors"
                  >
                    üì• Download Workout Plan PDF
                  </button>

                  {/* Voice Button with Pause/Resume - REMOVED */}
                  
                  <div className="bg-white dark:bg-gray-800 p-6 rounded-2xl shadow-md">
                    <h2 className="text-2xl font-bold text-gray-800 dark:text-gray-200 mb-4">{workoutPlan.plan_name}</h2>
                    <WorkoutPlanDisplay workoutPlan={workoutPlan} />
                  </div>
                  
                  {/* Download Button moved from bottom */}
                </div>
              )}
            </div>
          )}

          {activeTab === 'coach' && (
            <WorkoutFormCoach />
          )}

          <div id="exercises-wrapper" className={`${activeTab === 'exercises' ? 'block' : 'hidden'}`}>
            {exercisesMode === 'iframe' && (
              <div id="exercises-host" className="w-full"></div>
            )}

            {exercisesMode === 'cards' && (
              <div className="max-w-3xl mx-auto px-4 pb-24">
                <div className="mt-4 space-y-6">
                  {[
                  { title:'Upper Body', desc:'Introduction to upper body strength with basic movements', duration:'18 min', difficulty:'beginner', tag:'Upper Body' },
                  { title:'Lower Body', desc:'Build lower body strength with basic movements', duration:'22 min', difficulty:'beginner', tag:'Lower Body' },
                  { title:'Full Body', desc:'Complete body workout with gentle movements', duration:'25 min', difficulty:'beginner', tag:'Full Body' },
                  { title:'Upper Body', desc:'Build strength in chest, arms, and shoulders', duration:'25 min', difficulty:'intermediate', tag:'Upper Body' },
                  { title:'Lower Body', desc:'Advanced lower body training with dynamic movements', duration:'28 min', difficulty:'intermediate', tag:'Lower Body' },
                  { title:'Full Body', desc:'Intermediate full-body strength and endurance workout', duration:'30 min', difficulty:'intermediate', tag:'Full Body' },
                  { title:'Upper Body', desc:'Challenging upper body workout with push-up variations', duration:'30 min', difficulty:'advanced', tag:'Upper Body' },
                  { title:'Lower Body', desc:'High-intensity lower body power and strength session', duration:'32 min', difficulty:'advanced', tag:'Lower Body' },
                  { title:'Full Body', desc:'Advanced full-body workout with explosive movements', duration:'35 min', difficulty:'advanced', tag:'Full Body' },
                  { title:'Customise', desc:'Create your own workout by selecting exercises', duration:'Varies', difficulty:'custom', tag:'Your Plan' }
                ].map((w, idx) => (
                  <article
                    key={idx}
                    onClick={() => {
                      try { setPendingWorkoutIndex(idx); } catch (_) {}
                      try { setExercisesMode('iframe'); } catch (_) {}
                    }}
                    className="rounded-2xl overflow-hidden shadow-lg cursor-pointer"
                  >
                    <div className="h-44 md:h-52 rounded-2xl relative bg-gradient-to-br from-blue-500/10 via-cyan-500/10 to-indigo-500/10 dark:from-slate-800 dark:via-slate-900 dark:to-slate-950">
                      <div className="absolute inset-0 flex items-start px-5 pt-5 z-10">
                        <span className="text-2xl md:text-3xl font-extrabold text-gray-900 dark:text-white">{w.title}</span>
                        <div className="ml-auto">
                          <span className={`inline-block text-xs font-semibold uppercase px-3 py-1 rounded-full ${
                            w.difficulty === 'beginner' ? 'bg-green-500 text-black' :
                            w.difficulty === 'intermediate' ? 'bg-pink-500 text-white' :
                            w.difficulty === 'custom' ? 'bg-blue-500 text-white' :
                            'bg-red-500 text-white'
                          }`}>
                            {w.difficulty.charAt(0).toUpperCase() + w.difficulty.slice(1)}
                          </span>
                        </div>
                      </div>
                      <div className="absolute left-0 right-0 bottom-0 p-4 bg-white/90 dark:bg-slate-900/90 backdrop-blur-md">
                        <p className="text-sm text-gray-700 dark:text-gray-200">{w.desc}</p>
                        <div className="mt-3 flex items-center gap-6">
                          <div className="flex items-center gap-2 text-sm">
                            <svg className="w-5 h-5 text-pink-500" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.6"><circle cx="12" cy="12" r="9"/><path d="M12 7v5l3 2"/></svg>
                            <span className="text-gray-800 dark:text-gray-200 font-medium">~{w.duration}</span>
                          </div>
                          <div className="flex items-center gap-2 text-sm ml-auto">
                            <svg className="w-5 h-5 text-pink-500" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.6"><path d="M6 12h12"/></svg>
                            <span className="text-gray-800 dark:text-gray-200 font-medium">{w.tag}</span>
                          </div>
                        </div>
                      </div>
                    </div>
                  </article>
                ))}
                </div>
              </div>
            )}
          </div>
        </div>
      );
    };

  </script>
  <script>
    (function(){
      try {
        var badge = document.getElementById('midnight-sync-badge');
        if (!badge) return;
        var watchId = null;
        function toISO(d){ return d.getFullYear() + '-' + String(d.getMonth()+1).padStart(2,'0') + '-' + String(d.getDate()).padStart(2,'0'); }
        function todayStr(){ try { return (typeof toLocalISODate === 'function') ? toLocalISODate(new Date()) : toISO(new Date()); } catch(_) { return toISO(new Date()); } }
        function getIntake(){ try { return JSON.parse(localStorage.getItem('dailyIntake') || '{}') || {}; } catch(_) { return {}; } }
        function nonZeroIntake(i){ return ['calories','protein','carbs','fat','activity','water'].some(function(k){ return Number(i[k]||0) > 0; }); }
        function allZeroIntake(i){ return ['calories','protein','carbs','fat','activity','water'].every(function(k){ return Number(i[k]||0) === 0; }); }
        function shouldShow(){
          var intakeDate = localStorage.getItem('dailyIntakeDate') || '';
          var i = getIntake();
          return !!intakeDate && intakeDate !== todayStr() && nonZeroIntake(i);
        }
        function shouldHide(){
          var intakeDate = localStorage.getItem('dailyIntakeDate') || '';
          var i = getIntake();
          return (intakeDate === todayStr()) && allZeroIntake(i);
        }
        function updateBadge(){
          try {
            if (shouldShow()){
              badge.style.display = 'inline-flex';
              if (!watchId){
                watchId = setInterval(function(){
                  try { if (shouldHide()){ badge.style.display='none'; clearInterval(watchId); watchId=null; } } catch(_) {}
                }, 1000);
              }
            } else {
              badge.style.display = 'none';
            }
          } catch(_) {}
        }
        window.addEventListener('load', updateBadge);
        document.addEventListener('visibilitychange', function(){ if (!document.hidden) updateBadge(); });
        window.addEventListener('userDataSynced', updateBadge);
        window.addEventListener('workout-history-updated', updateBadge);
      } catch(_) {}
    })();
  </script>
  <script type="text/babel">
    // AI Coach Screen Component
    const Coach = ({ dailyIntake, recentMeals, goals, messages, setMessages, isDarkMode }) => {
      const [input, setInput] = useState('');
      const [isLoading, setIsLoading] = useState(false);
      const chatEndRef = useRef(null);
      const [attachment, setAttachment] = useState(null);
      const [attachmentPreview, setAttachmentPreview] = useState(null);
      const fileInputRef = useRef(null);
      // Temporarily disable uploads for AI Health Coach UI
      const uploadsEnabled = false;

      // Function to start a new conversation
      const startNewConversation = () => {
        setMessages([{ text: "Hello! I'm your AI Health Coach. Ask me anything about your nutrition or meals.", sender: 'ai' }]);
        setInput('');
        setAttachment(null);
        setAttachmentPreview(null);
      };

      useEffect(() => {
        chatEndRef.current?.scrollIntoView({ behavior: "smooth" });
      }, [messages]);

      const fileToBase64 = (file) => new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = () => resolve(reader.result.split(',')[1]);
        reader.onerror = error => reject(error);
      });

      const handleAttachmentChange = (event) => {
        const file = event.target.files[0];
        if (file) {
          setAttachment(file);
          setAttachmentPreview(URL.createObjectURL(file));
        }
      };

      const handleSend = async () => {
        if (!input.trim() && !attachment) return;

        const userMessage = { text: input, sender: 'user', attachment: attachmentPreview };
        setMessages(prev => [...prev, userMessage]);
        setInput('');
        setAttachment(null);
        setAttachmentPreview(null);
        setIsLoading(true);

        try {
          const mealContext = recentMeals.map(m => `${m.name} (Felt: ${m.mood || 'Not specified'})`).join(', ');
          
          // Calculate progress percentages
          const calorieProgress = ((dailyIntake.calories / goals.calories) * 100).toFixed(0);
          const proteinProgress = ((dailyIntake.protein / goals.protein) * 100).toFixed(0);
          const carbProgress = ((dailyIntake.carbs / goals.carbs) * 100).toFixed(0);
          const fatProgress = ((dailyIntake.fat / goals.fat) * 100).toFixed(0);
          // Read habits safely from localStorage (chat context doesn't receive habits prop)
          const habitsLS = (() => { try { return JSON.parse(localStorage.getItem('habits') || '[]'); } catch (e) { return []; } })();

          // Consolidate activity: combine dashboard activity with completed activity habit for today
          const todayStrAct = new Date().toISOString().split('T')[0];
          const activityHabitMinutesCtx = habitsLS.reduce((max, h) => {
            const isActivity = /(cardio|exercise|workout|run|walk|gym)/i.test(h.name || '');
            const done = h.completed && h.completed[todayStrAct];
            if (!isActivity || !done) return max;
            const m = (h.name || '').match(/(\d+)\s*(min|mins|minutes)/i) || (h.name || '').match(/(\d+)/);
            const mins = m ? parseInt(m[1], 10) : 30;
            return Math.max(max, mins);
          }, 0);
          const effectiveActivityCtx = Math.max(dailyIntake.activity || 0, activityHabitMinutesCtx || 0);
          const activityProgress = ((effectiveActivityCtx / goals.activity) * 100).toFixed(0);
          
          // Consolidate hydration: combine dashboard water with completed water habit for today
          const todayStr = new Date().toISOString().split('T')[0];
          const waterHabitGlassesCtx = habitsLS.reduce((max, h) => {
            const isWater = /\b(drink)?\s*\d+\s*(glass|glasses)\s*of\s*water\b|\bwater\b|\bhydrate\b/i.test(h.name || '');
            const doneToday = h.completed && h.completed[todayStr];
            if (!isWater || !doneToday) return max;
            const m = (h.name || '').match(/(\d+)\s*(glass|glasses)/i);
            const g = m ? parseInt(m[1], 10) : 0;
            return Math.max(max, g);
          }, 0);
          const effectiveWaterCtx = Math.max(dailyIntake.water || 0, waterHabitGlassesCtx || 0);
          const waterProgress = ((effectiveWaterCtx / goals.water) * 100).toFixed(0);
          
          // Identify areas needing attention
          const lowAreas = [];
          const highAreas = [];
          if (calorieProgress < 80) lowAreas.push('calories');
          if (proteinProgress < 80) lowAreas.push('protein');
          if (activityProgress < 80) lowAreas.push('activity');
          if (waterProgress < 80) lowAreas.push('water');
          if (calorieProgress > 120) highAreas.push('calories');
          if (carbProgress > 120) highAreas.push('carbs');
          if (fatProgress > 120) highAreas.push('fat');
          
          // Get workout history for enhanced coaching
          let workoutHistory;
          try {
            workoutHistory = JSON.parse(localStorage.getItem('workoutHistory') || '[]');
            if (!Array.isArray(workoutHistory)) {
              workoutHistory = [];
            }
          } catch (error) {
            console.warn('Error parsing workoutHistory in coaching, resetting to empty array:', error);
            workoutHistory = [];
          }
          const recentWorkouts = workoutHistory.slice(-5); // Last 5 workouts
          const workoutContext = recentWorkouts.map(w => 
            `${w.workoutTitle} (${w.workoutLevel || 'Unknown'} level) - ${w.completionRate}% completed on ${new Date(w.timestamp).toLocaleDateString()}`
          ).join('; ');
          
          // Calculate current health score
          const calculateHealthScore = () => {
            const todayStr = toLocalISODate(new Date());
            return computeHealthScoreForDate(dailyIntake, goals, todayStr).score;
          };
          
          const currentHealthScore = calculateHealthScore();

          // --- Stress Analyzer knowledge & context (read-only) ---
          // Pull latest stress inputs saved by Progress ‚Üí Stress Analyzer
          const stressFormLS = (() => { try { return JSON.parse(localStorage.getItem('stressForm') || '{}'); } catch (_) { return {}; } })();

          // Local helper mirrors Progress screen logic to compute a summary for the prompt
          const computeCoachStressScore = (inp) => {
            const v = {
              sleepHours: Number(inp.sleepHours || 0),
              workHours: Number(inp.workHours || 0),
              stressRating: Number(inp.stressRating || 0),
              stressEpisodes: Number(inp.stressEpisodes || 0),
              exerciseMins: Number(inp.exerciseMins || 0),
              meditationMins: Number(inp.meditationMins || 0),
              socialMins: Number(inp.socialMins || 0),
              screenHours: Number(inp.screenHours || 0),
              lifeEvent: inp.lifeEvent || 'none'
            };
            // Guard: total of time-based inputs must not exceed 24h
            const _totalHours = v.sleepHours + v.workHours + (v.exerciseMins/60) + (v.meditationMins/60) + (v.socialMins/60);
            if (_totalHours > 24) {
              return {
                stressScore: 0,
                category: 'Invalid',
                confidence: 0,
                breakdown: {
                  drivers: { sleep: 0, work: 0, selfRating: 0, episodes: 0, screen: 0 },
                  buffers: { exercise: 0, meditation: 0, social: 0 }
                },
                lifeEventMultiplier: 1.0
              };
            }
            const clamp01 = (x) => Math.max(0, Math.min(1, x));
            // Normalize inputs to 0-1 (same mapping used by Progress screen)
            const sleep = clamp01(Math.abs((v.sleepHours || 0) - 8) / 4);
            // Work: asymmetric deviation (underwork milder, overwork stronger)
            const workUnder = clamp01(Math.max(0, 8 - (v.workHours || 0)) / 5);
            const workOver = clamp01(Math.max(0, (v.workHours || 0) - 8) / 3);
            const work = clamp01(workUnder + workOver);
            const rating = clamp01((v.stressRating - 1) / 9);
            const episodes = clamp01((v.stressEpisodes || 0) / 6);
            const screen = clamp01((v.screenHours || 0) / 8);
            const exerciseRelief = clamp01((v.exerciseMins || 0) / 45);
            const meditationRelief = clamp01((v.meditationMins || 0) / 15);
            const socialRelief = clamp01((v.socialMins || 0) / 60);

            // Amplification tails for psychological extremes and lifestyle volatility
            const ratingTail = clamp01(Math.max(0, (v.stressRating || 0) - 7) / 3); // ramps 7‚Üí10
            const episodesTail = clamp01(Math.max(0, (v.stressEpisodes || 0) - 3) / 3); // ramps 3‚Üí6
            const undersleepTail = clamp01(Math.max(0, 7 - (v.sleepHours || 0)) / 3);  // sleep < 7h
            const moderateOverworkTail = clamp01(Math.max(0, (v.workHours || 0) - 10) / 4); // work > 10h
            const overworkTail = clamp01(Math.max(0, (v.workHours || 0) - 12) / 4);    // work > 12h
            const moderateWorkTailWeight = 10;
            const workTailWeight = 30;
            const sleepTailWeight = 20;
            const psychTailRatingWeight = 30;
            const psychTailEpisodesWeight = 30;

            // Weights consistent with Progress screen UI
            const w = { sleep:25, work:20, rating:12, episodes:8, screen:10, exercise:15, meditation:5, social:5 };
            const stressors = sleep*w.sleep + work*w.work + rating*w.rating + episodes*w.episodes + screen*w.screen
              + moderateOverworkTail*moderateWorkTailWeight + overworkTail*workTailWeight + undersleepTail*sleepTailWeight
              + ratingTail*psychTailRatingWeight + episodesTail*psychTailEpisodesWeight;

            const bufferSum = exerciseRelief*w.exercise + meditationRelief*w.meditation + socialRelief*w.social;
            // Damp buffers at high work or psychological extremes
            const WORK_BUFFER_DAMPEN = 0.7;
            const PSYCH_BUFFER_DAMPEN = 0.6;
            const bufferScale = clamp01((1 - WORK_BUFFER_DAMPEN * work) * (1 - PSYCH_BUFFER_DAMPEN * Math.max(ratingTail, episodesTail)));
            const effectiveBuffer = bufferSum * bufferScale;
            let rawIndex = stressors - effectiveBuffer; // [-25, 75]
            let baseScore = Math.max(0, Math.min(100, rawIndex + 25));

            let multiplier = 1.0;
            if (v.lifeEvent === 'minor') multiplier = 1.5;
            else if (v.lifeEvent === 'major') multiplier = 2.0;

            let stressScore = Math.round(Math.min(100, baseScore * multiplier));
            let category = 'Low';
            if (stressScore >= 76) category = 'Very High';
            else if (stressScore >= 51) category = 'High';
            else if (stressScore >= 26) category = 'Moderate';

            // Confidence model: inverse-of-stress baseline with penalties/boosts
            const pw = { sleepHours:.25, workHours:.20, stressRating:.12, stressEpisodes:.08, screenHours:.10, exerciseMins:.15, meditationMins:.05, socialMins:.05 };
            const filled = (k) => { const val = inp[k]; return val !== '' && val !== null && val !== undefined; };
            let coverage = 0; Object.keys(pw).forEach(k => { if (filled(k)) coverage += pw[k]; });
            const baseConfidence = 100 - stressScore;
            let volatilityPenalty = 0;
            if (undersleepTail > 0.66) volatilityPenalty += 10; else if (undersleepTail > 0.33) volatilityPenalty += 5;
            if (overworkTail > 0.50) volatilityPenalty += 8; else if (overworkTail > 0.25) volatilityPenalty += 4;
            if (rating >= 0.7) volatilityPenalty += 8; else if (rating >= 0.5) volatilityPenalty += 4;
            if (episodes >= 0.7) volatilityPenalty += 8; else if (episodes >= 0.5) volatilityPenalty += 4;
            if (screen >= 0.75) volatilityPenalty += 6; else if (screen >= 0.5) volatilityPenalty += 3;
            let bufferBoost = 0;
            if (exerciseRelief >= 0.8) bufferBoost += 5;
            if (meditationRelief >= 0.8) bufferBoost += 3;
            if (socialRelief >= 0.8) bufferBoost += 4;
            let missingPenalty = 0; if (coverage < 0.5) missingPenalty = 10; else if (coverage < 0.75) missingPenalty = 5;
            const eventPenalty = (v.lifeEvent === 'major') ? 10 : (v.lifeEvent === 'minor' ? 5 : 0);
            const confidence = Math.max(20, Math.min(95, Math.round(baseConfidence - volatilityPenalty - eventPenalty - missingPenalty + bufferBoost)));

            // UI drivers for Coach: cap to base weights to prevent over-display
            const drivers = {
              sleep: Math.min(w.sleep, Math.round(sleep * w.sleep)),
              work: Math.min(w.work, Math.round(work * w.work)),
              selfRating: Math.min(w.rating, Math.round(rating * w.rating)),
              episodes: Math.min(w.episodes, Math.round(episodes * w.episodes)),
              screen: Math.min(w.screen, Math.round(screen * w.screen))
            };
            const buffers = {
              exercise: Math.round(exerciseRelief * w.exercise),
              meditation: Math.round(meditationRelief * w.meditation),
              social: Math.round(socialRelief * w.social)
            };
            return { stressScore, category, confidence, breakdown: { drivers, buffers }, lifeEventMultiplier: multiplier };
          };

          let stressCtx = null;
          try {
            if (stressFormLS && Object.keys(stressFormLS).length > 0) {
              stressCtx = computeCoachStressScore(stressFormLS);
            }
          } catch (_) {}

          const topDriversStr = (() => {
            if (!stressCtx || !stressCtx.breakdown || !stressCtx.breakdown.drivers) return '';
            return Object.entries(stressCtx.breakdown.drivers).sort((a,b)=> (b[1]||0)-(a[1]||0)).slice(0,2).map(e=>e[0]).join(' and ');
          })();
          const topBufferStr = (() => {
            if (!stressCtx || !stressCtx.breakdown || !stressCtx.breakdown.buffers) return '';
            return Object.entries(stressCtx.breakdown.buffers).sort((a,b)=> (b[1]||0)-(a[1]||0)).slice(0,1).map(e=>e[0]).join(', ');
          })();
          
          let prompt = `You are an AI Health Coach specializing in FITNESS, WORKOUTS, and NUTRITION. You have comprehensive knowledge of the FitnessMate app's features and can provide expert guidance on ALL app screens and functionality.

üìä USER'S CURRENT STATUS:
üéØ OVERALL HEALTH SCORE: ${currentHealthScore}/100
Daily Intake vs Goals:
- Calories: ${dailyIntake.calories}/${goals.calories} (${calorieProgress}%)
- Protein: ${dailyIntake.protein}g/${goals.protein}g (${proteinProgress}%)
- Carbs: ${dailyIntake.carbs}g/${goals.carbs}g (${carbProgress}%)
- Fat: ${dailyIntake.fat}g/${goals.fat}g (${fatProgress}%)
- Activity: ${Math.min(effectiveActivityCtx, goals.activity)}/${goals.activity} mins (${Math.min(100, Number(activityProgress))}%)
- Water: ${dailyIntake.water}/${goals.water} glasses (${waterProgress}%)

üèãÔ∏è WORKOUT DATA:
- Recent workouts: ${workoutContext || 'No recent workouts'}
- Available workout types: Upper Body, Lower Body, Full Body, Core & Abs, Cardio HIIT
- Difficulty levels: Beginner, Intermediate, Advanced
- Features: AI Form Coach, Workout Planner, Progress Tracking

üéØ HEALTH SCORING SYSTEM:
- Nutrition: 40% (25% Calories, 5% Protein, 5% Carbs, 5% Fat; ¬±10% tolerance; calories beyond ¬±10% apply 25% penalty to total Nutrition)
- Activity: up to 15 pts ‚Äî 10m=5, 20m=10, 30m=15 (capped). Workouts do NOT add activity minutes.
- Workouts: 1 pt per 10% completion (max 10 per workout), cap at 30 total per day
- Hydration: 15 pts (water intake vs goals)
- Activity covers general movement (walking, cardio, steps logged via timer). Workouts are structured sessions scored separately.

üì± COMPLETE APP KNOWLEDGE:
DASHBOARD SCREEN: Health score visualization, daily intake tracking (calories/protein/carbs/fat/water), progress bars, recent meals display, motivational quotes, activity logging
FOOD SCANNER: AI nutritional analysis, portion size input (grams/ml), ingredient breakdown, health tips generation, meal logging with photos, instant calorie calculation
WORKOUT PLANNER: 15+ exercises with video guides (Burpee, Inchworm, Jumping Jack, Military Push Ups, Reverse Crunches, etc.), session tracking, timer, voice instructions, difficulty progression
MEAL PLANNER: Recipe generation, pantry scanning, menu decoder for restaurants, dietary goal integration, ingredient analysis
PROFILE SCREEN: Goal setting, notification preferences, dark mode toggle, consultation booking, data sync, account management
AI COACHES: Form Coach (exercise technique), Habit Coach (behavior change), personalized recommendations based on user data

Recent meals: ${mealContext || 'None logged'}
${lowAreas.length > 0 ? `\n‚ö†Ô∏è LOW AREAS: ${lowAreas.join(', ')}` : ''}
${highAreas.length > 0 ? `\nüî¥ HIGH AREAS: ${highAreas.join(', ')}` : ''}

üéØ ENHANCED RESPONSE RULES:
1. IDENTIFY QUESTION TYPE & DIRECT TO APPROPRIATE SCREEN:
   - WORKOUT PLANNING ‚Üí Guide to Workout Planner, recommend specific exercises
   - EXERCISE FORM ‚Üí Reference AI Form Coach feature for technique help
   - NUTRITION TRACKING ‚Üí Direct to Food Scanner for accurate logging
   - MEAL PLANNING ‚Üí Suggest Meal Planner for recipes and pantry management
   - GOAL SETTING ‚Üí Guide to Profile screen for goal adjustments
   - PROGRESS TRACKING ‚Üí Reference Dashboard for comprehensive health overview
   - APP NAVIGATION ‚Üí Explain which screen to use for specific needs

2. RESPONSE FORMAT (MAX 120 WORDS):
   - Direct answer with specific app feature recommendations
   - 2-3 actionable bullet points with screen references
   - Reference their actual data when applicable
   - Guide users to relevant app sections (e.g., "Check your Dashboard", "Use the Food Scanner")
   - Use emojis for readability and engagement

3. COMPREHENSIVE APP GUIDANCE:
   - Explain how different screens work together for complete health management
   - Reference specific features like portion size input, exercise videos, health scoring
   - Encourage cross-feature usage (e.g., scan food ‚Üí track on dashboard ‚Üí plan workouts)
   - Mention specific exercises from database when recommending fitness routines

üßò STRESS ANALYZER (Separate Feature):
- Purpose: quick check of a stress index (0‚Äì100) labeled Low/Moderate/High. It is NOT part of the Health Score points system.
- Inputs considered: sleep hours deviation, work hours, self‚Äërating (1‚Äì10), stress episodes, screen hours.
- Buffers: exercise minutes, meditation minutes, social time.
- Weights: sleep 25, work 20, self‚Äërating 12, episodes 8, screen 10; buffers exercise 15, meditation 5, social 5.
- Life event multiplier: minor √ó1.5, major √ó2.0.
- Reading the screen: gauge shows score; category + confidence; 'Drivers' bars show contributors; 'Buffers' bars show relief.
${stressCtx ? `- Current stress (from Progress ‚Üí Stress Analyzer): ${stressCtx.category} (${stressCtx.stressScore}), confidence ${stressCtx.confidence}%. Top drivers: ${topDriversStr || 'n/a'}. Relief: ${topBufferStr || 'n/a'}.` : `- No stress inputs logged yet. Open Progress ‚Üí Stress Analyzer to enter today's values.`}

User's question: "${userMessage.text}"`;

          const parts = [{ text: prompt }];

          if (attachment) {
            const base64ImageData = await fileToBase64(attachment);
            parts.push({ inlineData: { mimeType: attachment.type, data: base64ImageData } });
            prompt += "\n\nPlease also consider the attached document in your analysis.";
          }

          const orMessages = [
            attachment ? {
              role: 'user',
              content: [
                { type: 'text', text: prompt },
                { type: 'image_url', image_url: `data:${attachment.type};base64,${await fileToBase64(attachment)}` }
              ]
            } : { role: 'user', content: prompt }
          ];

          const response = await fetch(getDirectGeminiConfig().url, {
            method: 'POST',
            headers: getDirectGeminiConfig().headers,
            body: JSON.stringify({
              model: attachment ? OPENROUTER_QWEN_VL_MODEL : OPENROUTER_QWEN_MODEL,
              messages: orMessages
            })
          });

          if (!response.ok) {
            throw new Error(`API Error: ${response.status} ${response.statusText}`);
          }

          const result = await response.json();
          const aiResponse = (result.choices?.[0]?.message?.content || '');
          setMessages(prev => [...prev, { text: aiResponse, sender: 'ai' }]);
        } catch (err) {
          console.error("Chatbot error:", err);
          setMessages(prev => [...prev, { text: "Unable to connect or your prompt limit may be reached. Try again or sign in, or subscribe to continue.", sender: 'ai' }]);
        } finally {
          setIsLoading(false);
        }
      };

      return (
        <div className="p-6 pb-24 h-screen flex flex-col">
          <header className="mb-6 text-center">
            <div className="flex items-center justify-between mb-2">
              <div></div> {/* Spacer for centering */}
              <h1 className="text-3xl font-bold text-gray-800 dark:text-gray-200">AI Health Coach</h1>
              <button
                onClick={startNewConversation}
                className="bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded-lg text-sm font-medium transition-colors flex items-center gap-1"
                title="Start New Conversation"
              >
                üîÑ New
              </button>
            </div>
            <p className="text-gray-500 dark:text-gray-400">Your personal health assistant</p>
          </header>

          <div className="flex-grow overflow-y-auto p-4 rounded-2xl shadow-md relative" 
               style={{
                 backgroundColor: isDarkMode ? '#0f172a' : '#f7fafc',
                 backgroundImage: isDarkMode
                   ? `
                     radial-gradient(circle, rgba(255,255,255,0.10) 3px, transparent 4px),
                     radial-gradient(circle, rgba(99,102,241,0.22) 3px, transparent 4px),
                     radial-gradient(circle, rgba(236,72,153,0.18) 3px, transparent 4px)
                   `
                   : `
                     radial-gradient(circle, rgba(99,102,241,0.16) 3px, transparent 4px),
                     radial-gradient(circle, rgba(236,72,153,0.14) 3px, transparent 4px),
                     radial-gradient(circle, rgba(168,85,247,0.12) 3px, transparent 4px)
                   `,
                 backgroundSize: '42px 42px, 62px 62px, 82px 82px',
                 backgroundPosition: '0 0, 21px 21px, 11px 31px'
               }}>
            
            {/* Bubble overlay for subtle larger shapes (WhatsApp-like wallpaper) */}
            <div className="absolute inset-0 rounded-2xl pointer-events-none"
                 style={{
                   opacity: isDarkMode ? 0.45 : 0.2,
                   backgroundImage: isDarkMode
                     ? `
                       radial-gradient(circle at 30px 30px, rgba(255,255,255,0.18) 10px, transparent 11px),
                       radial-gradient(circle at 90px 90px, rgba(99,102,241,0.22) 12px, transparent 13px),
                       radial-gradient(circle at 150px 60px, rgba(236,72,153,0.20) 9px, transparent 10px)
                     `
                     : `
                       radial-gradient(circle at 30px 30px, rgba(99,102,241,0.16) 10px, transparent 11px),
                       radial-gradient(circle at 90px 90px, rgba(236,72,153,0.14) 12px, transparent 13px),
                       radial-gradient(circle at 150px 60px, rgba(168,85,247,0.12) 9px, transparent 10px)
                     `,
                   backgroundSize: '140px 140px'
                 }}></div>
            
            {/* Content container */}
            <div className="relative z-10">
              <div className="text-center text-xs text-gray-600 dark:text-gray-400 p-2 mb-2 bg-white dark:bg-gray-700 rounded-lg shadow-sm">
                Disclaimer: This AI is for informational purposes only and is not a substitute for professional medical advice. Always consult a doctor for health concerns.
              </div>

              {messages.map((msg, i) => (
                <div key={i} className={`flex mb-3 ${msg.sender === 'user' ? 'justify-end' : 'justify-start'}`}>
                  <div className={`p-3 rounded-2xl max-w-xs shadow-lg ${
                    msg.sender === 'user' 
                      ? 'bg-pink-500 text-white' 
                      : 'bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200'
                  }`}>
                    {msg.attachment && <img src={msg.attachment} alt="attachment" className="rounded-lg mb-2 max-w-full h-auto" />}
                    {msg.text}
                  </div>
                </div>
              ))}
              <div ref={chatEndRef} />
            </div>
          </div>

          {attachmentPreview && (
            <div className="mt-2 p-2 bg-gray-200 dark:bg-gray-700 rounded-lg flex items-center justify-between">
              <img src={attachmentPreview} alt="preview" className="w-12 h-12 rounded-md object-cover" />
              <button onClick={() => { setAttachment(null); setAttachmentPreview(null); }} className="text-red-500 font-bold">Remove</button>
            </div>
          )}

          <div className="mt-4 flex items-stretch w-full gap-2">
            {uploadsEnabled && (
              <>
                <input type="file" accept="image/*" ref={fileInputRef} onChange={handleAttachmentChange} className="hidden" />
                <button onClick={() => fileInputRef.current?.click()} className="p-3 border dark:border-gray-700 rounded-l-lg bg-gray-100 dark:bg-gray-700 flex-shrink-0">üìé</button>
              </>
            )}
            <input
              type="text"
              value={input}
              onChange={e => setInput(e.target.value)}
              onKeyDown={e => e.key === 'Enter' && handleSend()}
              placeholder="Ask a question..."
              className={`flex-1 min-w-0 p-3 ${uploadsEnabled ? 'border-t border-b' : 'border rounded-l-lg'} dark:border-gray-700 focus:outline-none focus:ring-2 focus:ring-pink-500 bg-white dark:bg-gray-800 text-gray-800 dark:text-gray-200`}
              disabled={isLoading}
            />
            <button onClick={handleSend} disabled={isLoading} className="bg-pink-500 text-white p-3 rounded-r-lg font-bold flex-shrink-0">
              {isLoading ? '...' : 'Send'}
            </button>
          </div>
        </div>
      );
    };

    // Progress Screen Component
    const Progress = ({ dailyHistory, goals, dailyIntake, habitAIAdvice, setHabitAIAdvice, isLoadingAdvice, setIsLoadingAdvice }) => {
      const { updateUserData, user } = useAuth();
      const [currentDate, setCurrentDate] = useState(new Date());
      const [selectedDay, setSelectedDay] = useState(null);
      const [viewMode, setViewMode] = useState('month'); // 'month' or 'year'
      const [activeTab, setActiveTab] = useState(() => localStorage.getItem('progress_activeTab') || 'progress'); // 'progress' or 'habits'
    useEffect(() => {
      try {
        if (typeof setLocalStorageWithSync === 'function') {
          setLocalStorageWithSync('progress_activeTab', activeTab);
        } else {
          localStorage.setItem('progress_activeTab', activeTab);
        }
      } catch (e) {
        // ignore storage errors
      }
    }, [activeTab]);
    const [habits, setHabits] = useState(() => {
        const savedHabits = localStorage.getItem('habits');
        return savedHabits ? JSON.parse(savedHabits) : [];
      });
      const [newHabit, setNewHabit] = useState('');
      const [workoutHistory, setWorkoutHistory] = useState(() => {
        try {
          const saved = localStorage.getItem('workoutHistory');
          return saved ? JSON.parse(saved) : [];
        } catch (e) {
          return [];
        }
      });

      useEffect(() => {
        const readWorkoutHistory = () => {
          try {
            const raw = localStorage.getItem('workoutHistory');
            const parsed = raw ? JSON.parse(raw) : [];
            setWorkoutHistory(Array.isArray(parsed) ? parsed : []);
          } catch (_) {
            setWorkoutHistory([]);
          }
        };

        const onStorage = (e) => {
          try {
            if (!e || e.key === 'workoutHistory') readWorkoutHistory();
          } catch (_) {}
        };

        const onMessage = (e) => {
          try {
            if (!e || e.origin !== window.location.origin) return;
            if (e.data && e.data.type === 'fitmate-workout-history-updated') readWorkoutHistory();
          } catch (_) {}
        };

        const onVis = () => {
          try {
            if (!document.hidden) readWorkoutHistory();
          } catch (_) {}
        };

        window.addEventListener('storage', onStorage);
        window.addEventListener('message', onMessage);
        document.addEventListener('visibilitychange', onVis);
        return () => {
          window.removeEventListener('storage', onStorage);
          window.removeEventListener('message', onMessage);
          document.removeEventListener('visibilitychange', onVis);
        };
      }, []);

      const [stressForm, setStressForm] = useState(() => {
        try {
          const raw = localStorage.getItem('stressForm');
          const parsed = raw ? JSON.parse(raw) : {};
          return {
            sleepHours: parsed.sleepHours ?? '',
            workHours: parsed.workHours ?? '',
            stressRating: parsed.stressRating ?? '',
            stressEpisodes: parsed.stressEpisodes ?? '',
            exerciseMins: parsed.exerciseMins ?? '',
            meditationMins: parsed.meditationMins ?? '',
            socialMins: parsed.socialMins ?? '',
            screenHours: parsed.screenHours ?? '',
            lifeEvent: parsed.lifeEvent ?? 'none',
            notes: parsed.notes ?? ''
          };
        } catch (_) {
          return { sleepHours:'', workHours:'', stressRating:'', stressEpisodes:'', exerciseMins:'', meditationMins:'', socialMins:'', screenHours:'', lifeEvent:'none', notes:'' };
        }
      });
        const [stressResult, setStressResult] = useState(null);
        const [stressInsight, setStressInsight] = useState('');
        // Persist and restore computed stress result so it survives tab changes
        useEffect(() => {
          try {
            const raw = localStorage.getItem('stressResult');
            if (raw) {
              const r = JSON.parse(raw);
              setStressResult(r);
              setStressInsight(generateStressInsight(r, stressForm));
            }
          } catch (_) {}
        }, []);
        useEffect(() => {
          try {
            if (stressResult) localStorage.setItem('stressResult', JSON.stringify(stressResult));
          } catch (_) {}
        }, [stressResult]);
      const [lifeEventInfoOpen, setLifeEventInfoOpen] = useState(false);
      // UI-only: track focus on Work hours to show helper when empty
      const [workHoursFocused, setWorkHoursFocused] = useState(false);

      // Breathing exercise state (UI-only; self-contained)
      const [showBreathing, setShowBreathing] = useState(false);
      const [breathStepIndex, setBreathStepIndex] = useState(0);
      const [breathPhaseLabel, setBreathPhaseLabel] = useState('');
      const [breathPhaseSecondsLeft, setBreathPhaseSecondsLeft] = useState(0);
      const [breathTotalSecondsLeft, setBreathTotalSecondsLeft] = useState(180); // default ~3 minutes
      const breathTimerRef = useRef(null);
      const breathPlanRef = useRef([
        { label: 'Breathe In!', duration: 4, scale: 1.12 },
        { label: 'Hold!', duration: 7, scale: 1.12 },
        { label: 'Exhale', duration: 8, scale: 0.95 }
      ]);
      const formatMMSS = (s) => {
        const m = Math.floor(s / 60);
        const sec = String(s % 60).padStart(2, '0');
        return `${String(m).padStart(2, '0')}:${sec}`;
      };
      const startBreathing = (total = 180) => {
        try { if (breathTimerRef.current) { clearInterval(breathTimerRef.current); breathTimerRef.current = null; } } catch(_) {}
        setBreathTotalSecondsLeft(total);
        setBreathStepIndex(0);
        setBreathPhaseLabel(breathPlanRef.current[0].label);
        setBreathPhaseSecondsLeft(breathPlanRef.current[0].duration);
        setShowBreathing(true);
      };
      const stopBreathing = () => {
        try { if (breathTimerRef.current) { clearInterval(breathTimerRef.current); breathTimerRef.current = null; } } catch(_) {}
        setShowBreathing(false);
        setBreathTotalSecondsLeft(180);
        setBreathPhaseSecondsLeft(0);
        setBreathStepIndex(0);
      };
      useEffect(() => {
        if (!showBreathing) return;
        try { if (breathTimerRef.current) clearInterval(breathTimerRef.current); } catch(_) {}
        breathTimerRef.current = setInterval(() => {
          setBreathTotalSecondsLeft(prev => {
            const next = Math.max(0, prev - 1);
            if (next === 0) { stopBreathing(); }
            return next;
          });
          setBreathPhaseSecondsLeft(prev => {
            const nxt = prev - 1;
            if (nxt <= 0) {
              setBreathStepIndex(idx => {
                const newIdx = (idx + 1) % breathPlanRef.current.length;
                const step = breathPlanRef.current[newIdx];
                setBreathPhaseLabel(step.label);
                setBreathPhaseSecondsLeft(step.duration);
                return newIdx;
              });
              return 0;
            }
            return nxt;
          });
        }, 1000);
        return () => { try { clearInterval(breathTimerRef.current); } catch(_) {} breathTimerRef.current = null; };
      }, [showBreathing]);

      useEffect(() => {
        try { localStorage.setItem('stressForm', JSON.stringify(stressForm)); } catch (_) {}
      }, [stressForm]);

      // Derived totals: enforce that time-based inputs do not exceed 24 hours/day
      const stressTotalHours = (() => {
        const sh = Number(stressForm.sleepHours || 0);
        const wh = Number(stressForm.workHours || 0);
        const scr = Number(stressForm.screenHours || 0);
        const ex = Number(stressForm.exerciseMins || 0) / 60;
        const med = Number(stressForm.meditationMins || 0) / 60;
        const soc = Number(stressForm.socialMins || 0) / 60;
        return sh + wh + scr + ex + med + soc;
      })();
      const exceedsDayHours = stressTotalHours > 24;

      const computeStressScore = (inp) => {
        const v = {
          sleepHours: Number(inp.sleepHours || 0),
          workHours: Number(inp.workHours || 0),
          stressRating: Number(inp.stressRating || 0),
          stressEpisodes: Number(inp.stressEpisodes || 0),
          exerciseMins: Number(inp.exerciseMins || 0),
          meditationMins: Number(inp.meditationMins || 0),
          socialMins: Number(inp.socialMins || 0),
          screenHours: Number(inp.screenHours || 0),
          lifeEvent: inp.lifeEvent || 'none'
        };
        // Guard: total of time-based inputs must not exceed 24h
        const _totalHours = v.sleepHours + v.workHours + v.screenHours + (v.exerciseMins/60) + (v.meditationMins/60) + (v.socialMins/60);
        if (_totalHours > 24) {
          return {
            stressScore: 0,
            category: 'Invalid',
            confidence: 0,
            breakdown: {
              drivers: { sleep: 0, work: 0, selfRating: 0, episodes: 0, screen: 0 },
              buffers: { exercise: 0, meditation: 0, social: 0 }
            },
            lifeEventMultiplier: 1.0
          };
        }
        const clamp01 = (x) => Math.max(0, Math.min(1, x));
        // Normalize inputs to 0-1
        const sleep = clamp01(Math.abs((v.sleepHours || 0) - 8) / 4);
        // Work: asymmetric deviation around 8h (below is milder, above is stronger)
        const workUnder = clamp01(Math.max(0, 8 - (v.workHours || 0)) / 5); // slower ramp
        const workOver = clamp01(Math.max(0, (v.workHours || 0) - 8) / 3);   // faster ramp
        const work = clamp01(workUnder + workOver);
        const rating = clamp01((v.stressRating - 1) / 9);
        const episodes = clamp01((v.stressEpisodes || 0) / 6);
        const screen = clamp01((v.screenHours || 0) / 8);
        const exerciseRelief = clamp01((v.exerciseMins || 0) / 45);
        const meditationRelief = clamp01((v.meditationMins || 0) / 15);
        const socialRelief = clamp01((v.socialMins || 0) / 60);

        // Amplification tails and dampening
        const ratingTail = clamp01(Math.max(0, (v.stressRating || 0) - 7) / 3); // 7‚Üí10
        const episodesTail = clamp01(Math.max(0, (v.stressEpisodes || 0) - 3) / 3); // 3‚Üí6
        const undersleepTail = clamp01(Math.max(0, 7 - (v.sleepHours || 0)) / 3);
        // Moderate tail begins at 10h (gentle bump), heavy tail beyond 12h
        const moderateOverworkTail = clamp01(Math.max(0, (v.workHours || 0) - 10) / 4);
        const overworkTail = clamp01(Math.max(0, (v.workHours || 0) - 12) / 4);
        const moderateWorkTailWeight = 10;
        const workTailWeight = 30;
        const sleepTailWeight = 20;
        const psychTailRatingWeight = 30;
        const psychTailEpisodesWeight = 30;

        // Weights
        const w = { sleep:25, work:20, rating:12, episodes:8, screen:10, exercise:15, meditation:5, social:5 };
        const stressors = sleep*w.sleep + work*w.work + rating*w.rating + episodes*w.episodes + screen*w.screen
          + moderateOverworkTail*moderateWorkTailWeight + overworkTail*workTailWeight + undersleepTail*sleepTailWeight
          + ratingTail*psychTailRatingWeight + episodesTail*psychTailEpisodesWeight;

        const bufferSum = exerciseRelief*w.exercise + meditationRelief*w.meditation + socialRelief*w.social;
        const WORK_BUFFER_DAMPEN = 0.7;
        const PSYCH_BUFFER_DAMPEN = 0.6;
        const bufferScale = clamp01((1 - WORK_BUFFER_DAMPEN * work) * (1 - PSYCH_BUFFER_DAMPEN * Math.max(ratingTail, episodesTail)));
        const effectiveBuffer = bufferSum * bufferScale;
        let rawIndex = stressors - effectiveBuffer; // Range: [-25, 75]
        
        // Map to 0-100 base score
        let baseScore = Math.max(0, Math.min(100, rawIndex + 25));
        
        // Life event multiplier (amplifies stress)
        let multiplier = 1.0;
        if (v.lifeEvent === 'minor') multiplier = 1.5;
        else if (v.lifeEvent === 'major') multiplier = 2.0;
        
        let stressScore = Math.round(Math.min(100, baseScore * multiplier));

        let category = 'Low';
        if (stressScore >= 76) category = 'Very High';
        else if (stressScore >= 51) category = 'High';
        else if (stressScore >= 26) category = 'Moderate';

        // Confidence: inverse-of-stress baseline with penalties and boosts
        const pw = { sleepHours:.25, workHours:.20, stressRating:.12, stressEpisodes:.08, screenHours:.10, exerciseMins:.15, meditationMins:.05, socialMins:.05 };
        const filled = (k) => { const val = inp[k]; return val !== '' && val !== null && val !== undefined; };
        let coverage = 0; Object.keys(pw).forEach(k => { if (filled(k)) coverage += pw[k]; });
        const baseConfidence = 100 - stressScore;
        let volatilityPenalty = 0;
        if (undersleepTail > 0.66) volatilityPenalty += 10; else if (undersleepTail > 0.33) volatilityPenalty += 5;
        if (overworkTail > 0.50) volatilityPenalty += 8; else if (overworkTail > 0.25) volatilityPenalty += 4;
        if (rating >= 0.7) volatilityPenalty += 8; else if (rating >= 0.5) volatilityPenalty += 4;
        if (episodes >= 0.7) volatilityPenalty += 8; else if (episodes >= 0.5) volatilityPenalty += 4;
        if (screen >= 0.75) volatilityPenalty += 6; else if (screen >= 0.5) volatilityPenalty += 3;
        let bufferBoost = 0;
        if (exerciseRelief >= 0.8) bufferBoost += 5;
        if (meditationRelief >= 0.8) bufferBoost += 3;
        if (socialRelief >= 0.8) bufferBoost += 4;
        let missingPenalty = 0; if (coverage < 0.5) missingPenalty = 10; else if (coverage < 0.75) missingPenalty = 5;
        const eventPenalty = (v.lifeEvent === 'major') ? 10 : (v.lifeEvent === 'minor' ? 5 : 0);
        const confidence = Math.max(20, Math.min(95, Math.round(baseConfidence - volatilityPenalty - eventPenalty - missingPenalty + bufferBoost)));

        // UI drivers: cap to base weights to avoid misleading values
        const drivers = {
          sleep: Math.min(w.sleep, Math.round(sleep * w.sleep)),
          work: Math.min(w.work, Math.round(work * w.work)),
          selfRating: Math.min(w.rating, Math.round(rating * w.rating)),
          episodes: Math.min(w.episodes, Math.round(episodes * w.episodes)),
          screen: Math.min(w.screen, Math.round(screen * w.screen))
        };
        const buffers = {
          exercise: Math.round(exerciseRelief * w.exercise),
          meditation: Math.round(meditationRelief * w.meditation),
          social: Math.round(socialRelief * w.social)
        };

        return { stressScore, category, confidence, breakdown: { drivers, buffers }, lifeEventMultiplier: multiplier };
      };

      const generateStressInsight = (res, inp) => {
        const d = res.breakdown?.drivers || {};
        const entries = [
          ['work', d.work],
          ['self rating', d.selfRating],
          ['sleep', d.sleep],
          ['screen time', d.screen],
          ['episodes', d.episodes]
        ];
        entries.sort((a, b) => (b[1]||0) - (a[1]||0));
        const top = entries.filter(e => (e[1]||0) > 0).slice(0, 2).map(e => e[0]);

        const b = res.breakdown?.buffers || {};
        const reliefs = [
          ['exercise', b.exercise],
          ['meditation', b.meditation],
          ['social time', b.social]
        ].filter(e => (e[1]||0) > 0).sort((a,b)=> (b[1]||0) - (a[1]||0));

        const act = [];
        if (top.includes('sleep') || Number(inp.sleepHours || 0) < 7) act.push('sleeping less or more than the ideal 8 hours can raise stress by disrupting recovery and mood. Any deviation from this target affects your score, so aim for 7.5‚Äì8 hours tonight and keep screens away for an hour before bed');
        if (top.includes('work') || Number(inp.workHours || 0) > 9) act.push('working less or more than the ideal 8 hours can elevate stress by affecting productivity and routine, and any deviation from this target impacts your score negatively. Once you reach 8 hours, take 10-minute breaks every 90 minutes and aim to finish work at a consistent, firm time');
        if (top.includes('screen time') || Number(inp.screenHours || 0) > 6) act.push('excessive screen time can heighten stress by overstimulating the mind and disrupting wind-down. Set a 30-minute app limit after 9 PM to help reduce late-evening screen use');
        if (top.includes('self rating') || Number(inp.stressRating || 0) >= 7) act.push('high stress ratings signal elevated tension in your system. Use the 4-7-8 breathing technique for three cycles whenever stress spikes to help calm your mind and body');
        if (top.includes('episodes') || Number(inp.stressEpisodes || 0) >= 3) act.push('frequent stress episodes indicate recurring triggers. Log each trigger and take a brief walk to reset when an episode appears');

        let s1 = `Stress is ${res.category} (score ${res.stressScore}). Top drivers: ${top.join(' and ') || 'balanced factors'}.`;
        let s2 = `Action: ${act.slice(0,2).join('; ')}.`;
        let s3 = '';
        if (reliefs.length > 0) s3 = `Good job: ${reliefs[0][0]} helped buffer stress. Keep it up.`;
        const text = [s1, s2, s3].filter(Boolean).join(' ');
        return text;
      };

      // New: Generate Stress-Linked Habit Suggestions (UI-only, no layout changes)
      const generateStressHabitSuggestions = (res, inp) => {
        try {
          if (!res || !res.breakdown) return [];
          const d = res.breakdown.drivers || {};
          // Rank primary stress drivers
          const rank = [
            ['sleep', d.sleep || 0],
            ['screen', d.screen || 0],
            ['work', d.work || 0],
            ['selfRating', d.selfRating || 0],
            ['episodes', d.episodes || 0]
          ].sort((a,b)=> (b[1]||0) - (a[1]||0));

          const topKey = (rank[0] && rank[0][0]) || null;

          const suggestions = [];
          // Driver-targeted suggestion
          if (res.stressScore >= 26 && topKey) {
            if (topKey === 'sleep') {
              suggestions.push({ name: 'Wind-down routine', note: 'Sleep below or above your ideal range ‚Üí add a wind-down routine to stabilize your rhythm.' });
            } else if (topKey === 'screen') {
              suggestions.push({ name: 'Digital Sunset', note: 'High screen time ‚Üí start a Digital Sunset habit.' });
            } else if (topKey === 'work') {
              suggestions.push({ name: 'Daily ritual', note: 'Irregular work hours whether too high or too low ‚Üí set a daily ritual reminder.' });
            } else if (topKey === 'selfRating') {
              suggestions.push({ name: '4-7-8 breathing (3 cycles)', note: 'High stress rating ‚Üí practice 4‚Äë7‚Äë8 breathing each evening.' });
            } else if (topKey === 'episodes') {
              suggestions.push({ name: 'Trigger log + 10m walk', note: 'Frequent episodes ‚Üí log triggers and take a short walk.' });
            }

            // Buffer-based suggestions (light-touch, capped to keep UI compact)
            const b = res.breakdown.buffers || {};
            if ((b.meditation||0) < 3) suggestions.push({ name: '15m evening meditation', note: 'Build a calming buffer for stress.' });
            if ((b.exercise||0) < 5) suggestions.push({ name: '30m light cardio', note: 'Movement reduces stress load.' });
            if ((b.social||0) < 2) suggestions.push({ name: 'Weekly 60m social time', note: 'Quality time buffers stress.' });
          }
          return suggestions.slice(0, 3);
        } catch (_) { return []; }
      };

      // Helper: use shared timezone-aware formatter so calendar keys match archive keys
      const getLocalDateString = (date) => toLocalISODate(date);

      useEffect(() => {
        let timeoutId;
        let lastKey = getLocalDateString(new Date());

        const scheduleNextMidnight = () => {
          const now = new Date();
          const nextMidnight = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1, 0, 0, 0, 0);
          const ms = nextMidnight.getTime() - now.getTime();
          timeoutId = setTimeout(() => {
            setCurrentDate(new Date());
            lastKey = getLocalDateString(new Date());
            scheduleNextMidnight();
          }, Math.max(ms, 1000));
        };

        scheduleNextMidnight();

        const pollId = setInterval(() => {
          const key = getLocalDateString(new Date());
          if (key !== lastKey) {
            lastKey = key;
            setCurrentDate(new Date());
          }
        }, 60000);

        return () => {
          clearTimeout(timeoutId);
          clearInterval(pollId);
        };
      }, []);

      // Save habits to localStorage and sync with Firebase whenever they change
      useEffect(() => {
        localStorage.setItem('habits', JSON.stringify(habits));
        // Sync with Firebase if user is authenticated
        if (user && updateUserData) {
          updateUserData({ habits });
        }
      }, [habits, user, updateUserData]);

      useEffect(() => {
        const handleStorageChange = (e) => {
          if (e.key === 'workoutHistory') {
            try {
              const updatedHistory = JSON.parse(e.newValue || '[]');
              if (Array.isArray(updatedHistory)) {
                setWorkoutHistory(updatedHistory);
              }
            } catch (error) {
              console.warn('Error parsing workoutHistory from storage event:', error);
            }
          }
        };

        window.addEventListener('storage', handleStorageChange);
        return () => window.removeEventListener('storage', handleStorageChange);
      }, []);

      // Monthly backfill: fetch remote daily_history when Progress view opens
      useEffect(() => {
        const fetchMonthlyBackfill = async () => {
          if (!user || !supabase) return;
          
          try {
            console.log('üîÑ Progress view opened: fetching monthly history backfill...');
            
            // Get current month date range
            const now = new Date();
            const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
            const endOfMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0);
            const todayISO = toLocalISODate(now);
            
            // Fetch user data from Supabase
            const userData = await db.getUser(user.id);
            
            if (userData && userData.daily_history) {
              const localHistory = (() => { 
                try { 
                  return JSON.parse(localStorage.getItem('dailyHistory') || '{}') || {}; 
                } catch { 
                  return {}; 
                } 
              })();
              
              const remoteHistory = userData.daily_history || {};
              
              // Remote-only past days: prefer remote for all past days, keep current day local
              const merged = { ...remoteHistory }; // Start with remote data
              
              // Only preserve local data for today
              if (localHistory[todayISO]) {
                merged[todayISO] = localHistory[todayISO];
              }
              
              localStorage.setItem('dailyHistory', JSON.stringify(merged));
              console.log('‚úÖ Monthly backfill completed: remote history merged (preserving today\'s local data)');
              
              // Trigger UI refresh
              window.dispatchEvent(new CustomEvent('userDataSynced'));
            }
          } catch (error) {
            console.error('Error during monthly backfill:', error);
          }
        };
        
        // Only run backfill if we have a user
        if (user) {
          fetchMonthlyBackfill();
        }
      }, [user, supabase]); // Run when user changes or component mounts

      const startOfMonth = new Date(currentDate.getFullYear(), currentDate.getMonth(), 1);
      const endOfMonth = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 0);
      // Adjust start day for Monday-first calendar (0=Sunday becomes 6, 1=Monday becomes 0)
      const startDay = (startOfMonth.getDay() + 6) % 7;
      const daysInMonth = endOfMonth.getDate();

      const getScoreColor = (score) => {
        if (score >= 90) return 'from-emerald-400 to-emerald-600';
        if (score >= 80) return 'from-green-400 to-green-600';
        if (score >= 70) return 'from-lime-400 to-lime-600';
        if (score >= 60) return 'from-yellow-400 to-yellow-600';
        if (score >= 50) return 'from-orange-400 to-orange-600';
        return 'from-red-400 to-red-600';
      };

      const getScoreGlow = (score) => {
        if (score >= 90) return 'shadow-emerald-500/50';
        if (score >= 80) return 'shadow-green-500/50';
        if (score >= 70) return 'shadow-lime-500/50';
        if (score >= 60) return 'shadow-yellow-500/50';
        if (score >= 50) return 'shadow-orange-500/50';
        return 'shadow-red-500/50';
      };

      // Calculate current streak without breaking mid-day: if today's score < 70 or not yet available, start from yesterday
      const calculateStreak = () => {
        const today = new Date();
        let streak = 0;
        let currentDay = new Date(today);

        const todayISO = toLocalISODate(today);
        let todayScore = dailyHistory[todayISO]?.score;
        if (todayScore === undefined) {
          // Compute on the fly if not archived yet
          const computed = computeHealthScoreForDate(dailyIntake, goals, todayISO).score;
          todayScore = typeof computed === 'number' ? computed : undefined;
        }

        // If today's score isn't >= 70, begin counting from yesterday so the streak doesn't drop to 0 mid-day
        if (!(typeof todayScore === 'number' && todayScore >= 70)) {
          currentDay.setDate(currentDay.getDate() - 1);
        }

        const oneYearAgo = new Date(today.getTime() - 365 * 24 * 60 * 60 * 1000);
        while (currentDay >= oneYearAgo) {
          const dateString = toLocalISODate(currentDay);
          let dayScore = dailyHistory[dateString]?.score;

          if (typeof dayScore === 'number' && dayScore >= 70) {
            streak++;
          } else {
            break;
          }

          currentDay.setDate(currentDay.getDate() - 1);
        }

        return streak;
      };

      // Calculate monthly stats (includes today's computed score if in current month)
      const getMonthlyStats = () => {
        let monthData = Object.entries(dailyHistory)
          .filter(([date]) => {
            // Parse YYYY-MM-DD as local time to avoid UTC shift issues
            const [y, m, d] = (date || '').split('-').map(Number);
            if (!y || !m || !d) return false;
            const local = new Date(y, m - 1, d);
            return local.getMonth() === currentDate.getMonth() && local.getFullYear() === currentDate.getFullYear();
          })
          .map(([_, data]) => data);

        const today = new Date();
        const todayISO = toLocalISODate(today);
        const inCurrentMonth = today.getMonth() === currentDate.getMonth() && today.getFullYear() === currentDate.getFullYear();
        if (inCurrentMonth && !dailyHistory[todayISO]) {
          const computed = computeHealthScoreForDate(dailyIntake, goals, todayISO).score;
          monthData = monthData.concat([{ score: computed }]);
        }

        if (monthData.length === 0) return { avg: 0, best: 0, days: 0 };

        const scores = monthData.map(d => d.score).filter(s => typeof s === 'number');
        if (scores.length === 0) return { avg: 0, best: 0, days: 0 };

        const avg = scores.reduce((sum, s) => sum + s, 0) / scores.length;
        const best = Math.max(...scores);
        return { avg: Math.round(avg), best, days: scores.length };
      };

      const currentStreak = calculateStreak();
      const monthlyStats = getMonthlyStats();

      return (
        <div className="p-6 pb-24 bg-gradient-to-br from-purple-50 via-pink-50 to-blue-50 dark:from-gray-900 dark:via-purple-900/20 dark:to-blue-900/20 min-h-screen">
          {/* Header */}
          <header className="mb-8 text-center">
            <div className="inline-flex items-center justify-center w-16 h-16 bg-gradient-to-r from-purple-500 to-pink-500 rounded-2xl mb-4 shadow-lg">
              <span className="text-2xl">üìä</span>
            </div>
            <h1 className="text-4xl font-bold bg-gradient-to-r from-purple-600 to-pink-600 bg-clip-text text-transparent mb-2">Your Progress</h1>
            <p className="text-gray-600 dark:text-gray-400 text-lg">Track your fitness journey</p>
          </header>

          {/* Tab Navigation */}
          <div className="flex justify-center mb-6">
            <div className="bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm p-1 rounded-xl shadow-md border border-white/20 flex">
              <button 
                onClick={() => setActiveTab('progress')} 
                className={`px-6 py-3 rounded-lg font-semibold transition-all duration-200 ${activeTab === 'progress' ? 'bg-gradient-to-r from-purple-500 to-pink-500 text-white shadow-md' : 'text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700'}`}
              >
                Progress
              </button>
              <button 
                onClick={() => setActiveTab('habits')} 
                className={`px-6 py-3 rounded-lg font-semibold transition-all duration-200 ${activeTab === 'habits' ? 'bg-gradient-to-r from-purple-500 to-pink-500 text-white shadow-md' : 'text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700'}`}
              >
                Habit Tracker
              </button>
              <button 
                onClick={() => setActiveTab('stress')} 
                className={`px-6 py-3 rounded-lg font-semibold transition-all duration-200 ${activeTab === 'stress' ? 'bg-gradient-to-r from-purple-500 to-pink-500 text-white shadow-md' : 'text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700'}`}
              >
                Stress Analyzer
              </button>
            </div>
          </div>

          {/* Tab Content */}
          {activeTab === 'progress' && (
            <>
              {/* Streak & Stats Cards */}
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-8">
            {/* Current Streak */}
            <div className="bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm p-6 rounded-3xl shadow-xl border border-white/20">
              <div className="flex items-center justify-between mb-3">
                <div className="w-12 h-12 bg-gradient-to-r from-orange-400 to-red-500 rounded-2xl flex items-center justify-center">
                  <span className="text-xl">üî•</span>
                </div>
                <span className="text-3xl font-bold bg-gradient-to-r from-orange-500 to-red-500 bg-clip-text text-transparent">
                  {currentStreak}
                </span>
              </div>
              <h3 className="font-semibold text-gray-800 dark:text-gray-200">Day Streak</h3>
              <p className="text-sm text-gray-600 dark:text-gray-400">Keep it going! üí™</p>
              <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">Counts days with Health Score &ge; 70.</p>
            </div>

            {/* Monthly Average */}
            <div className="bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm p-6 rounded-3xl shadow-xl border border-white/20">
              <div className="flex items-center justify-between mb-3">
                <div className="w-12 h-12 bg-gradient-to-r from-blue-400 to-purple-500 rounded-2xl flex items-center justify-center">
                  <span className="text-xl">üìà</span>
                </div>
                <span className="text-3xl font-bold bg-gradient-to-r from-blue-500 to-purple-500 bg-clip-text text-transparent">
                  {monthlyStats.avg}
                </span>
              </div>
              <h3 className="font-semibold text-gray-800 dark:text-gray-200">Monthly Avg</h3>
              <p className="text-sm text-gray-600 dark:text-gray-400">{monthlyStats.days} active days</p>
            </div>

            {/* Best Score */}
            <div className="bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm p-6 rounded-3xl shadow-xl border border-white/20">
              <div className="flex items-center justify-between mb-3">
                <div className="w-12 h-12 bg-gradient-to-r from-emerald-400 to-green-500 rounded-2xl flex items-center justify-center">
                  <span className="text-xl">üèÜ</span>
                </div>
                <span className="text-3xl font-bold bg-gradient-to-r from-emerald-500 to-green-500 bg-clip-text text-transparent">
                  {monthlyStats.best}
                </span>
              </div>
              <h3 className="font-semibold text-gray-800 dark:text-gray-200">Best Score</h3>
              <p className="text-sm text-gray-600 dark:text-gray-400">This month</p>
            </div>
          </div>

          {/* Modern Calendar */}
          <div className="bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm rounded-3xl shadow-2xl border border-white/20 overflow-hidden">
            {/* Calendar Header */}
            <div className="bg-blue-500 p-6">
              <div className="flex justify-between items-center">
                <button 
                  onClick={() => setCurrentDate(new Date(currentDate.setMonth(currentDate.getMonth() - 1)))} 
                  className="w-12 h-12 bg-white/20 hover:bg-white/30 rounded-2xl flex items-center justify-center text-white transition-all duration-200 hover:scale-105"
                >
                  <span className="text-xl">‚Üê</span>
                </button>
                
                <div className="text-center">
                  <h2 className="text-2xl font-bold text-white mb-1">
                    {currentDate.toLocaleString('default', { month: 'long', year: 'numeric' })}
                  </h2>
                  <p className="text-white/80 text-sm">Tap any day to see details</p>
                </div>
                
                <button 
                  onClick={() => setCurrentDate(new Date(currentDate.setMonth(currentDate.getMonth() + 1)))} 
                  className="w-12 h-12 bg-white/20 hover:bg-white/30 rounded-2xl flex items-center justify-center text-white transition-all duration-200 hover:scale-105"
                >
                  <span className="text-xl">‚Üí</span>
                </button>
              </div>
            </div>

            {/* Calendar Grid */}
            <div className="p-6">
              {/* Day Headers - Monday to Sunday */}
              <div className="grid grid-cols-7 gap-1 mb-2 bg-gray-100 dark:bg-gray-700 rounded-xl p-2">
                {['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'].map((day, index) => (
                  <div key={day} className={`text-center py-3 text-sm font-semibold rounded-lg border ${
                    index === 5 || index === 6 
                      ? 'bg-red-50 dark:bg-red-900/20 text-red-600 dark:text-red-400 border-red-200 dark:border-red-700' 
                      : 'bg-white dark:bg-gray-600 text-gray-600 dark:text-gray-300 border-gray-200 dark:border-gray-500'
                  }`}>
                    {day}
                  </div>
                ))}
              </div>

              {/* Calendar Days with Monday-first layout */}
              <div className="grid grid-cols-7 gap-1 bg-gray-100 dark:bg-gray-700 p-2 rounded-xl">
                {Array.from({ length: startDay }).map((_, i) => {
                  const dayOfWeek = i;
                  const isWeekend = dayOfWeek === 5 || dayOfWeek === 6; // Saturday=5, Sunday=6
                  return (
                    <div key={`empty-${i}`} className={`aspect-square rounded-lg border ${
                      isWeekend 
                        ? 'bg-red-50 dark:bg-red-900/10 border-red-200 dark:border-red-700' 
                        : 'bg-white dark:bg-gray-600 border-gray-200 dark:border-gray-500'
                    }`}></div>
                  );
                })}
                
                {Array.from({ length: daysInMonth }).map((_, day) => {
                  const date = new Date(currentDate.getFullYear(), currentDate.getMonth(), day + 1);
                  const dateString = getLocalDateString(date);
                  const data = dailyHistory[dateString];
                  const isToday = dateString === getLocalDateString(new Date());
                  // Adjust day of week calculation for Monday-first calendar
                  const dayOfWeek = (startDay + day) % 7;
                  const isWeekend = dayOfWeek === 5 || dayOfWeek === 6; // Saturday=5, Sunday=6
                  // Live score for today even if not yet archived
                  const liveScore = isToday ? computeHealthScoreForDate(dailyIntake, goals, dateString).score : null;
                  const showBubble = !!data || isToday;
                  const scoreValue = (data && typeof data.score === 'number') ? data.score : (isToday ? liveScore : null);
                  const inProgress = isToday && ((data && data.inProgress !== false) || !data);
                  const tileBase = 'aspect-square flex items-center justify-center cursor-pointer group relative rounded-lg border transition-all duration-200 overflow-hidden';
                  const tileWeekend = 'bg-red-50 dark:bg-red-900/10 border-red-200 dark:border-red-700 hover:border-red-300 dark:hover:border-red-600';
                  const tileWeekday = 'bg-white dark:bg-gray-600 border-gray-200 dark:border-gray-500 hover:border-gray-300 dark:hover:border-gray-400';
                  const tileToday = 'bg-purple-50 dark:bg-purple-900/10 border-purple-300 dark:border-purple-600 hover:border-purple-400 dark:hover:border-purple-500';

                  return (
                    <div 
                      key={day} 
                      onClick={() => {
                        if (data) {
                          setSelectedDay({ date: dateString, ...data });
                        } else if (isToday) {
                          const comps = computeHealthScoreForDate(dailyIntake, goals, dateString).components;
                          setSelectedDay({ date: dateString, intake: dailyIntake, score: liveScore, components: comps });
                        }
                      }} 
                      className={`${tileBase} ${isToday ? tileToday : (isWeekend ? tileWeekend : tileWeekday)}`}
                    >
                      {showBubble ? (
                        <div className={`w-10 h-10 bg-gradient-to-br ${getScoreColor(scoreValue)} rounded-xl flex items-center justify-center text-white font-bold text-sm shadow-lg ${getScoreGlow(scoreValue)} transform transition-all duration-200 group-hover:scale-110 group-hover:shadow-2xl ${isToday ? 'ring-2 ring-purple-400 ring-opacity-60' : ''} ${isWeekend ? 'ring-2 ring-red-300 dark:ring-red-600' : ''} ${inProgress ? 'animate-pulse' : ''}`}>
                          {scoreValue}
                        </div>
                      ) : (
                        <div className={`w-10 h-10 rounded-xl flex items-center justify-center font-medium transition-all duration-200 ${
                          isWeekend 
                            ? 'text-red-500 dark:text-red-400 group-hover:bg-red-100 dark:group-hover:bg-red-900/20' 
                            : 'text-gray-500 dark:text-gray-400 group-hover:bg-gray-50 dark:group-hover:bg-gray-500'
                        } ${isToday ? 'bg-purple-100 dark:bg-purple-900/40 text-purple-600 dark:text-purple-400 ring-2 ring-purple-400 ring-opacity-60' : ''}`}>
                          {day + 1}
                        </div>
                      )}

                      {/* Weekend Corner Marker */}
                      {isWeekend && (
                        <div className="absolute top-1 right-1 w-2 h-2 bg-red-400 dark:bg-red-500 rounded-full opacity-60"></div>
                      )}
                      {/* In-Progress badge for today (responsive) */}
                      {inProgress && (
                        <>
                          {/* Compact mobile badge to avoid overflow */}
                          <div className="absolute bottom-1 right-1 px-1 py-[1px] text-[9px] font-semibold rounded-full bg-purple-200 dark:bg-purple-700 text-purple-700 dark:text-purple-200 shadow-sm sm:hidden">
                            Live
                          </div>
                          {/* Full text badge for larger screens */}
                          <div className="absolute bottom-1 left-1 right-1 mx-auto w-fit max-w-[90%] px-2 py-[2px] text-[10px] font-semibold rounded-full bg-purple-200 dark:bg-purple-700 text-purple-700 dark:text-purple-200 shadow-sm hidden sm:flex">
                            In Progress
                          </div>
                        </>
                      )}
                    </div>
                  );
                })}
              </div>
            </div>
          </div>

          {/* Workout Analytics Dashboard */}
          <div className="mt-8 bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm p-6 rounded-3xl shadow-xl border border-white/20">
            <h3 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-4 flex items-center">
              <span className="mr-2">üí™</span>
              Workout Analytics
            </h3>
            {(() => {
              const last7Days = Array.from({length: 7}, (_, i) => {
                const date = new Date();
                date.setDate(date.getDate() - i);
                return date.toDateString();
              }).reverse();
              
              const weeklyWorkouts = last7Days.map(dateStr => {
                const dayWorkouts = workoutHistory.filter(w => new Date(w.timestamp).toDateString() === dateStr);
                return {
                  date: dateStr,
                  count: dayWorkouts.length,
                  totalTime: dayWorkouts.reduce((sum, w) => sum + w.duration, 0),
                  avgCompletion: dayWorkouts.length > 0 ? dayWorkouts.reduce((sum, w) => sum + w.completionRate, 0) / dayWorkouts.length : 0
                };
              });
              
              const totalWorkouts = workoutHistory.length;
              const avgCompletionRate = totalWorkouts > 0 ? workoutHistory.reduce((sum, w) => sum + w.completionRate, 0) / totalWorkouts : 0;
              const totalWorkoutTime = workoutHistory.reduce((sum, w) => sum + w.duration, 0);
              const workoutStreak = (() => {
                let streak = 0;
                for (let i = 0; i < 30; i++) {
                  const date = new Date();
                  date.setDate(date.getDate() - i);
                  const hasWorkout = workoutHistory.some(w => new Date(w.timestamp).toDateString() === date.toDateString());
                  if (hasWorkout) streak++;
                  else break;
                }
                return streak;
              })();
              
              return (
                <div className="space-y-4">
                  {/* Key Metrics */}
                  <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                    <div className="bg-gradient-to-br from-purple-500 to-pink-500 p-4 rounded-2xl text-white text-center">
                      <div className="text-2xl font-bold">{totalWorkouts >= 100 ? '100+' : totalWorkouts}</div>
                      <div className="text-xs opacity-90">Total Workouts</div>
                    </div>
                    <div className="bg-gradient-to-br from-blue-500 to-cyan-500 p-4 rounded-2xl text-white text-center">
                      <div className="text-2xl font-bold">{Math.round(avgCompletionRate)}%</div>
                      <div className="text-xs opacity-90">Avg Completion</div>
                    </div>
                    <div className="bg-gradient-to-br from-green-500 to-emerald-500 p-4 rounded-2xl text-white text-center">
                      <div className="text-2xl font-bold">
                        {totalWorkoutTime >= 60 
                          ? `${Math.floor(totalWorkoutTime/60)}h ${totalWorkoutTime%60}m`
                          : `${totalWorkoutTime}m`
                        }
                      </div>
                      <div className="text-xs opacity-90">Total Time</div>
                    </div>
                    <div className="bg-gradient-to-br from-orange-500 to-red-500 p-4 rounded-2xl text-white text-center">
                      <div className="text-2xl font-bold">{workoutStreak}</div>
                      <div className="text-xs opacity-90">Workout Streak</div>
                    </div>
                  </div>
                  
                  {/* Weekly Activity Chart (temporarily hidden)
                  <div className="bg-gray-50 dark:bg-gray-700/50 p-4 rounded-2xl">
                    <h4 className="text-sm font-semibold text-gray-700 dark:text-gray-300 mb-3">7-Day Activity</h4>
                    <div className="flex items-end justify-between h-20 space-x-1">
                      {weeklyWorkouts.map((day, index) => {
                        const maxTime = Math.max(...weeklyWorkouts.map(d => d.totalTime), 1);
                        const height = (day.totalTime / maxTime) * 100;
                        return (
                          <div key={index} className="flex-1 flex flex-col items-center">
                            <div 
                              className={`w-full rounded-t transition-all duration-300 ${
                                day.count > 0 
                                  ? 'bg-gradient-to-t from-purple-500 to-pink-500' 
                                  : 'bg-gray-300 dark:bg-gray-600'
                              }`}
                              style={{height: `${Math.max(height, 5)}%`}}
                              title={`${day.count} workouts, ${day.totalTime}min`}
                            ></div>
                            <div className="text-xs text-gray-500 dark:text-gray-400 mt-1">
                              {new Date(day.date).toLocaleDateString('en', {weekday: 'short'}).slice(0,1)}
                            </div>
                          </div>
                        );
                      })}
                    </div>
                  </div>
                  */}
                  
                  {/* Recent Workouts */}
                  {workoutHistory.length > 0 && (
                    <div className="bg-gray-50 dark:bg-gray-700/50 p-4 rounded-2xl">
                      <h4 className="text-sm font-semibold text-gray-700 dark:text-gray-300 mb-3">üìã Recent Workouts</h4>
                      <div className="space-y-2 max-h-40 overflow-y-auto">
                        {[...workoutHistory].sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp)).slice(0, 5).map((workout, index) => (
                          <div key={index} className="flex justify-between items-center p-3 bg-white dark:bg-gray-600 rounded-lg text-xs">
                            <div className="flex-1">
                              <div className="font-medium text-gray-800 dark:text-gray-200">{workout.workoutTitle}</div>
                              <div className="text-gray-500 dark:text-gray-400 space-y-1">
                                <div className="flex items-center gap-2">
                                  <span className={`px-2 py-0.5 rounded-full text-xs font-medium ${
                                    workout.workoutLevel === 'beginner' ? 'bg-green-100 text-green-700 dark:bg-green-900/30 dark:text-green-400' :
                                    workout.workoutLevel === 'intermediate' ? 'bg-yellow-100 text-yellow-700 dark:bg-yellow-900/30 dark:text-yellow-400' :
                                    'bg-red-100 text-red-700 dark:bg-red-900/30 dark:text-red-400'
                                  }`}>
                                    {workout.workoutLevel ? workout.workoutLevel.charAt(0).toUpperCase() + workout.workoutLevel.slice(1) : 'Beginner'}
                                  </span>
                                  <span>‚Ä¢</span>
                                  <span>{workout.duration}min</span>
                                  <span>‚Ä¢</span>
                                  <span>{Math.round(workout.completionRate)}% complete</span>
                                </div>
                                <div className="text-xs">
                                  {new Date(workout.timestamp).toLocaleDateString()} at {new Date(workout.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}
                                </div>
                              </div>
                            </div>
                            <div className="text-right">
                              <div className="text-green-600 dark:text-green-400 font-medium">{workout.exercisesCompleted}/{workout.totalExercises}</div>
                            </div>
                          </div>
                        ))}
                      </div>
                    </div>
                  )}
                  
                  {/* Workout Quality Insights */}
                  {workoutHistory.length > 0 && (
                    <div className="bg-gradient-to-r from-indigo-50 to-purple-50 dark:from-indigo-900/20 dark:to-purple-900/20 p-4 rounded-2xl">
                      <h4 className="text-sm font-semibold text-gray-700 dark:text-gray-300 mb-2">üí° Insights</h4>
                      <div className="text-sm text-gray-600 dark:text-gray-400 space-y-1">
                        {avgCompletionRate >= 90 && <div>üåü Excellent completion rate! You're crushing your workouts.</div>}
                        {workoutStreak >= 7 && <div>üî• Amazing streak! Consistency is key to success.</div>}
                        {totalWorkoutTime >= 300 && <div>‚è±Ô∏è You've invested serious time in your fitness journey.</div>}
                        {workoutHistory.filter(w => new Date(w.timestamp).toDateString() === new Date().toDateString()).length > 0 && 
                         <div>‚úÖ Great job working out today!</div>}
                      </div>
                    </div>
                  )}
                </div>
              );
            })()}
          </div>

          {/* Achievement Badges */}
          <div className="mt-8 bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm p-6 rounded-3xl shadow-xl border border-white/20">
            <h3 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-4 flex items-center">
              <span className="mr-2">üèÖ</span>
              Achievement Badges
            </h3>
            {(() => {
              const totalWorkouts = workoutHistory.length;
              const workoutStreak = (() => {
                let streak = 0;
                for (let i = 0; i < 30; i++) {
                  const date = new Date();
                  date.setDate(date.getDate() - i);
                  const hasWorkout = workoutHistory.some(w => new Date(w.timestamp).toDateString() === date.toDateString());
                  if (hasWorkout) streak++;
                  else break;
                }
                return streak;
              })();
              const avgCompletionRate = totalWorkouts > 0 ? workoutHistory.reduce((sum, w) => sum + w.completionRate, 0) / totalWorkouts : 0;
              const totalWorkoutTime = workoutHistory.reduce((sum, w) => sum + w.duration, 0);
              
              return (
                <div className="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-6 gap-4">
                  {/* Health Score Achievements (temporarily hidden)
                  <div className={`p-4 rounded-2xl text-center ${currentStreak >= 7 ? 'bg-gradient-to-br from-yellow-400 to-orange-500 text-white' : 'bg-gray-100 dark:bg-gray-700 text-gray-400'}`}>
                    <div className="text-2xl mb-2">üî•</div>
                    <div className="text-xs font-semibold">Week Warrior</div>
                    <div className="text-xs opacity-80">7 day streak</div>
                  </div>
                  
                  <div className={`p-4 rounded-2xl text-center ${currentStreak >= 30 ? 'bg-gradient-to-br from-purple-400 to-pink-500 text-white' : 'bg-gray-100 dark:bg-gray-700 text-gray-400'}`}>
                    <div className="text-2xl mb-2">üíé</div>
                    <div className="text-xs font-semibold">Diamond</div>
                    <div className="text-xs opacity-80">30 day streak</div>
                  </div>
                  
                  <div className={`p-4 rounded-2xl text-center ${monthlyStats.avg >= 80 ? 'bg-gradient-to-br from-green-400 to-emerald-500 text-white' : 'bg-gray-100 dark:bg-gray-700 text-gray-400'}`}>
                    <div className="text-2xl mb-2">‚≠ê</div>
                    <div className="text-xs font-semibold">Superstar</div>
                    <div className="text-xs opacity-80">80+ avg score</div>
                  </div>
                  
                  <div className={`p-4 rounded-2xl text-center ${monthlyStats.best >= 95 ? 'bg-gradient-to-br from-blue-400 to-cyan-500 text-white' : 'bg-gray-100 dark:bg-gray-700 text-gray-400'}`}>
                    <div className="text-2xl mb-2">üöÄ</div>
                    <div className="text-xs font-semibold">Perfectionist</div>
                    <div className="text-xs opacity-80">95+ best score</div>
                  </div>
                  */}
                  
                  {/* Workout Achievements */}
                  <div className={`p-4 rounded-2xl text-center ${totalWorkouts >= 10 ? 'bg-gradient-to-br from-indigo-400 to-blue-500 text-white' : 'bg-gray-100 dark:bg-gray-700 text-gray-400'}`}>
                    <div className="text-2xl mb-2">üí™</div>
                    <div className="text-xs font-semibold">Fitness Starter</div>
                    <div className="text-xs opacity-80">10 workouts in total</div>
                  </div>
                  
                  <div className={`p-4 rounded-2xl text-center ${workoutStreak >= 5 ? 'bg-gradient-to-br from-red-400 to-pink-500 text-white' : 'bg-gray-100 dark:bg-gray-700 text-gray-400'}`}>
                    <div className="text-2xl mb-2">üèÉ</div>
                    <div className="text-xs font-semibold">Consistent</div>
                    <div className="text-xs opacity-80">5 workout out days in a row</div>
                  </div>
                  
                  <div className={`p-4 rounded-2xl text-center ${avgCompletionRate >= 90 ? 'bg-gradient-to-br from-emerald-400 to-teal-500 text-white' : 'bg-gray-100 dark:bg-gray-700 text-gray-400'}`}>
                    <div className="text-2xl mb-2">üéØ</div>
                    <div className="text-xs font-semibold">Finisher</div>
                    <div className="text-xs opacity-80">Average workout completion at 90% or higher</div>
                  </div>
                  
                  <div className={`p-4 rounded-2xl text-center ${totalWorkoutTime >= 600 ? 'bg-gradient-to-br from-amber-400 to-yellow-500 text-white' : 'bg-gray-100 dark:bg-gray-700 text-gray-400'}`}>
                    <div className="text-2xl mb-2">‚è∞</div>
                    <div className="text-xs font-semibold">Time Master</div>
                    <div className="text-xs opacity-80">10 hours total workout time</div>
                  </div>
                </div>
              );
            })()}
          </div>

          {/* Health Score Info */}
          <div className="mt-8 bg-gradient-to-r from-indigo-500/10 to-purple-500/10 dark:from-indigo-500/5 dark:to-purple-500/5 p-6 rounded-3xl border border-indigo-200/50 dark:border-indigo-700/50">
            <h3 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-3 flex items-center">
              <span className="mr-2">üßÆ</span>
              Health Score Formula
            </h3>
            <div className="grid grid-cols-1 md:grid-cols-4 gap-4 text-center">
              <div className="bg-white/50 dark:bg-gray-800/50 p-4 rounded-2xl">
                <div className="text-2xl font-bold text-pink-500 mb-1">40%</div>
                <div className="text-sm font-semibold text-gray-700 dark:text-gray-300">Nutrition</div>
                <div className="text-xs text-gray-600 dark:text-gray-400">25% Calories + 5% Protein + 5% Carbs + 5% Fat</div>
              </div>
              
              <div className="bg-white/50 dark:bg-gray-800/50 p-4 rounded-2xl">
                <div className="text-2xl font-bold text-purple-500 mb-1">15%</div>
                <div className="text-sm font-semibold text-gray-700 dark:text-gray-300">Activity</div>
                <div className="text-xs text-gray-600 dark:text-gray-400">10m=5, 20m=10, 30m+=15 (cap)</div>
              </div>
              
              <div className="bg-white/50 dark:bg-gray-800/50 p-4 rounded-2xl">
                <div className="text-2xl font-bold text-indigo-500 mb-1">30%</div>
                <div className="text-sm font-semibold text-gray-700 dark:text-gray-300">Workout</div>
                <div className="text-xs text-gray-600 dark:text-gray-400">1 pt per 10% completion (max 10/workout), cap 30/day</div>
              </div>
              
              <div className="bg-white/50 dark:bg-gray-800/50 p-4 rounded-2xl">
                <div className="text-2xl font-bold text-blue-500 mb-1">15%</div>
                <div className="text-sm font-semibold text-gray-700 dark:text-gray-300">Hydration</div>
                <div className="text-xs text-gray-600 dark:text-gray-400">Water intake (1 glass ‚âà 250 ml)</div>
              </div>

            </div>
          </div>
            </>
          )}

          {activeTab === 'habits' && (
            <div className="space-y-8">
              {/* Habit Tracker Content */}
              <div className="bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm p-6 rounded-3xl shadow-xl border border-white/20">
                <h3 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-4 flex items-center">
                  <span className="mr-2">‚úÖ</span>
                  My Habits
                </h3>
                
                {/* Add New Habit */}
                <div className="flex mb-6 w-full min-w-0">
                  <input 
                    type="text" 
                    value={newHabit}
                    onChange={(e) => setNewHabit(e.target.value)}
                    placeholder="Add a new habit..."
                    className="flex-grow min-w-0 p-3 rounded-l-xl border border-gray-200 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 focus:outline-none focus:ring-2 focus:ring-purple-500"
                  />
                  <button 
                    onClick={() => {
                      if (newHabit.trim()) {
                        setHabits([...habits, {
                          id: Date.now().toString(),
                          name: newHabit.trim(),
                          streak: 0,
                          completed: {},
                          created: new Date().toISOString()
                        }]);
                        setNewHabit('');
                      }
                    }}
                    className="flex-shrink-0 bg-gradient-to-r from-purple-500 to-pink-500 text-white font-bold p-3 rounded-r-xl hover:from-purple-600 hover:to-pink-600 transition-all duration-200"
                  >
                    Add
                  </button>
                </div>
                
                {/* Habits List */}
                <div className="space-y-4 max-h-96 overflow-y-auto">
                  {habits.length === 0 ? (
                    <div className="text-center p-8 text-gray-500 dark:text-gray-400">
                      <div className="text-4xl mb-2">üå±</div>
                      <p>No habits yet. Add your first habit to start tracking!</p>
                    </div>
                  ) : (
                    habits.map(habit => {
                      const today = getLocalDateString(new Date());
                      const isCompletedToday = habit.completed && habit.completed[today];
                      
                      return (
                        <div key={habit.id} className="bg-white dark:bg-gray-700 rounded-2xl p-4 shadow-md border border-gray-100 dark:border-gray-600">
                          <div className="flex items-center justify-between">
                            <div className="flex items-center">
                              <button 
                                onClick={() => {
                                  const updatedHabits = habits.map(h => {
                                    if (h.id === habit.id) {
                                      const completed = {...h.completed};
                                      const wasCompleted = completed[today];
                                      
                                      if (completed[today]) {
                                        delete completed[today];
                                      } else {
                                        completed[today] = true;
                                      }
                                      
                                      // Note: Auto-sync with dailyIntake would require passing setDailyIntake as prop
                                      // This functionality is commented out to avoid prop drilling
                                      // if (!wasCompleted && (h.name.toLowerCase().includes('cardio') || h.name.toLowerCase().includes('exercise') || h.name.toLowerCase().includes('workout') || h.name.toLowerCase().includes('run') || h.name.toLowerCase().includes('walk') || h.name.toLowerCase().includes('gym'))) {
                                      //   const minutes = parseInt(h.name.match(/\d+/)?.[0]) || 30;
                                      //   setDailyIntake(prev => ({ ...prev, activity: prev.activity + minutes }));
                                      // }
                                      // if (!wasCompleted && h.name.toLowerCase().includes('water')) {
                                      //   const glasses = parseInt(h.name.match(/\d+/)?.[0]) || 1;
                                      //   setDailyIntake(prev => ({ ...prev, water: prev.water + glasses }));
                                      // }
                                      
                                      // Calculate streak
                                      let streak = 0;
                                      let currentDate = new Date();
                                      
                                      while (true) {
                                        const dateStr = getLocalDateString(currentDate);
                                        if (completed[dateStr]) {
                                          streak++;
                                          currentDate.setDate(currentDate.getDate() - 1);
                                        } else {
                                          break;
                                        }
                                      }
                                      
                                      return {...h, completed, streak};
                                    }
                                    return h;
                                  });
                                  
                                  setHabits(updatedHabits);
                                }}
                                className={`w-8 h-8 rounded-lg mr-3 flex items-center justify-center transition-all duration-200 ${isCompletedToday ? 'bg-gradient-to-r from-green-400 to-emerald-500 text-white' : 'bg-gray-100 dark:bg-gray-600 text-gray-400 dark:text-gray-500'}`}
                              >
                                {isCompletedToday ? '‚úì' : ''}
                              </button>
                              <div>
                                <h4 className="font-semibold text-gray-800 dark:text-gray-200">{habit.name}</h4>
                                <div className="text-xs text-gray-500 dark:text-gray-400 flex items-center">
                                  <span className="mr-2">üî•</span>
                                  <span>{habit.streak} day streak</span>
                                </div>
                              </div>
                            </div>
                            <button 
                              onClick={() => {
                                setHabits(habits.filter(h => h.id !== habit.id));
                              }}
                              className="text-gray-400 hover:text-red-500 transition-colors duration-200"
                            >
                              √ó
                            </button>
                          </div>
                        </div>
                      );
                    })
                  )}
                </div>
              </div>
              
              {/* AI Habit Coach */}
              <div className="bg-gradient-to-r from-blue-500/10 to-purple-500/10 dark:from-blue-500/5 dark:to-purple-500/5 p-6 rounded-3xl border border-blue-200/50 dark:border-blue-700/50">
                <h3 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-4 flex items-center">
                  <span className="mr-2">ü§ñ</span>
                  AI Habit Coach
                </h3>
                
                <div className="bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm p-4 rounded-2xl mb-4">
                  {habitAIAdvice ? (
                    <div className="text-gray-800 dark:text-gray-200">
                      {habitAIAdvice}
                    </div>
                  ) : (
                    <div className="text-center p-4 text-gray-500 dark:text-gray-400">
                      <p>Ask for habit recommendations or insights</p>
                    </div>
                  )}
                </div>
                
                <div className="flex">
                  <button 
                    onClick={async () => {
                      setIsLoadingAdvice(true);
                      try {
                        // Get habits data for context
                        const habitsContext = habits.map(h => `${h.name} (${h.streak} day streak)`);

                        // Consolidate hydration: combine dashboard water with completed water habit for today
                        const _today = new Date().toISOString().split('T')[0];
                        const waterHabitGlasses = habits.reduce((max, h) => {
                          const isWater = /\b(drink)?\s*\d+\s*(glass|glasses)\s*of\s*water\b|\bwater\b|\bhydrate\b/i.test(h.name);
                          const doneToday = h.completed && h.completed[_today];
                          if (!isWater || !doneToday) return max;
                          const m = h.name.match(/(\d+)\s*(glass|glasses)/i);
                          const g = m ? parseInt(m[1], 10) : 0;
                          return Math.max(max, g);
                        }, 0);
                        const effectiveWater = Math.max(dailyIntake.water || 0, waterHabitGlasses || 0);
                        
                        // Consolidate activity: include completed activity habit for today
                        const _todayAct = new Date().toISOString().split('T')[0];
                        const activityHabitMins = habits.reduce((max, h) => {
                          const isAct = /(cardio|exercise|workout|run|walk|gym)/i.test(h.name || '');
                          const done = h.completed && h.completed[_todayAct];
                          if (!isAct || !done) return max;
                          const m = (h.name || '').match(/(\d+)\s*(min|mins|minutes)/i) || (h.name || '').match(/(\d+)/);
                          const mins = m ? parseInt(m[1], 10) : 30;
                          return Math.max(max, mins);
                        }, 0);
                        const effectiveActivity = Math.max(dailyIntake.activity || 0, activityHabitMins || 0);

                        // Create prompt for the AI
                        let prompt = `You are an AI Habit Coach with comprehensive knowledge of the FitMate app. Analyze user data and provide smart recommendations using all app features.

**HABIT STATUS TODAY:**
${habits.map(habit => {
  const today = new Date().toISOString().split('T')[0];
  const isCompleted = habit.completed && habit.completed[today];
  return `‚Ä¢ ${habit.name}: ${isCompleted ? '‚úÖ COMPLETED' : '‚ùå NOT DONE'} (${habit.streak}d streak)`;
}).join('\n')}

**DAILY PROGRESS:**
‚Ä¢ Calories: ${dailyIntake.calories}/${goals.calories} (${((dailyIntake.calories / goals.calories) * 100).toFixed(0)}%)
‚Ä¢ Protein: ${dailyIntake.protein}g/${goals.protein}g (${((dailyIntake.protein / goals.protein) * 100).toFixed(0)}%)
‚Ä¢ Activity: ${Math.min(effectiveActivity, goals.activity)}/${goals.activity}min (${Math.min(100, ((effectiveActivity / goals.activity) * 100)).toFixed(0)}%)
‚Ä¢ Water: ${Math.min(effectiveWater, goals.water)}/${goals.water} glasses (${Math.min(100, ((effectiveWater / goals.water) * 100)).toFixed(0)}%)

**APP FEATURES TO REFERENCE:**
üìä Dashboard: Track progress and view health score
üîç Food Scanner: Log meals accurately with portion sizes
üèãÔ∏è Workout Planner: Access 15+ exercises with video guides
üçΩÔ∏è Meal Planner: Generate recipes and scan pantry items
üë§ Profile: Adjust goals and manage preferences
ü§ñ AI Coaches: Get form tips and personalized guidance

**INSTRUCTIONS:**
1. If habits are completed today, congratulate and suggest app features to maintain momentum
2. If habits are incomplete, recommend specific app screens/features to help complete them
3. For nutrition goals, suggest Food Scanner for accurate tracking
4. For activity goals, recommend Workout Planner with specific exercises
5. Reference actual app features users can access immediately

**FORMAT (exactly 4 lines, max 120 chars total):**
üéØ [Focus area with app feature reference]
‚ö° [Specific action using app screen/feature]
üî• [App-based habit tip]
üí™ [Motivation with feature suggestion]

**RULES:**
- Maximum 120 characters total across all 4 lines
- Reference specific app screens when relevant (Dashboard, Scanner, Workout, etc.)
- Acknowledge completed habits positively
- Guide users to appropriate app features for improvement
- Use actual percentages and app-specific recommendations`;
                        
                        // Call the AI API
                        const response = await fetch(getDirectGeminiConfig().url, {
                          method: 'POST',
                          headers: getDirectGeminiConfig().headers,
                          signal: AbortSignal.timeout(25000),
                          body: JSON.stringify({
                            model: OPENROUTER_QWEN_MODEL,
                            messages: [{ role: 'user', content: prompt }]
                          })
                        });
                        
                        if (!response.ok) {
                          let details = '';
                          try {
                            const errText = await response.text();
                            try { const errJson = JSON.parse(errText); details = errJson?.error?.message || errJson?.message || errText; } catch { details = errText; }
                          } catch {}
                          throw new Error(`OpenRouter API error (${response.status}): ${details}`);
                        }
                        
                        const result = await response.json();
                        const advice = (result.choices?.[0]?.message?.content || '');
                        setHabitAIAdvice(advice);
                      } catch (error) {
                        console.error("Failed to get habit recommendations:", error);
                        setHabitAIAdvice("Sorry, I couldn't generate recommendations right now. Please try again later.");
                      } finally {
                        setIsLoadingAdvice(false);
                      }
                    }}
                    disabled={isLoadingAdvice}
                    className="flex-grow bg-gradient-to-r from-blue-500 to-purple-500 text-white font-bold p-3 rounded-xl hover:from-blue-600 hover:to-purple-600 transition-all duration-200 disabled:opacity-50"
                  >
                    {isLoadingAdvice ? 'Thinking...' : 'Get AI Recommendations'}
                  </button>
                </div>
              </div>
              
              {/* Habit Statistics */}
              <div className="bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm p-6 rounded-3xl shadow-xl border border-white/20">
                <h3 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-4 flex items-center">
                  <span className="mr-2">üìà</span>
                  Habit Statistics
                </h3>
                
                <div className="grid grid-cols-1 md:grid-cols-4 gap-4 text-center">
                  <div className="bg-gradient-to-br from-purple-500/10 to-pink-500/10 dark:from-purple-500/5 dark:to-pink-500/5 p-4 rounded-2xl">
                    <div className="text-2xl font-bold text-purple-500 mb-1">{habits.length}</div>
                    <div className="text-sm font-semibold text-gray-700 dark:text-gray-300">Active Habits</div>
                    <div className="text-xs text-gray-600 dark:text-gray-400">Total habits added</div>
                  </div>
                  <div className="bg-gradient-to-br from-blue-500/10 to-cyan-500/10 dark:from-blue-500/5 dark:to-cyan-500/5 p-4 rounded-2xl">
                    <div className="text-2xl font-bold text-blue-500 mb-1">
                      {habits.reduce((total, habit) => {
                        const today = getLocalDateString(new Date());
                        return total + (habit.completed && habit.completed[today] ? 1 : 0);
                      }, 0)}
                    </div>
                    <div className="text-sm font-semibold text-gray-700 dark:text-gray-300">Completed Today</div>
                    <div className="text-xs text-gray-600 dark:text-gray-400 flex items-center justify-center">
                      <span>Habits marked</span>
                      <span className="inline-flex items-center justify-center w-5 h-5 ml-1 rounded-lg bg-gradient-to-br from-green-400 to-emerald-500 text-white shadow-sm">‚úì</span>
                    </div>
                  </div>
                  <div className="bg-gradient-to-br from-green-500/10 to-emerald-500/10 dark:from-green-500/5 dark:to-emerald-500/5 p-4 rounded-2xl">
                    <div className="text-2xl font-bold text-green-500 mb-1">
                      {habits.length > 0 ? Math.max(...habits.map(h => h.streak)) : 0}
                    </div>
                    <div className="text-sm font-semibold text-gray-700 dark:text-gray-300">Longest Streak</div>
                    <div className="text-xs text-gray-600 dark:text-gray-400">Highest consecutive-day count</div>
                    
                  </div>

                  {/* Daily Score (percent) */}
                  <div className="bg-gradient-to-br from-amber-500/10 to-yellow-500/10 dark:from-amber-500/5 dark:to-yellow-500/5 p-4 rounded-2xl">
                    <div className="text-2xl font-bold text-amber-600 mb-1">
                      {(() => {
                        const total = habits.length;
                        if (total === 0) return '0%';
                        const today = getLocalDateString(new Date());
                        const completed = habits.reduce((acc, h) => acc + ((h.completed && h.completed[today]) ? 1 : 0), 0);
                        const perBasis = Math.floor(10000 / total); // basis points per habit (0.01%)
                        let scoreBasis = perBasis * completed;
                        if (completed === total) scoreBasis += (10000 - perBasis * total); // remainder to reach exactly 100%
                        const val = Math.ceil(scoreBasis / 100);
                        return `${val}%`;
                      })()}
                    </div>
                    <div className="text-sm font-semibold text-gray-700 dark:text-gray-300">Daily Score</div>
                    <div className="text-xs text-gray-600 dark:text-gray-400">Equal‚Äëweighted; resets at midnight</div>
                    
                  </div>
                </div>
              </div>
            </div>
          )}

          {activeTab === 'stress' && (
            <div className="space-y-8">
              <div className="bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm p-6 rounded-3xl shadow-xl border border-white/20">
                <h3 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-4 flex items-center">
                  <span className="mr-2">üß†</span>
                  Stress Analyzer
                </h3>

                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div>
                    <label className="text-sm font-semibold text-gray-700 dark:text-gray-300">Sleep hours <span className="text-red-500">*</span></label>
                    <input type="number" inputMode="numeric" min="4" step="0.5" value={stressForm.sleepHours}
                      placeholder="8h ideal; deviation increases stress (25%)"
                      onChange={e=>setStressForm({...stressForm, sleepHours:e.target.value})}
                      aria-invalid={!stressForm.sleepHours || Number(stressForm.sleepHours) < 4 || exceedsDayHours}
                      className={`w-full p-3 rounded-xl border border-gray-200 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 focus:outline-none focus:ring-2 placeholder:text-[11px] md:placeholder:text-sm appearance-none ${(!stressForm.sleepHours || Number(stressForm.sleepHours) < 4 || exceedsDayHours) ? 'border-red-500 focus:ring-red-500 ring-1 ring-red-500' : 'focus:ring-purple-500'}`}
                      style={{MozAppearance:'textfield'}} />
                    {(!stressForm.sleepHours || Number(stressForm.sleepHours) < 4) && (
                      <div className="mt-1 text-[11px] md:text-xs text-red-600">Minimum 4 hours of sleep is required to compute your stress score.</div>
                    )}
                  </div>
                  <div>
                    <label className="text-sm font-semibold text-gray-700 dark:text-gray-300">Work hours nett.(without breaks) <span className="text-red-500">*</span></label>
                    <input type="number" inputMode="numeric" min="0" step="0.5" value={stressForm.workHours}
                      placeholder="8h ideal; deviation increases stress (20%)"
                      onChange={e=>setStressForm({...stressForm, workHours:e.target.value})}
                      onFocus={()=>setWorkHoursFocused(true)}
                      onBlur={()=>setWorkHoursFocused(false)}
                      aria-invalid={!stressForm.workHours || exceedsDayHours}
                      className={`w-full p-3 rounded-xl border border-gray-200 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 focus:outline-none focus:ring-2 placeholder:text-[11px] md:placeholder:text-sm appearance-none ${(!stressForm.workHours || exceedsDayHours) ? 'border-red-500 focus:ring-red-500 ring-1 ring-red-500' : 'focus:ring-purple-500'}`}
                      style={{MozAppearance:'textfield'}} />
                    {(!stressForm.workHours) && (
                      <div className="mt-1 text-[11px] md:text-xs text-red-600">Minimum 0 hours is required ‚Äî enter 0 if you don‚Äôt work.</div>
                    )}
                  </div>
                  <div>
                    <label className="text-sm font-semibold text-gray-700 dark:text-gray-300">Self‚Äërated stress (1‚Äì10)</label>
                    <input type="number" inputMode="numeric" min="1" max="10" value={stressForm.stressRating}
                      placeholder="Higher rating increases stress (12%)"
                      onChange={e=>setStressForm({...stressForm, stressRating: e.target.value})}
                      className="w-full p-3 rounded-xl border border-gray-200 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 focus:outline-none focus:ring-2 focus:ring-purple-500 placeholder:text-[11px] md:placeholder:text-sm appearance-none" style={{MozAppearance:'textfield'}} />
                  </div>
                  <div>
                    <label className="text-sm font-semibold text-gray-700 dark:text-gray-300">Stress episodes (count)</label>
                    <input type="number" inputMode="numeric" min="0" step="1" value={stressForm.stressEpisodes}
                      placeholder="More episodes raise stress; 6 caps impact (8%)"
                      onChange={e=>setStressForm({...stressForm, stressEpisodes:e.target.value})}
                      className="w-full p-3 rounded-xl border border-gray-200 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 focus:outline-none focus:ring-2 focus:ring-purple-500 placeholder:text-[11px] md:placeholder:text-sm appearance-none" style={{MozAppearance:'textfield'}} />
                  </div>
                  <div>
                    <label className="text-sm font-semibold text-gray-700 dark:text-gray-300">Exercise (mins)</label>
                    <input type="number" inputMode="numeric" min="0" step="5" value={stressForm.exerciseMins}
                      placeholder="More mins reduce stress; ~45m full relief (15%)"
                      onChange={e=>setStressForm({...stressForm, exerciseMins:e.target.value})}
                      aria-invalid={exceedsDayHours}
                      className={`w-full p-3 rounded-xl border border-gray-200 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 focus:outline-none focus:ring-2 placeholder:text-[11px] md:placeholder:text-sm appearance-none ${exceedsDayHours ? 'border-red-500 focus:ring-red-500 ring-1 ring-red-500' : 'focus:ring-purple-500'}`}
                      style={{MozAppearance:'textfield'}} />
                  </div>
                  <div>
                    <label className="text-sm font-semibold text-gray-700 dark:text-gray-300">Meditation (mins)</label>
                    <input type="number" inputMode="numeric" min="0" step="5" value={stressForm.meditationMins}
                      placeholder="More mins reduce stress; ~15m full relief (5%)"
                      onChange={e=>setStressForm({...stressForm, meditationMins:e.target.value})}
                      aria-invalid={exceedsDayHours}
                      className={`w-full p-3 rounded-xl border border-gray-200 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 focus:outline-none focus:ring-2 placeholder:text-[11px] md:placeholder:text-sm appearance-none ${exceedsDayHours ? 'border-red-500 focus:ring-red-500 ring-1 ring-red-500' : 'focus:ring-purple-500'}`}
                      style={{MozAppearance:'textfield'}} />
                  </div>
                  <div>
                    <label className="text-sm font-semibold text-gray-700 dark:text-gray-300">Social interaction (mins)</label>
                    <input type="number" inputMode="numeric" min="0" step="5" value={stressForm.socialMins}
                      placeholder="Quality time buffers stress; ~60m relief (5%)"
                      onChange={e=>setStressForm({...stressForm, socialMins:e.target.value})}
                      aria-invalid={exceedsDayHours}
                      className={`w-full p-3 rounded-xl border border-gray-200 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 focus:outline-none focus:ring-2 placeholder:text-[10px] md:placeholder:text-sm appearance-none ${exceedsDayHours ? 'border-red-500 focus:ring-red-500 ring-1 ring-red-500' : 'focus:ring-purple-500'}`}
                      style={{MozAppearance:'textfield'}} />
                  </div>
                  <div>
                    <label className="text-sm font-semibold text-gray-700 dark:text-gray-300">Screen time Exclude work (hours)</label>
                    <input type="number" inputMode="numeric" min="0" step="0.5" value={stressForm.screenHours}
                      placeholder="More hours add stress ~8h cap impact (10%)"
                      onChange={e=>setStressForm({...stressForm, screenHours:e.target.value})}
                      aria-invalid={exceedsDayHours}
                      className={`w-full p-3 rounded-xl border border-gray-200 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 focus:outline-none focus:ring-2 placeholder:text-[11px] md:placeholder:text-sm appearance-none ${exceedsDayHours ? 'border-red-500 focus:ring-red-500 ring-1 ring-red-500' : 'focus:ring-purple-500'}`}
                      style={{MozAppearance:'textfield'}} />
                  </div>
                  <div>
                    <label className="text-sm font-semibold text-gray-700 dark:text-gray-300">Life event</label>
                    <div className="mt-1">
                      <div className="flex items-center justify-between text-[11px] md:text-xs text-gray-600 dark:text-gray-400">
                        <span className="truncate block max-w-[calc(100%-2.5rem)]">Amplifies: None 1.0√ó, Minor 1.5√ó, Major 2.0√ó</span>
                        <button type="button"
                          onClick={() => setLifeEventInfoOpen(v => !v)}
                          aria-label="Show life event info"
                          className="ml-2 inline-flex items-center justify-center w-6 h-6 rounded-full border border-gray-300 dark:border-gray-600 text-gray-600 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700">
                          i
                        </button>
                      </div>
                      {lifeEventInfoOpen && (
                        <div className="mt-2 p-2 rounded-xl border border-gray-200 dark:border-gray-600 bg-white/80 dark:bg-gray-800/80 text-xs text-gray-700 dark:text-gray-300">
                          <div className="font-semibold mb-1">What counts as a life event?</div>
                          <ul className="list-disc pl-4 space-y-1">
                            <li>None: regular day, routine changes.</li>
                            <li>Minor: exam week, deadline, travel, minor illness, brief conflict.</li>
                            <li>Major: bereavement, job loss, breakup/divorce, serious illness, major crisis.</li>
                          </ul>
                          <div className="mt-2 text-right">
                            <button type="button" onClick={() => setLifeEventInfoOpen(false)} className="px-3 py-1 rounded-lg bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-200">Close</button>
                          </div>
                        </div>
                      )}
                      <select value={stressForm.lifeEvent}
                        onChange={e=>setStressForm({...stressForm, lifeEvent:e.target.value})}
                        className="mt-2 w-full p-3 rounded-xl border border-gray-200 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 focus:outline-none focus:ring-2 focus:ring-purple-500">
                        <option value="none">None ‚Äî no multiplier</option>
                        <option value="minor">Minor ‚Äî 1.5√ó stress amplifier</option>
                        <option value="major">Major ‚Äî 2.0√ó stress amplifier</option>
                      </select>
                    </div>
                  </div>
                  
                </div>

                {exceedsDayHours && (
                  <div className="mt-2 text-[11px] md:text-xs text-red-600">Total time across Sleep, Work, Screen time, Exercise, Meditation, and Social must be ‚â§ 24 hours.</div>
                )}

                <div className="flex mt-4">
                  <button
                          onClick={() => { const r = computeStressScore(stressForm); setStressResult(r); setStressInsight(generateStressInsight(r, stressForm)); try { localStorage.setItem('stressResult', JSON.stringify(r)); } catch (_) {} }}
                    disabled={!String(stressForm.sleepHours || '').trim() || Number(stressForm.sleepHours) < 4 || !String(stressForm.workHours || '').trim() || exceedsDayHours}
                    className="flex-grow bg-gradient-to-r from-purple-500 to-pink-500 text-white font-bold p-3 rounded-xl hover:from-purple-600 hover:to-pink-600 transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed">
                    Compute Stress Score
                  </button>
                </div>

                <div className="mt-3 text-[11px] md:text-xs text-gray-500 dark:text-gray-400 text-center">
                  Disclaimer: This is a simulated stress estimate. Real stress varies due to personal, financial, health, and work‚Äìlife factors. This is not a medical tool.
                </div>
              </div>

              {stressResult && (
                <div className="bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm p-6 rounded-3xl shadow-xl border border-white/20">
                  <div className="flex items-center justify-between mb-4">
                    <div className={`w-20 h-20 bg-gradient-to-br ${
                      stressResult.stressScore >= 76 ? 'from-red-500 to-red-600' : (
                      stressResult.stressScore >= 51 ? 'from-orange-500 to-orange-600' : (
                      stressResult.stressScore >= 26 ? 'from-amber-400 to-yellow-500' : 'from-emerald-400 to-green-600'))
                    } rounded-3xl flex items-center justify-center text-white font-bold text-2xl shadow-lg`}>
                      {stressResult.stressScore}
                    </div>
                    <div className="text-right">
            <div className="text-2xl font-bold text-gray-800 dark:text-gray-200">{stressResult.stressScore === 0 ? 'üòä' : (stressResult.stressScore === 100 ? ('üö® ' + stressResult.category) : stressResult.category)}</div>
                      <div className="text-sm text-gray-600 dark:text-gray-400">Confidence {stressResult.confidence}%</div>
                      {stressResult.lifeEventMultiplier > 1.0 && (
                        <div className="text-xs text-orange-600 dark:text-orange-400 mt-1">Life event: {stressResult.lifeEventMultiplier}√ó amplifier</div>
                      )}
                    </div>
                  </div>

                  <div className="grid grid-cols-1 md:grid-cols-2 gap-3 mb-2">
                    {/* Sleep Driver */}
                    <div className="p-3 bg-gray-50 dark:bg-gray-700 rounded-xl">
                      <div className="flex justify-between items-center mb-1">
                        <div className="text-xs font-semibold text-gray-500 dark:text-gray-400">Sleep Quality (25%)</div>
                        <div className="text-lg font-bold text-pink-600 dark:text-pink-400">{stressResult.breakdown.drivers.sleep}/25</div>
                      </div>
                      <div className="w-full bg-gray-200 dark:bg-gray-600 rounded-full h-2 mb-1">
                        <div className="bg-gradient-to-r from-pink-400 to-pink-600 h-2 rounded-full" style={{width: `${Math.min(100, (stressResult.breakdown.drivers.sleep / 25) * 100)}%`}}></div>
                      </div>
                      <div className="text-xs text-gray-600 dark:text-gray-400">Deviation from 8h optimal sleep</div>
                    </div>

                    {/* Work Driver */}
                    <div className="p-3 bg-gray-50 dark:bg-gray-700 rounded-xl">
                      <div className="flex justify-between items-center mb-1">
                        <div className="text-xs font-semibold text-gray-500 dark:text-gray-400">Work Hours (20%)</div>
                        <div className="text-lg font-bold text-purple-600 dark:text-purple-400">{stressResult.breakdown.drivers.work}/20</div>
                      </div>
                      <div className="w-full bg-gray-200 dark:bg-gray-600 rounded-full h-2 mb-1">
                        <div className="bg-gradient-to-r from-purple-400 to-purple-600 h-2 rounded-full" style={{width: `${Math.min(100, (stressResult.breakdown.drivers.work / 20) * 100)}%`}}></div>
                      </div>
                      <div className="text-xs text-gray-600 dark:text-gray-400">Deviation from 8h optimal work</div>
                    </div>

                    {/* Self-rating + Episodes Group */}
                    <div className="p-3 bg-gradient-to-br from-indigo-50 to-orange-50 dark:from-indigo-900/20 dark:to-orange-900/20 rounded-xl border border-indigo-200 dark:border-indigo-700">
                      <div className="text-xs font-bold text-gray-700 dark:text-gray-300 mb-2">Psychological (20%)</div>
                      
                      <div className="mb-2">
                        <div className="flex justify-between items-center mb-1">
                          <div className="text-xs text-gray-600 dark:text-gray-400">Self‚Äërating (12%)</div>
                          <div className="text-sm font-bold text-indigo-600 dark:text-indigo-400">{stressResult.breakdown.drivers.selfRating}/12</div>
                        </div>
                        <div className="w-full bg-gray-200 dark:bg-gray-600 rounded-full h-1.5">
                          <div className="bg-gradient-to-r from-indigo-400 to-indigo-600 h-1.5 rounded-full" style={{width: `${Math.min(100, (stressResult.breakdown.drivers.selfRating / 12) * 100)}%`}}></div>
                        </div>
                      </div>

                      <div>
                        <div className="flex justify-between items-center mb-1">
                          <div className="text-xs text-gray-600 dark:text-gray-400">Episodes (8%)</div>
                          <div className="text-sm font-bold text-orange-600 dark:text-orange-400">{stressResult.breakdown.drivers.episodes}/8</div>
                        </div>
                        <div className="w-full bg-gray-200 dark:bg-gray-600 rounded-full h-1.5">
                          <div className="bg-gradient-to-r from-orange-400 to-orange-600 h-1.5 rounded-full" style={{width: `${Math.min(100, (stressResult.breakdown.drivers.episodes / 8) * 100)}%`}}></div>
                        </div>
                      </div>
                      
                      <div className="text-xs text-gray-600 dark:text-gray-400 mt-2">How you feel + stress events</div>
                    </div>

                    {/* Screen Driver */}
                    <div className="p-3 bg-gray-50 dark:bg-gray-700 rounded-xl">
                      <div className="flex justify-between items-center mb-1">
                        <div className="text-xs font-semibold text-gray-500 dark:text-gray-400">Screen Time (10%)</div>
                        <div className="text-lg font-bold text-blue-600 dark:text-blue-400">{stressResult.breakdown.drivers.screen}/10</div>
                      </div>
                      <div className="w-full bg-gray-200 dark:bg-gray-600 rounded-full h-2 mb-1">
                        <div className="bg-gradient-to-r from-blue-400 to-blue-600 h-2 rounded-full" style={{width: `${Math.min(100, (stressResult.breakdown.drivers.screen / 10) * 100)}%`}}></div>
                      </div>
                      <div className="text-xs text-gray-600 dark:text-gray-400">Excessive screen use adds stress</div>
                    </div>
                  </div>

                  <div className="text-xs font-bold text-gray-700 dark:text-gray-300 mb-2">Protective Buffers (higher = more stress reduction)</div>
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-3 mb-4">
                    {/* Exercise + Meditation Group */}
                    <div className="p-3 bg-gradient-to-br from-emerald-50 to-teal-50 dark:from-emerald-900/20 dark:to-teal-900/20 rounded-xl border border-emerald-200 dark:border-emerald-700">
                      <div className="text-xs font-bold text-gray-700 dark:text-gray-300 mb-2">Wellness Activities (20%)</div>
                      
                      <div className="mb-2">
                        <div className="flex justify-between items-center mb-1">
                          <div className="text-xs text-gray-600 dark:text-gray-400">Exercise (15%)</div>
                          <div className="text-sm font-bold text-emerald-600 dark:text-emerald-400">{stressResult.breakdown.buffers.exercise}/15</div>
                        </div>
                        <div className="w-full bg-gray-200 dark:bg-gray-600 rounded-full h-1.5">
                          <div className="bg-gradient-to-r from-emerald-400 to-emerald-600 h-1.5 rounded-full" style={{width: `${Math.min(100, (stressResult.breakdown.buffers.exercise / 15) * 100)}%`}}></div>
                        </div>
                      </div>

                      <div>
                        <div className="flex justify-between items-center mb-1">
                          <div className="text-xs text-gray-600 dark:text-gray-400">Meditation (5%)</div>
                          <div className="text-sm font-bold text-teal-600 dark:text-teal-400">{stressResult.breakdown.buffers.meditation}/5</div>
                        </div>
                        <div className="w-full bg-gray-200 dark:bg-gray-600 rounded-full h-1.5">
                          <div className="bg-gradient-to-r from-teal-400 to-teal-600 h-1.5 rounded-full" style={{width: `${Math.min(100, (stressResult.breakdown.buffers.meditation / 5) * 100)}%`}}></div>
                        </div>
                      </div>
                      
                      <div className="text-xs text-gray-600 dark:text-gray-400 mt-2">Higher values reduce stress</div>
                    </div>

                    {/* Social Buffer */}
                    <div className="p-3 bg-gray-50 dark:bg-gray-700 rounded-xl">
                      <div className="flex justify-between items-center mb-1">
                        <div className="text-xs font-semibold text-gray-500 dark:text-gray-400">Social Connection (5%)</div>
                        <div className="text-lg font-bold text-emerald-600 dark:text-emerald-400">{stressResult.breakdown.buffers.social}/5</div>
                      </div>
                      <div className="w-full bg-gray-200 dark:bg-gray-600 rounded-full h-2 mb-1">
                        <div className="bg-gradient-to-r from-emerald-400 to-green-600 h-2 rounded-full" style={{width: `${Math.min(100, (stressResult.breakdown.buffers.social / 5) * 100)}%`}}></div>
                      </div>
                      <div className="text-xs text-gray-600 dark:text-gray-400">Quality time with others buffers stress</div>
                    </div>
                  </div>

                  {stressInsight && (
                    <div className="bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm p-4 rounded-2xl text-gray-800 dark:text-gray-200">
                      {stressInsight}
                    </div>
                  )}

                  {stressResult && stressResult.stressScore >= 26 && (
                    <div className="mt-4 mb-4 bg-gradient-to-r from-purple-500/10 to-pink-500/10 dark:from-purple-500/5 dark:to-pink-500/5 p-4 rounded-2xl border border-pink-200/50 dark:border-pink-700/40">
                      <div className="text-sm font-semibold text-gray-800 dark:text-gray-200 mb-2 flex items-center">
                        <span className="mr-2">ü™Ñ</span>
                        Stress‚ÄëLinked Habit Suggestions
                      </div>
                      <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
                        {generateStressHabitSuggestions(stressResult, stressForm).map((sug, idx) => {
                          const exists = habits.some(h => (h.name || '').toLowerCase() === (sug.name || '').toLowerCase());
                          return (
                            <div key={idx} className="flex items-center justify-between bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm p-3 rounded-xl border border-gray-100 dark:border-gray-700">
                              <div className="min-w-0">
                                <div className="text-sm font-semibold text-gray-800 dark:text-gray-200 whitespace-normal break-words">{sug.name}</div>
                                <div className="text-xs text-gray-600 dark:text-gray-400 whitespace-normal break-words">{sug.note}</div>
                              </div>
                              <button
                                onClick={() => {
                                  if (exists) return;
                                  setHabits([...habits, { id: Date.now().toString(), name: sug.name, streak: 0, completed: {}, created: new Date().toISOString() }]);
                                }}
                                disabled={exists}
                                className="ml-3 px-3 py-1 rounded-lg bg-gradient-to-r from-purple-500 to-pink-500 text-white text-xs font-bold hover:from-purple-600 hover:to-pink-600 transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed"
                              >
                                {exists ? 'Added' : 'Add'}
                              </button>
                            </div>
                          );
                        })}
                      </div>
                    </div>
                  )}

                  {/* Breathing Exercise CTA when stress is elevated (>25) */}
                  {stressResult && stressResult.stressScore > 25 && (
                    <div className="mt-2 bg-white dark:bg-gray-800 p-4 rounded-2xl border border-gray-200 dark:border-gray-700 shadow-lg flex items-center justify-between">
                      <div className="min-w-0">
                        <div className="text-xs font-semibold text-gray-600 dark:text-gray-400">Guided Breathing</div>
                        <div className="text-lg font-bold text-gray-800 dark:text-gray-200">Release Tension</div>
                        <div className="text-xs text-gray-500 dark:text-gray-400">4‚Äì7‚Äì8 cycle ‚Ä¢ ~3 minutes</div>
                      </div>
                      <button onClick={() => startBreathing(180)} className="ml-3 px-4 py-2 rounded-lg bg-gradient-to-r from-teal-500 to-indigo-500 text-white text-sm font-bold shadow hover:from-teal-600 hover:to-indigo-600">Start</button>
                    </div>
                  )}
                </div>
              )}
            </div>
          )}

          {/* Breathing Exercise Overlay (self-contained; mobile/tablet responsive) */}
          {showBreathing && (
            <div className="fixed inset-0 z-[10000] bg-black/40 backdrop-blur-sm flex items-center justify-center p-4" onClick={stopBreathing}>
              <div className="w-full max-w-sm md:max-w-md bg-white dark:bg-gray-800 rounded-3xl shadow-2xl border border-gray-200 dark:border-gray-700 p-6" onClick={e => e.stopPropagation()}>
                <div className="text-center mb-4">
                  <div className="text-gray-800 dark:text-gray-200 font-semibold">Release Tension</div>
                  <div className="mt-1 text-gray-900 dark:text-white text-2xl font-bold">{formatMMSS(breathTotalSecondsLeft)}</div>
                </div>
                <div className="flex items-center justify-center mb-4">
                  <div className="relative" style={{ transform: `scale(${(breathPlanRef.current[breathStepIndex]||{}).scale || 1})`, transition: 'transform 0.8s ease-in-out' }}>
                    <div className="w-48 h-48 sm:w-64 sm:h-64 md:w-72 md:h-72 rounded-full p-[6px] bg-gradient-to-r from-teal-300 via-emerald-300 to-indigo-300 shadow-xl">
                      <div className="w-full h-full rounded-full bg-gradient-to-b from-indigo-100 to-pink-100 dark:from-indigo-800/40 dark:to-pink-700/40"></div>
                    </div>
                    <div className="absolute inset-0 flex items-center justify-center">
                      <div className="text-4xl sm:text-5xl">üíó</div>
                    </div>
                  </div>
                </div>
                <div className="text-center text-gray-900 dark:text-white font-semibold text-lg sm:text-xl mb-6">{breathPhaseLabel || 'Breathe In!'}</div>
                <div className="flex items-center justify-center">
                  <button onClick={stopBreathing} className="px-6 py-2 rounded-xl bg-gradient-to-r from-pink-500 via-rose-500 to-fuchsia-500 text-white font-semibold shadow hover:from-pink-600 hover:via-rose-600 hover:to-fuchsia-600 focus:outline-none focus:ring-2 focus:ring-pink-400">Stop</button>
                </div>
              </div>
            </div>
          )}

          {/* Day Detail Modal */}
          {selectedDay && (
            <div className="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center p-4 z-[60] animate-fade-in" onClick={() => setSelectedDay(null)}>
              <div className="bg-white dark:bg-gray-800 p-4 sm:p-6 md:p-8 rounded-3xl shadow-2xl max-w-md w-full max-h-[90vh] overflow-y-auto transform transition-all duration-300 scale-100" onClick={e => e.stopPropagation()}>
                <div className="text-center mb-6">
                  <div className={`w-20 h-20 bg-gradient-to-br ${getScoreColor(selectedDay.score)} rounded-3xl flex items-center justify-center text-white font-bold text-2xl mx-auto mb-4 shadow-lg ${getScoreGlow(selectedDay.score)}`}>
                    {selectedDay.score}
                  </div>
                  <h3 className="text-2xl font-bold text-gray-800 dark:text-gray-200 mb-2">
                    {new Date(selectedDay.date).toLocaleDateString('en-US', { 
                      weekday: 'long', 
                      year: 'numeric', 
                      month: 'long', 
                      day: 'numeric' 
                    })}
                  </h3>
                </div>
                
                {(() => {
                  // Derive components using stored breakdown or compute on the fly
                  const dateISO = selectedDay.date;
                  const comps = selectedDay.components || computeHealthScoreForDate(selectedDay.intake, goals, dateISO).components;
                  // Workout summary for this day
                  let numWorkouts = 0, avgCompletion = 0, totalTime = 0;
                  try {
                    const all = JSON.parse(localStorage.getItem('workoutHistory') || '[]');
                    const dayWorkouts = (Array.isArray(all) ? all : []).filter(w => {
                      try { return toLocalISODate(new Date(w.timestamp)) === dateISO; } catch { return false; }
                    });
                    numWorkouts = dayWorkouts.length;
                    if (numWorkouts > 0) {
                      avgCompletion = Math.round(dayWorkouts.reduce((s, w) => s + (Number(w.completionRate)||0), 0) / numWorkouts);
                      totalTime = dayWorkouts.reduce((s, w) => s + (Number(w.duration)||0), 0);
                    }
                  } catch {}
                  return (
                    <div className="mb-6">
                      <h4 className="font-bold text-gray-800 dark:text-gray-200 mb-3">How this score was calculated</h4>
                      <div className="grid grid-cols-2 gap-3">
                        <div className="p-3 bg-gray-50 dark:bg-gray-700 rounded-xl">
                          <div className="text-xs text-gray-500 dark:text-gray-400">Nutrition (40%)</div>
                          <div className="text-lg font-semibold text-pink-600 dark:text-pink-400">{comps.nutrition} pts</div>
                        </div>
                        <div className="p-3 bg-gray-50 dark:bg-gray-700 rounded-xl">
                          <div className="text-xs text-gray-500 dark:text-gray-400">Activity (15%)</div>
                          <div className="text-lg font-semibold text-purple-600 dark:text-purple-400">{comps.activity} pts</div>
                        </div>
                        <div className="p-3 bg-gray-50 dark:bg-gray-700 rounded-xl">
                          <div className="text-xs text-gray-500 dark:text-gray-400">Workout (30%)</div>
                          <div className="text-lg font-semibold text-indigo-600 dark:text-indigo-400">{comps.workout} pts</div>
                          {numWorkouts > 0 && (
                            <div className="text-xs text-gray-500 dark:text-gray-400 mt-1">{numWorkouts} workouts ‚Ä¢ {avgCompletion}% avg ‚Ä¢ {totalTime}m</div>
                          )}
                        </div>
                        <div className="p-3 bg-gray-50 dark:bg-gray-700 rounded-xl">
                          <div className="text-xs text-gray-500 dark:text-gray-400">Hydration (15%)</div>
                          <div className="text-lg font-semibold text-blue-600 dark:text-blue-400">{comps.hydration} pts</div>
                        </div>
                      </div>
                      <div className="text-xs text-gray-500 dark:text-gray-400 mt-2">
                        Scoring: Activity 10m=5, 20m=10, 30m+=15 (cap 15). Workouts 1 pt per 10% completion (max 10/workout), cap 30/day; Hydration 15.
                      </div>
                    </div>
                  );
                })()}

                <div className="space-y-4 mb-6">
                  <div className="flex justify-between items-center p-3 bg-gray-50 dark:bg-gray-700 rounded-2xl">
                    <span className="font-semibold text-gray-700 dark:text-gray-300">üçΩÔ∏è Calories</span>
                    <span className="font-bold text-gray-800 dark:text-gray-200">{selectedDay.intake.calories.toFixed(0)}</span>
                  </div>
                  <div className="flex justify-between items-center p-3 bg-gray-50 dark:bg-gray-700 rounded-2xl">
                    <span className="font-semibold text-gray-700 dark:text-gray-300">üèÉ Activity</span>
                    <span className="font-bold text-gray-800 dark:text-gray-200">{selectedDay.intake.activity} mins</span>
                  </div>
                  <div className="flex justify-between items-center p-3 bg-gray-50 dark:bg-gray-700 rounded-2xl">
                    <span className="font-semibold text-gray-700 dark:text-gray-300">üíß Water</span>
                    <span className="font-bold text-gray-800 dark:text-gray-200">{selectedDay.intake.water} glasses</span>
                  </div>
                </div>
                
                {selectedDay.meals && selectedDay.meals.length > 0 && (
                  <div className="mb-6">
                    <h4 className="font-bold text-gray-800 dark:text-gray-200 mb-3 flex items-center">
                      <span className="mr-2">üçΩÔ∏è</span>
                      Meals
                    </h4>
                    <div className="space-y-2 max-h-32 overflow-y-auto">
                      {selectedDay.meals.map(m => (
                        <div key={m.id} className="p-2 bg-gray-50 dark:bg-gray-700 rounded-xl text-sm text-gray-700 dark:text-gray-300">
                          {m.name}
                        </div>
                      ))}
                    </div>
                  </div>
                )}
                
                <button 
                  onClick={() => setSelectedDay(null)} 
                  className="w-full bg-gradient-to-r from-purple-500 to-pink-500 text-white font-bold py-4 rounded-2xl hover:from-purple-600 hover:to-pink-600 transition-all duration-200 transform hover:scale-105 shadow-lg"
                >
                  Close
                </button>
              </div>
            </div>
          )}
        </div>
      );
    };

    // --- Helper Components ---

    // Activity Timer Component (for Dashboard) - persistent across navigation/reloads
    const ActivityTimer = ({ onLogActivity }) => {
      const STORAGE_KEY = 'activityTimerState';
      const [timeLeft, setTimeLeft] = useState(0);
      const [isActive, setIsActive] = useState(false);
      const [duration, setDuration] = useState(0); // in minutes
      const [startedAt, setStartedAt] = useState(null); // epoch ms
      const [pendingMins, setPendingMins] = useState(0);
      const timerRef = useRef(null);

      // Recalculate timer state from startedAt (used on mount and when returning from background)
      const recalculateTimer = useCallback(() => {
        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          if (!raw) return;
          const st = JSON.parse(raw);
          if (!st || !st.isActive) return;

          const todayISO = toLocalISODate(new Date());
          if (st.intakeDate && st.intakeDate !== todayISO) {
            // Timer belongs to a previous day; drop it
            localStorage.removeItem(STORAGE_KEY);
            return;
          }

          const now = Date.now();
          const elapsed = Math.floor((now - Number(st.startedAt || now)) / 1000);
          const remaining = Math.max(0, Number(st.durationSec || 0) - elapsed);

          if (remaining > 0) {
            setIsActive(true);
            setDuration(Math.round((st.durationSec || 0) / 60));
            setStartedAt(Number(st.startedAt));
            setTimeLeft(remaining);
          } else {
            // Completed while away ‚Äî require user confirmation to log
            const mins = Math.round((st.durationSec || 0) / 60);
            localStorage.setItem(
              STORAGE_KEY,
              JSON.stringify({ ...st, isActive: false, logged: false, pendingMinutes: mins, pendingDate: todayISO, completedAt: now })
            );
            setPendingMins(mins);
            try {
              if ('Notification' in window && Notification.permission === 'granted') {
                new Notification('Activity Complete!', { body: `Session finished. Confirm to log ${mins} min.` });
              }
            } catch (_) {}
            setIsActive(false);
          }
        } catch (_) {}
      }, [onLogActivity]);

      // Hydrate from storage on mount
      useEffect(() => {
        recalculateTimer();
      }, [recalculateTimer]);

      // Recalculate when returning from background/sleep
      useEffect(() => {
        const handleVisibilityChange = () => {
          if (!document.hidden) {
            recalculateTimer();
          }
        };
        document.addEventListener('visibilitychange', handleVisibilityChange);
        return () => document.removeEventListener('visibilitychange', handleVisibilityChange);
      }, [recalculateTimer]);

      // Tick effect
      useEffect(() => {
        if (timeLeft > 0 && isActive) {
          timerRef.current = setTimeout(() => setTimeLeft((t) => t - 1), 1000);
        } else if (timeLeft === 0 && isActive) {
          // Finish ‚Äî require confirmation to log
          const mins = duration;
          setIsActive(false);
          try {
            const todayISO = toLocalISODate(new Date());
            const st = JSON.parse(localStorage.getItem(STORAGE_KEY) || 'null') || {};
            localStorage.setItem(
              STORAGE_KEY,
              JSON.stringify({ ...st, isActive: false, logged: false, pendingMinutes: mins, pendingDate: todayISO, completedAt: Date.now() })
            );
          } catch (_) {}
          setPendingMins(mins);
          if ('Notification' in window && Notification.permission === 'granted') {
            try { new Notification('Activity Complete!', { body: `Session finished. Confirm to log ${mins} min.` }); } catch (_) {}
          }
        }
        return () => clearTimeout(timerRef.current);
      }, [timeLeft, isActive, duration, onLogActivity]);

      const startTimer = (minutes) => {
        const durSec = minutes * 60;
        const now = Date.now();
        const todayISO = toLocalISODate(new Date());
        setTimeLeft(durSec);
        setDuration(minutes);
        setIsActive(true);
        setStartedAt(now);
        // Persist start so it survives navigation/reload
        try {
          localStorage.setItem(STORAGE_KEY, JSON.stringify({
            isActive: true,
            startedAt: now,
            durationSec: durSec,
            intakeDate: todayISO,
            logged: false
          }));
        } catch (_) {}
      };

      const confirmPending = () => {
        const now = Date.now();
        try {
          const st = JSON.parse(localStorage.getItem(STORAGE_KEY) || 'null') || {};
          const mins = Number(st.pendingMinutes || pendingMins || 0);
          if (mins > 0) {
            onLogActivity({ minutes: mins });
          }
          localStorage.setItem(STORAGE_KEY, JSON.stringify({ ...st, isActive: false, logged: true, pendingMinutes: 0, completedAt: now }));
        } catch (_) {}
        setPendingMins(0);
      };

      const dismissPending = () => {
        const now = Date.now();
        try {
          const st = JSON.parse(localStorage.getItem(STORAGE_KEY) || 'null') || {};
          localStorage.setItem(STORAGE_KEY, JSON.stringify({ ...st, isActive: false, logged: true, pendingMinutes: 0, completedAt: now }));
        } catch (_) {}
        setPendingMins(0);
      };

      const formatTime = (seconds) => {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins}:${secs < 10 ? '0' : ''}${secs}`;
      };

      if (isActive) {
        return <div className="text-center font-bold text-3xl text-pink-500">{formatTime(timeLeft)}</div>;
      }

      return (
        <div className="space-y-2">
          {pendingMins > 0 && (
            <div className="p-3 bg-yellow-100 dark:bg-yellow-900 rounded-lg flex flex-wrap items-center justify-between gap-2">
              <span className="text-sm font-semibold text-gray-800 dark:text-gray-200">Log {pendingMins} min activity?</span>
              <div className="flex items-center gap-2 w-full sm:w-auto">
                <button onClick={confirmPending} className="inline-flex items-center justify-center px-2 sm:px-3 py-2 text-xs sm:text-sm bg-green-600 hover:bg-green-700 text-white rounded-lg flex-1">Log</button>
                <button onClick={dismissPending} className="inline-flex items-center justify-center px-2 sm:px-3 py-2 text-xs sm:text-sm bg-gray-300 dark:bg-gray-600 text-gray-800 dark:text-gray-200 rounded-lg flex-1">Dismiss</button>
              </div>
            </div>
          )}
          <p className="font-semibold text-gray-800 dark:text-gray-200 text-center">Start a quick session:</p>
          <div className="grid grid-cols-3 gap-2">
            <button onClick={() => startTimer(10)} className="p-2 bg-pink-500 text-white rounded-lg">10 min</button>
            <button onClick={() => startTimer(20)} className="p-2 bg-pink-500 text-white rounded-lg">20 min</button>
            <button onClick={() => startTimer(30)} className="p-2 bg-pink-500 text-white rounded-lg">30 min</button>
          </div>
        </div>
      );
    };

    // Water Tracker Component (for Dashboard)
    const WaterTracker = ({ onLogWater, dailyIntake, goals, masked = false }) => {
      useEffect(() => {
        const interval = setInterval(() => {
          if ('Notification' in window && Notification.permission === "granted") {
            new Notification("Stay Hydrated!", { body: "Time for a glass of water to keep you going." });
          }
        }, 2 * 60 * 60 * 1000); // Remind every 2 hours
        return () => clearInterval(interval);
      }, []);

      return (
        <div>
          <p className="font-semibold text-gray-800 dark:text-gray-200 text-center">Water Intake: {masked ? '‚Äî' : dailyIntake.water} / {masked ? '‚Äî' : goals.water} glasses</p>
          <button
            onClick={masked ? () => { try { window.dispatchEvent(new Event('request-account-modal')); } catch (_) {} } : onLogWater}
            disabled={masked}
            className={`w-full mt-2 font-bold py-2 rounded-xl ${masked ? 'bg-gray-400 cursor-not-allowed text-white' : 'bg-blue-500 text-white'}`}
          >
            {masked ? 'Sign in to log' : 'Log a Glass'}
          </button>
          <p className="text-xs text-gray-500 dark:text-gray-400 text-center mt-2">
            <span className="font-semibold">Hydration</span> = log water glasses. You can log more than 8, but points cap at 15 (earned at 8 glasses).
          </p>
        </div>
      );
    };

    const MacroCard = ({ title, value, goal, unit, color, masked = false }) => (
      <div className="bg-white dark:bg-gray-800 rounded-2xl p-4 flex flex-col items-center justify-center shadow-md">
        <p className={`font-bold ${color}`}>{title}</p>
        <p className="text-xl font-bold my-1 text-gray-800 dark:text-gray-200">{masked ? '‚Äî' : Math.round(value)}{masked ? '' : unit}</p>
        <p className="text-xs text-gray-500 dark:text-gray-400">Goal: {masked ? '‚Äî' : goal}{masked ? '' : unit}</p>
      </div>
    );

    const MealCard = ({ meal }) => (
      <div className="flex items-center bg-white dark:bg-gray-800 rounded-2xl p-3 shadow-md">
        <img src={meal.image} alt={meal.name} className="w-16 h-16 rounded-lg" />
        <div className="ml-4 flex-grow">
          <p className="font-bold text-gray-800 dark:text-gray-200">{meal.name}</p>
          <p className="text-gray-500 dark:text-gray-400">{Math.round(meal.calories)} kcal</p>
        </div>
        {meal.mood && (
          <span className="text-3xl">{{ Energized: '‚ö°Ô∏è', Happy: 'üòä', Sluggish: 'üò¥', Bloated: 'ü§¢' }[meal.mood]}</span>
        )}
      </div>
    );

    const GoalItem = ({ label, value }) => (
      <div className="flex justify-between items-center p-2">
        <p className="text-gray-600 dark:text-gray-300">{label}</p>
        <p className="font-bold text-gray-800 dark:text-gray-200">{value}</p>
      </div>
    );

    const SettingItem = ({ label }) => (
      <button className="w-full text-left p-3 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-300 transition-colors">
        {label}
      </button>
    );

    const MealPlanDisplay = ({ mealPlan }) => {
      return (
        <div className="space-y-8">
          {/* Breakfast Section */}
          <div className="bg-white dark:bg-gray-800 rounded-lg p-6 shadow-md">
            <h3 className="text-xl font-bold text-gray-800 dark:text-white mb-4">Breakfast: {mealPlan.breakfast.name}</h3>
            
            <div className="mb-4">
              <div className="flex items-center justify-between mb-2">
                <h4 className="font-semibold text-gray-700 dark:text-gray-300">Ingredients:</h4>
                <VoiceButton 
                  text={`Breakfast ingredients: ${mealPlan.breakfast.ingredients.join(', ')}`}
                  buttonId="breakfast-ingredients"
                  label="Ingredients"
                  className="ml-2"
                />
              </div>
              <ul className="list-disc list-inside text-gray-600 dark:text-gray-400">
                {mealPlan.breakfast.ingredients.map((ingredient, index) => (
                  <li key={index}>{ingredient}</li>
                ))}
              </ul>
            </div>
            
            <div>
              <div className="flex items-center justify-between mb-2">
                <h4 className="font-semibold text-gray-700 dark:text-gray-300">Instructions:</h4>
                <VoiceButton 
                  text={`Breakfast instructions: ${mealPlan.breakfast.instructions.join('. ')}`}
                  buttonId="breakfast-instructions"
                  label="Instructions"
                  className="ml-2"
                />
              </div>
              <ol className="list-decimal list-inside text-gray-600 dark:text-gray-400 space-y-1">
                {mealPlan.breakfast.instructions.map((instruction, index) => (
                  <li key={index}>{instruction}</li>
                ))}
              </ol>
            </div>
          </div>

          {/* Lunch Section */}
          <div className="bg-white dark:bg-gray-800 rounded-lg p-6 shadow-md">
            <h3 className="text-xl font-bold text-gray-800 dark:text-white mb-4">Lunch: {mealPlan.lunch.name}</h3>
            
            <div className="mb-4">
              <div className="flex items-center justify-between mb-2">
                <h4 className="font-semibold text-gray-700 dark:text-gray-300">Ingredients:</h4>
                <VoiceButton 
                  text={`Lunch ingredients: ${mealPlan.lunch.ingredients.join(', ')}`}
                  buttonId="lunch-ingredients"
                  label="Ingredients"
                  className="ml-2"
                />
              </div>
              <ul className="list-disc list-inside text-gray-600 dark:text-gray-400">
                {mealPlan.lunch.ingredients.map((ingredient, index) => (
                  <li key={index}>{ingredient}</li>
                ))}
              </ul>
            </div>
            
            <div>
              <div className="flex items-center justify-between mb-2">
                <h4 className="font-semibold text-gray-700 dark:text-gray-300">Instructions:</h4>
                <VoiceButton 
                  text={`Lunch instructions: ${mealPlan.lunch.instructions.join('. ')}`}
                  buttonId="lunch-instructions"
                  label="Instructions"
                  className="ml-2"
                />
              </div>
              <ol className="list-decimal list-inside text-gray-600 dark:text-gray-400 space-y-1">
                {mealPlan.lunch.instructions.map((instruction, index) => (
                  <li key={index}>{instruction}</li>
                ))}
              </ol>
            </div>
          </div>

          {/* Dinner Section */}
          <div className="bg-white dark:bg-gray-800 rounded-lg p-6 shadow-md">
            <h3 className="text-xl font-bold text-gray-800 dark:text-white mb-4">Dinner: {mealPlan.dinner.name}</h3>
            
            <div className="mb-4">
              <div className="flex items-center justify-between mb-2">
                <h4 className="font-semibold text-gray-700 dark:text-gray-300">Ingredients:</h4>
                <VoiceButton 
                  text={`Dinner ingredients: ${mealPlan.dinner.ingredients.join(', ')}`}
                  buttonId="dinner-ingredients"
                  label="Ingredients"
                  className="ml-2"
                />
              </div>
              <ul className="list-disc list-inside text-gray-600 dark:text-gray-400">
                {mealPlan.dinner.ingredients.map((ingredient, index) => (
                  <li key={index}>{ingredient}</li>
                ))}
              </ul>
            </div>
            
            <div>
              <div className="flex items-center justify-between mb-2">
                <h4 className="font-semibold text-gray-700 dark:text-gray-300">Instructions:</h4>
                <VoiceButton 
                  text={`Dinner instructions: ${mealPlan.dinner.instructions.join('. ')}`}
                  buttonId="dinner-instructions"
                  label="Instructions"
                  className="ml-2"
                />
              </div>
              <ol className="list-decimal list-inside text-gray-600 dark:text-gray-400 space-y-1">
                {mealPlan.dinner.instructions.map((instruction, index) => (
                  <li key={index}>{instruction}</li>
                ))}
              </ol>
            </div>
          </div>
        </div>
      );
    };

    // Workout Plan Display Component
    const WorkoutPlanDisplay = ({ workoutPlan }) => {
      // Channel allowlist (label + YouTube handle if known). If handle missing, we fall back to general search including label.
      const CHANNELS = [
        { label: 'All YouTube', value: 'all' },
        { label: 'Athlean-X', value: 'athleanx', handle: '@ATHLEANX' },
        { label: 'Jeff Nippard', value: 'jeffnippard', handle: '@JeffNippard' },
        { label: 'Renaissance Periodization', value: 'rp', handle: '@RenaissancePeriodization' },
        { label: 'Juggernaut Training Systems', value: 'juggernaut', handle: '@JuggernautTrainingSystems' },
        { label: 'Barbell Medicine', value: 'barbellmedicine', handle: '@BarbellMedicine' },
        { label: 'Alan Thrall', value: 'alanthrall', handle: '@AlanThrall' },
        { label: 'Squat University', value: 'squatuniversity', handle: '@SquatUniversity' },
        { label: 'Calisthenic Movement', value: 'calimove', handle: '@calimove' },
        { label: 'FitnessFAQs', value: 'fitnessfaqs', handle: '@FitnessFAQs' },
        // { label: 'ThenX', value: 'thenx', handle: '@OFFICIALTHENX' },
        // { label: 'StrongFirst', value: 'strongfirst', handle: '@strongfirst' },
        // { label: 'Kettlebell Kings', value: 'kettlebellkings', handle: '@KettlebellKings' },
        { label: 'Onnit Academy', value: 'onnit', handle: '@OnnitAcademy' },
        { label: 'Catalyst Athletics', value: 'catalyst', handle: '@catalystathletics' },
        { label: 'California Strength', value: 'calstrength', handle: '@CaliforniaStrength' },
        { label: 'E3Rehab', value: 'e3rehab', handle: '@E3Rehab' },
        { label: 'PhysioTutors', value: 'physiotutors', handle: '@PhysioTutors' },
        { label: 'Girls Gone Strong', value: 'ggs', handle: '@GirlsGoneStrong' },
      ];

      const [selectedChannel, setSelectedChannel] = useState('all');
      const [shortOnly, setShortOnly] = useState(false);

      // Detect Android WebView (PWA-to-native wrapper) to route YouTube with Intent
      const isAndroidWebView = () => {
        const ua = navigator.userAgent || '';
        const isAndroid = /Android/i.test(ua);
        // "wv" token indicates Android WebView; also check for crosswalk chromes
        const isWV = /; wv\)/i.test(ua) || /Version\/\d+\.\d+ Chrome\/\d+/i.test(ua);
        return isAndroid && isWV;
      };

      const openYouTubeExternally = async (e, url) => {
        try {
          if (isAndroidWebView()) {
            // In Android WebView, intent:// is not a recognized scheme and causes
            // net::ERR_UNKNOWN_URL_SCHEME. Provide immediate feedback and prefer
            // opening externally; if blocked, navigate in-place.
            e.preventDefault();
            try { window.__transitionOverlay?.show('Opening YouTube‚Ä¶'); } catch(_) {}
            try {
              const win = window.open(url, '_blank', 'noopener,noreferrer');
              if (!win) {
                // Optional share sheet as a nicer fallback if available
                if (navigator.share && typeof navigator.share === 'function') {
                  try { await navigator.share({ title: 'YouTube', url }); } catch(_) {}
                } else {
                  // Fallback: navigate within the WebView
                  window.location.href = url;
                }
              }
            } catch (_) {
              window.location.href = url;
            } finally {
              setTimeout(() => { try { window.__transitionOverlay?.hide(); } catch(_) {} }, 1200);
            }
          }
        } catch (_) {}
      };

      // Minimal transition overlay to reassure users during external navigation
      (function(){
        try {
          const api = {
            el: null,
            ensure(){
              if (this.el) return;
              const overlay = document.createElement('div');
              overlay.id = 'transition-overlay';
              overlay.style.position = 'fixed';
              overlay.style.inset = '0';
              overlay.style.background = 'rgba(17,24,39,0.45)';
              overlay.style.backdropFilter = 'blur(2px)';
              overlay.style.display = 'none';
              overlay.style.alignItems = 'center';
              overlay.style.justifyContent = 'center';
              overlay.style.zIndex = '9999';
              const box = document.createElement('div');
              box.className = 'rounded-lg bg-white dark:bg-gray-800 px-4 py-3 shadow';
              box.style.minWidth = '220px';
              box.style.textAlign = 'center';
              box.innerHTML = `
                <div class="flex items-center justify-center gap-2 text-gray-800 dark:text-gray-200">
                  <svg class="w-5 h-5 text-red-600" viewBox="0 0 24 24" fill="currentColor"><path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"/></svg>
                  <span class="font-medium">Opening YouTube‚Ä¶</span>
                </div>`;
              overlay.appendChild(box);
              document.body.appendChild(overlay);
              this.el = overlay;
            },
            show(text){
              this.ensure();
              try {
                const span = this.el.querySelector('span');
                if (text && span) span.textContent = text;
                this.el.style.display = 'flex';
              } catch(_) {}
            },
            hide(){ try { if (this.el) this.el.style.display = 'none'; } catch(_) {}
            }
          };
          window.__transitionOverlay = api;
          window.addEventListener('pageshow', () => { try { api.hide(); } catch(_) {} });
          document.addEventListener('visibilitychange', () => { if (!document.hidden) { try { api.hide(); } catch(_) {} } });
        } catch(_) {}
      })();

      // Helpers to generate YouTube search URLs with channel/duration preferences
      const normalizeExerciseName = (exerciseName) => {
        let name = String(exerciseName || '');
        // Capture equipment before stripping parens
        const equipment = (name.match(/\((.*?)\)/)?.[1] || '').toLowerCase();
        // Strip parentheses content
        name = name.replace(/\(.*?\)/g, '').trim();
        // Drop prefixes like "Exercise 1:", "Warm-up:", "Cooldown:"
        if (name.includes(':')) {
          const parts = name.split(':');
          name = parts[parts.length - 1].trim();
        }
        name = name.replace(/^Exercise\s*\d+\s*-?\s*/i, '').trim();
        name = name.replace(/^Warm-?up\s*-?\s*/i, '').trim();
        name = name.replace(/^Cooldown\s*-?\s*/i, '').trim();
        return { baseName: name, equipment };
      };

      const getYouTubeGlobalSearchUrl = (exerciseName) => {
        const { baseName, equipment } = normalizeExerciseName(exerciseName);
        const level = (workoutPlan?.plan_name || '').toLowerCase();
        const levelHint = /beginner/.test(level) ? 'beginner' : /intermediate/.test(level) ? 'intermediate' : /advanced|expert/.test(level) ? 'advanced' : '';

        const extras = ['proper form', 'tutorial'];
        if (shortOnly) extras.push('short tutorial', 'quick');
        if (equipment) extras.push(equipment);
        if (levelHint) extras.push(levelHint);

        // Keep negatives minimal to avoid zero-results; do not exclude shorts globally by default
        const negatives = ['-compilation', '-montage', '-meme'];

        const query = `${baseName} ${extras.join(' ')} ${negatives.join(' ')}`.replace(/\s+/g, ' ').trim();
        return `https://www.youtube.com/results?search_query=${encodeURIComponent(query)}&hl=en`;
      };

      const getYouTubeChannelSearchUrl = (exerciseName) => {
        if (selectedChannel === 'all') return null;
        const ch = CHANNELS.find(c => c.value === selectedChannel);
        const { baseName, equipment } = normalizeExerciseName(exerciseName);
        // Use a minimal, broad query for channel search; avoid time hints
        const terms = [baseName, 'tutorial', 'form'];
        if (equipment) terms.push(equipment);
        const query = terms.join(' ').replace(/\s+/g, ' ').trim();
        if (ch?.handle) return `https://www.youtube.com/${encodeURIComponent(ch.handle)}/search?query=${encodeURIComponent(query)}&hl=en`;
        const biased = `${query} \"${ch?.label || ''}\"`;
        return `https://www.youtube.com/results?search_query=${encodeURIComponent(biased)}&hl=en`;
      };

      return (
        <div className="space-y-4 sm:space-y-6">
          {workoutPlan.exercises.map((exercise, index) => (
            <div key={index} className="bg-white dark:bg-gray-800 rounded-lg p-4 sm:p-6 shadow-md">
              <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between mb-4 gap-2">
                <h3 className="text-lg sm:text-xl font-bold text-gray-800 dark:text-white">
                  Exercise {index + 1}: {exercise.name}
                </h3>
                <VoiceButton 
                  text={`Exercise ${index + 1}: ${exercise.name}. You will do ${exercise.sets} sets of ${exercise.reps} repetitions. Instructions: ${exercise.instructions}`}
                  buttonId={`exercise-${index}`}
                  label="Listen"
                  className="self-start sm:ml-2"
                />
              </div>
              
              <div className="grid grid-cols-2 gap-2 sm:gap-4 mb-4">
                <div className="text-center p-2 sm:p-3 bg-blue-50 dark:bg-blue-900/20 rounded-lg">
                  <div className="text-xl sm:text-2xl font-bold text-blue-600 dark:text-blue-400">{exercise.sets}</div>
                  <div className="text-xs sm:text-sm text-gray-600 dark:text-gray-400">Sets</div>
                </div>
                <div className="text-center p-2 sm:p-3 bg-green-50 dark:bg-green-900/20 rounded-lg">
                  <div className="text-xl sm:text-2xl font-bold text-green-600 dark:text-green-400">{exercise.reps}</div>
                  <div className="text-xs sm:text-sm text-gray-600 dark:text-gray-400">Reps</div>
                </div>
              </div>
              
              <div className="mb-4">
                <h4 className="font-semibold text-gray-700 dark:text-gray-300 mb-2 text-sm sm:text-base">Instructions:</h4>
                <p className="text-gray-600 dark:text-gray-400 text-sm sm:text-base leading-relaxed">{exercise.instructions}</p>
              </div>
              
              {/* YouTube Video Search Link with Channel Filter */}
              <div className="mt-4 p-3 sm:p-4 bg-red-50 dark:bg-red-900/20 rounded-lg border border-red-200 dark:border-red-800">
                <div className="grid gap-3 sm:flex sm:items-center sm:justify-between">
                  <div className="flex items-center">
                    <svg className="w-5 h-5 sm:w-6 sm:h-6 text-red-600 dark:text-red-400 mr-2 flex-shrink-0" fill="currentColor" viewBox="0 0 24 24">
                      <path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"/>
                    </svg>
                    <span className="font-semibold text-red-700 dark:text-red-300 text-sm sm:text-base">Watch Tutorial</span>
                  </div>
                  <div className="flex flex-col sm:flex-row items-stretch sm:items-center gap-2 sm:gap-3">
                    <select
                      value={selectedChannel}
                      onChange={(e) => setSelectedChannel(e.target.value)}
                      className="bg-white dark:bg-gray-800 border border-red-200 dark:border-red-700 rounded-md px-2 py-2 text-sm text-gray-800 dark:text-gray-200"
                      aria-label="Preferred channel"
                    >
                      {CHANNELS.map(ch => (
                        <option key={ch.value} value={ch.value}>{ch.label}</option>
                      ))}
                    </select>
                    <label className="inline-flex items-center gap-2 text-xs sm:text-sm text-gray-700 dark:text-gray-300">
                      <input
                        type="checkbox"
                        checked={shortOnly}
                        onChange={(e) => setShortOnly(e.target.checked)}
                        className="w-4 h-4 accent-red-600"
                      />
                      Prefer shorter
                    </label>
                    {selectedChannel !== 'all' && (
                      <a 
                        href={getYouTubeChannelSearchUrl(exercise.name)} 
                        target="_blank" 
                        rel="noopener noreferrer"
                        onClick={(e) => openYouTubeExternally(e, getYouTubeChannelSearchUrl(exercise.name))}
                        className="bg-red-600 hover:bg-red-700 text-white px-3 py-2 sm:px-4 sm:py-2 rounded-lg font-medium transition-colors flex items-center justify-center gap-2 text-sm sm:text-base w-full sm:w-auto"
                      >
                        <svg className="w-4 h-4 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                        </svg>
                        Search This Channel
                      </a>
                    )}
                    <a 
                      href={getYouTubeGlobalSearchUrl(exercise.name)} 
                      target="_blank" 
                      rel="noopener noreferrer"
                      onClick={(e) => openYouTubeExternally(e, getYouTubeGlobalSearchUrl(exercise.name))}
                      className="bg-red-600 hover:bg-red-700 text-white px-3 py-2 sm:px-4 sm:py-2 rounded-lg font-medium transition-colors flex items-center justify-center gap-2 text-sm sm:text-base w-full sm:w-auto"
                    >
                      <svg className="w-4 h-4 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                      </svg>
                      Search All
                    </a>
                  </div>
                </div>
              </div>
            </div>
          ))}
        </div>
      );
    };


    const BottomNavBar = ({ screen, setScreen }) => (
    <nav id="bottom-nav" className="fixed bottom-0 left-0 right-0 bg-white/80 dark:bg-gray-900/80 backdrop-blur-sm shadow-[0_-2px_10px_rgba(0,0,0,0.05)] dark:shadow-[0_-2px_10px_rgba(0,0,0,0.2)] h-20 flex justify-around items-center px-4 z-50">
        <button onClick={() => setScreen('dashboard')} aria-current={screen === 'dashboard' ? 'page' : undefined} className={`flex flex-col items-center justify-center font-semibold transition-colors rounded-xl px-2 py-1 ${screen === 'dashboard' ? 'text-pink-600 bg-pink-50 dark:bg-gray-800' : 'text-gray-400'}`}>
          <span className="text-2xl">üè†</span>
          <span className={`${screen === 'dashboard' ? 'block' : 'hidden'} w-6 h-1 bg-pink-500 rounded-full mt-1`}></span>
        </button>
        <button onClick={() => setScreen('progress')} aria-current={screen === 'progress' ? 'page' : undefined} className={`flex flex-col items-center justify-center font-semibold transition-colors rounded-xl px-2 py-1 ${screen === 'progress' ? 'text-pink-600 bg-pink-50 dark:bg-gray-800' : 'text-gray-400'}`}>
          <span className="text-2xl">üìä</span>
          <span className={`${screen === 'progress' ? 'block' : 'hidden'} w-6 h-1 bg-pink-500 rounded-full mt-1`}></span>
        </button>
        <button onClick={() => setScreen('planner')} aria-current={screen === 'planner' ? 'page' : undefined} className={`flex flex-col items-center justify-center font-semibold transition-colors rounded-xl px-2 py-1 ${screen === 'planner' ? 'text-pink-600 bg-pink-50 dark:bg-gray-800' : 'text-gray-400'}`}>
          <span className="text-2xl">üçΩÔ∏è</span>
          <span className={`${screen === 'planner' ? 'block' : 'hidden'} w-6 h-1 bg-pink-500 rounded-full mt-1`}></span>
        </button>
        <button onClick={() => setScreen('scan')} className="bg-blue-500 text-white w-14 h-14 rounded-full flex items-center justify-center text-lg font-bold shadow-lg">
          Cal
        </button>
        <button onClick={() => { try { localStorage.setItem('workoutPlanner_activeTab', 'planner'); } catch(_) {} setScreen('workout'); }} aria-current={screen === 'workout' ? 'page' : undefined} className={`flex flex-col items-center justify-center font-semibold transition-colors rounded-xl px-2 py-1 ${screen === 'workout' ? 'text-pink-600 bg-pink-50 dark:bg-gray-800' : 'text-gray-400'}`}>
          <span className="text-2xl">üèãÔ∏è</span>
          <span className={`${screen === 'workout' ? 'block' : 'hidden'} w-6 h-1 bg-pink-500 rounded-full mt-1`}></span>
        </button>
        <button onClick={() => setScreen('coach')} aria-current={screen === 'coach' ? 'page' : undefined} className={`flex flex-col items-center justify-center font-semibold transition-colors rounded-xl px-2 py-1 ${screen === 'coach' ? 'text-pink-600 bg-pink-50 dark:bg-gray-800' : 'text-gray-400'}`}>
          <span className="text-2xl">ü§ñ</span>
          <span className={`${screen === 'coach' ? 'block' : 'hidden'} w-6 h-1 bg-pink-500 rounded-full mt-1`}></span>
        </button>
        <button onClick={() => setScreen('profile')} aria-current={screen === 'profile' ? 'page' : undefined} className={`flex flex-col items-center justify-center font-semibold transition-colors rounded-xl px-2 py-1 ${screen === 'profile' ? 'text-pink-600 bg-pink-50 dark:bg-gray-800' : 'text-gray-400'}`}>
          <span className="text-2xl">üë§</span>
          <span className={`${screen === 'profile' ? 'block' : 'hidden'} w-6 h-1 bg-pink-500 rounded-full mt-1`}></span>
        </button>
      </nav>
    );
  </script>
  <script type="text/babel">
    // --- Mount App ---
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(
      <AuthProvider>
        <App />
      </AuthProvider>
    );
  </script>
  <!-- PDF Generation Library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script>
    // Register service worker (safe, idempotent). Remove duplicate registrations if already present
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/sw.js')
          .then(reg => console.log('ServiceWorker registered:', reg.scope))
          .catch(err => console.warn('ServiceWorker registration failed:', err));
      });
    }
  </script>
  
  <!-- ‚úÖ Animated Install FitnessMate App Banner -->
  <style>
    #installBanner {
      position: fixed;
      bottom: -100px;
      left: 0;
      right: 0;
      background: #2563EB;
      color: white;
      text-align: center;
      padding: 14px;
      font-family: system-ui, sans-serif;
      font-size: 15px;
      z-index: 9999;
      box-shadow: 0 -2px 8px rgba(0,0,0,0.3);
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      transition: bottom 0.4s ease;
    }
    #installBanner.show { bottom: 0; }
    #installBanner button {
      background: white;
      color: #2563EB;
      border: none;
      border-radius: 6px;
      padding: 6px 12px;
      font-weight: 600;
      cursor: pointer;
    }
    #closeBanner {
      background: transparent;
      border: none;
      color: white;
      font-size: 20px;
      line-height: 1;
      cursor: pointer;
      position: absolute;
      right: 12px;
      top: 8px;
    }
    /* Mobile-only: prevent close (√ó) from overlapping Install button */
    @media (max-width: 480px) {
      #closeBanner {
        position: static;
        right: auto;
        top: auto;
        margin-left: auto; /* push close to the far right */
      }
    }
  </style>
  
  <div id="installBanner">
    <span class="android-icon" aria-hidden="true">
      <img src="/logo.png" alt="FitnessMate logo" style="width:100%; height:100%; object-fit:contain;" />
    </span>
    Get <b>FitnessMate</b> on Android
    <button id="installBtn">Play Store</button>
    <button id="closeBanner">√ó</button>
  </div>
  <div id="installBannerIOS">
    <div class="banner-content">
      <div class="main-text">
        <span class="ios-icon" aria-hidden="true">
          <svg viewBox="0 0 814 1000" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
            <path d="M788.1 340.9c-5.8 4.5-108.2 62.2-108.2 190.5 0 148.4 130.3 200.9 134.2 202.2-.6 3.2-20.7 71.9-68.7 141.9-42.8 61.6-87.5 123.1-155.5 123.1s-85.5-39.5-164-39.5c-76.5 0-103.7 40.8-165.9 40.8s-105.6-57-155.5-127C46.7 790.7 0 663 0 541.8c0-194.4 126.4-297.5 250.8-297.5 66.1 0 121.2 43.4 162.7 43.4 39.5 0 101.1-46 176.3-46 28.5 0 130.9 2.6 198.3 99.2zm-234-181.5c31.1-36.9 53.1-88.1 53.1-139.3 0-7.1-.6-14.3-1.9-20.1-50.6 1.9-110.8 33.7-147.1 75.8-28.5 32.4-55.1 83.6-55.1 135.5 0 7.8 1.3 15.6 1.9 18.1 3.2.6 8.4 1.3 13.6 1.3 45.4 0 102.5-30.4 135.5-71.3z"/>
          </svg>
        </span>
        Install <b class="app-name">FitnessMate</b>
      </div>
      <div class="sub-text">On iPhone: Tap Share 
        <svg aria-hidden="true" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.4" stroke-linecap="round" stroke-linejoin="round" shape-rendering="geometricPrecision" style="display:inline-block;width:24px;height:24px;margin:0 8px -3px 8px;vertical-align:-3px;">
          <!-- Open-top rounded square (no top stroke) -->
          <path d="M6 20h12a2 2 0 0 0 2-2v-10" />
          <path d="M6 20a2 2 0 0 1-2-2v-10" />
          <!-- Up arrow emerging from the square -->
          <path d="M12 3v7" />
          <path d="M8.5 7.5L12 4l3.5 3.5" />
        </svg>, then Add to Home Screen</div>
    </div>
    <button id="closeBannerIOS">√ó</button>
  </div>
  
  <script>
    let deferredPrompt;
    const banner = document.getElementById('installBanner');
    const installBtn = document.getElementById('installBtn');
    const closeBanner = document.getElementById('closeBanner');
    const PLAY_STORE_URL = 'https://play.google.com/store/apps/details?id=app.netlify.fitnessmate.twa';
  
    window.addEventListener('beforeinstallprompt', (e) => {
      e.preventDefault();
      deferredPrompt = e;
      banner.classList.add('show');
    });
  
    installBtn.addEventListener('click', () => {
      banner.classList.remove('show');
      window.location.href = PLAY_STORE_URL;
    });
  
    closeBanner.addEventListener('click', () => {
      banner.classList.remove('show');
    });
  
    window.addEventListener('appinstalled', () => {
      banner.classList.remove('show');
      console.log('PWA installed');
    });
    const isiOS = /iphone|ipad|ipod/i.test(navigator.userAgent) || (navigator.userAgent.includes('Mac') && 'ontouchend' in document);
    const isStandalone = (window.navigator.standalone === true) || window.matchMedia('(display-mode: standalone)').matches;
    const bannerIOS = document.getElementById('installBannerIOS');
    const installBtnIOS = document.getElementById('installBtnIOS');
    const closeBannerIOS = document.getElementById('closeBannerIOS');
    window.addEventListener('load', () => {
      if (isiOS && !isStandalone && bannerIOS) {
        bannerIOS.classList.add('show');
      }
    });
    if (installBtnIOS && bannerIOS) {
      installBtnIOS.addEventListener('click', () => {
        if (window.showToast) { showToast('To install FitnessMate on iPhone: tap the Share icon in Safari, then select "Add to Home Screen".', 'info', { duration: 5000 }); } else { console.log('To install FitnessMate on iPhone: tap the Share icon in Safari, then select "Add to Home Screen".'); }
        bannerIOS.classList.remove('show');
      });
    }
    if (closeBannerIOS && bannerIOS) {
      closeBannerIOS.addEventListener('click', () => {
        bannerIOS.classList.remove('show');
      });
    }
    window.addEventListener('appinstalled', () => {
      if (bannerIOS) bannerIOS.classList.remove('show');
    });
  </script>
<!-- Stripe Pricing Table modal -->
<script async src="https://js.stripe.com/v3/pricing-table.js"></script>
<div id="stripePricingModal" style="display:none; position:fixed; inset:0; z-index:10000; background:rgba(0,0,0,0.6); align-items:center; justify-content:center; overflow:auto;">
  <div style="background:#fff; max-width:480px; width:100%; margin:40px; padding:20px; border-radius:8px; position:relative;">
    <button onclick="window.closeStripePricingModal()" style="position:absolute; top:8px; right:12px; font-size:24px; border:none; background:transparent; cursor:pointer;">√ó</button>
    <stripe-pricing-table pricing-table-id="prctbl_1SIvLCJRFG3zIhTKhJSKc5jk"
      publishable-key="pk_live_51SIu0RJRFG3zIhTKZkkXcQZdRbWXshYT78KWQqpsRfDPIhuxYh9Ngtz5HbqcIMBioEXrpk9rp6dJtHLp0IQ106f900MI4zPe2M">
    </stripe-pricing-table>
  </div>
</div>
<script>
(function(){
  window.openStripePricingModal = function(){ var m=document.getElementById('stripePricingModal'); if(m) m.style.display='flex'; };
  window.closeStripePricingModal = function(){ var m=document.getElementById('stripePricingModal'); if(m) m.style.display='none'; };
})();
</script>
<!-- Fitmate Toast / Snackbar UI -->
<style id="fitmate-toast-styles">
  .fitmate-toast-container { position: fixed; top: 16px; left: 50%; transform: translateX(-50%); z-index: 100000; display: flex; flex-direction: column; gap: 8px; pointer-events: none; }
  .fitmate-toast { min-width: 240px; max-width: 86vw; background: rgba(20,20,22,0.85); color: #fff; border-radius: 12px; padding: 12px 16px; box-shadow: 0 10px 24px rgba(0,0,0,0.35); backdrop-filter: blur(12px); font: 600 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; opacity: 0; transform: translateY(-8px); transition: opacity .25s ease, transform .25s ease; pointer-events: auto; }
  .fitmate-toast.visible { opacity: 1; transform: translateY(0); }
  .fitmate-toast--success { background: linear-gradient(135deg, #10b981, #0ea5e9 20%, #059669 80%); }
  .fitmate-toast--error { background: linear-gradient(135deg, #ef4444, #f43f5e 30%, #dc2626 85%); }
  .fitmate-toast--info { background: linear-gradient(135deg, #3b82f6, #2563eb 70%); }
  .fitmate-toast__icon { margin-right: 8px; }
  @media (prefers-color-scheme: light) {
    .fitmate-toast { background: rgba(25,25,28,0.85); }
  }
</style>
<script>
  (function(){
    const containerId = 'fitmate-toast-container';
    function ensureToastContainer(){
      let el = document.getElementById(containerId);
      if (!el) {
        el = document.createElement('div');
        el.id = containerId;
        el.className = 'fitmate-toast-container';
        document.body.appendChild(el);
      }
      return el;
    }

    function buildToast(message, type){
      const toast = document.createElement('div');
      toast.className = 'fitmate-toast' + (type ? (' fitmate-toast--' + type) : '');
      toast.role = 'status';
      toast.setAttribute('aria-live', 'polite');
      toast.textContent = message;
      // Dismiss on tap
      toast.addEventListener('click', function(){
        toast.classList.remove('visible');
        setTimeout(function(){ toast.remove(); }, 250);
      });
      return toast;
    }

    window.showToast = function(message, type = 'info', options){
      try {
        const container = ensureToastContainer();
        const toast = buildToast(String(message || ''), type);
        const duration = Math.max(800, Math.min(6000, (options && options.duration) || 2200));
        container.appendChild(toast);
        requestAnimationFrame(function(){ toast.classList.add('visible'); });
        setTimeout(function(){
          toast.classList.remove('visible');
          setTimeout(function(){ toast.remove(); }, 250);
        }, duration);
        return toast;
      } catch (_) {
        console.log('[toast]', message);
        return null;
      }
    };
  })();
</script>
</body>
</html>
