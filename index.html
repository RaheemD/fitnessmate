<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>FitnessMate</title>
  <link rel="icon" type="image/x-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' fill='%23ec4899'/><text x='50' y='70' text-anchor='middle' fill='white' font-family='Arial, sans-serif' font-weight='bold' font-size='60'>F</text></svg>">
  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      darkMode: 'class',
    }
  </script>
  
  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-storage-compat.js"></script>
  
  <!-- Custom Booking System - No longer using Calendly -->
  
  <!-- Stripe.js -->
  <script src="https://js.stripe.com/v3/"></script>
  
  <!-- Whereby for video meetings -->
  
  <!-- EmailJS for email sending -->
  <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@emailjs/browser@3/dist/email.min.js"></script>
  <script>
    (function() {
      // Initialize EmailJS with your public key
      emailjs.init("NBoWj-4wIbDY-qLS8"); // Replace with your actual EmailJS public key
      
      /* 
      IMPORTANT: To set up EmailJS for booking confirmations:
      
      1. Sign up at https://www.emailjs.com/ (free tier available)
      2. Create a new Email Service (Gmail, Outlook, etc.)
      3. Create two email templates:
         - For free sessions (template_id): Include {{to_name}}, {{session_date}}, {{session_time}}, {{session_type}}, {{meeting_link}}
         - For paid sessions (template_paid_id): Include all above plus {{sessions_count}} and {{amount_paid}}
      4. Replace 'YOUR_PUBLIC_KEY' above with your EmailJS public key
      5. Replace 'service_id', 'template_id', and 'template_paid_id' in the code with your actual IDs
      */
    })();
  </script>
  
  <!-- Custom Booking Calendar Styles -->
  <style>
    .booking-calendar-container {
      width: 100%;
      min-height: 650px;
    }
    
    .booking-step {
      animation: fadeIn 0.3s ease-in-out;
    }
    
    .calendar-container {
      width: 100%;
    }
    
    .calendar-day {
      aspect-ratio: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }
    
    .time-slots-container {
      max-height: 400px;
      overflow-y: auto;
    }
    
    .time-slot {
      transition: all 0.2s ease;
    }
    
    .package-card {
      height: 100%;
      display: flex;
      flex-direction: column;
      transition: all 0.2s ease;
    }
    
    .package-price {
      margin-bottom: 1rem;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
  </style>
</head>
<body class="bg-gray-50 dark:bg-gray-900">
  <!-- Hidden Netlify Form for Support -->
  <form name="support-form" netlify hidden>
    <input type="text" name="full-name" />
    <input type="email" name="email" />
    <input type="text" name="subject" />
    <textarea name="message"></textarea>
  </form>
  
  <!-- Background Music Audio Element -->
  <audio id="background-music" loop preload="auto">
    <source src="./Gym.mp3" type="audio/mpeg">
    Your browser does not support the audio element.
  </audio>
  
  <div id="root"></div>

  <!-- React + ReactDOM + Babel (for JSX in-browser) -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    const { useState, useRef, useEffect } = React;

    // Firebase Configuration with obfuscated API key
    const getFirebaseConfig = () => {
      const keyParts = [
        'QUl6YVN5RHVEWWJncnY0WTdrUU90bWdzX1VraVFPUXJ6aFdOanJZ', // AIzaSyDuDYbgrv4Y7kQOtmgs_UkiQOQrzhWNjrY
      ];
      return {
        apiKey: atob(keyParts[0]),
        authDomain: "fitnessmate-ba739.firebaseapp.com",
        databaseURL: "https://fitnessmate-ba739-default-rtdb.europe-west1.firebasedatabase.app",
        projectId: "fitnessmate-ba739",
        storageBucket: "fitnessmate-ba739.firebasestorage.app",
        messagingSenderId: "1023464958187",
        appId: "1:1023464958187:web:256a30e06441d54d3236ae",
        measurementId: "G-JLMLLTTY43"
      };
    };
    
    const firebaseConfig = getFirebaseConfig();

    // Initialize Firebase
    let app, auth, db, storage;
    try {
      app = firebase.initializeApp(firebaseConfig);
      auth = firebase.auth();
      db = firebase.database(); // Using Realtime Database
      storage = firebase.storage(); // Add if you need file uploads
    } catch (error) {
      console.log('Firebase not configured yet:', error.message);
      // Show user-friendly error message
      setTimeout(() => {
        const errorDiv = document.createElement('div');
        errorDiv.innerHTML = `
          <div style="position: fixed; top: 20px; left: 20px; right: 20px; background: #fee; border: 1px solid #fcc; color: #c33; padding: 15px; border-radius: 8px; z-index: 9999; font-family: Arial, sans-serif;">
            <strong>‚ö†Ô∏è Firebase Connection Issue:</strong><br>
            The app is running in offline mode. Some features may be limited.<br>
            <small>Error: ${error.message}</small>
          </div>
        `;
        document.body.appendChild(errorDiv);
        setTimeout(() => errorDiv.remove(), 10000);
      }, 1000);
    }

    // Authentication Context
    const AuthContext = React.createContext();

    const AuthProvider = ({ children }) => {
      const [user, setUser] = useState(null);
      const [loading, setLoading] = useState(true);
      const [authError, setAuthError] = useState(null);

      useEffect(() => {
        if (!auth) {
          setLoading(false);
          return;
        }

        const unsubscribe = auth.onAuthStateChanged((user) => {
          setUser(user);
          setLoading(false);
          if (user) {
            // Sync user data when authenticated
            syncUserData(user);
          }
        });

        return () => unsubscribe();
      }, []);

      const createInitialUserDocument = async (user) => {
        if (!db) return;
        
        try {
          await db.ref(`users/${user.uid}`).set({
            // Basic user info
            displayName: user.displayName || 'User',
            email: user.email,
            createdAt: firebase.database.ServerValue.TIMESTAMP,
            updatedAt: firebase.database.ServerValue.TIMESTAMP,
            
            // Profile data
            goals: JSON.parse(localStorage.getItem('goals') || '{}'),
            profilePicture: localStorage.getItem('profilePicture') || '',
            notificationsEnabled: JSON.parse(localStorage.getItem('notificationsEnabled') || 'true'),
            darkMode: JSON.parse(localStorage.getItem('fitmate-dark-mode') || 'false'),
            
            // Fitness data
            dailyIntake: JSON.parse(localStorage.getItem('dailyIntake') || '{"calories":0,"protein":0,"carbs":0,"fat":0,"activity":0,"water":0}'),
            recentMeals: JSON.parse(localStorage.getItem('recentMeals') || '[]'),
            dailyHistory: JSON.parse(localStorage.getItem('dailyHistory') || '{}'),
            
            // AI and coaching data
            coachMessages: JSON.parse(localStorage.getItem('coachMessages') || '[{"text":"Hello! I\'m your AI Health Coach. Ask me anything about your nutrition or meals.","sender":"ai"}]'),
            habitAIAdvice: localStorage.getItem('habitAIAdvice') || '',
            habits: JSON.parse(localStorage.getItem('habits') || '[]'),
            
            // AI-generated content
            mealPlan: JSON.parse(localStorage.getItem('mealPlan') || 'null'),
            workoutPlan: JSON.parse(localStorage.getItem('workoutPlan') || 'null'),
            scanResult: JSON.parse(localStorage.getItem('scanResult') || 'null'),
            formAnalysis: JSON.parse(localStorage.getItem('formAnalysis') || 'null')
          });
          console.log('‚úÖ Comprehensive user document created in Realtime Database');
        } catch (error) {
          console.error('Error creating initial user document:', error);
        }
      };

      const syncUserData = async (user) => {
        if (!db) {
          console.log('Realtime Database not available - data will be stored locally only');
          return;
        }
        
        try {
          const userSnapshot = await db.ref(`users/${user.uid}`).once('value');
          if (userSnapshot.exists()) {
            const userData = userSnapshot.val();
            const localLastSync = localStorage.getItem('lastSyncTimestamp');
            const remoteLastSync = userData.updatedAt;
            
            console.log('üîÑ Intelligent sync - comparing timestamps...');
            console.log('Local last sync:', localLastSync);
            console.log('Remote last sync:', remoteLastSync);
            
            // Smart sync: only update if remote data is newer
            const shouldSyncFromRemote = !localLastSync || (remoteLastSync && remoteLastSync > parseInt(localLastSync));
            
            if (shouldSyncFromRemote) {
              console.log('üì• Syncing newer data from remote to local');
              
              // Sync all user data to localStorage
              if (userData.goals) localStorage.setItem('goals', JSON.stringify(userData.goals));
              if (userData.profilePicture) localStorage.setItem('profilePicture', userData.profilePicture);
              if (userData.notificationsEnabled !== undefined) {
                localStorage.setItem('notificationsEnabled', JSON.stringify(userData.notificationsEnabled));
              }
              
              // Sync additional user data
              if (userData.dailyIntake) localStorage.setItem('dailyIntake', JSON.stringify(userData.dailyIntake));
              if (userData.recentMeals) localStorage.setItem('recentMeals', JSON.stringify(userData.recentMeals));
              if (userData.dailyHistory) localStorage.setItem('dailyHistory', JSON.stringify(userData.dailyHistory));
              if (userData.coachMessages) localStorage.setItem('coachMessages', JSON.stringify(userData.coachMessages));
              if (userData.habitAIAdvice) localStorage.setItem('habitAIAdvice', userData.habitAIAdvice);
              if (userData.habits) localStorage.setItem('habits', JSON.stringify(userData.habits));
              if (userData.darkMode !== undefined) localStorage.setItem('fitmate-dark-mode', userData.darkMode.toString());
              
              // Sync AI-generated content
              if (userData.mealPlan) localStorage.setItem('mealPlan', JSON.stringify(userData.mealPlan));
              if (userData.workoutPlan) localStorage.setItem('workoutPlan', JSON.stringify(userData.workoutPlan));
              if (userData.workoutHistory) {
                const wh = userData.workoutHistory;
                const whArray = Array.isArray(wh) ? wh : (wh && typeof wh === 'object' ? Object.values(wh) : []);
                try { whArray.sort((a,b) => new Date(a.timestamp) - new Date(b.timestamp)); } catch (e) {}
                localStorage.setItem('workoutHistory', JSON.stringify(whArray));
              }
              if (userData.scanResult) localStorage.setItem('scanResult', JSON.stringify(userData.scanResult));
              if (userData.formAnalysis) localStorage.setItem('formAnalysis', JSON.stringify(userData.formAnalysis));
              
              // Update local sync timestamp
              localStorage.setItem('lastSyncTimestamp', remoteLastSync.toString());
              
              console.log('‚úÖ Remote data synced to local storage');
              
              // Trigger a custom event to notify App component to refresh state
              window.dispatchEvent(new CustomEvent('userDataSynced'));
            } else {
              console.log('üì§ Local data is newer, syncing to remote');
              // Push local data to remote if it's newer
              await syncAllDataToRTDB();
            }
          } else {
            console.log('No user document found, creating new one');
            // Create comprehensive initial user document
            await createInitialUserDocument(user);
          }
        } catch (error) {
          if (error.code === 'PERMISSION_DENIED') {
            console.log('Realtime Database access denied - using local storage only');
          } else {
            console.error('Error syncing user data:', error);
          }
        }
      };

      const signUp = async (email, password, displayName) => {
        if (!auth) throw new Error('Firebase Authentication not available');
        
        setAuthError(null);
        
        // Validate password strength
        const passwordValidation = validatePassword(password);
        if (!passwordValidation.isValid) {
          setAuthError(passwordValidation.message);
          throw new Error(passwordValidation.message);
        }
        
        try {
          const result = await auth.createUserWithEmailAndPassword(email, password);
          await result.user.updateProfile({ displayName });
          
          // Create user document in Realtime Database (if available)
          if (db) {
            try {
              await db.ref(`users/${result.user.uid}`).set({
                displayName,
                email,
                createdAt: firebase.database.ServerValue.TIMESTAMP,
                goals: JSON.parse(localStorage.getItem('goals') || '{}'),
                profilePicture: localStorage.getItem('profilePicture') || '',
                notificationsEnabled: JSON.parse(localStorage.getItem('notificationsEnabled') || 'true')
              });
              console.log('‚úÖ User document created in Realtime Database');
            } catch (dbError) {
              console.warn('‚ö†Ô∏è Could not create user document in Realtime Database:', dbError.message);
              // Continue without Realtime Database - user can still use the app
            }
          } else {
            console.log('üì± Account created successfully (local mode)');
          }
          
          return result.user;
        } catch (error) {
          let friendlyMessage = error.message;
          
          // Provide user-friendly error messages
          if (error.code === 'auth/email-already-in-use') {
            friendlyMessage = 'This email is already registered. Try signing in instead.';
          } else if (error.code === 'auth/weak-password') {
            friendlyMessage = 'Password is too weak. Please use at least 6 characters.';
          } else if (error.code === 'auth/invalid-email') {
            friendlyMessage = 'Please enter a valid email address.';
          }
          
          setAuthError(friendlyMessage);
          throw new Error(friendlyMessage);
        }
      };

      const signIn = async (email, password) => {
        if (!auth) throw new Error('Firebase Authentication not available');
        
        setAuthError(null);
        try {
          const result = await auth.signInWithEmailAndPassword(email, password);
          console.log('‚úÖ User signed in successfully');
          return result.user;
        } catch (error) {
          let friendlyMessage = error.message;
          
          // Provide user-friendly error messages
          if (error.code === 'auth/user-not-found') {
            friendlyMessage = 'No account found with this email. Please sign up first.';
          } else if (error.code === 'auth/wrong-password') {
            friendlyMessage = 'Incorrect password. Please try again.';
          } else if (error.code === 'auth/invalid-email') {
            friendlyMessage = 'Please enter a valid email address.';
          } else if (error.code === 'auth/too-many-requests') {
            friendlyMessage = 'Too many failed attempts. Please try again later.';
          }
          
          setAuthError(friendlyMessage);
          throw new Error(friendlyMessage);
        }
      };

      const signOut = async () => {
        if (!auth) return;
        
        try {
          await auth.signOut();
        } catch (error) {
          setAuthError(error.message);
          throw error;
        }
      };

      const resetPassword = async (email) => {
        if (!auth) throw new Error('Firebase Authentication not available');
        
        setAuthError(null);
        try {
          await auth.sendPasswordResetEmail(email);
          return true;
        } catch (error) {
          let friendlyMessage = error.message;
          
          if (error.code === 'auth/user-not-found') {
            friendlyMessage = 'No account found with this email address.';
          } else if (error.code === 'auth/invalid-email') {
            friendlyMessage = 'Please enter a valid email address.';
          }
          
          setAuthError(friendlyMessage);
          throw new Error(friendlyMessage);
        }
      };

      const validatePassword = (password) => {
        const minLength = 8;
        const hasUpperCase = /[A-Z]/.test(password);
        const hasLowerCase = /[a-z]/.test(password);
        const hasNumbers = /\d/.test(password);
        const hasSpecialChar = /[!@#$%^&*(),.?":{}|<>]/.test(password);
        
        const errors = [];
        
        if (password.length < minLength) {
          errors.push(`At least ${minLength} characters`);
        }
        if (!hasUpperCase) {
          errors.push('One uppercase letter');
        }
        if (!hasLowerCase) {
          errors.push('One lowercase letter');
        }
        if (!hasNumbers) {
          errors.push('One number');
        }
        if (!hasSpecialChar) {
          errors.push('One special character (!@#$%^&*)');
        }
        
        return {
          isValid: errors.length === 0,
          message: errors.length > 0 ? `Password must contain: ${errors.join(', ')}` : 'Password is valid',
          errors: errors
        };
      };

      const updateUserData = async (data) => {
        if (!user) {
          console.log('No user signed in');
          return;
        }
        
        if (!db) {
          console.log('Realtime Database not available, data saved locally only');
          return;
        }
        
        try {
          const currentTimestamp = Date.now();

          // Build payload and guard against overwriting valid remote intake with local defaults on fresh devices
          let payload = { ...data };
          if (payload && typeof payload === 'object' && 'dailyIntake' in payload) {
            const localIntake = payload.dailyIntake || {};
            const isLocalDefault = Object.values(localIntake).every(v => Number(v) === 0);
            const localSyncTs = parseInt(localStorage.getItem('lastSyncTimestamp') || '0');
            try {
              const snap = await db.ref(`users/${user.uid}`).once('value');
              const remote = snap.exists() ? snap.val() : {};
              const remoteIntake = remote.dailyIntake || {};
              const remoteHasNonZero = Object.values(remoteIntake).some(v => Number(v) > 0);
              if (localSyncTs === 0 && isLocalDefault && remoteHasNonZero) {
                // Skip overwriting remote with zeros; also avoid bumping timestamps for intake
                delete payload.dailyIntake;
                if ('lastIntakeUpdate' in payload) delete payload.lastIntakeUpdate;
              }
            } catch (cmpErr) {
              console.warn('Safe-guard compare failed, proceeding:', cmpErr);
            }
          }

          if (Object.keys(payload).length === 0) {
            console.log('‚è≠Ô∏è Skipping update to avoid overwriting remote with defaults on fresh device');
            return;
          }

          await db.ref(`users/${user.uid}`).update({
            ...payload,
            updatedAt: currentTimestamp
          });
          
          // Update local sync timestamp
          localStorage.setItem('lastSyncTimestamp', currentTimestamp.toString());
          
          console.log('‚úÖ User data updated in Realtime Database with timestamp:', currentTimestamp);
        } catch (error) {
          console.error('Error updating user data:', error);
          
          // For Realtime Database, if user doesn't exist, create initial document
          try {
            await createInitialUserDocument(user);
            // Then update with the new data
            const currentTimestamp = Date.now();

            let payload = { ...data };
            if (payload && typeof payload === 'object' && 'dailyIntake' in payload) {
              const localIntake = payload.dailyIntake || {};
              const isLocalDefault = Object.values(localIntake).every(v => Number(v) === 0);
              const localSyncTs = parseInt(localStorage.getItem('lastSyncTimestamp') || '0');
              try {
                const snap = await db.ref(`users/${user.uid}`).once('value');
                const remote = snap.exists() ? snap.val() : {};
                const remoteIntake = remote.dailyIntake || {};
                const remoteHasNonZero = Object.values(remoteIntake).some(v => Number(v) > 0);
                if (localSyncTs === 0 && isLocalDefault && remoteHasNonZero) {
                  delete payload.dailyIntake;
                  if ('lastIntakeUpdate' in payload) delete payload.lastIntakeUpdate;
                }
              } catch (cmpErr) {
                console.warn('Safe-guard compare failed, proceeding:', cmpErr);
              }
            }

            if (Object.keys(payload).length === 0) {
              console.log('‚è≠Ô∏è Skipping update to avoid overwriting remote with defaults on fresh device');
              return;
            }

            await db.ref(`users/${user.uid}`).update({
              ...payload,
              updatedAt: currentTimestamp
            });
            localStorage.setItem('lastSyncTimestamp', currentTimestamp.toString());
            console.log('‚úÖ User document created and updated');
          } catch (createError) {
            console.error('Error creating user document:', createError);
          }
        }
      };


      // Debounced auto-sync function to prevent excessive syncing
      let autoSyncTimeout = null;
      const triggerAutoSync = () => {
        if (!user || !db) return;
        
        // Clear existing timeout
        if (autoSyncTimeout) {
          clearTimeout(autoSyncTimeout);
        }
        
        // Set new timeout for 2 seconds
        autoSyncTimeout = setTimeout(async () => {
          try {
            console.log('üîÑ Auto-sync triggered');
            await syncUserData();
          } catch (error) {
            console.error('Auto-sync failed:', error);
          }
        }, 2000);
      };

      // Enhanced localStorage setter with auto-sync trigger and quota management
      const setLocalStorageWithSync = (key, value) => {
        try {
          localStorage.setItem(key, value);
        } catch (error) {
          if (error.name === 'QuotaExceededError') {
            console.warn('localStorage quota exceeded, cleaning up...');
            cleanupLocalStorage();
            try {
              localStorage.setItem(key, value);
            } catch (retryError) {
              console.error('Failed to store data even after cleanup:', retryError);
              // Store only essential data
              if (key.includes('imagePreview')) {
                console.warn('Skipping image storage due to quota limits');
                return;
              }
              throw retryError;
            }
          } else {
            throw error;
          }
        }
        triggerAutoSync();
      };

      // Clean up localStorage to free space
      const cleanupLocalStorage = () => {
        const keysToClean = [
          'pantryChef_imagePreview',
          'menuDecoder_imagePreview',
          'dailyQuote',
          'lastQuoteFetchDate'
        ];
        
        // Remove image previews first (largest items)
        keysToClean.forEach(key => {
          try {
            localStorage.removeItem(key);
            console.log(`Cleaned up localStorage key: ${key}`);
          } catch (e) {
            console.warn(`Failed to remove ${key}:`, e);
          }
        });
        
        // Clean up old cache entries
        Object.keys(localStorage).forEach(key => {
          if (key.startsWith('fitmate-slots-') && key !== `fitmate-slots-${new Date().toISOString().split('T')[0]}`) {
            try {
              localStorage.removeItem(key);
              console.log(`Cleaned up old cache: ${key}`);
            } catch (e) {
              console.warn(`Failed to remove cache ${key}:`, e);
            }
          }
        });
      };

      // Function to compress image for mobile compatibility - Safe mobile approach
      const compressImageForMobile = (base64Image, maxWidth = 200, quality = 0.7) => {
        return new Promise((resolve) => {
          if (!base64Image || !base64Image.startsWith('data:image/')) {
            resolve(base64Image);
            return;
          }
          
          try {
            // First, check if the image is already small enough (under 500KB)
            const base64Length = base64Image.length;
            const estimatedSizeKB = Math.ceil((base64Length * 3) / 4096); // Rough estimate
            
            if (estimatedSizeKB < 500) {
              console.log('üìè Image already small enough:', estimatedSizeKB + 'KB, skipping compression');
              resolve(base64Image);
              return;
            }
            
            console.log('üìè Compressing large image:', estimatedSizeKB + 'KB');
            
            const img = new Image();
            img.onload = () => {
              try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // Calculate new dimensions
                let { width, height } = img;
                if (width > maxWidth) {
                  height = (height * maxWidth) / width;
                  width = maxWidth;
                }
                
                canvas.width = width;
                canvas.height = height;
                
                // Draw and compress
                ctx.drawImage(img, 0, 0, width, height);
                const compressedImage = canvas.toDataURL('image/jpeg', quality);
                
                // Log compression results
                const compressedSizeKB = Math.ceil((compressedImage.length * 3) / 4096);
                console.log('‚úÖ Image compressed:', estimatedSizeKB + 'KB ‚Üí ' + compressedSizeKB + 'KB');
                
                resolve(compressedImage);
              } catch (canvasError) {
                console.warn('Canvas compression failed:', canvasError);
                resolve(base64Image);
              }
            };
            
            img.onerror = () => {
              console.warn('Image load failed for compression');
              resolve(base64Image);
            };
            
            img.src = base64Image;
            
          } catch (error) {
            console.warn('Image compression failed, using original:', error);
            resolve(base64Image);
          }
        });
      };

      // Monitor localStorage usage
      const checkLocalStorageUsage = () => {
        let totalSize = 0;
        const usage = {};
        
        for (let key in localStorage) {
          if (localStorage.hasOwnProperty(key)) {
            const size = localStorage[key].length;
            totalSize += size;
            usage[key] = size;
          }
        }
        
        const totalSizeMB = (totalSize / (1024 * 1024)).toFixed(2);
        console.log(`localStorage usage: ${totalSizeMB}MB`);
        
        // Warn if approaching 5MB limit
        if (totalSize > 4 * 1024 * 1024) {
          console.warn('localStorage approaching quota limit, consider cleanup');
          // Auto-cleanup if very close to limit
          if (totalSize > 4.5 * 1024 * 1024) {
            cleanupLocalStorage();
          }
        }
        
        return { totalSize, totalSizeMB, usage };
      };

      // Check usage periodically
      setInterval(checkLocalStorageUsage, 60000); // Check every minute

      // Real-time listener for cross-device sync
      React.useEffect(() => {
        if (!user || !db) return;
        
        console.log('üîó Setting up real-time sync listener for user:', user.uid);
        
        const userRef = db.ref(`users/${user.uid}`);
        
        const handleDataChange = (snapshot) => {
          if (!snapshot.exists()) return;
          
          const remoteData = snapshot.val();
          const remoteTimestamp = remoteData.updatedAt || 0;
          const localTimestamp = parseInt(localStorage.getItem('lastSyncTimestamp') || '0');
          
          // Only sync if remote data is newer than local
          if (remoteTimestamp > localTimestamp) {
            console.log('üîÑ Real-time sync: Remote data is newer, updating local data');
            
            // Update localStorage silently (without triggering auto-sync)
            if (remoteData.goals) localStorage.setItem('goals', JSON.stringify(remoteData.goals));
            if (remoteData.profilePicture) localStorage.setItem('profilePicture', remoteData.profilePicture);
            if (remoteData.notificationsEnabled !== undefined) localStorage.setItem('notificationsEnabled', JSON.stringify(remoteData.notificationsEnabled));
            if (remoteData.darkMode !== undefined) localStorage.setItem('fitmate-dark-mode', remoteData.darkMode.toString());
            if (remoteData.dailyIntake) localStorage.setItem('dailyIntake', JSON.stringify(remoteData.dailyIntake));
            if (remoteData.recentMeals) localStorage.setItem('recentMeals', JSON.stringify(remoteData.recentMeals));
            if (remoteData.dailyHistory) localStorage.setItem('dailyHistory', JSON.stringify(remoteData.dailyHistory));
            if (remoteData.coachMessages) localStorage.setItem('coachMessages', JSON.stringify(remoteData.coachMessages));
            if (remoteData.habitAIAdvice) localStorage.setItem('habitAIAdvice', remoteData.habitAIAdvice);
            if (remoteData.habits) localStorage.setItem('habits', JSON.stringify(remoteData.habits));
            if (remoteData.mealPlan) localStorage.setItem('mealPlan', JSON.stringify(remoteData.mealPlan));
            if (remoteData.workoutPlan) localStorage.setItem('workoutPlan', JSON.stringify(remoteData.workoutPlan));
            if (remoteData.workoutHistory) {
              const wh = remoteData.workoutHistory;
              const whArray = Array.isArray(wh) ? wh : (wh && typeof wh === 'object' ? Object.values(wh) : []);
              try { whArray.sort((a,b) => new Date(a.timestamp) - new Date(b.timestamp)); } catch (e) {}
              localStorage.setItem('workoutHistory', JSON.stringify(whArray));
            }
            if (remoteData.scanResult) localStorage.setItem('scanResult', JSON.stringify(remoteData.scanResult));
            if (remoteData.formAnalysis) localStorage.setItem('formAnalysis', JSON.stringify(remoteData.formAnalysis));
            
            // Update local sync timestamp
            localStorage.setItem('lastSyncTimestamp', remoteTimestamp.toString());
            
            // Dispatch event to update React components
            window.dispatchEvent(new CustomEvent('userDataSynced'));
            
            console.log('‚úÖ Real-time sync completed');
          }
        };
        
        // Listen for data changes
        userRef.on('value', handleDataChange);
        
        // Cleanup listener on unmount or user change
        return () => {
          console.log('üîå Removing real-time sync listener');
          userRef.off('value', handleDataChange);
        };
      }, [user, db]);

      const syncAllDataToRTDB = async () => {
        if (!user || !db) return;
        
        try {
          const currentTimestamp = Date.now();
          const allLocalData = {
            goals: JSON.parse(localStorage.getItem('goals') || '{}'),
            profilePicture: localStorage.getItem('profilePicture') || '',
            notificationsEnabled: JSON.parse(localStorage.getItem('notificationsEnabled') || 'true'),
            dailyIntake: JSON.parse(localStorage.getItem('dailyIntake') || '{}'),
            recentMeals: JSON.parse(localStorage.getItem('recentMeals') || '[]'),
            dailyHistory: JSON.parse(localStorage.getItem('dailyHistory') || '{}'),
            coachMessages: JSON.parse(localStorage.getItem('coachMessages') || '[]'),
            habitAIAdvice: localStorage.getItem('habitAIAdvice') || '',
            habits: JSON.parse(localStorage.getItem('habits') || '[]'),
            darkMode: JSON.parse(localStorage.getItem('fitmate-dark-mode') || 'false'),
            mealPlan: JSON.parse(localStorage.getItem('mealPlan') || 'null'),
            workoutPlan: JSON.parse(localStorage.getItem('workoutPlan') || 'null'),
            workoutHistory: JSON.parse(localStorage.getItem('workoutHistory') || '[]'),
            scanResult: JSON.parse(localStorage.getItem('scanResult') || 'null'),
            formAnalysis: JSON.parse(localStorage.getItem('formAnalysis') || 'null'),
            updatedAt: currentTimestamp
          };
          
          await db.ref(`users/${user.uid}`).update(allLocalData);
          
          // Update local sync timestamp to match what we just sent
          localStorage.setItem('lastSyncTimestamp', currentTimestamp.toString());
          
          console.log('‚úÖ All local data synced to Realtime Database with timestamp:', currentTimestamp);
        } catch (error) {
          console.error('Error syncing all data to Realtime Database:', error);
          throw error; // Re-throw to handle in calling function
        }
      };

      // Sync daily intake data
      const syncDailyIntake = async (dailyIntake) => {
        if (user && db) {
          try {
            await updateUserData({ 
              dailyIntake,
              lastIntakeUpdate: firebase.database.ServerValue.TIMESTAMP
            });
          } catch (error) {
            console.error('Error syncing daily intake:', error);
          }
        }
      };

      // Sync meals data
      const syncMealsData = async (recentMeals) => {
        if (user && db) {
          try {
            await updateUserData({ 
              recentMeals,
              lastMealsUpdate: firebase.database.ServerValue.TIMESTAMP
            });
          } catch (error) {
            console.error('Error syncing meals data:', error);
          }
        }
      };

      // Sync daily history
      const syncDailyHistory = async (dailyHistory) => {
        if (user && db) {
          try {
            await updateUserData({ 
              dailyHistory,
              lastHistoryUpdate: firebase.database.ServerValue.TIMESTAMP
            });
          } catch (error) {
            console.error('Error syncing daily history:', error);
          }
        }
      };

      // Sync AI-generated content
      const syncAIContent = async (contentType, content) => {
        if (user && db) {
          try {
            await updateUserData({ 
              [contentType]: content,
              [`last${contentType}Update`]: firebase.database.ServerValue.TIMESTAMP
            });
          } catch (error) {
            console.error(`Error syncing ${contentType}:`, error);
          }
        }
      };

      const value = {
        user,
        loading,
        authError,
        signUp,
        signIn,
        signOut,
        resetPassword,
        validatePassword,
        updateUserData,
        syncUserData,
        syncAllDataToRTDB,
        syncDailyIntake,
        syncMealsData,
        syncDailyHistory,
        syncAIContent,
        triggerAutoSync,
        setLocalStorageWithSync,
        setAuthError
      };

      return (
        <AuthContext.Provider value={value}>
          {children}
        </AuthContext.Provider>
      );
    };

    const useAuth = () => {
      const context = React.useContext(AuthContext);
      if (!context) {
        throw new Error('useAuth must be used within an AuthProvider');
      }
      return context;
    };

    // --- Centralized API Configuration ---
    // Edge function endpoint
    const NETLIFY_API_URL = '/api/myapi';
    
    // Removed deprecated Gemini simple config and GEMINI_API_URL (migrated to OpenRouter)
    
    // Use Netlify Edge Function proxy instead of direct OpenRouter API calls
    const OPENROUTER_QWEN_MODEL = 'openai/gpt-4o-mini'; // text-only
    const OPENROUTER_QWEN_VL_MODEL = 'openai/gpt-4o-mini'; // vision
    const getDirectGeminiConfig = () => {
      return {
        url: '/api/myapi',
        headers: {
          'Content-Type': 'application/json'
        }
      };
    };
    
    // PDF Generation Utility
    const generatePDF = (title, content, filename) => {
      const { jsPDF } = window.jspdf;
      const doc = new jsPDF();
      
      // Add title
      doc.setFontSize(18);
      doc.text(title, 20, 20);
      
      // Add content
      doc.setFontSize(12);
      let y = 30;
      
      // Split content into lines to fit page width
      const splitContent = doc.splitTextToSize(content, 170);
      
      // Calculate line height
      const lineHeight = 7;
      
      // Add content with pagination
      for (let i = 0; i < splitContent.length; i++) {
        // Check if we need a new page
        if (y > 280) { // A4 height is about 297mm, leaving margin
          doc.addPage();
          y = 20; // Reset y position for new page
        }
        
        // Add the line
        doc.text(splitContent[i], 20, y);
        y += lineHeight;
      }
      
      // Save the PDF
      doc.save(filename);
    };

    // Enhanced Speech Controller for granular control
    const speechController = {
      isPlaying: false,
      currentUtterance: null,
      activeButton: null,
      currentText: null,
      
      speak: function(text, buttonId) {
        if ('speechSynthesis' in window) {
          // If this button is currently playing, stop it
          if (this.isPlaying && this.activeButton === buttonId) {
            this.stop();
            return 'stop';
          }
          
          // Stop any other playing speech
          if (this.isPlaying) {
            this.stop();
          }
          
          // Start new speech
          this.currentText = text;
          const utterance = new SpeechSynthesisUtterance(text);
          utterance.rate = 0.9;
          
          // Mobile-optimized voice selection
          const voices = window.speechSynthesis.getVoices();
          const preferredVoice = voices.find(voice => 
            voice.lang.startsWith('en') && (voice.name.includes('Google') || voice.name.includes('Microsoft'))
          ) || voices.find(voice => voice.lang.startsWith('en'));
          if (preferredVoice) {
            utterance.voice = preferredVoice;
          }
          
          utterance.onstart = () => {
            this.isPlaying = true;
            this.activeButton = buttonId;
          };
          
          utterance.onend = () => {
            this.isPlaying = false;
            this.currentUtterance = null;
            this.activeButton = null;
            this.currentText = null;
          };
          
          utterance.onerror = (event) => {
            console.error('Speech synthesis error:', event);
            this.stop();
          };
          
          this.currentUtterance = utterance;
          window.speechSynthesis.speak(utterance);
          this.isPlaying = true;
          this.activeButton = buttonId;
          return 'play';
        } else {
          alert('Text-to-speech not supported in this browser');
          return 'error';
        }
      },
      
      stop: function() {
        window.speechSynthesis.cancel();
        this.isPlaying = false;
        this.currentUtterance = null;
        this.activeButton = null;
        this.currentText = null;
      },
      
      isActuallyPlaying: function() {
        return this.isPlaying && window.speechSynthesis.speaking;
      }
    };

    // Simple Text-to-Speech Function (for backward compatibility)
    const speakText = (text) => {
      speechController.speak(text);
    };

    // --- Default Goal Data ---
    const defaultGoals = {
      calories: 2000,
      protein: 120,
      carbs: 250,
      fat: 60,
      activity: 30, // in minutes
      water: 8, // in glasses
    };

    // --- Helper Components ---


    // --- Main App Component ---
    function App() {
      const [screen, setScreen] = useState(() => {
        const savedScreen = localStorage.getItem('fitmate-current-screen');
        return savedScreen || 'dashboard';
      }); // 'dashboard', 'scan', 'profile', 'planner', 'workout', 'coach', 'progress'

      // --- Clean Theme State Management ---
      const [isDarkMode, setIsDarkMode] = useState(() => {
        const saved = localStorage.getItem('fitmate-dark-mode');
        return saved === 'true';
      });

      // --- Coach and Progress State Management ---
      const [coachMessages, setCoachMessages] = useState(() => {
        const savedMessages = localStorage.getItem('coachMessages');
        return savedMessages ? JSON.parse(savedMessages) : [{ text: "Hello! I'm your AI Health Coach. Ask me anything about your nutrition or meals.", sender: 'ai' }];
      });
      const [habitAIAdvice, setHabitAIAdvice] = useState(() => {
        const savedAdvice = localStorage.getItem('habitAIAdvice');
        return savedAdvice || '';
      });
      const [isLoadingAdvice, setIsLoadingAdvice] = useState(false);

      // Add these new AI states:
      const [scanResult, setScanResult] = useState(() => {
        const saved = localStorage.getItem('scanResult');
        return saved ? JSON.parse(saved) : null;
      });
      const [scanLoading, setScanLoading] = useState(false);
      const [scanError, setScanError] = useState(null);

      const [mealPlan, setMealPlan] = useState(() => {
        const saved = localStorage.getItem('mealPlan');
        return saved ? JSON.parse(saved) : null;
      });
      const [mealPlanLoading, setMealPlanLoading] = useState(false);
      const [mealPlanError, setMealPlanError] = useState(null);

      const [workoutPlan, setWorkoutPlan] = useState(() => {
        const saved = localStorage.getItem('workoutPlan');
        return saved ? JSON.parse(saved) : null;
      });
      const [workoutPlanLoading, setWorkoutPlanLoading] = useState(false);
      const [workoutPlanError, setWorkoutPlanError] = useState(null);

      const [formAnalysis, setFormAnalysis] = useState(() => {
        const saved = localStorage.getItem('formAnalysis');
        return saved ? JSON.parse(saved) : null;
      });
      const [formAnalysisLoading, setFormAnalysisLoading] = useState(false);
      const [formAnalysisError, setFormAnalysisError] = useState(null);

      useEffect(() => {
        if (isDarkMode) {
          document.documentElement.classList.add('dark');
        } else {
          document.documentElement.classList.remove('dark');
        }
        localStorage.setItem('fitmate-dark-mode', isDarkMode.toString());
        
        // Sync dark mode preference to Firebase
        if (user) {
          updateUserData({ darkMode: isDarkMode });
        }
      }, [isDarkMode, user]);

      useEffect(() => {
        if ('Notification' in window && Notification.permission === 'default') {
          Notification.requestPermission();
        }
      }, []);

      // Persist current screen state
      useEffect(() => {
        localStorage.setItem('fitmate-current-screen', screen);
      }, [screen]);

      // Listen for userDataSynced event to refresh React state
      useEffect(() => {
        const handleUserDataSynced = () => {
          // Refresh all React states from localStorage after sync
          const savedGoals = localStorage.getItem('goals');
          if (savedGoals) setGoals(JSON.parse(savedGoals));
          
          const savedIntake = localStorage.getItem('dailyIntake');
          if (savedIntake) setDailyIntake(JSON.parse(savedIntake));
          
          const savedMeals = localStorage.getItem('recentMeals');
          if (savedMeals) setRecentMeals(JSON.parse(savedMeals));
          
          const savedHistory = localStorage.getItem('dailyHistory');
          if (savedHistory) setDailyHistory(JSON.parse(savedHistory));
          
          console.log('‚úÖ React state refreshed after sync');
        };
        
        window.addEventListener('userDataSynced', handleUserDataSynced);
        
        return () => {
          window.removeEventListener('userDataSynced', handleUserDataSynced);
        };
      }, []);

      const toggleDarkMode = () => {
        setIsDarkMode(prev => !prev);
      };

      // --- State Initialization from localStorage ---
      const [goals, setGoals] = useState(() => {
        const savedGoals = localStorage.getItem('goals');
        return savedGoals ? JSON.parse(savedGoals) : defaultGoals;
      });

      const [dailyIntake, setDailyIntake] = useState(() => {
        const savedIntake = localStorage.getItem('dailyIntake');
        return savedIntake ? JSON.parse(savedIntake) : { calories: 0, protein: 0, carbs: 0, fat: 0, activity: 0, water: 0 };
      });

      const [recentMeals, setRecentMeals] = useState(() => {
        const savedMeals = localStorage.getItem('recentMeals');
        return savedMeals ? JSON.parse(savedMeals) : [];
      });

      const [dailyHistory, setDailyHistory] = useState(() => {
        const savedHistory = localStorage.getItem('dailyHistory');
        return savedHistory ? JSON.parse(savedHistory) : {};
      });

      // --- Data Archiving Logic ---
      useEffect(() => {
        const lastSavedDate = localStorage.getItem('lastSavedDate');
        const today = new Date().toISOString().split('T')[0];

        if (lastSavedDate && lastSavedDate !== today) {
          const oldIntake = JSON.parse(localStorage.getItem('dailyIntake'));
          const oldMeals = JSON.parse(localStorage.getItem('recentMeals'));
          const savedGoals = JSON.parse(localStorage.getItem('goals')) || defaultGoals;

          const calorieScore = Math.max(0, 100 - Math.abs(oldIntake.calories - savedGoals.calories) / savedGoals.calories * 100);
          const activityScore = Math.min(100, (oldIntake.activity / savedGoals.activity) * 100);
          const waterScore = Math.min(100, (oldIntake.water / savedGoals.water) * 100);
          const finalScore = Math.round((calorieScore * 0.5) + (activityScore * 0.3) + (waterScore * 0.2));

          setDailyHistory(prevHistory => ({
            ...prevHistory,
            [lastSavedDate]: {
              intake: oldIntake,
              meals: oldMeals,
              score: finalScore,
            }
          }));

          // Reset for the new day
          setDailyIntake({ calories: 0, protein: 0, carbs: 0, fat: 0, activity: 0, water: 0 });
          setRecentMeals([]);
        }

        localStorage.setItem('lastSavedDate', today);
      }, []);

      // --- Enhanced Data Persistence with Firebase Sync ---
      const { user, updateUserData, syncDailyIntake, syncMealsData, syncDailyHistory, syncAIContent } = useAuth();
      const isRemoteSyncRef = useRef(false);
      // Track initial state to avoid overwriting remote with defaults
      const hadDailyIntakeAtStartRef = useRef(!!localStorage.getItem('dailyIntake'));
      const initialSyncCompletedRef = useRef(false);
      const isDefaultIntake = (di) => !di || (
        Number(di.calories) === 0 &&
        Number(di.protein) === 0 &&
        Number(di.carbs) === 0 &&
        Number(di.fat) === 0 &&
        Number(di.activity) === 0 &&
        Number(di.water) === 0
      );

      // Realtime listener to reflect remote changes into UI/localStorage
      useEffect(() => {
        if (!user || !db) return;
        const userRef = db.ref(`users/${user.uid}`);
        const handle = (snapshot) => {
          const userData = snapshot.val();
          if (!userData) return;

          // Update localStorage from remote
          if (userData.goals) localStorage.setItem('goals', JSON.stringify(userData.goals));
          if (userData.profilePicture) localStorage.setItem('profilePicture', userData.profilePicture);
          if (userData.notificationsEnabled !== undefined) localStorage.setItem('notificationsEnabled', JSON.stringify(userData.notificationsEnabled));
          if (userData.darkMode !== undefined) localStorage.setItem('fitmate-dark-mode', userData.darkMode.toString());
          if (userData.dailyIntake) localStorage.setItem('dailyIntake', JSON.stringify(userData.dailyIntake));
          if (userData.recentMeals) localStorage.setItem('recentMeals', JSON.stringify(userData.recentMeals));
          if (userData.dailyHistory) localStorage.setItem('dailyHistory', JSON.stringify(userData.dailyHistory));
          if (userData.coachMessages) localStorage.setItem('coachMessages', JSON.stringify(userData.coachMessages));
          if (userData.habitAIAdvice) localStorage.setItem('habitAIAdvice', userData.habitAIAdvice);
          if (userData.habits) localStorage.setItem('habits', JSON.stringify(userData.habits));
          if (userData.mealPlan) localStorage.setItem('mealPlan', JSON.stringify(userData.mealPlan));
          if (userData.workoutPlan) localStorage.setItem('workoutPlan', JSON.stringify(userData.workoutPlan));
          if (userData.scanResult) localStorage.setItem('scanResult', JSON.stringify(userData.scanResult));
          if (userData.formAnalysis) localStorage.setItem('formAnalysis', JSON.stringify(userData.formAnalysis));

          // Prevent feedback loop: mark update as remote, then refresh UI
          isRemoteSyncRef.current = true;
          window.dispatchEvent(new CustomEvent('userDataSynced'));
          setTimeout(() => { isRemoteSyncRef.current = false; }, 300);
        };

        userRef.on('value', handle);
        return () => userRef.off('value', handle);
      }, [user]);
      
      useEffect(() => { 
        localStorage.setItem('goals', JSON.stringify(goals));
        if (user && !isRemoteSyncRef.current) updateUserData({ goals });
      }, [goals, user, updateUserData]);
      
      useEffect(() => { 
        localStorage.setItem('dailyIntake', JSON.stringify(dailyIntake));
        if (user && !isRemoteSyncRef.current) {
          // Avoid pushing default/zero intake on fresh sessions before initial remote sync
          if (!initialSyncCompletedRef.current && !hadDailyIntakeAtStartRef.current && isDefaultIntake(dailyIntake)) {
            console.log('‚è∏Ô∏è Skipping sync of default dailyIntake before initial remote sync');
          } else {
            syncDailyIntake(dailyIntake);
          }
        }
      }, [dailyIntake, user, syncDailyIntake]);

      // Mark when initial remote sync completes to allow subsequent updates
      useEffect(() => {
        const onSynced = () => {
          initialSyncCompletedRef.current = true;
        };
        window.addEventListener('userDataSynced', onSynced);
        return () => window.removeEventListener('userDataSynced', onSynced);
      }, []);
      
      useEffect(() => { 
        localStorage.setItem('recentMeals', JSON.stringify(recentMeals));
        if (user && !isRemoteSyncRef.current) syncMealsData(recentMeals);
      }, [recentMeals, user, syncMealsData]);
      
      useEffect(() => { 
        localStorage.setItem('dailyHistory', JSON.stringify(dailyHistory));
        if (user && !isRemoteSyncRef.current) syncDailyHistory(dailyHistory);
      }, [dailyHistory, user, syncDailyHistory]);
      
      useEffect(() => { 
        localStorage.setItem('coachMessages', JSON.stringify(coachMessages));
        if (user) updateUserData({ coachMessages });
      }, [coachMessages, user, updateUserData]);
      
      useEffect(() => { 
        localStorage.setItem('habitAIAdvice', habitAIAdvice);
        if (user) updateUserData({ habitAIAdvice });
      }, [habitAIAdvice, user, updateUserData]);
      
      // --- AI State Persistence with Firebase Sync ---
      useEffect(() => {
        if (scanResult) {
          localStorage.setItem('scanResult', JSON.stringify(scanResult));
          if (user) syncAIContent('scanResult', scanResult);
        }
      }, [scanResult, user, syncAIContent]);
      
      useEffect(() => {
        if (mealPlan) {
          localStorage.setItem('mealPlan', JSON.stringify(mealPlan));
          if (user) syncAIContent('mealPlan', mealPlan);
        }
      }, [mealPlan, user, syncAIContent]);
      
      useEffect(() => {
        if (workoutPlan) {
          localStorage.setItem('workoutPlan', JSON.stringify(workoutPlan));
          if (user) syncAIContent('workoutPlan', workoutPlan);
        }
      }, [workoutPlan, user, syncAIContent]);
      
      useEffect(() => {
        if (formAnalysis) {
          localStorage.setItem('formAnalysis', JSON.stringify(formAnalysis));
          if (user) syncAIContent('formAnalysis', formAnalysis);
        }
      }, [formAnalysis, user, syncAIContent]);

      // Function to compress image to target size (in KB)
      const compressImageToSize = (base64Image, targetKB, quality = 0.7, maxWidth = 400) => {
        return new Promise((resolve) => {
          if (!base64Image || !base64Image.startsWith('data:image/')) {
            resolve(base64Image);
            return;
          }
          
          const img = new Image();
          img.onload = function() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // Calculate dimensions to fit within maxWidth while maintaining aspect ratio
            let width = img.width;
            let height = img.height;
            
            if (width > maxWidth) {
              height = (height * maxWidth) / width;
              width = maxWidth;
            }
            
            canvas.width = width;
            canvas.height = height;
            
            // Draw image with quality settings
            ctx.imageSmoothingQuality = 'medium';
            ctx.drawImage(img, 0, 0, width, height);
            
            // Function to compress with quality adjustment
            const compressWithQuality = (currentQuality) => {
              try {
                const compressed = canvas.toDataURL('image/jpeg', currentQuality);
                const sizeKB = Math.round(compressed.length / 1024);
                
                if (sizeKB <= targetKB || currentQuality <= 0.3) {
                  resolve(compressed);
                } else {
                  // Reduce quality and try again
                  setTimeout(() => compressWithQuality(currentQuality - 0.1), 10);
                }
              } catch (error) {
                console.warn('Compression error, using original:', error);
                resolve(base64Image);
              }
            };
            
            // Start compression with initial quality
            compressWithQuality(quality);
          };
          
          img.onerror = () => {
            console.warn('Image loading failed, using original');
            resolve(base64Image);
          };
          
          img.src = base64Image;
        });
      };

      // Function to add a new meal to the log - Mobile-optimized crash-resistant version
      const handleLogMeal = async (mealData) => {
        console.log('üìù Logging meal data (mobile-safe):', mealData);
        
        try {
          // Extract nutritional values with fallbacks
          const calories = Number(mealData.calories) || Number(mealData.total_calories) || 0;
          const protein = Number(mealData.protein) || Number(mealData.total_protein) || 0;
          const carbs = Number(mealData.carbs) || Number(mealData.total_carbs) || 0;
          const fat = Number(mealData.fat) || Number(mealData.total_fat) || 0;
          
          // Generate unique meal ID
          const mealId = Date.now();
          
          // Universal image handling - always use original image for both desktop and mobile
          let processedImage = mealData.image || 'https://placehold.co/100x100/cccccc/333333?text=Meal';
          
          if (mealData.image && mealData.image.startsWith('data:image/')) {
            // Client-side compression: Compress image to ~100KB before processing
            try {
              const compressedImage = await compressImageToSize(mealData.image, 100); // Target 100KB
              processedImage = compressedImage;
              console.log('‚úÖ Image compressed for mobile:', Math.round(compressedImage.length / 1024) + 'KB');
            } catch (error) {
              console.warn('Image compression failed, using original:', error);
              processedImage = mealData.image; // Fallback to original
            }
          }
          
          const newMeal = {
            id: mealId,
            name: mealData.name || mealData.food_name || 'Scanned Meal',
            calories: calories,
            image: processedImage,
            mood: mealData.mood || 'Neutral',
          };
          
          // Batch state updates with proper error boundaries
          setTimeout(() => {
            try {
              // Update daily intake
              setDailyIntake(prevIntake => ({
                ...prevIntake,
                calories: prevIntake.calories + calories,
                protein: prevIntake.protein + protein,
                carbs: prevIntake.carbs + carbs,
                fat: prevIntake.fat + fat,
              }));
              
              // Add to recent meals
              setRecentMeals(prevMeals => [newMeal, ...prevMeals.slice(0, 9)]); // Limit to 10 items
              
              console.log('üíæ Meal saved successfully:', newMeal);
              
              // Navigate to dashboard with safety delay
              setTimeout(() => {
                try {
                  setScreen('dashboard');
                } catch (navError) {
                  console.error('Navigation error:', navError);
                  // Fallback: reload the page if navigation fails
                  window.location.reload();
                }
              }, 200);
              
            } catch (stateError) {
              console.error('State update error:', stateError);
              // Emergency fallback: reload to recover from state corruption
              window.location.reload();
            }
          }, 50);
          
        } catch (mainError) {
          console.error('Critical error in handleLogMeal:', mainError);
          // Ultimate fallback: reload the entire application
          window.location.reload();
        }
      };

      // Function to log daily activity
      const handleLogActivity = (activity) => {
        const updatedIntake = {
          ...dailyIntake,
          activity: dailyIntake.activity + (activity.minutes || 0),
        };
        setDailyIntake(updatedIntake);
        
        // Sync to Firebase immediately
        if (user) {
          syncDailyIntake(updatedIntake);
          // Dispatch event to refresh UI from localStorage
          setTimeout(() => {
            window.dispatchEvent(new CustomEvent('userDataSynced'));
          }, 100);
        }
      };

      const handleLogWater = () => {
        const updatedIntake = {
          ...dailyIntake,
          water: dailyIntake.water + 1,
        };
        setDailyIntake(updatedIntake);
        
        // Sync to Firebase immediately
        if (user) {
          syncDailyIntake(updatedIntake);
          // Dispatch event to refresh UI from localStorage
          setTimeout(() => {
            window.dispatchEvent(new CustomEvent('userDataSynced'));
          }, 100);
        }
      };

      // Function to render the current screen based on state
      const renderScreen = () => {
        switch (screen) {
          case 'dashboard': return <Dashboard dailyIntake={dailyIntake} goals={goals} recentMeals={recentMeals} onLogActivity={handleLogActivity} onLogWater={handleLogWater} />;
          case 'scan': return <Scan 
            onLogMeal={handleLogMeal}
          />;
          case 'profile': return <Profile isDarkMode={isDarkMode} toggleDarkMode={toggleDarkMode} goals={goals} setGoals={setGoals} setDailyIntake={setDailyIntake} setRecentMeals={setRecentMeals} setDailyHistory={setDailyHistory} setScreen={setScreen} />;
          case 'planner': return <MealPlanner 
            goals={goals} 
            mealPlan={mealPlan}
            setMealPlan={setMealPlan}
            isLoading={mealPlanLoading}
            setIsLoading={setMealPlanLoading}
            error={mealPlanError}
            setError={setMealPlanError}
          />;
          case 'workout': return <WorkoutPlanner 
            workoutPlan={workoutPlan}
            setWorkoutPlan={setWorkoutPlan}
            isLoading={workoutPlanLoading}
            setIsLoading={setWorkoutPlanLoading}
            error={workoutPlanError}
            setError={setWorkoutPlanError}
          />;
          case 'coach': return <Coach 
            dailyIntake={dailyIntake} 
            recentMeals={recentMeals} 
            goals={goals}
            messages={coachMessages}
            setMessages={setCoachMessages}
            isDarkMode={isDarkMode}
          />;
          case 'progress': return <Progress 
            dailyHistory={dailyHistory} 
            goals={goals} 
            dailyIntake={dailyIntake}
            habitAIAdvice={habitAIAdvice}
            setHabitAIAdvice={setHabitAIAdvice}
            isLoadingAdvice={isLoadingAdvice}
            setIsLoadingAdvice={setIsLoadingAdvice}
          />;
          default: return <Dashboard dailyIntake={dailyIntake} goals={goals} recentMeals={recentMeals} onLogActivity={handleLogActivity} onLogWater={handleLogWater} />;
        }
      };

      return (
        <div className="bg-gray-50 dark:bg-gray-900 min-h-screen font-sans flex flex-col">
          <main className="flex-grow">
            {renderScreen()}
          </main>
          <BottomNavBar screen={screen} setScreen={setScreen} />
        </div>
      );
    }

    // --- Screens ---

    // Dashboard Screen Component
    const Dashboard = ({ dailyIntake, recentMeals, goals, onLogActivity, onLogWater }) => {
      const rawCalorieProgress = goals.calories > 0 ? (Number(dailyIntake.calories) / Number(goals.calories)) * 100 : 0;
      const calorieProgress = Math.min(100, Math.max(0, isFinite(rawCalorieProgress) ? rawCalorieProgress : 0));
      const [quote, setQuote] = useState('');
      const { setLocalStorageWithSync } = useAuth();

      // Fetch daily motivational quote
      useEffect(() => {
        const fetchQuote = async () => {
          const today = new Date().toISOString().split('T')[0];
          const lastFetchDate = localStorage.getItem('lastQuoteFetchDate');
          const savedQuote = localStorage.getItem('dailyQuote');

          if (lastFetchDate === today && savedQuote) {
            setQuote(savedQuote);
            return;
          }

          const prompt = "Give me a short, powerful motivational quote for fitness. Respond with only the quote itself, no extra text or quotation marks.";

          try {
            const payload = {
              model: OPENROUTER_QWEN_MODEL,
              messages: [
                { role: 'user', content: prompt }
              ]
            };

            const response = await fetch(getDirectGeminiConfig().url, {
              method: 'POST',
              headers: getDirectGeminiConfig().headers,
              body: JSON.stringify(payload),
              signal: AbortSignal.timeout(25000) // 25 second timeout
            });

            if (!response.ok) throw new Error('Failed to fetch quote');

            const result = await response.json();
            const newQuote = (result.choices?.[0]?.message?.content || '').trim();
            setQuote(newQuote);
            setLocalStorageWithSync('dailyQuote', newQuote);
            setLocalStorageWithSync('lastQuoteFetchDate', today);
          } catch (error) {
            console.error("Failed to fetch daily quote:", error);
            setQuote("The only bad workout is the one that didn't happen."); // Fallback quote
          }
        };

        fetchQuote();
      }, []);

      // Calculate Health Score with Enhanced Workout Integration
      const calculateHealthScore = () => {
        if (!dailyIntake) return 0;
        
        // Base scores
        const calorieScore = Math.max(0, 100 - Math.abs(dailyIntake.calories - goals.calories) / goals.calories * 100);
        const activityScore = Math.min(100, (dailyIntake.activity / goals.activity) * 100);
        const waterScore = Math.min(100, (dailyIntake.water / goals.water) * 100);
        
        // Enhanced workout quality score
        let workoutHistory;
        try {
          workoutHistory = JSON.parse(localStorage.getItem('workoutHistory') || '[]');
          // Ensure it's an array
          if (!Array.isArray(workoutHistory)) {
            workoutHistory = [];
            localStorage.setItem('workoutHistory', '[]');
          }
        } catch (error) {
          console.warn('Error parsing workoutHistory, resetting to empty array:', error);
          workoutHistory = [];
          localStorage.setItem('workoutHistory', '[]');
        }
        const today = new Date().toDateString();
        const todaysWorkouts = workoutHistory.filter(w => new Date(w.timestamp).toDateString() === today);
        
        let workoutQualityScore = 0;
        if (todaysWorkouts.length > 0) {
          const avgCompletionRate = todaysWorkouts.reduce((sum, w) => sum + w.completionRate, 0) / todaysWorkouts.length;
          const totalWorkoutTime = todaysWorkouts.reduce((sum, w) => sum + w.duration, 0);
          
          // Bonus for structured workouts vs just activity minutes
          const structuredWorkoutBonus = todaysWorkouts.length * 10; // 10 points per completed workout
          const completionBonus = avgCompletionRate > 80 ? 20 : avgCompletionRate > 60 ? 10 : 0;
          const consistencyBonus = totalWorkoutTime >= 30 ? 15 : totalWorkoutTime >= 15 ? 10 : 5;
          
          workoutQualityScore = Math.min(100, structuredWorkoutBonus + completionBonus + consistencyBonus);
        }
        
        // Enhanced calculation: workout can replace activity but not vice versa
        // Max combined workout + activity = 45 points (20% workout + 25% activity)
        const workoutPoints = workoutQualityScore * 0.2; // Max 20 points
        const activityPoints = activityScore * 0.25; // Max 25 points
        const combinedActivityScore = Math.min(45, workoutPoints + activityPoints); // Cap at 45 points
        
        const baseScore = (calorieScore * 0.4) + (waterScore * 0.15);
        const enhancedScore = baseScore + combinedActivityScore;
        
        return Math.round(Math.min(100, enhancedScore));
      };

      const healthScore = calculateHealthScore();

      return (
        <div className="p-6 pb-24">
          <header className="mb-6 bg-white dark:bg-gray-800 p-4 rounded-2xl shadow-md">
            <div className="flex items-center">
              <svg className="w-10 h-10 mr-3 text-pink-500" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M12 2C6.48 2 2 6.48 2 12C2 17.52 6.48 22 12 22C17.52 22 22 17.52 22 12C22 6.48 17.52 2 12 2ZM16.6 13.2L14.4 15.4C13.6 16.2 12.4 16.2 11.6 15.4L7.4 11.2C6.6 10.4 6.6 9.2 7.4 8.4L9.6 6.2C10.4 5.4 11.6 5.4 12.4 6.2L16.6 10.4C17.4 11.2 17.4 12.4 16.6 13.2Z" fill="currentColor"/>
              </svg>
              <div>
                <h1 className="text-3xl font-bold text-gray-800 dark:text-gray-200">FitnessMate</h1>
                <p className="text-gray-500 dark:text-gray-400">AI That Fuels Your Health Journey</p>
              </div>
            </div>
            {quote && <p className="text-gray-600 dark:text-gray-300 italic mt-2 text-center bg-gray-100 dark:bg-gray-700 p-2 rounded-lg">"{quote}"</p>}
          </header>

          <div className="grid md:grid-cols-2 gap-6 mb-6">
            {/* Health Score Card - Fixed light gradient */}
            <div className="bg-white dark:bg-gray-800 p-6 rounded-2xl shadow-md text-center h-full flex flex-col">
              <h2 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-4">Health Score</h2>
              <div className="flex-grow flex flex-col justify-center">
                <div className="relative w-32 h-32 mx-auto">
                  <svg className="w-full h-full" viewBox="0 0 36 36">
                    <path className="text-gray-200 dark:text-gray-700" strokeWidth="3" fill="none" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831" />
                    <path className="text-green-500" strokeWidth="3" strokeLinecap="round" fill="none" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831" strokeDasharray={`${healthScore}, 100`} />
                  </svg>
                  <div className="absolute inset-0 flex items-center justify-center">
                    <span className="text-3xl font-bold text-green-500">{healthScore}</span>
                  </div>
                </div>
                <p className="text-gray-600 dark:text-gray-400 mt-2">Today's Score / 100</p>
                <div className="text-xs text-gray-500 dark:text-gray-400 mt-2 space-y-1">
                  <p><span className="font-bold text-pink-500">40%</span> Nutrition</p>
                  <p><span className="font-bold text-purple-500">45%</span> Activity + Workouts (max)</p>
                  <p><span className="font-bold text-blue-500">15%</span> Hydration</p>
                </div>
              </div>
            </div>

            {/* Activity & Water Tracker Card - Fixed light gradient */}
            <div className="bg-white dark:bg-gray-800 p-4 sm:p-6 rounded-2xl shadow-md h-full flex flex-col">
              <h2 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-4 text-center">Activity & Hydration</h2>
              <div className="flex-grow flex flex-col justify-center space-y-4">
                <ActivityTimer onLogActivity={onLogActivity} />
                <WaterTracker onLogWater={onLogWater} dailyIntake={dailyIntake} goals={goals} />
              </div>
            </div>
          </div>

          <div className="bg-gradient-to-br from-cyan-400 to-pink-500 rounded-2xl p-6 mb-6 text-white shadow-lg">
            <p className="font-semibold">Calories</p>
            <div className="flex items-end my-2">
              <p className="text-5xl font-bold">{Math.round(dailyIntake.calories)}</p>
              <p className="ml-2 mb-1">/ {goals.calories} kcal</p>
            </div>
            <div className="w-full bg-white/30 rounded-full h-2.5 overflow-hidden">
              <div className="bg-white h-2.5 rounded-full max-w-full" style={{ width: `${calorieProgress}%` }}></div>
            </div>
          </div>

          <div className="grid grid-cols-3 gap-4 mb-6">
            <MacroCard title="Protein" value={dailyIntake.protein} goal={goals.protein} unit="g" color="text-blue-500" />
            <MacroCard title="Carbs" value={dailyIntake.carbs} goal={goals.carbs} unit="g" color="text-yellow-500" />
            <MacroCard title="Fat" value={dailyIntake.fat} goal={goals.fat} unit="g" color="text-red-500" />
          </div>

          <div>
            <h2 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-4">Recent Meals</h2>
            {recentMeals.length > 0 ? (
              <div className="space-y-3">
                {recentMeals.map((meal) => (
                  <MealCard key={meal.id} meal={meal} />
                ))}
              </div>
            ) : (
              <div className="text-center text-gray-500 dark:text-gray-400 bg-white dark:bg-gray-800 p-6 rounded-2xl shadow-md">
                <p>No meals logged yet.</p>
                <p>Tap the 'Cal' button to scan your first meal!</p>
              </div>
            )}
          </div>
        </div>
      );
    };

    // Profile Screen Component
    const Profile = ({ isDarkMode, toggleDarkMode, goals, setGoals, setDailyIntake, setRecentMeals, setDailyHistory, setScreen }) => {
      const { user, signOut, updateUserData, syncAllDataToRTDB } = useAuth();
      const [profilePicture, setProfilePicture] = useState(() => {
        const saved = localStorage.getItem('profilePicture');
        return saved || "https://placehold.co/100x100/EAB543/ffffff?text=User";
      });
      const [isGeneratingAvatar, setIsGeneratingAvatar] = useState(false);
      const [isSyncing, setIsSyncing] = useState(false);
      const [syncStatus, setSyncStatus] = useState(null); // 'success', 'error', 'warning'
      const [lastSyncTime, setLastSyncTime] = useState(null);
      const [notificationsEnabled, setNotificationsEnabled] = useState(() => {
        const saved = localStorage.getItem('notificationsEnabled');
        return saved ? JSON.parse(saved) : true;
      });
      const [backgroundMusicEnabled, setBackgroundMusicEnabled] = useState(() => {
        const saved = localStorage.getItem('backgroundMusicEnabled');
        return saved ? JSON.parse(saved) : false;
      });
      const [showPrivacyModal, setShowPrivacyModal] = useState(false);
      const [showSupportModal, setShowSupportModal] = useState(false);
      const [showAccountModal, setShowAccountModal] = useState(false);
      const [supportForm, setSupportForm] = useState({
        fullName: '',
        email: '',
        subject: '',
        message: ''
      });
      const [isSubmittingSupport, setIsSubmittingSupport] = useState(false);
      const [supportSubmissionStatus, setSupportSubmissionStatus] = useState(null);
      const [showBookingModal, setShowBookingModal] = useState(false);
  const [bookingStep, setBookingStep] = useState(1);
  const [selectedDate, setSelectedDate] = useState(null);
  const [selectedTimeSlot, setSelectedTimeSlot] = useState(null);
  const [selectedPackage, setSelectedPackage] = useState(null);
  const [currentMonth, setCurrentMonth] = useState('');
  const [currentYear, setCurrentYear] = useState(2023);
  const [calendarDays, setCalendarDays] = useState([]);
  const [availableTimeSlots, setAvailableTimeSlots] = useState([]);
  
  // Booking History State
  const [bookingHistory, setBookingHistory] = useState([]);
  const [isLoadingBookings, setIsLoadingBookings] = useState(false);
  const [showBookingHistory, setShowBookingHistory] = useState(false);
  const [showMeetingModal, setShowMeetingModal] = useState(false);
  const [currentMeetingLink, setCurrentMeetingLink] = useState('');
  const [bookedSlots, setBookedSlots] = useState([]);
  const [slotsCache, setSlotsCache] = useState({});
  const [isLoadingSlots, setIsLoadingSlots] = useState(false);
  const [confirmationMessage, setConfirmationMessage] = useState(null);
  const [debounceTimer, setDebounceTimer] = useState(null);
  const [abortController, setAbortController] = useState(null);


      const fileInputRef = useRef(null);

      // Save profile picture to localStorage whenever it changes
      useEffect(() => {
        localStorage.setItem('profilePicture', profilePicture);
      }, [profilePicture]);

      // Sync profile picture to Firebase when user is authenticated
      useEffect(() => {
        if (user && profilePicture) {
          updateUserData({ profilePicture });
        }
      }, [profilePicture, user]);

      // Listen for remote data sync and update profile picture
      useEffect(() => {
        const handleUserDataSync = () => {
          const syncedProfilePicture = localStorage.getItem('profilePicture');
          if (syncedProfilePicture && syncedProfilePicture !== profilePicture) {
            setProfilePicture(syncedProfilePicture);
          }
        };

        window.addEventListener('userDataSynced', handleUserDataSync);
        return () => window.removeEventListener('userDataSynced', handleUserDataSync);
      }, [profilePicture]);

      // Load profile picture from localStorage when user logs in
      useEffect(() => {
        if (user) {
          const savedProfilePicture = localStorage.getItem('profilePicture');
          if (savedProfilePicture && savedProfilePicture !== profilePicture) {
            setProfilePicture(savedProfilePicture);
          }
        }
      }, [user]);

      // Save notifications setting to localStorage
      useEffect(() => {
        localStorage.setItem('notificationsEnabled', JSON.stringify(notificationsEnabled));
      }, [notificationsEnabled]);

      // Save background music setting to localStorage
      useEffect(() => {
        localStorage.setItem('backgroundMusicEnabled', JSON.stringify(backgroundMusicEnabled));
      }, [backgroundMusicEnabled]);

      // Initialize background music on component mount
      useEffect(() => {
        const audio = document.getElementById('background-music');
        if (audio && backgroundMusicEnabled) {
          // Set volume to a reasonable level
          audio.volume = 0.3;
          audio.play().catch(e => console.log('Audio autoplay failed:', e));
        }
      }, []);

      // Control background music when setting changes
      useEffect(() => {
        const audio = document.getElementById('background-music');
        if (audio) {
          audio.volume = 0.3;
          if (backgroundMusicEnabled) {
            // Try to play, but don't force it on mobile without user interaction
            audio.play().catch(e => {
              console.log('Audio autoplay prevented:', e);
              // On mobile, we'll wait for user interaction instead of showing alert here
            });
          } else {
            audio.pause();
          }
        }
      }, [backgroundMusicEnabled]);

      const toggleNotifications = () => {
        setNotificationsEnabled(prev => {
          const newValue = !prev;
          // Update Firebase if user is authenticated
          if (user) {
            updateUserData({ notificationsEnabled: newValue });
          }
          // Show user feedback
          if (newValue) {
            alert('‚úÖ Notifications enabled! You\'ll receive fitness reminders and updates.');
          } else {
            alert('üîï Notifications disabled. You won\'t receive any alerts.');
          }
          return newValue;
        });      };

      const toggleBackgroundMusic = () => {
        setBackgroundMusicEnabled(prev => {
          const newValue = !prev;
          // Update Firebase if user is authenticated
          if (user) {
            updateUserData({ backgroundMusicEnabled: newValue });
          }
          // Control background music
          const audio = document.getElementById('background-music');
          if (audio) {
            if (newValue) {
              // For mobile browsers, we need user interaction to play audio
              audio.play().catch(e => {
                console.log('Audio play failed (likely due to autoplay policy):', e);
                // Show user-friendly message for mobile
                if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
                  alert('üéµ Tap anywhere on the screen to start background music!');
                  // Add click listener to start music on next user interaction
                  const startMusicOnClick = () => {
                    audio.play().catch(e => console.log('Audio play still failed:', e));
                    document.removeEventListener('click', startMusicOnClick);
                    document.removeEventListener('touchstart', startMusicOnClick);
                  };
                  document.addEventListener('click', startMusicOnClick, { once: true });
                  document.addEventListener('touchstart', startMusicOnClick, { once: true });
                }
              });
            } else {
              audio.pause();
            }
          }
          return newValue;
        });
      };

      const handleGoalChange = (key, value) => {
        const newGoals = { ...goals, [key]: Number(value) };
        setGoals(newGoals);
        // Update Firebase if user is authenticated
        if (user) {
          updateUserData({ goals: newGoals });
        }
      };

      const handleImageUpload = (event) => {
        const file = event.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (e) => {
            setProfilePicture(e.target.result);
          };
          reader.readAsDataURL(file);
        }
      };

      const handleSignOut = async () => {
        try {
          await signOut();
          alert('‚úÖ Successfully signed out!');
        } catch (error) {
          alert('‚ùå Error signing out: ' + error.message);
        }
      };

      // Booking History Functions
      // Check if a time slot is available across all users
      const checkSlotAvailability = async (date, timeSlot) => {
        if (!db) {
          console.log('Database not available');
          return false;
        }
        
        try {
          const usersRef = db.ref('users');
          const snapshot = await usersRef.once('value');
          const usersData = snapshot.val();
          
          if (!usersData) return true; // No bookings exist, slot is available
          
          // Check all users' bookings for the same date and time slot
          for (const userId in usersData) {
            const userBookings = usersData[userId].bookings;
            if (userBookings) {
              for (const bookingId in userBookings) {
                const booking = userBookings[bookingId];
                if (booking.date === date && booking.time === timeSlot && booking.status !== 'cancelled') {
                  return false; // Slot is already booked
                }
              }
            }
          }
          
          return true; // Slot is available
        } catch (error) {
          console.error('Error checking slot availability:', error);
          return false; // Assume unavailable on error for safety
        }
      };

      // Fetch booked slots for a specific date
      // Memoization cache for Firebase requests
      const requestCache = new Map();
      const CACHE_DURATION = 30000; // 30 seconds
      
      const fetchBookedSlotsForDate = async (date, signal = null) => {
        if (!db) {
          console.log('Database not available, using fallback');
          // Return mock data for testing when Firebase is unavailable
          return [];
        }
        
        // Check cache first
        const cacheKey = `booked-slots-${date}`;
        const cached = requestCache.get(cacheKey);
        if (cached && Date.now() - cached.timestamp < CACHE_DURATION) {
          return cached.data;
        }
        
        try {
          // Check if request was cancelled
          if (signal && signal.aborted) {
            throw new Error('Request cancelled');
          }
          
          // Use a more efficient approach with a global bookings index
          // First, try to get from a global bookings collection if it exists
          const globalBookingsRef = db.ref('globalBookings');
          
          // Add timeout to prevent infinite loading
          const timeoutPromise = new Promise((_, reject) => {
            setTimeout(() => reject(new Error('Firebase query timeout')), 10000);
          });
          
          const globalSnapshot = await Promise.race([
            globalBookingsRef.orderByChild('date').equalTo(date).limitToFirst(50).once('value'),
            timeoutPromise
          ]);
          
          // Check again after async operation
          if (signal && signal.aborted) {
            throw new Error('Request cancelled');
          }
          const globalBookings = globalSnapshot.val();
          
          const bookedTimes = [];
          
          if (globalBookings) {
            // Use global bookings index for faster lookup
            for (const bookingId in globalBookings) {
              const booking = globalBookings[bookingId];
              if (booking.status !== 'cancelled') {
                bookedTimes.push(booking.time);
              }
            }
          } else {
            // Check if request was cancelled before fallback
            if (signal && signal.aborted) {
              throw new Error('Request cancelled');
            }
            
            // Optimized fallback - only fetch bookings, not full user data
            const usersRef = db.ref('users');
            
            // Add timeout for fallback query too
            const fallbackTimeoutPromise = new Promise((_, reject) => {
              setTimeout(() => reject(new Error('Fallback query timeout')), 8000);
            });
            
            const snapshot = await Promise.race([
              usersRef.orderByKey().limitToFirst(100).once('value'),
              fallbackTimeoutPromise
            ]);
            
            // Check again after async operation
            if (signal && signal.aborted) {
              throw new Error('Request cancelled');
            }
            
            const usersData = snapshot.val();
            
            if (usersData) {
              // Check all users' bookings for the same date
              for (const userId in usersData) {
                const userBookings = usersData[userId].bookings;
                if (userBookings) {
                  for (const bookingId in userBookings) {
                    const booking = userBookings[bookingId];
                    if (booking.date === date && booking.status !== 'cancelled') {
                      bookedTimes.push(booking.time);
                    }
                  }
                }
              }
            }
          }
          
          // Cache the result
          requestCache.set(cacheKey, {
            data: bookedTimes,
            timestamp: Date.now()
          });
          
          return bookedTimes;
        } catch (error) {
          if (error.message.includes('timeout')) {
            console.warn('Firebase query timed out, using empty slots');
          } else {
            console.error('Error fetching booked slots:', error);
          }
          return [];
        }
      };

      const fetchBookingHistory = async () => {
        if (!user || !db) {
          console.log('User not authenticated or database not available');
          return;
        }
        
        setIsLoadingBookings(true);
        try {
          const bookingsRef = db.ref(`users/${user.uid}/bookings`);
          const snapshot = await bookingsRef.once('value');
          const bookingsData = snapshot.val();
          
          if (bookingsData) {
            // Convert Firebase object to array and sort by creation date (newest first)
            const bookingsArray = Object.keys(bookingsData).map(key => {
              const booking = { id: key, ...bookingsData[key] };
              
              // Replace old Jitsi or Daily.co links with new Whereby URL
              if (booking.meetingLink && (booking.meetingLink.includes('jit.si') || booking.meetingLink.includes('daily.co'))) {
                booking.meetingLink = 'https://fitness-mate.whereby.com/meeting410ee91d-38a8-4636-bcc8-5b9b86035b45';
              }
              if (booking.meeting_link && (booking.meeting_link.includes('jit.si') || booking.meeting_link.includes('daily.co'))) {
                booking.meeting_link = 'https://fitness-mate.whereby.com/meeting410ee91d-38a8-4636-bcc8-5b9b86035b45';
              }
              
              return booking;
            }).sort((a, b) => (b.createdAt || 0) - (a.createdAt || 0));
            
            setBookingHistory(bookingsArray);
          } else {
            setBookingHistory([]);
          }
        } catch (error) {
          console.error('Error fetching booking history:', error);
          alert('‚ùå Error loading booking history. Please try again.');
        } finally {
          setIsLoadingBookings(false);
        }
      };
      
      // Load booking history when user changes or component mounts
      useEffect(() => {
        if (user) {
          fetchBookingHistory();
        } else {
          setBookingHistory([]);
        }
      }, [user]);
      
      const toggleBookingHistory = () => {
        setShowBookingHistory(prev => !prev);
        if (!showBookingHistory && bookingHistory.length === 0) {
          fetchBookingHistory();
        }
      };

      const handleManualSync = async () => {
        if (!user) {
          alert('‚ùå Please sign in to sync your data.');
          return;
        }

        if (!db) {
          alert('‚ùå Sync unavailable: Database connection not available.');
          return;
        }

        // Check if user is properly authenticated
        if (!auth.currentUser) {
          alert('‚ùå Authentication required. Please sign out and sign back in.');
          return;
        }

        setIsSyncing(true);
        try {
          console.log('üîÑ Starting intelligent manual sync for user:', user.uid);
          
          // Test database connection first
          await db.ref(`users/${user.uid}`).once('value');
          console.log('‚úÖ Database connection verified');
          
          // Get remote data and timestamps
          const userSnapshot = await db.ref(`users/${user.uid}`).once('value');
          const remoteData = userSnapshot.exists() ? userSnapshot.val() : null;
          const remoteTimestamp = remoteData?.updatedAt || 0;
          
          // Get local timestamp
          const localTimestamp = parseInt(localStorage.getItem('lastSyncTimestamp') || '0');
          
          console.log('üìä Sync comparison - Local:', new Date(localTimestamp), 'Remote:', new Date(remoteTimestamp));
          
          let syncDirection = 'bidirectional';
          let mergedData = {};
          
          if (!remoteData) {
            // No remote data exists, push all local data
            console.log('üì§ No remote data found, pushing all local data');
            await syncAllDataToRTDB();
            syncDirection = 'local-to-remote';
          } else if (localTimestamp > remoteTimestamp) {
            // Local is newer, push local data
            console.log('üì§ Local data is newer, pushing to remote');
            await syncAllDataToRTDB();
            syncDirection = 'local-to-remote';
          } else if (remoteTimestamp > localTimestamp) {
            // Remote is newer, pull remote data
            console.log('üì• Remote data is newer, pulling from remote');
            
            // Update local storage and React state with remote data
            if (remoteData.goals) {
              localStorage.setItem('goals', JSON.stringify(remoteData.goals));
              setGoals(remoteData.goals);
            }
            if (remoteData.profilePicture) {
              localStorage.setItem('profilePicture', remoteData.profilePicture);
              setProfilePicture(remoteData.profilePicture);
            }
            if (remoteData.notificationsEnabled !== undefined) {
              localStorage.setItem('notificationsEnabled', JSON.stringify(remoteData.notificationsEnabled));
              setNotificationsEnabled(remoteData.notificationsEnabled);
            }
            if (remoteData.darkMode !== undefined) {
              localStorage.setItem('fitmate-dark-mode', remoteData.darkMode.toString());
            }
            if (remoteData.dailyIntake) {
              localStorage.setItem('dailyIntake', JSON.stringify(remoteData.dailyIntake));
              setDailyIntake(remoteData.dailyIntake);
            }
            if (remoteData.recentMeals) {
              localStorage.setItem('recentMeals', JSON.stringify(remoteData.recentMeals));
              setRecentMeals(remoteData.recentMeals);
            }
            if (remoteData.dailyHistory) {
              localStorage.setItem('dailyHistory', JSON.stringify(remoteData.dailyHistory));
              setDailyHistory(remoteData.dailyHistory);
            }
            if (remoteData.coachMessages) localStorage.setItem('coachMessages', JSON.stringify(remoteData.coachMessages));
            if (remoteData.habitAIAdvice) localStorage.setItem('habitAIAdvice', remoteData.habitAIAdvice);
            if (remoteData.habits) localStorage.setItem('habits', JSON.stringify(remoteData.habits));
            if (remoteData.mealPlan) localStorage.setItem('mealPlan', JSON.stringify(remoteData.mealPlan));
            if (remoteData.workoutPlan) localStorage.setItem('workoutPlan', JSON.stringify(remoteData.workoutPlan));
            if (remoteData.scanResult) localStorage.setItem('scanResult', JSON.stringify(remoteData.scanResult));
            if (remoteData.formAnalysis) localStorage.setItem('formAnalysis', JSON.stringify(remoteData.formAnalysis));
            
            // Update local sync timestamp
            localStorage.setItem('lastSyncTimestamp', remoteTimestamp.toString());
            
            syncDirection = 'remote-to-local';
          } else {
            // Timestamps are equal, data is already in sync
            console.log('‚úÖ Data is already in sync');
            syncDirection = 'already-synced';
          }
          
          // Dispatch sync event to update other components
          window.dispatchEvent(new CustomEvent('userDataSynced'));
          
          const syncMessages = {
            'local-to-remote': '‚úÖ Local data synced to cloud successfully!',
            'remote-to-local': '‚úÖ Latest data pulled from cloud successfully!',
            'already-synced': '‚úÖ Data is already synchronized across devices!',
            'bidirectional': '‚úÖ Data synchronized successfully!'
          };
          
          // Set success status and timestamp
          setSyncStatus('success');
          setLastSyncTime(new Date());
          
          alert(syncMessages[syncDirection] + ' All devices will now have the latest data.');
          
          // Clear success status after 5 seconds
          setTimeout(() => setSyncStatus(null), 5000);
          
          // Navigate back to dashboard to see updated data
          setTimeout(() => setScreen('dashboard'), 1000);
        } catch (error) {
          console.error('‚ùå Detailed sync error:', error);
          console.error('Error code:', error.code);
          console.error('Error message:', error.message);
          
          // Set error status
          setSyncStatus('error');
          setLastSyncTime(new Date());
          
          let errorMessage = '';
          if (error.code === 'PERMISSION_DENIED') {
            errorMessage = 'Permission denied. Please check your database security rules.';
          } else if (error.code === 'NETWORK_ERROR') {
            errorMessage = 'Network error. Please check your internet connection.';
          } else if (error.code === 'UNAVAILABLE') {
            errorMessage = 'Service temporarily unavailable. Please try again later.';
          } else {
            errorMessage = error.message || 'Unknown error occurred';
          }
          
          alert('‚ùå Sync failed: ' + errorMessage);
          
          // Clear error status after 10 seconds
          setTimeout(() => setSyncStatus(null), 10000);
        } finally {
          setIsSyncing(false);
        }
      };

      const openAccountModal = () => setShowAccountModal(true);
      const closeAccountModal = () => setShowAccountModal(false);

      const openPrivacyModal = () => {
        setShowPrivacyModal(true);
      };

      const closePrivacyModal = () => {
        setShowPrivacyModal(false);
      };

      const openSupportModal = () => {
        setShowSupportModal(true);
        setSupportSubmissionStatus(null);
      };

      const closeSupportModal = () => {
        setShowSupportModal(false);
        setSupportForm({ fullName: '', email: '', subject: '', message: '' });
        setSupportSubmissionStatus(null);
      };

      const handleSupportFormChange = (field, value) => {
        setSupportForm(prev => ({ ...prev, [field]: value }));
      };

      const openBookingModal = () => {
    setBookingStep(1);
    setSelectedDate(null);
    setSelectedTimeSlot(null);
    setSelectedPackage(null);
    initializeCalendar();
    setShowBookingModal(true);
  };
  
  const closeBookingModal = () => {
    setShowBookingModal(false);
    setBookingStep(1);
    setSelectedDate(null);
    setSelectedTimeSlot(null);
    setSelectedPackage(null);
  };
  
  const initializeCalendar = () => {
    const today = new Date();
    const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
    
    setCurrentMonth(monthNames[today.getMonth()]);
    setCurrentYear(today.getFullYear());
    
    generateCalendarDays(today.getMonth(), today.getFullYear());
  };
  
  const generateCalendarDays = (month, year) => {
    const firstDay = new Date(year, month, 1).getDay();
    const daysInMonth = new Date(year, month + 1, 0).getDate();
    const daysInPrevMonth = new Date(year, month, 0).getDate();
    
    const days = [];
    
    // Previous month days
    for (let i = firstDay - 1; i >= 0; i--) {
      days.push({
        dayOfMonth: daysInPrevMonth - i,
        isCurrentMonth: false,
        isAvailable: false,
        date: new Date(year, month - 1, daysInPrevMonth - i)
      });
    }
    
    // Current month days
    for (let i = 1; i <= daysInMonth; i++) {
      const date = new Date(year, month, i);
      const isAvailable = date >= new Date(); // Available if not in the past (including Sundays)
      
      days.push({
        dayOfMonth: i,
        isCurrentMonth: true,
        isAvailable,
        date,
        dayName: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][date.getDay()],
        monthName: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'][date.getMonth()],
        year: date.getFullYear()
      });
    }
    
    // Next month days
    const remainingDays = 42 - days.length; // 6 rows of 7 days
    for (let i = 1; i <= remainingDays; i++) {
      days.push({
        dayOfMonth: i,
        isCurrentMonth: false,
        isAvailable: false,
        date: new Date(year, month + 1, i)
      });
    }
    
    setCalendarDays(days);
  };
  
  const changeMonth = (direction) => {
    const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
    let newMonthIndex = monthNames.indexOf(currentMonth) + direction;
    let newYear = currentYear;
    
    if (newMonthIndex < 0) {
      newMonthIndex = 11;
      newYear--;
    } else if (newMonthIndex > 11) {
      newMonthIndex = 0;
      newYear++;
    }
    
    setCurrentMonth(monthNames[newMonthIndex]);
    setCurrentYear(newYear);
    generateCalendarDays(newMonthIndex, newYear);
    
    // Preload data for adjacent months
    preloadAdjacentMonths(newMonthIndex, newYear, monthNames);
  };
  
  const preloadAdjacentMonths = async (monthIndex, year, monthNames) => {
    // Preload previous month
    let prevMonthIndex = monthIndex - 1;
    let prevYear = year;
    if (prevMonthIndex < 0) {
      prevMonthIndex = 11;
      prevYear--;
    }
    
    // Preload next month
    let nextMonthIndex = monthIndex + 1;
    let nextYear = year;
    if (nextMonthIndex > 11) {
      nextMonthIndex = 0;
      nextYear++;
    }
    
    // Preload first few days of each adjacent month
    const preloadDays = [1, 2, 3, 15]; // Sample key dates
    
    for (const day of preloadDays) {
      // Previous month
      const prevDateString = `${monthNames[prevMonthIndex]} ${day}, ${prevYear}`;
      if (!slotsCache[prevDateString]) {
        try {
          await fetchBookedSlotsForDate(prevDateString);
        } catch (e) {
          // Silently fail preloading
        }
      }
      
      // Next month
      const nextDateString = `${monthNames[nextMonthIndex]} ${day}, ${nextYear}`;
      if (!slotsCache[nextDateString]) {
        try {
          await fetchBookedSlotsForDate(nextDateString);
        } catch (e) {
          // Silently fail preloading
        }
      }
    }
  };
  
  const selectDate = async (day) => {
    setSelectedDate(day);
    
    // Cancel any ongoing request
    if (abortController) {
      abortController.abort();
    }
    
    // Clear existing timer
    if (debounceTimer) {
      clearTimeout(debounceTimer);
    }
    
    // Set new timer for debounced slot generation
    const timer = setTimeout(async () => {
      await generateTimeSlots(day);
    }, 300);
    
    setDebounceTimer(timer);
  };
  
  const generateTimeSlots = async (day) => {
    const dateString = `${day.monthName} ${day.dayOfMonth}, ${day.year}`;
    
    // Create new AbortController for this request
    const controller = new AbortController();
    setAbortController(controller);
    
    // Clear ALL cached slots to ensure changes apply to all dates
    Object.keys(localStorage).forEach(key => {
      if (key.startsWith('fitmate-slots-')) {
        localStorage.removeItem(key);
      }
    });
    
    // Check localStorage cache first
    const localCacheKey = `fitmate-slots-${dateString}`;
    const localCache = localStorage.getItem(localCacheKey);
    
    if (localCache) {
      try {
        const cached = JSON.parse(localCache);
        // Check if cache is still valid (1 hour expiration)
        if (Date.now() - cached.timestamp < 3600000) {
          setAvailableTimeSlots(cached.slots);
          setBookedSlots(cached.bookedTimes);
          // Update memory cache too
          setSlotsCache(prev => ({
            ...prev,
            [dateString]: { slots: cached.slots, bookedTimes: cached.bookedTimes }
          }));
          return;
        } else {
          // Remove expired cache
          localStorage.removeItem(localCacheKey);
        }
      } catch (e) {
        localStorage.removeItem(localCacheKey);
      }
    }
    
    // Check memory cache
    if (slotsCache[dateString]) {
      setAvailableTimeSlots(slotsCache[dateString].slots);
      setBookedSlots(slotsCache[dateString].bookedTimes);
      return;
    }
    
    setIsLoadingSlots(true);
    
    try {
      // Generate time slots from 6 AM to 9 PM (45-minute sessions)
      const slots = [];
      const startHour = 6;
      const endHour = 21;
      
      for (let hour = startHour; hour < endHour; hour++) {
        const hourFormatted = hour === 0 ? 12 : hour > 12 ? hour - 12 : hour;
        const period = hour >= 12 ? 'PM' : 'AM';
        
        // 45-minute slots with timezone-friendly labels for US/Canada clients
        slots.push(`${hourFormatted}:00 ${period} EST/EDT`);
        slots.push(`${hourFormatted}:45 ${period} EST/EDT`);
      }
      
      // Fetch booked slots for this date
      const bookedTimes = await fetchBookedSlotsForDate(dateString, controller.signal);
      
      // Cache the results in memory and localStorage
      const cacheData = { slots, bookedTimes, timestamp: Date.now() };
      
      setSlotsCache(prev => ({
        ...prev,
        [dateString]: { slots, bookedTimes }
      }));
      
      // Save to localStorage with expiration
      try {
        setLocalStorageWithSync(`fitmate-slots-${dateString}`, JSON.stringify(cacheData));
      } catch (e) {
        console.warn('Failed to save to localStorage:', e);
      }
      
      setBookedSlots(bookedTimes);
      setAvailableTimeSlots(slots);
    } catch (error) {
      // Don't log errors for cancelled requests
      if (error.message !== 'Request cancelled') {
        console.error('Error generating time slots:', error);
      }
    } finally {
      // Only update loading state if request wasn't cancelled
      if (!controller.signal.aborted) {
        setIsLoadingSlots(false);
      }
    }
  };
  
  const selectTimeSlot = (slot) => {
    setSelectedTimeSlot(slot);
  };
  
  const selectPackage = (packageType) => {
    setSelectedPackage(packageType);
  };
  
  const handleBookingSubmit = async () => {
    if (!selectedDate || !selectedTimeSlot || !selectedPackage) {
      alert('Please complete all booking steps');
      return;
    }
    
    // Check slot availability before proceeding
    const dateString = `${selectedDate.monthName} ${selectedDate.dayOfMonth}, ${selectedDate.year}`;
    const isAvailable = await checkSlotAvailability(dateString, selectedTimeSlot);
    
    if (!isAvailable) {
      alert('‚ùå Sorry, this time slot is already booked. Please select a different time.');
      return;
    }
    
    if (selectedPackage === 'free') {
      // Handle free session booking
      handleFreeSessionBooking();
    } else {
      // Handle paid session booking
      handlePaidSessionBooking();
    }
  };
  
  const handleFreeSessionBooking = () => {
    // Prepare booking details
    const bookingDetails = {
      date: `${selectedDate.monthName} ${selectedDate.dayOfMonth}, ${selectedDate.year}`,
      time: selectedTimeSlot,
      package: 'Free Trial Session',
      email: user?.email || prompt('Please enter your email address:') || 'user@example.com',
      type: 'free',
      sessions: 1,
      price: 0
    };
    
    console.log('Free session booking:', bookingDetails);
    
    // Use the single Whereby meeting room for all sessions
       const meetingId = `FitmateFree${Date.now()}${Math.random().toString(36).substr(2, 9)}`;
       const wherebyLink = `https://fitness-mate.whereby.com/meeting410ee91d-38a8-4636-bcc8-5b9b86035b45`;
    
    // Store booking in Firebase
    if (user && db) {
      const bookingData = {
        ...bookingDetails,
        meetingLink: wherebyLink,
        userId: user.uid,
        userName: user.displayName || 'User',
        userEmail: user.email,
        bookingId: meetingId,
        createdAt: firebase.database.ServerValue.TIMESTAMP,
        status: 'confirmed'
      };
      
      // Save to user's bookings in Firebase
      db.ref(`users/${user.uid}/bookings`).push(bookingData)
        .then(() => {
          console.log('Booking saved to Firebase successfully');
          // Clear slots cache to ensure fresh data on next load
          setSlotsCache({});
        })
        .catch((error) => {
          console.error('Error saving booking to Firebase:', error);
        });
    }
    
    // Send confirmation email using EmailJS
    const templateParams = {
      to_email: bookingDetails.email,
      to_name: user?.displayName || 'Fitness Enthusiast',
      session_date: bookingDetails.date,
      session_time: bookingDetails.time,
      session_type: bookingDetails.package,
      meeting_link: wherebyLink
    };
    
    // Show immediate confirmation while email is being sent
    setConfirmationMessage({
      type: 'success',
      title: 'Booking Confirmed!',
      message: `Your free session has been booked for ${bookingDetails.date} at ${bookingDetails.time}. Confirmation email is being sent...`
    });
    closeBookingModal();
    
    // Send the email using EmailJS with timeout
    const emailTimeout = new Promise((_, reject) => {
      setTimeout(() => reject(new Error('Email timeout')), 15000);
    });
    
    Promise.race([
      emailjs.send(
        'service_94q9wl7', // Replace with your EmailJS service ID
        'template_3oqo92k', // Replace with your EmailJS template ID
        templateParams
      ),
      emailTimeout
    ]).then(function(response) {
      console.log('Email sent successfully:', response);
      // Update confirmation message to show email was sent
      setConfirmationMessage({
        type: 'success',
        title: 'Booking Confirmed!',
        message: `Your free session has been booked for ${bookingDetails.date} at ${bookingDetails.time}. Confirmation email sent successfully!`
      });
    }).catch(function(error) {
      console.error('Email sending failed or timed out:', error);
      // Update confirmation message to show email issue
      setConfirmationMessage({
        type: 'warning',
        title: 'Booking Confirmed',
        message: 'Your session was booked successfully, but there was an issue sending the confirmation email. Please contact support if needed.'
      });
    });
    
    // Log what is being sent
    console.log('Email being sent with session details:', {
      to: bookingDetails.email,
      subject: 'Your Free Fitness Session is Confirmed!',
      body: `
        Hi there,
        
        Your free fitness session is confirmed for ${bookingDetails.date} at ${bookingDetails.time}.
        
        Join link: ${wherebyLink}
        
        We look forward to seeing you!
        
        The Fitmate Team
      `
    });
  };
  
  const handlePaidSessionBooking = () => {
    // Set up the bundle based on the selected package
    const bundle = selectedPackage === 'basic' ? 
      { sessions: 5, price: 100 } : 
      { sessions: 10, price: 150 };
    
    // Prepare booking details
    const bookingDetails = {
      date: `${selectedDate.monthName} ${selectedDate.dayOfMonth}, ${selectedDate.year}`,
      time: selectedTimeSlot,
      package: selectedPackage === 'basic' ? 'Basic Package' : 'Premium Package',
      sessions: bundle.sessions,
      price: bundle.price,
      email: user?.email || prompt('Please enter your email address:') || 'user@example.com',
      type: 'paid'
    };
    
    // Use the single Whereby meeting room for all sessions
       const meetingId = `FitmatePaid${Date.now()}${Math.random().toString(36).substr(2, 9)}`;
       const wherebyLink = `https://fitness-mate.whereby.com/meeting410ee91d-38a8-4636-bcc8-5b9b86035b45`;
    
    // Store booking in Firebase
    if (user && db) {
      const bookingData = {
        ...bookingDetails,
        meetingLink: wherebyLink,
        userId: user.uid,
        userName: user.displayName || 'User',
        userEmail: user.email,
        bookingId: meetingId,
        createdAt: firebase.database.ServerValue.TIMESTAMP,
        status: 'confirmed',
        packageType: selectedPackage
      };
      
      // Save to user's bookings in Firebase
      db.ref(`users/${user.uid}/bookings`).push(bookingData)
        .then(() => {
          console.log('Paid booking saved to Firebase successfully');
          // Clear slots cache to ensure fresh data on next load
          setSlotsCache({});
        })
        .catch((error) => {
          console.error('Error saving paid booking to Firebase:', error);
        });
    }
    
    // Prepare email template parameters
    const templateParams = {
      to_email: bookingDetails.email,
      to_name: user?.displayName || 'Fitness Enthusiast',
      session_date: bookingDetails.date,
      session_time: bookingDetails.time,
      session_type: bookingDetails.package,
      sessions_count: bookingDetails.sessions,
      amount_paid: bookingDetails.price,
      meeting_link: wherebyLink
    };
    
    // Show immediate confirmation while email is being sent
    setConfirmationMessage({
      type: 'success',
      title: 'Payment Successful!',
      message: `Booking confirmed! You've selected ${bookingDetails.sessions} sessions for $${bookingDetails.price}. Confirmation email is being sent...`
    });
    closeBookingModal();
    
    // Send the email using EmailJS with timeout
    const paidEmailTimeout = new Promise((_, reject) => {
      setTimeout(() => reject(new Error('Email timeout')), 15000);
    });
    
    Promise.race([
      emailjs.send(
        'service_94q9wl7', // Replace with your EmailJS service ID
        'template_3oqo92k', // Replace with your EmailJS template ID
        templateParams
      ),
      paidEmailTimeout
    ]).then(function(response) {
      console.log('Email sent successfully:', response);
      // Update confirmation message to show email was sent
      setConfirmationMessage({
        type: 'success',
        title: 'Payment Successful!',
        message: `Booking confirmed! You've selected ${bookingDetails.sessions} sessions for $${bookingDetails.price}. Confirmation email sent successfully!`
      });
    }).catch(function(error) {
      console.error('Email sending failed or timed out:', error);
      // Update confirmation message to show email issue
      setConfirmationMessage({
        type: 'warning',
        title: 'Booking Confirmed',
        message: 'Your booking was confirmed successfully, but there was an issue sending the confirmation email. Please contact support if needed.'
      });
    });
  };
      

      


      const validateEmail = (email) => {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
      };

      const handleSupportSubmit = async (e) => {
        e.preventDefault();
        
        // Validation
        if (!supportForm.fullName.trim()) {
          alert('Please enter your full name.');
          return;
        }
        
        if (!supportForm.email.trim() || !validateEmail(supportForm.email)) {
          alert('Please enter a valid email address.');
          return;
        }
        
        if (!supportForm.subject.trim()) {
          alert('Please enter a subject.');
          return;
        }
        
        if (!supportForm.message.trim()) {
          alert('Please enter your message.');
          return;
        }

        setIsSubmittingSupport(true);
        
        try {
          // Create URLSearchParams directly for Netlify form submission
          const formData = new URLSearchParams();
          formData.append('form-name', 'support-form');
          formData.append('full-name', supportForm.fullName);
          formData.append('email', supportForm.email);
          formData.append('subject', supportForm.subject);
          formData.append('message', supportForm.message);
          
          const response = await fetch('/', {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: formData.toString()
          });
          
          if (response.ok) {
            setSupportSubmissionStatus('success');
            setSupportForm({ fullName: '', email: '', subject: '', message: '' });
          } else {
            throw new Error('Form submission failed');
          }
        } catch (error) {
          console.error('Support form submission error:', error);
          setSupportSubmissionStatus('error');
        } finally {
          setIsSubmittingSupport(false);
        }
      };

      const generateAIAvatar = async () => {
        // Show prompt to collect user preferences
        const gender = prompt("What gender would you like for your avatar? (male/female/non-binary)", "male");
        if (!gender) return; // User cancelled
        
        const style = prompt("What style do you prefer? (professional/casual/sporty/artistic)", "sporty");
        if (!style) return; // User cancelled
        
        const hairColor = prompt("Preferred hair color? (brown/black/blonde/red/gray/other)", "brown");
        if (!hairColor) return; // User cancelled
        
        setIsGeneratingAvatar(true);
        try {
          const prompt = `Create a professional, friendly avatar for a fitness app user with these specifications:
          - Gender: ${gender}
          - Style: ${style} 
          - Hair color: ${hairColor}
          - Clean, modern design
          - Suitable for a health and fitness application
          - Colorful but professional
          - Square format, suitable for profile picture
          - Cartoon or illustrated style, not photorealistic
          - Should look healthy, fit, and approachable
          - Age range: 25-35 years old
          
          Generate a detailed description for an avatar that represents health, fitness, and wellness with the specified characteristics.`;

            const response = await fetch(getDirectGeminiConfig().url, {
            method: 'POST',
            headers: getDirectGeminiConfig().headers,
            body: JSON.stringify({
              model: OPENROUTER_QWEN_MODEL,
              messages: [{ role: 'user', content: prompt }]
            })
          });

          if (!response.ok) {
            throw new Error(`API Error: ${response.status}`);
          }

          const result = await response.json();
          const description = (result.choices?.[0]?.message?.content || '');
          
          // Use the AI description with user preferences as seed for avatar generation
          const seed = `${gender}-${style}-${hairColor}-${description.substring(0, 30)}`;
          const avatarUrl = `https://api.dicebear.com/7.x/avataaars/svg?seed=${encodeURIComponent(seed)}&backgroundColor=b6e3f4,c0aede,d1d4f9,ffd5dc,ffdfbf&hair=${hairColor === 'blonde' ? 'blonde' : hairColor === 'red' ? 'red' : 'brown'}`;
          
          setProfilePicture(avatarUrl);
        } catch (error) {
          console.error('Avatar generation error:', error);
          alert('Failed to generate avatar. Please try again.');
        } finally {
          setIsGeneratingAvatar(false);
        }
      };

      return (
        <div className="p-6 pb-24">
          {showBookingModal && (
            <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4">
              <div className="bg-white dark:bg-gray-900 rounded-2xl shadow-2xl w-full max-w-4xl max-h-[90vh] flex flex-col transform transition-all opacity-100 scale-100">
                <div className="flex justify-between items-center p-4 border-b border-gray-200 dark:border-gray-700 flex-shrink-0">
                  <h3 className="text-2xl font-bold text-gray-800 dark:text-gray-200">Book Your Session</h3>
                  <button onClick={closeBookingModal} className="text-gray-500 hover:text-gray-800 dark:text-gray-400 dark:hover:text-gray-200 p-2 rounded-full bg-gray-100 dark:bg-gray-800">
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" /></svg>
                  </button>
                </div>
                <div className="p-2 md:p-6 flex-1 overflow-y-auto">
                  {/* Custom Booking Calendar */}
                  <div className="booking-calendar-container">
                    {/* Step 1: Date Selection */}
                    {bookingStep === 1 && (
                      <div className="booking-step">
                        <h3 className="text-xl font-semibold text-gray-800 dark:text-gray-200 mb-4">Select a Date</h3>
                        <div className="calendar-container">
                          <div className="calendar-header flex justify-between items-center mb-4">
                            <button 
                              onClick={() => changeMonth(-1)} 
                              className="p-2 rounded-full bg-gray-100 dark:bg-gray-800 text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-700"
                            >
                              <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fillRule="evenodd" d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z" clipRule="evenodd" />
                              </svg>
                            </button>
                            <h4 className="text-lg font-medium text-gray-800 dark:text-gray-200">{currentMonth} {currentYear}</h4>
                            <button 
                              onClick={() => changeMonth(1)} 
                              className="p-2 rounded-full bg-gray-100 dark:bg-gray-800 text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-700"
                            >
                              <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fillRule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clipRule="evenodd" />
                              </svg>
                            </button>
                          </div>
                          
                          <div className="calendar-grid grid grid-cols-7 gap-1 mb-6">
                            {['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].map((day, index) => (
                              <div key={index} className="calendar-day-header text-center text-sm font-medium text-gray-500 dark:text-gray-400 py-2">
                                {day}
                              </div>
                            ))}
                            
                            {calendarDays.map((day, index) => (
                              <div 
                                key={index} 
                                className={`
                                  calendar-day text-center py-2 rounded-lg cursor-pointer
                                  ${day.isCurrentMonth ? 'text-gray-800 dark:text-gray-200' : 'text-gray-400 dark:text-gray-600'} 
                                  ${day.isAvailable ? 'hover:bg-pink-100 dark:hover:bg-pink-900' : 'opacity-50 cursor-not-allowed'}
                                  ${selectedDate && day.date.toDateString() === selectedDate.date.toDateString() ? 'bg-pink-500 text-white' : ''}
                                `}
                                onClick={() => day.isAvailable ? selectDate(day) : null}
                              >
                                {day.dayOfMonth}
                              </div>
                            ))}
                          </div>
                          
                          <button 
                            className={`
                              w-full py-3 rounded-lg font-medium text-white
                              ${selectedDate ? 'bg-pink-500 hover:bg-pink-600' : 'bg-gray-300 dark:bg-gray-700 cursor-not-allowed'}
                            `}
                            disabled={!selectedDate} 
                            onClick={() => setBookingStep(2)}
                          >
                            Next: Select Time
                          </button>
                        </div>
                      </div>
                    )}
                    
                    {/* Step 2: Time Selection */}
                    {bookingStep === 2 && (
                      <div className="booking-step">
                        <h3 className="text-xl font-semibold text-gray-800 dark:text-gray-200 mb-2">Select a Time</h3>
                        <p className="text-gray-600 dark:text-gray-400 mb-4">
                          {selectedDate ? `${selectedDate.dayName}, ${selectedDate.monthName} ${selectedDate.dayOfMonth}, ${selectedDate.year}` : ''}
                        </p>
                        
                        <div className="time-slots-container grid grid-cols-3 gap-3 mb-6">
                          {isLoadingSlots ? (
                            // Skeleton loading for time slots
                            Array.from({ length: 12 }).map((_, index) => (
                              <div key={index} className="animate-pulse">
                                <div className="bg-gray-200 dark:bg-gray-700 rounded-lg h-12 w-full"></div>
                              </div>
                            ))
                          ) : availableTimeSlots.map((slot, index) => {
                            const isBooked = bookedSlots.includes(slot);
                            const isSelected = selectedTimeSlot === slot;
                            
                            return (
                              <div 
                                key={index} 
                                className={`
                                  time-slot text-center py-3 rounded-lg border relative
                                  ${isBooked 
                                    ? 'bg-red-100 dark:bg-red-900 text-red-600 dark:text-red-300 border-red-300 dark:border-red-700 cursor-not-allowed opacity-60' 
                                    : isSelected 
                                      ? 'bg-pink-500 text-white border-pink-500 cursor-pointer' 
                                      : 'bg-white dark:bg-gray-800 text-gray-800 dark:text-gray-200 border-gray-200 dark:border-gray-700 hover:border-pink-500 dark:hover:border-pink-500 cursor-pointer'
                                  }
                                `}
                                onClick={() => !isBooked && selectTimeSlot(slot)}
                              >
                                {slot}
                                {isBooked && (
                                  <div className="absolute inset-0 flex items-center justify-center">
                                    <span className="text-xs font-semibold bg-red-500 text-white px-2 py-1 rounded-full">Booked</span>
                                  </div>
                                )}
                              </div>
                            );
                          })}
                        
                        </div>
                        
                        <div className="flex space-x-3">
                          <button 
                            className="flex-1 py-3 rounded-lg font-medium text-gray-700 dark:text-gray-300 bg-gray-100 dark:bg-gray-800 hover:bg-gray-200 dark:hover:bg-gray-700"
                            onClick={() => setBookingStep(1)}
                          >
                            Back
                          </button>
                          <button 
                            className={`
                              flex-1 py-3 rounded-lg font-medium text-white
                              ${selectedTimeSlot ? 'bg-pink-500 hover:bg-pink-600' : 'bg-gray-300 dark:bg-gray-700 cursor-not-allowed'}
                            `}
                            disabled={!selectedTimeSlot} 
                            onClick={() => setBookingStep(3)}
                          >
                            Next: Select Package
                          </button>
                        </div>
                      </div>
                    )}
                    
                    {/* Step 3: Package Selection */}
                    {bookingStep === 3 && (
                      <div className="booking-step">
                        <h3 className="text-xl font-semibold text-gray-800 dark:text-gray-200 mb-2">Select a Package</h3>
                        <p className="text-gray-600 dark:text-gray-400 mb-4">
                          {selectedDate ? `${selectedDate.dayName}, ${selectedDate.monthName} ${selectedDate.dayOfMonth}, ${selectedDate.year} at ${selectedTimeSlot}` : ''}
                        </p>
                        
                        <div className="package-options grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                          <div 
                            className={`
                              package-card p-4 rounded-lg border cursor-pointer
                              ${selectedPackage === 'free' ? 'bg-pink-50 dark:bg-pink-900/20 border-pink-500' : 'bg-white dark:bg-gray-800 border-gray-200 dark:border-gray-700 hover:border-pink-500 dark:hover:border-pink-500'}
                            `}
                            onClick={() => selectPackage('free')}
                          >
                            <h4 className="text-lg font-semibold text-gray-800 dark:text-gray-200 mb-2">Free Trial Session</h4>
                            <p className="text-2xl font-bold text-pink-500 mb-3">$0</p>
                            <ul className="text-sm text-gray-600 dark:text-gray-400 space-y-2">
                              <li>‚úì 45-minute introduction session</li>
                              <li>‚úì Fitness assessment</li>
                              <li>‚úì Goal setting consultation</li>
                            </ul>
                          </div>
                          
                          <div 
                            className={`
                              package-card p-4 rounded-lg border cursor-pointer
                              ${selectedPackage === 'basic' ? 'bg-pink-50 dark:bg-pink-900/20 border-pink-500' : 'bg-white dark:bg-gray-800 border-gray-200 dark:border-gray-700 hover:border-pink-500 dark:hover:border-pink-500'}
                            `}
                            onClick={() => selectPackage('basic')}
                          >
                            <h4 className="text-lg font-semibold text-gray-800 dark:text-gray-200 mb-2">Basic Package</h4>
                            <p className="text-2xl font-bold text-pink-500 mb-3">$100</p>
                            <ul className="text-sm text-gray-600 dark:text-gray-400 space-y-2">
                              <li>‚úì 5 training sessions</li>
                              <li>‚úì Personalized workout plan</li>
                              <li>‚úì Nutrition guidance</li>
                            </ul>
                          </div>
                          
                          <div 
                            className={`
                              package-card p-4 rounded-lg border cursor-pointer
                              ${selectedPackage === 'premium' ? 'bg-pink-50 dark:bg-pink-900/20 border-pink-500' : 'bg-white dark:bg-gray-800 border-gray-200 dark:border-gray-700 hover:border-pink-500 dark:hover:border-pink-500'}
                            `}
                            onClick={() => selectPackage('premium')}
                          >
                            <h4 className="text-lg font-semibold text-gray-800 dark:text-gray-200 mb-2">Premium Package</h4>
                            <p className="text-2xl font-bold text-pink-500 mb-3">$150</p>
                            <ul className="text-sm text-gray-600 dark:text-gray-400 space-y-2">
                              <li>‚úì 10 training sessions</li>
                              <li>‚úì Comprehensive fitness plan</li>
                              <li>‚úì Detailed nutrition program</li>
                              <li>‚úì 24/7 support</li>
                            </ul>
                          </div>
                        </div>
                        
                        <div className="flex space-x-3">
                          <button 
                            className="flex-1 py-3 rounded-lg font-medium text-gray-700 dark:text-gray-300 bg-gray-100 dark:bg-gray-800 hover:bg-gray-200 dark:hover:bg-gray-700"
                            onClick={() => setBookingStep(2)}
                          >
                            Back
                          </button>
                          <button 
                            className={`
                              flex-1 py-3 rounded-lg font-medium text-white
                              ${selectedPackage ? 'bg-pink-500 hover:bg-pink-600' : 'bg-gray-300 dark:bg-gray-700 cursor-not-allowed'}
                            `}
                            disabled={!selectedPackage} 
                            onClick={handleBookingSubmit}
                          >
                            {selectedPackage === 'free' ? 'Book Free Session' : 'Proceed to Payment'}
                          </button>
                        </div>
                      </div>
                    )}
                  </div>
                </div>
              </div>
            </div>
           )}
           
           {/* Optimized Confirmation Message Modal */}
           {confirmationMessage && (
             <div className="fixed inset-0 bg-black/75 flex items-center justify-center z-50 p-4 will-change-transform">
               <div className="bg-white dark:bg-gray-900 rounded-2xl shadow-2xl w-full max-w-md mx-auto transform transition-transform duration-200 scale-100 will-change-transform">
                 <div className="p-6 text-center">
                   <div className={`mx-auto mb-4 w-12 h-12 rounded-full flex items-center justify-center will-change-transform ${
                     confirmationMessage.type === 'success' ? 'bg-green-100 dark:bg-green-900/20' : 'bg-yellow-100 dark:bg-yellow-900/20'
                   }`}>
                     {confirmationMessage.type === 'success' ? (
                       <svg className="w-6 h-6 text-green-600 dark:text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" style={{willChange: 'transform'}}>
                         <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
                       </svg>
                     ) : (
                       <svg className="w-6 h-6 text-yellow-600 dark:text-yellow-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" style={{willChange: 'transform'}}>
                         <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z" />
                       </svg>
                     )}
                   </div>
                   <h3 className="text-lg font-semibold text-gray-800 dark:text-gray-200 mb-2 will-change-contents">
                     {confirmationMessage.title}
                   </h3>
                   <p className="text-gray-600 dark:text-gray-400 mb-6 will-change-contents">
                     {confirmationMessage.message}
                   </p>
                   <button
                     onClick={() => setConfirmationMessage(null)}
                     className="w-full bg-pink-500 active:bg-pink-600 text-white font-medium py-3 px-4 rounded-lg transition-colors duration-150 will-change-transform touch-manipulation"
                   >
                     OK
                   </button>
                 </div>
               </div>
             </div>
           )}

           <header className="mb-6 flex justify-between items-center">
            <h1 className="text-3xl font-bold text-gray-800 dark:text-gray-200">My Profile</h1>
            {user && (
              <button 
                onClick={() => document.getElementById('virtual-trainer-card')?.scrollIntoView({ behavior: 'smooth' })}
                className="flex items-center gap-2 bg-gradient-to-r from-purple-500 to-pink-500 text-white px-3 py-2 rounded-full shadow-lg hover:scale-105 transition-transform text-sm md:text-base md:px-4"
              >
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M2 5a2 2 0 012-2h7a2 2 0 012 2v4a2 2 0 01-2 2H9l-3 3v-3H4a2 2 0 01-2-2V5z"/><path d="M15 7v2a2 2 0 012 2v5a2 2 0 01-2 2H9a2 2 0 01-2-2v-2h6V7z"/></svg>
                <span>Virtual Trainer</span>
              </button>
            )}
          </header>

          <div className="flex flex-col items-center mb-6 bg-white dark:bg-gray-800 p-6 rounded-2xl shadow-md">
            <div className="relative mb-4">
              <img 
                src={profilePicture} 
                alt="User profile" 
                className="w-24 h-24 rounded-full object-cover border-4 border-pink-200 dark:border-pink-400" 
              />
              <button
                onClick={() => fileInputRef.current?.click()}
                className="absolute -bottom-2 -right-2 bg-pink-500 text-white p-2 rounded-full shadow-lg hover:bg-pink-600 transition-colors"
                title="Upload Photo"
              >
                üì∑
              </button>
            </div>
            
            <div className="flex gap-2 mb-4">
              <button
                onClick={() => fileInputRef.current?.click()}
                className="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-lg text-sm font-medium transition-colors"
              >
                üìÅ Upload Photo
              </button>
              <button
                onClick={generateAIAvatar}
                disabled={isGeneratingAvatar}
                className="bg-purple-500 hover:bg-purple-600 disabled:bg-gray-400 text-white px-4 py-2 rounded-lg text-sm font-medium transition-colors flex items-center gap-1"
              >
                {isGeneratingAvatar ? '‚è≥ Generating...' : 'ü§ñ AI Avatar'}
              </button>
            </div>

            <input
              type="file"
              ref={fileInputRef}
              onChange={handleImageUpload}
              accept="image/*"
              className="hidden"
            />
            
            <h2 className="text-2xl font-bold text-gray-800 dark:text-gray-200">
              {user ? (user.displayName || 'User') : 'John Doe'}
            </h2>
            <p className="text-gray-500 dark:text-gray-400">
              {user ? user.email : 'john.doe@example.com'}
            </p>
          </div>

          <div className="mb-6">
            <h3 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-4">My Goals</h3>
            <div className="bg-white dark:bg-gray-800 rounded-2xl shadow-md p-4 space-y-3">
              <div className="p-2">
                <label className="font-semibold mb-2 block text-gray-800 dark:text-gray-200">Daily Calories: {goals.calories} kcal</label>
                <input type="range" min="1200" max="4000" step="50" value={goals.calories} onChange={e => handleGoalChange('calories', e.target.value)} className="w-full" />
              </div>
              <div className="flex justify-between items-center p-2">
                <p className="text-gray-600 dark:text-gray-300">Protein</p>
                <p className="font-bold text-gray-800 dark:text-gray-200">{goals.protein} g</p>
              </div>
              <div className="flex justify-between items-center p-2">
                <p className="text-gray-600 dark:text-gray-300">Carbs</p>
                <p className="font-bold text-gray-800 dark:text-gray-200">{goals.carbs} g</p>
              </div>
              <div className="flex justify-between items-center p-2">
                <p className="text-gray-600 dark:text-gray-300">Fat</p>
                <p className="font-bold text-gray-800 dark:text-gray-200">{goals.fat} g</p>
              </div>
            </div>
          </div>

          {/* Virtual Trainer Section */}
          <div id="virtual-trainer-card" className="mb-6">
            <h3 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-4">Virtual Trainer</h3>
            <div className="bg-white dark:bg-gray-800 rounded-2xl shadow-md p-6">
              <div className="flex flex-col md:flex-row items-center gap-6">
                <div className="flex-shrink-0">
                  <img src="naim.png" alt="Virtual Trainer" className="w-32 h-32 rounded-full object-cover object-center border-4 border-pink-200 dark:border-pink-400"/>
                </div>
                <div className="flex-grow">
                  <h4 className="text-2xl font-bold text-gray-800 dark:text-gray-200">Book a Personal Session</h4>
                  <p className="text-gray-600 dark:text-gray-400 mt-2">
                    Get one-on-one guidance from a certified trainer. Your first 45-minute session is <strong>FREE</strong>!
                  </p>
                  <div className="mt-4 space-y-3">
                    <div className="flex justify-between items-center p-3 bg-gray-50 dark:bg-gray-700 rounded-lg">
                      <div>
                        <p className="text-gray-700 dark:text-gray-300"><span className="font-bold text-pink-500">5 Sessions:</span> $100</p>
                        <p className="text-xs text-gray-500 dark:text-gray-400">Save $25 compared to individual sessions</p>
                      </div>
                      {user && (
                        <button 
                          onClick={() => {
                            setSelectedPackage('basic');
                            openBookingModal();
                          }}
                          className="bg-pink-500 hover:bg-pink-600 text-white px-4 py-2 rounded-lg text-sm font-medium transition-colors"
                        >
                          Buy Now
                        </button>
                      )}
                    </div>
                    <div className="flex justify-between items-center p-3 bg-gray-50 dark:bg-gray-700 rounded-lg">
                      <div>
                        <p className="text-gray-700 dark:text-gray-300"><span className="font-bold text-pink-500">10 Sessions:</span> $150</p>
                        <p className="text-xs text-gray-500 dark:text-gray-400">Best value - Save $50!</p>
                      </div>
                      {user && (
                        <button 
                          onClick={() => {
                            setSelectedPackage('premium');
                            openBookingModal();
                          }}
                          className="bg-pink-500 hover:bg-pink-600 text-white px-4 py-2 rounded-lg text-sm font-medium transition-colors"
                        >
                          Buy Now
                        </button>
                      )}
                    </div>
                  </div>
                  <div className="mt-6 flex flex-col md:flex-row gap-3">
                    {user ? (
                      <>
                        <button 
                          onClick={openBookingModal}
                          className="w-full md:w-auto bg-gradient-to-r from-green-500 to-blue-500 text-white px-6 py-3 rounded-lg shadow-lg hover:scale-105 transition-transform font-semibold"
                        >
                          Book a Session
                        </button>
                      </>
                    ) : (
                      <button 
                        onClick={openAccountModal}
                        className="w-full md:w-auto bg-gradient-to-r from-purple-500 to-pink-500 text-white px-6 py-3 rounded-lg shadow-lg hover:scale-105 transition-transform font-semibold"
                      >
                        Sign In to Book
                      </button>
                    )}
                  </div>
                </div>
              </div>
            </div>
          </div>

          <div>
            <h3 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-4">Settings</h3>
            <div className="bg-white dark:bg-gray-800 rounded-2xl shadow-md p-4 space-y-1">
              <button 
                onClick={openAccountModal}
                className="w-full text-left p-3 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-300 transition-colors flex justify-between items-center"
              >
                <span>Account</span>
                {user && (
                  <span className="text-xs bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-200 px-2 py-1 rounded-full">
                    Signed In
                  </span>
                )}
              </button>
              
              {/* Booking History Button - Only show when user is signed in */}
              {user && (
                <button 
                  onClick={toggleBookingHistory}
                  className="w-full text-left p-3 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-300 transition-colors flex justify-between items-center"
                >
                  <span className="flex items-center gap-2">
                    <span>üìÖ</span>
                    <span>Booking History</span>
                  </span>
                  {bookingHistory.length > 0 && (
                    <span className="text-xs bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200 px-2 py-1 rounded-full">
                      {bookingHistory.length}
                    </span>
                  )}
                </button>
              )}
              
              {/* Manual Sync Button - Only show when user is signed in */}
              {user && (
                <div className="space-y-2">
                  <button 
                    onClick={handleManualSync}
                    disabled={isSyncing}
                    className={`w-full text-left p-3 rounded-lg transition-colors flex justify-between items-center disabled:opacity-50 disabled:cursor-not-allowed ${
                      syncStatus === 'success' ? 'bg-green-50 dark:bg-green-900/20 border border-green-200 dark:border-green-800' :
                      syncStatus === 'error' ? 'bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800' :
                      'hover:bg-gray-100 dark:hover:bg-gray-700'
                    } text-gray-700 dark:text-gray-300`}
                  >
                    <span className="flex items-center gap-2">
                      <span className={isSyncing ? 'animate-spin' : ''}>
                        {syncStatus === 'success' ? '‚úÖ' : syncStatus === 'error' ? '‚ùå' : 'üîÑ'}
                      </span>
                      <span>Sync Profile Data</span>
                    </span>
                    <div className="flex flex-col items-end text-xs">
                      {isSyncing && (
                        <span className="bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200 px-2 py-1 rounded-full animate-pulse">
                          Syncing...
                        </span>
                      )}
                      {syncStatus === 'success' && (
                        <span className="text-green-600 dark:text-green-400">
                          ‚úì Synced
                        </span>
                      )}
                      {syncStatus === 'error' && (
                        <span className="text-red-600 dark:text-red-400">
                          ‚úó Failed
                        </span>
                      )}
                      {lastSyncTime && (
                        <span className="text-gray-500 dark:text-gray-400 mt-1">
                          {lastSyncTime.toLocaleTimeString()}
                        </span>
                      )}
                    </div>
                  </button>
                  
                  {/* Sync Status Info */}
                  {syncStatus === 'error' && (
                    <div className="text-xs text-red-600 dark:text-red-400 px-3 py-2 bg-red-50 dark:bg-red-900/20 rounded-lg border border-red-200 dark:border-red-800">
                      ‚ö†Ô∏è Sync failed. Check your internet connection and try again.
                    </div>
                  )}
                  
                  {syncStatus === 'success' && (
                    <div className="text-xs text-green-600 dark:text-green-400 px-3 py-2 bg-green-50 dark:bg-green-900/20 rounded-lg border border-green-200 dark:border-green-800">
                      ‚úÖ All data synchronized across devices successfully!
                    </div>
                  )}
                </div>
              )}
              
              {/* Updated Notifications with toggle */}
              <div className="flex justify-between items-center p-3">
                <span className="text-gray-700 dark:text-gray-300">Notifications</span>
                <button 
                  onClick={toggleNotifications}
                  className={`relative w-14 h-7 rounded-full p-1 transition-colors duration-200 focus:outline-none ${
                    notificationsEnabled ? 'bg-green-500' : 'bg-gray-300'
                  }`}
                  title={notificationsEnabled ? 'Notifications ON' : 'Notifications OFF'}
                >
                  <div className={`w-5 h-5 bg-white rounded-full shadow-md transform transition-transform duration-200 ${
                    notificationsEnabled ? 'translate-x-7' : 'translate-x-0'
                  }`}></div>
                </button>
              </div>
              
              {/* Background Music toggle */}
              <div className="p-3">
                <div className="flex justify-between items-center">
                  <span className="text-gray-700 dark:text-gray-300">Background Music</span>
                  <button 
                    onClick={toggleBackgroundMusic}
                    className={`relative w-14 h-7 rounded-full p-1 transition-colors duration-200 focus:outline-none ${
                      backgroundMusicEnabled ? 'bg-pink-500' : 'bg-gray-300'
                    }`}
                    title={backgroundMusicEnabled ? 'Background Music ON' : 'Background Music OFF'}
                  >
                    <div className={`w-5 h-5 bg-white rounded-full shadow-md transform transition-transform duration-200 ${
                      backgroundMusicEnabled ? 'translate-x-7' : 'translate-x-0'
                    }`}></div>
                  </button>
                </div>
                {backgroundMusicEnabled && (
                  <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">
                    üì± On mobile: Tap anywhere to start music
                  </p>
                )}
              </div>
              
              <button 
                onClick={openPrivacyModal}
                className="w-full text-left p-3 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-300 transition-colors"
              >
                Privacy
              </button>
              
              {/* New Support Button */}
              <button 
                onClick={openSupportModal}
                className="w-full text-left p-3 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-300 transition-colors"
              >
                Support
              </button>
              
              {/* Existing Dark Mode toggle */}
              <div className="flex justify-between items-center p-3">
                <span className="text-gray-700 dark:text-gray-300">Dark Mode</span>
                <button 
                  onClick={toggleDarkMode} 
                  className={`relative w-14 h-7 rounded-full p-1 transition-colors duration-200 focus:outline-none ${
                    isDarkMode ? 'bg-pink-500' : 'bg-gray-300'
                  }`}
                >
                  <div className={`w-5 h-5 bg-white rounded-full shadow-md transform transition-transform duration-200 ${
                    isDarkMode ? 'translate-x-7' : 'translate-x-0'
                  }`}></div>
                </button>
              </div>
            </div>
          </div>

          {/* Privacy Modal */}
          {showPrivacyModal && (
            <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
              <div className="bg-white dark:bg-gray-800 rounded-2xl shadow-2xl max-w-md w-full max-h-[80vh] overflow-y-auto">
                {/* Modal Header */}
                <div className="flex justify-between items-center p-6 border-b border-gray-200 dark:border-gray-700">
                  <h2 className="text-2xl font-bold text-gray-800 dark:text-gray-200 flex items-center">
                    üîí Privacy Policy
                  </h2>
                  <button 
                    onClick={closePrivacyModal}
                    className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 text-2xl font-bold transition-colors"
                  >
                    √ó
                  </button>
                </div>
                
                {/* Modal Content */}
                <div className="p-6 space-y-4">
                  <div className="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-4">
                    <h3 className="font-semibold text-blue-800 dark:text-blue-200 mb-2 flex items-center">
                      üì± Local Storage Only
                    </h3>
                    <p className="text-blue-700 dark:text-blue-300 text-sm">
                      Your data is stored locally on your device only. We do not collect, transmit, or store any personal information on external servers.
                    </p>
                  </div>
                  
                  <div className="space-y-3 text-gray-700 dark:text-gray-300">
                    <div>
                      <h4 className="font-semibold mb-1">üõ°Ô∏è Data Security</h4>
                      <p className="text-sm">
                        All your fitness data, goals, and preferences remain on your device using browser's local storage technology.
                      </p>
                    </div>
                    
                    <div>
                      <h4 className="font-semibold mb-1">üîÑ Data Control</h4>
                      <p className="text-sm">
                        You have complete control over your data. Clearing your browser data will remove all stored information.
                      </p>
                    </div>
                    
                    <div>
                      <h4 className="font-semibold mb-1">ü§ñ AI Interactions</h4>
                      <p className="text-sm">
                        AI coaching features may send anonymized queries to external services for responses, but no personal data is retained.
                      </p>
                    </div>
                    
                    <div>
                      <h4 className="font-semibold mb-1">üì∏ Image Processing</h4>
                      <p className="text-sm">
                        Food scanning and image analysis are processed temporarily and not stored permanently.
                      </p>
                    </div>
                  </div>
                  
                  <div className="bg-green-50 dark:bg-green-900/20 border border-green-200 dark:border-green-800 rounded-lg p-4">
                    <p className="text-green-800 dark:text-green-200 text-sm font-medium">
                      ‚úÖ Your privacy is our priority. This app is designed with privacy-first principles.
                    </p>
                  </div>
                </div>
                
                {/* Modal Footer */}
                <div className="p-6 border-t border-gray-200 dark:border-gray-700">
                  <button 
                    onClick={closePrivacyModal}
                    className="w-full bg-gradient-to-r from-purple-500 to-pink-500 text-white py-3 px-4 rounded-xl font-semibold hover:from-purple-600 hover:to-pink-600 transition-all duration-200 shadow-lg"
                  >
                    Got it!
                  </button>
                </div>
              </div>
            </div>
          )}

          {/* Account Modal */}
          {showAccountModal && (
            <AccountModal 
              user={user}
              onClose={closeAccountModal}
              onSignOut={handleSignOut}
            />
          )}

          {/* Booking History Modal */}
          {showBookingHistory && (
            <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
              <div className="bg-white dark:bg-gray-800 rounded-2xl shadow-2xl max-w-2xl w-full max-h-[80vh] overflow-y-auto">
                {/* Modal Header */}
                <div className="flex justify-between items-center p-6 border-b border-gray-200 dark:border-gray-700">
                  <h2 className="text-2xl font-bold text-gray-800 dark:text-gray-200 flex items-center">
                    üìÖ Booking History
                  </h2>
                  <button 
                    onClick={toggleBookingHistory}
                    className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 text-2xl font-bold transition-colors"
                  >
                    √ó
                  </button>
                </div>
                
                {/* Modal Content */}
                <div className="p-6">
                  {isLoadingBookings ? (
                    <div className="text-center py-8">
                      <div className="animate-spin text-4xl mb-4">‚è≥</div>
                      <p className="text-gray-600 dark:text-gray-400">Loading your booking history...</p>
                    </div>
                  ) : bookingHistory.length === 0 ? (
                    <div className="text-center py-8">
                      <div className="text-6xl mb-4">üìÖ</div>
                      <h3 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-2">No Bookings Yet</h3>
                      <p className="text-gray-600 dark:text-gray-400 mb-4">
                        You haven't made any bookings yet. Book your first session to get started!
                      </p>
                      <button 
                         onClick={() => {
                           toggleBookingHistory();
                           openBookingModal();
                         }}
                         className="bg-gradient-to-r from-pink-500 to-purple-600 text-white py-2 px-6 rounded-xl font-semibold hover:from-pink-600 hover:to-purple-700 transition-all duration-200 shadow-lg"
                       >
                         Book Now
                       </button>
                    </div>
                  ) : (
                    <div className="space-y-4">
                      <div className="flex justify-between items-center mb-4">
                        <p className="text-gray-600 dark:text-gray-400">
                          Total bookings: <span className="font-semibold text-gray-800 dark:text-gray-200">{bookingHistory.length}</span>
                        </p>
                        <button 
                          onClick={fetchBookingHistory}
                          className="text-blue-600 dark:text-blue-400 hover:text-blue-700 dark:hover:text-blue-300 text-sm font-medium"
                        >
                          üîÑ Refresh
                        </button>
                      </div>
                      
                      {bookingHistory.map((booking) => (
                        <div key={booking.id} className="bg-gray-50 dark:bg-gray-700 rounded-xl p-4 border border-gray-200 dark:border-gray-600">
                          <div className="flex justify-between items-start mb-3">
                            <div>
                              <h4 className="font-semibold text-gray-800 dark:text-gray-200">
                                {booking.package || 'Session'}
                              </h4>
                              <p className="text-sm text-gray-600 dark:text-gray-400">
                                {booking.date} at {booking.time}
                              </p>
                            </div>
                            <div className="text-right">
                              <span className={`inline-block px-2 py-1 rounded-full text-xs font-medium ${
                                booking.type === 'free' 
                                  ? 'bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-200'
                                  : 'bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200'
                              }`}>
                                {booking.type === 'free' ? 'Free Trial' : `$${booking.price}`}
                              </span>
                            </div>
                          </div>
                          
                          <div className="grid grid-cols-2 gap-4 text-sm">
                            <div>
                              <span className="text-gray-500 dark:text-gray-400">Sessions:</span>
                              <span className="ml-2 font-medium text-gray-800 dark:text-gray-200">{booking.sessions || 1}</span>
                            </div>
                            <div>
                              <span className="text-gray-500 dark:text-gray-400">Status:</span>
                              <span className="ml-2 font-medium text-green-600 dark:text-green-400">{booking.status || 'Confirmed'}</span>
                            </div>
                          </div>
                          
                          {booking.createdAt && (
                            <div className="mt-2 text-xs text-gray-500 dark:text-gray-400">
                              Booked: {new Date(booking.createdAt).toLocaleDateString()} at {new Date(booking.createdAt).toLocaleTimeString()}
                            </div>
                          )}
                          
                          {booking.meetingLink && (
                            <div className="mt-3">
                              <button 
                                onClick={() => {
                                  setCurrentMeetingLink(booking.meetingLink);
                                  setShowMeetingModal(true);
                                }}
                                className="inline-flex items-center gap-2 text-blue-600 dark:text-blue-400 hover:text-blue-700 dark:hover:text-blue-300 text-sm font-medium bg-transparent border-none cursor-pointer"
                              >
                                üé• Join Meeting
                              </button>
                            </div>
                          )}
                        </div>
                      ))}
                    </div>
                  )}
                </div>
              </div>
            </div>
          )}

          {/* Support Modal */}
          {showSupportModal && (
            <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
              <div className="bg-white dark:bg-gray-800 rounded-2xl shadow-2xl max-w-md w-full max-h-[80vh] overflow-y-auto">
                {/* Modal Header */}
                <div className="flex justify-between items-center p-6 border-b border-gray-200 dark:border-gray-700">
                  <h2 className="text-2xl font-bold text-gray-800 dark:text-gray-200 flex items-center">
                    üéß Support
                  </h2>
                  <button 
                    onClick={closeSupportModal}
                    className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 text-2xl font-bold transition-colors"
                  >
                    √ó
                  </button>
                </div>
                
                {/* Modal Content */}
                <div className="p-6">
                  {supportSubmissionStatus === 'success' ? (
                    <div className="text-center space-y-4">
                      <div className="text-6xl">‚úÖ</div>
                      <h3 className="text-xl font-bold text-green-600 dark:text-green-400">Message Sent!</h3>
                      <p className="text-gray-600 dark:text-gray-400">
                        Thank you for contacting us. We'll get back to you within 24 hours.
                      </p>
                      <button 
                        onClick={closeSupportModal}
                        className="w-full bg-gradient-to-r from-green-500 to-green-600 text-white py-3 px-4 rounded-xl font-semibold hover:from-green-600 hover:to-green-700 transition-all duration-200 shadow-lg"
                      >
                        Close
                      </button>
                    </div>
                  ) : (
                    <form onSubmit={handleSupportSubmit} className="space-y-4">
                      {/* Hidden Netlify form field */}
                      <input type="hidden" name="form-name" value="support-form" />
                      
                      {/* Full Name */}
                      <div>
                        <label className="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-2">
                          Full Name *
                        </label>
                        <input
                          type="text"
                          name="full-name"
                          value={supportForm.fullName}
                          onChange={(e) => handleSupportFormChange('fullName', e.target.value)}
                          className="w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-xl focus:ring-2 focus:ring-pink-500 focus:border-transparent bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 transition-all"
                          placeholder="Enter your full name"
                          required
                        />
                      </div>
                      
                      {/* Email */}
                      <div>
                        <label className="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-2">
                          Email Address *
                        </label>
                        <input
                          type="email"
                          name="email"
                          value={supportForm.email}
                          onChange={(e) => handleSupportFormChange('email', e.target.value)}
                          className="w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-xl focus:ring-2 focus:ring-pink-500 focus:border-transparent bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 transition-all"
                          placeholder="Enter your email address"
                          required
                        />
                      </div>
                      
                      {/* Subject */}
                      <div>
                        <label className="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-2">
                          Subject *
                        </label>
                        <input
                          type="text"
                          name="subject"
                          value={supportForm.subject}
                          onChange={(e) => handleSupportFormChange('subject', e.target.value)}
                          className="w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-xl focus:ring-2 focus:ring-pink-500 focus:border-transparent bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 transition-all"
                          placeholder="Brief description of your issue"
                          required
                        />
                      </div>
                      
                      {/* Message */}
                      <div>
                        <label className="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-2">
                          Message *
                        </label>
                        <textarea
                          name="message"
                          value={supportForm.message}
                          onChange={(e) => handleSupportFormChange('message', e.target.value)}
                          rows={4}
                          className="w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-xl focus:ring-2 focus:ring-pink-500 focus:border-transparent bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 transition-all resize-none"
                          placeholder="Please describe your issue or question in detail..."
                          required
                        ></textarea>
                      </div>
                      
                      {supportSubmissionStatus === 'error' && (
                        <div className="bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg p-4">
                          <p className="text-red-800 dark:text-red-200 text-sm font-medium">
                            ‚ùå Failed to send message. Please try again or contact us directly.
                          </p>
                        </div>
                      )}
                      
                      {/* Submit Button */}
                      <button 
                        type="submit"
                        disabled={isSubmittingSupport}
                        className="w-full bg-gradient-to-r from-purple-500 to-pink-500 text-white py-3 px-4 rounded-xl font-semibold hover:from-purple-600 hover:to-pink-600 disabled:from-gray-400 disabled:to-gray-500 disabled:cursor-not-allowed transition-all duration-200 shadow-lg"
                      >
                        {isSubmittingSupport ? 'üì§ Sending...' : 'üì§ Send Message'}
                      </button>
                    </form>
                  )}
                </div>
              </div>
            </div>
          )}

          {/* Meeting Modal */}
          {showMeetingModal && (
            <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
              <div className="bg-white dark:bg-gray-800 rounded-2xl shadow-2xl max-w-6xl w-full max-h-[90vh] overflow-hidden">
                {/* Modal Header with FitnessMate Branding */}
                <div className="flex justify-between items-center p-4 border-b border-gray-200 dark:border-gray-700 bg-gradient-to-r from-purple-500 to-pink-500">
                  <div className="flex items-center space-x-3">
                    <div className="text-2xl">üí™</div>
                    <div>
                      <h2 className="text-xl font-bold text-white">FitnessMate Meeting</h2>
                      <p className="text-purple-100 text-sm">Your personal fitness session</p>
                    </div>
                  </div>
                  <button 
                    onClick={() => {
                      setShowMeetingModal(false);
                      setCurrentMeetingLink('');
                    }}
                    className="text-white hover:text-purple-200 text-2xl font-bold transition-colors bg-white bg-opacity-20 rounded-full w-8 h-8 flex items-center justify-center"
                  >
                    √ó
                  </button>
                </div>
                
                {/* Modal Content - Embedded Whereby Meeting */}
                <div className="relative h-[70vh]">
                  {currentMeetingLink && (
                    <iframe 
                      src={currentMeetingLink}
                      className="w-full h-full border-0"
                      title="FitnessMate Meeting Session"
                      allow="camera; microphone; fullscreen; display-capture; autoplay; clipboard-write"
                      allowFullScreen
                    />
                  )}
                  

                </div>
                

              </div>
            </div>
          )}
        </div>
      );
    };



    // Account Modal Component
    const AccountModal = ({ user, onClose, onSignOut }) => {
      const { signIn, signUp, authError, setAuthError, validatePassword, resetPassword } = useAuth();
      const [isSignUp, setIsSignUp] = useState(false);
      const [formData, setFormData] = useState({
        email: '',
        password: '',
        confirmPassword: '',
        displayName: ''
      });
      const [isLoading, setIsLoading] = useState(false);

      const handleInputChange = (field, value) => {
        setFormData(prev => ({ ...prev, [field]: value }));
        if (authError) setAuthError(null);
      };

      const handleSubmit = async (e) => {
        e.preventDefault();
        setIsLoading(true);

        try {
          if (isSignUp) {
            if (formData.password !== formData.confirmPassword) {
              throw new Error('Passwords do not match');
            }
            if (formData.password.length < 6) {
              throw new Error('Password must be at least 6 characters');
            }
            await signUp(formData.email, formData.password, formData.displayName);
            alert('‚úÖ Account created successfully!');
          } else {
            await signIn(formData.email, formData.password);
            alert('‚úÖ Successfully signed in!');
          }
          onClose();
        } catch (error) {
          console.error('Auth error:', error);
        } finally {
          setIsLoading(false);
        }
      };

      if (user) {
        // Authenticated user view
        return (
          <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
            <div className="bg-white dark:bg-gray-800 rounded-2xl shadow-2xl max-w-md w-full">
              {/* Modal Header */}
              <div className="flex justify-between items-center p-6 border-b border-gray-200 dark:border-gray-700">
                <h2 className="text-2xl font-bold text-gray-800 dark:text-gray-200 flex items-center">
                  üë§ Account
                </h2>
                <button 
                  onClick={onClose}
                  className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 text-2xl font-bold transition-colors"
                >
                  √ó
                </button>
              </div>
              
              {/* User Info */}
              <div className="p-6 space-y-4">
                <div className="text-center">
                  <div className="w-20 h-20 bg-gradient-to-r from-pink-500 to-purple-600 rounded-full flex items-center justify-center text-white text-2xl font-bold mx-auto mb-4">
                    {user.displayName ? user.displayName.charAt(0).toUpperCase() : user.email.charAt(0).toUpperCase()}
                  </div>
                  <h3 className="text-xl font-semibold text-gray-800 dark:text-gray-200">
                    {user.displayName || 'User'}
                  </h3>
                  <p className="text-gray-600 dark:text-gray-400">{user.email}</p>
                </div>
                
                <div className="bg-green-50 dark:bg-green-900/20 border border-green-200 dark:border-green-800 rounded-lg p-4">
                  <p className="text-green-800 dark:text-green-200 text-sm font-medium flex items-center">
                    ‚úÖ Account verified
                  </p>
                </div>
                
                <div className="space-y-2 text-sm text-gray-600 dark:text-gray-400">
                  <p><strong>Account created:</strong> {user.metadata.creationTime ? new Date(user.metadata.creationTime).toLocaleDateString() : 'Unknown'}</p>
                  <p><strong>Last sign in:</strong> {user.metadata.lastSignInTime ? new Date(user.metadata.lastSignInTime).toLocaleDateString() : 'Unknown'}</p>
                </div>
                
                <button 
                  onClick={onSignOut}
                  className="w-full bg-red-500 hover:bg-red-600 text-white py-3 px-4 rounded-xl font-semibold transition-colors"
                >
                  Sign Out
                </button>
              </div>
            </div>
          </div>
        );
      }

      // Sign in/up form
      return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
          <div className="bg-white dark:bg-gray-800 rounded-2xl shadow-2xl max-w-md w-full">
            {/* Modal Header */}
            <div className="flex justify-between items-center p-6 border-b border-gray-200 dark:border-gray-700">
              <h2 className="text-2xl font-bold text-gray-800 dark:text-gray-200 flex items-center">
                üîê {isSignUp ? 'Create Account' : 'Sign In'}
              </h2>
              <button 
                onClick={onClose}
                className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 text-2xl font-bold transition-colors"
              >
                √ó
              </button>
            </div>
            
            {/* Form */}
            <form onSubmit={handleSubmit} className="p-6 space-y-4">
              {isSignUp && (
                <div>
                  <label className="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-2">
                    Full Name
                  </label>
                  <input
                    type="text"
                    value={formData.displayName}
                    onChange={(e) => handleInputChange('displayName', e.target.value)}
                    className="w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-xl focus:ring-2 focus:ring-pink-500 focus:border-transparent bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 transition-all"
                    placeholder="Enter your full name"
                    required
                  />
                </div>
              )}
              
              <div>
                <label className="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-2">
                  Email Address
                </label>
                <input
                  type="email"
                  value={formData.email}
                  onChange={(e) => handleInputChange('email', e.target.value)}
                  className="w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-xl focus:ring-2 focus:ring-pink-500 focus:border-transparent bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 transition-all"
                  placeholder="Enter your email"
                  required
                />
              </div>
              
              <div>
                <label className="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-2">
                  Password
                </label>
                <input
                  type="password"
                  value={formData.password}
                  onChange={(e) => handleInputChange('password', e.target.value)}
                  className="w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-xl focus:ring-2 focus:ring-pink-500 focus:border-transparent bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 transition-all"
                  placeholder="Enter your password"
                  required
                />
                {isSignUp && formData.password && (
                  <div className="mt-2 text-xs space-y-1">
                    {(() => {
                      const validation = validatePassword(formData.password);
                      return (
                        <div className="space-y-1">
                          <div className={`flex items-center ${formData.password.length >= 8 ? 'text-green-600' : 'text-red-500'}`}>
                            <span className="mr-1">{formData.password.length >= 8 ? '‚úì' : '‚úó'}</span>
                            At least 8 characters
                          </div>
                          <div className={`flex items-center ${/[A-Z]/.test(formData.password) ? 'text-green-600' : 'text-red-500'}`}>
                            <span className="mr-1">{/[A-Z]/.test(formData.password) ? '‚úì' : '‚úó'}</span>
                            One uppercase letter
                          </div>
                          <div className={`flex items-center ${/[a-z]/.test(formData.password) ? 'text-green-600' : 'text-red-500'}`}>
                            <span className="mr-1">{/[a-z]/.test(formData.password) ? '‚úì' : '‚úó'}</span>
                            One lowercase letter
                          </div>
                          <div className={`flex items-center ${/[0-9]/.test(formData.password) ? 'text-green-600' : 'text-red-500'}`}>
                            <span className="mr-1">{/[0-9]/.test(formData.password) ? '‚úì' : '‚úó'}</span>
                            One number
                          </div>
                          <div className={`flex items-center ${/[!@#$%^&*(),.?":{}|<>]/.test(formData.password) ? 'text-green-600' : 'text-red-500'}`}>
                            <span className="mr-1">{/[!@#$%^&*(),.?":{}|<>]/.test(formData.password) ? '‚úì' : '‚úó'}</span>
                            One special character
                          </div>
                        </div>
                      );
                    })()
                    }
                  </div>
                )}
              </div>
              
              {isSignUp && (
                <div>
                  <label className="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-2">
                    Confirm Password
                  </label>
                  <input
                    type="password"
                    value={formData.confirmPassword}
                    onChange={(e) => handleInputChange('confirmPassword', e.target.value)}
                    className={`w-full px-4 py-3 border rounded-xl focus:ring-2 focus:ring-pink-500 focus:border-transparent bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 transition-all ${
                      formData.confirmPassword && formData.password !== formData.confirmPassword 
                        ? 'border-red-500 dark:border-red-500' 
                        : 'border-gray-300 dark:border-gray-600'
                    }`}
                    placeholder="Confirm your password"
                    required
                  />
                  {formData.confirmPassword && formData.password !== formData.confirmPassword && (
                    <div className="mt-2 text-xs text-red-500 flex items-center">
                      <span className="mr-1">‚úó</span>
                      Passwords do not match
                    </div>
                  )}
                  {formData.confirmPassword && formData.password === formData.confirmPassword && formData.confirmPassword.length > 0 && (
                    <div className="mt-2 text-xs text-green-600 flex items-center">
                      <span className="mr-1">‚úì</span>
                      Passwords match
                    </div>
                  )}
                </div>
              )}
              
              {authError && (
                <div className="bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg p-4">
                  <p className="text-red-800 dark:text-red-200 text-sm font-medium">
                    ‚ùå {authError}
                  </p>
                </div>
              )}
              
              <button 
                type="submit"
                disabled={isLoading}
                className="w-full bg-gradient-to-r from-pink-500 to-purple-600 text-white py-3 px-4 rounded-xl font-semibold hover:from-pink-600 hover:to-purple-700 transition-all duration-200 shadow-lg disabled:opacity-50 disabled:cursor-not-allowed"
              >
                {isLoading ? '‚è≥ Processing...' : (isSignUp ? 'Create Account' : 'Sign In')}
              </button>
              
              {!isSignUp && (
                <div className="text-center">
                  <button 
                    type="button"
                    onClick={async () => {
                      if (!formData.email) {
                        setAuthError('Please enter your email address first.');
                        return;
                      }
                      try {
                        await resetPassword(formData.email);
                        setAuthError('');
                        alert('Password reset email sent! Check your inbox.');
                      } catch (error) {
                        // Error is already handled in resetPassword function
                      }
                    }}
                    className="text-sm text-gray-600 dark:text-gray-400 hover:text-pink-500 transition-colors"
                  >
                    Forgot your password?
                  </button>
                </div>
              )}
              
              <div className="text-center">
                <button 
                  type="button"
                  onClick={() => setIsSignUp(!isSignUp)}
                  className="text-pink-500 hover:text-pink-600 font-medium transition-colors"
                >
                  {isSignUp ? 'Already have an account? Sign In' : 'Need an account? Sign Up'}
                </button>
              </div>
              
              <div className="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-4">
                <p className="text-blue-800 dark:text-blue-200 text-sm">
                  üí° <strong>Benefits of creating an account:</strong><br/>
                  ‚Ä¢ Sync data across all devices<br/>
                  ‚Ä¢ Never lose your progress<br/>
                  ‚Ä¢ Access from any browser
                </p>
              </div>
            </form>
          </div>
        </div>
      );
    };

    // Scan Screen Component with OpenRouter (Qwen VL) Integration
    const Scan = ({ onLogMeal }) => {
      const [isLoading, setIsLoading] = useState(false);
      const [scanResult, setScanResult] = useState(null);
      const [error, setError] = useState(null);
      const [imagePreview, setImagePreview] = useState(null);
      const [selectedMood, setSelectedMood] = useState(null);
      const fileInputRef = useRef(null);

      const fileToBase64 = (file) => new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = () => resolve(reader.result.split(',')[1]);
        reader.onerror = error => reject(error);
      });

      const handleImageChange = (event) => {
        const file = event.target.files[0];
        if (file) {
          const previewUrl = URL.createObjectURL(file);
          setImagePreview(previewUrl);
          setScanResult(null);
          setError(null);
          setSelectedMood(null);
          handleScan(file, previewUrl);
        }
      };

      const handleScan = async (file, previewUrl) => {
        setIsLoading(true);
        setError(null);
        try {
          const base64ImageData = await fileToBase64(file);
          const prompt = `Analyze the food in this image.
1. Identify the main dish.
2. Break it down into primary ingredients and estimate calories for each.
3. Provide a total nutritional summary (calories, protein, carbs, fat).
4. Offer a single, actionable, and encouraging "health_tip" to make this meal healthier next time.
Respond ONLY with a valid JSON object in this format:
{
  "name": "Overall Dish Name",
  "total_calories": 550,
  "total_protein": 30.5,
  "total_carbs": 45.2,
  "total_fat": 25.8,
  "ingredients": [
    {"name": "Ingredient 1", "calories": 200},
    {"name": "Ingredient 2", "calories": 150}
  ],
  "health_tip": "A short, encouraging tip to improve the meal."
}`;

          const payload = {
            model: OPENROUTER_QWEN_VL_MODEL,
            messages: [
              {
                role: 'user',
                content: [
                  { type: 'text', text: prompt },
                  { type: 'image_url', image_url: `data:${file.type};base64,${base64ImageData}` }
                ]
              }
            ]
          };

          const response = await fetch(getDirectGeminiConfig().url, {
            method: 'POST',
            headers: getDirectGeminiConfig().headers,
            body: JSON.stringify(payload)
          });

          if (!response.ok) {
            throw new Error(`API Error: ${response.status} ${response.statusText}`);
          }

          const result = await response.json();
          const textResponse = (result.choices?.[0]?.message?.content || '');
          const jsonString = textResponse.replace(/```json|```/g, '').trim();
          const data = JSON.parse(jsonString);
          data.image = `data:${file.type};base64,${base64ImageData}`;
          setScanResult(data);
        } catch (err) {
          console.error("OpenRouter API call failed:", err);
          setError('Could not analyze the image. Please try again.');
        } finally {
          setIsLoading(false);
        }
      };

      const resetScan = () => {
        setImagePreview(null);
        setScanResult(null);
        setError(null);
        setSelectedMood(null);
        if (fileInputRef.current) {
          fileInputRef.current.value = '';
        }
        console.log('Scan reset');
      };



      return (
        <div className="p-6 pb-24 flex flex-col items-center">
          <header className="mb-6 text-center">
            <h1 className="text-3xl font-bold text-gray-800 dark:text-gray-200">AI Food Scanner</h1>
            <p className="text-gray-500 dark:text-gray-400">Get instant nutritional info and health tips</p>
          </header>

          <div className="w-full max-w-md mx-auto">
            <div className="bg-white dark:bg-gray-800 p-8 rounded-2xl shadow-md text-center">
              <div className="mb-6">
                <div className="w-24 h-24 mx-auto mb-4 bg-gradient-to-br from-purple-400 to-pink-500 rounded-full flex items-center justify-center">
                  <span className="text-4xl">üì∑</span>
                </div>
                <h3 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-2">Scan Your Food</h3>
                <p className="text-gray-600 dark:text-gray-400 mb-6">Take a photo of your meal and get instant nutritional analysis with personalized health tips!</p>
              </div>
              
              {imagePreview ? (
                <div className="relative w-full h-64 rounded-2xl mb-6 overflow-hidden">
                  <img src={imagePreview} alt="Meal preview" className="w-full h-full object-cover" />
                  {isLoading && (
                    <div className="absolute inset-0 bg-black/50 flex items-center justify-center text-white">
                      Analyzing...
                    </div>
                  )}
                </div>
              ) : (
                <button
                  onClick={() => fileInputRef.current.click()}
                  className="w-full bg-gradient-to-r from-purple-500 to-pink-500 text-white font-bold py-4 rounded-2xl shadow-lg hover:from-purple-600 hover:to-pink-600 transition-all transform hover:scale-105 mb-6"
                >
                  üì∑ Scan Your Meal
                </button>
              )}
              
              <div className="mt-6 p-4 bg-purple-50 dark:bg-purple-900/20 rounded-xl">
                <h4 className="font-semibold text-purple-800 dark:text-purple-200 mb-2">üí° Pro Tips:</h4>
                <ul className="text-sm text-purple-700 dark:text-purple-300 space-y-1">
                  <li>‚Ä¢ Ensure good lighting for best results</li>
                  <li>‚Ä¢ Include labels and packaging when visible</li>
                  <li>‚Ä¢ Multiple ingredients in one photo work great!</li>
                </ul>
              </div>
            </div>
            
            <input
              type="file"
              accept="image/*"
              capture="environment"
              ref={fileInputRef}
              onChange={handleImageChange}
              className="hidden"
            />

            {error && <div className="my-4 text-center text-red-500 bg-red-100 p-3 rounded-lg">{error}</div>}

            {scanResult && (
              <div className="mt-6 bg-white dark:bg-gray-800 p-6 rounded-2xl shadow-md animate-fade-in">
                <h2 className="text-2xl font-bold text-gray-800 dark:text-gray-200 mb-2">{scanResult.name}</h2>
                <p className="text-lg font-semibold text-gray-600 dark:text-gray-300 mb-4">{scanResult.total_calories} kcal</p>

                {scanResult.health_tip && (
                  <div className="mb-4 p-4 bg-yellow-100 text-yellow-800 rounded-lg flex items-start">
                    <span className="text-2xl mr-3">üí°</span>
                    <div>
                      <h3 className="font-bold">Plate Perfecter Tip</h3>
                      <p>{scanResult.health_tip}</p>
                    </div>
                  </div>
                )}

                {/* Mindful Journal Section */}
                <div className="my-4">
                  <h3 className="font-bold text-gray-700 dark:text-gray-300 mb-2 text-center">How do you feel after this meal?</h3>
                  <div className="flex justify-around">
                    {['Energized', 'Happy', 'Sluggish', 'Bloated'].map(mood => (
                      <button
                        key={mood}
                        onClick={() => setSelectedMood(mood)}
                        className={`p-2 rounded-lg border-2 ${selectedMood === mood ? 'border-pink-500' : 'border-transparent'}`}
                      >
                        <span className="text-3xl">{{ Energized: '‚ö°Ô∏è', Happy: 'üòä', Sluggish: 'üò¥', Bloated: 'ü§¢' }[mood]}</span>
                      </button>
                    ))}
                  </div>
                </div>

                <div className="space-y-3 mb-4 text-gray-800 dark:text-gray-200">
                  <h3 className="font-bold text-gray-700 dark:text-gray-300">Nutritional Summary:</h3>
                  <p><strong>Protein:</strong> {scanResult.total_protein} g</p>
                  <p><strong>Carbs:</strong> {scanResult.total_carbs} g</p>
                  <p><strong>Fat:</strong> {scanResult.total_fat} g</p>
                </div>

                {scanResult.ingredients && scanResult.ingredients.length > 0 && (
                  <div className="space-y-3 mb-4 text-gray-800 dark:text-gray-200">
                    <h3 className="font-bold text-gray-700 dark:text-gray-300">Ingredient Breakdown:</h3>
                    {scanResult.ingredients.map((item, index) => (
                      <div key={index} className="flex justify-between">
                        <span>{item.name}</span>
                        <span>{item.calories} kcal</span>
                      </div>
                    ))}
                  </div>
                )}

                <button
                  onClick={() => onLogMeal({
                    ...scanResult,
                    calories: scanResult.total_calories,
                    protein: scanResult.total_protein,
                    carbs: scanResult.total_carbs,
                    fat: scanResult.total_fat,
                    image: scanResult.image,
                    mood: selectedMood
                  })}
                  className="w-full mt-4 bg-green-500 text-white font-bold py-3 rounded-xl hover:bg-green-600 transition-colors"
                >
                  Log this Meal
                </button>
              </div>
            )}
          </div>
        </div>
      );

    };

    // Menu Decoder Component
    const MenuDecoder = ({ goals, menuState, setMenuState }) => {
      const { imagePreview, isLoading, menuItems, recommendations, error, userGoals } = menuState;
      
      const setIsLoading = (value) => setMenuState(prev => ({ ...prev, isLoading: value }));
      const setImagePreview = (value) => {
        setMenuState(prev => ({ ...prev, imagePreview: value }));
        localStorage.setItem('menuDecoder_imagePreview', value || '');
      };
      const setMenuItems = (value) => {
        setMenuState(prev => ({ ...prev, menuItems: value }));
        localStorage.setItem('menuDecoder_menuItems', JSON.stringify(value));
      };
      const setRecommendations = (value) => {
        setMenuState(prev => ({ ...prev, recommendations: value }));
        localStorage.setItem('menuDecoder_recommendations', JSON.stringify(value));
      };
      const setError = (value) => setMenuState(prev => ({ ...prev, error: value }));
      const setUserGoals = (value) => {
        setMenuState(prev => ({ ...prev, userGoals: value }));
        localStorage.setItem('menuDecoder_userGoals', value);
      };
      const fileInputRef = useRef(null);

      const fileToBase64 = (file) => new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = () => resolve(reader.result.split(',')[1]);
        reader.onerror = error => reject(error);
      });

      const resetScan = () => {
        setImagePreview(null);
        localStorage.removeItem('menuDecoder_imagePreview');
        setMenuItems(null);
        localStorage.removeItem('menuDecoder_menuItems');
        setRecommendations(null);
        localStorage.removeItem('menuDecoder_recommendations');
        setError(null);
      };

      const handleImageChange = (e) => {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = async (e) => {
            setImagePreview(e.target.result);
            try {
              const compressedImage = await compressImageForMobile(e.target.result, 300, 0.6);
              setLocalStorageWithSync('menuDecoder_imagePreview', compressedImage);
            } catch (error) {
              console.warn('Failed to store compressed image:', error);
            }
          };
          reader.readAsDataURL(file);
          setMenuItems(null);
          localStorage.removeItem('menuDecoder_menuItems');
          setRecommendations(null);
          localStorage.removeItem('menuDecoder_recommendations');
          setError(null);
          handleScan(file);
        }
      };

      const handleScan = async (file) => {
        setIsLoading(true);
        setError(null);
        try {
          const base64ImageData = await fileToBase64(file);
          const prompt = `Analyze this restaurant menu image and provide personalized recommendations.

1. Extract all visible menu items with their names, descriptions, and prices (if visible).
2. Based on the user's dietary goals: "${userGoals}" and daily calorie target of ${goals.calories} calories, analyze each item.
3. Provide specific recommendations with explanations.

Respond ONLY with a valid JSON object in this format:
{
  "menu_items": [
    {
      "name": "Item Name",
      "description": "Item description from menu",
      "price": "$X.XX or null if not visible",
      "estimated_calories": 000,
      "health_score": 1-10,
      "recommendation_reason": "Why this fits or doesn't fit user goals"
    }
  ],
  "top_recommendations": [
    {
      "item_name": "Best Item Name",
      "why_recommended": "Detailed explanation",
      "modification_tip": "Optional suggestion to make it healthier"
    }
  ],
  "items_to_avoid": [
    {
      "item_name": "Item to avoid",
      "why_avoid": "Reason why it doesn't fit goals"
    }
  ]
}`;

          const payload = {
            contents: [
              {
                parts: [
                  { text: prompt },
                  { inlineData: { mimeType: file.type, data: base64ImageData } }
                ]
              }
            ],
          };

          // Use Direct OpenRouter (Qwen)
          const response = await fetch(getDirectGeminiConfig().url, {
            method: 'POST',
            headers: getDirectGeminiConfig().headers,
            body: JSON.stringify({
              model: OPENROUTER_QWEN_VL_MODEL,
              messages: [{
                role: 'user',
                content: [
                  { type: 'text', text: prompt },
                  { type: 'image_url', image_url: `data:${file.type};base64,${base64ImageData}` }
                ]
              }]
            })
          });

          if (!response.ok) {
            throw new Error(`API Error: ${response.status} ${response.statusText}`);
          }

          const result = await response.json();
          const textResponse = (result.choices?.[0]?.message?.content || '');
          const jsonString = textResponse.replace(/```json|```/g, '').trim();
          const data = JSON.parse(jsonString);
          setMenuItems(data.menu_items);
          localStorage.setItem('menuDecoder_menuItems', JSON.stringify(data.menu_items));
          setRecommendations({
            top: data.top_recommendations,
            avoid: data.items_to_avoid
          });
          localStorage.setItem('menuDecoder_recommendations', JSON.stringify({
            top: data.top_recommendations,
            avoid: data.items_to_avoid
          }));
        } catch (err) {
          console.error("Menu analysis failed:", err);
          setError('Could not analyze menu. Please try again with a clearer image.');
        } finally {
          setIsLoading(false);
        }
      };

      return (
        <div className="p-6 pb-24">
          <header className="mb-6 text-center">
            <h1 className="text-3xl font-bold text-gray-800 dark:text-gray-200">üçΩÔ∏è Menu Decoder</h1>
            <p className="text-gray-500 dark:text-gray-400">Smart dining choices made easy!</p>
          </header>

          {!imagePreview && (
            <div className="max-w-md mx-auto">
              {/* Goals Input */}
              <div className="bg-white dark:bg-gray-800 p-4 rounded-2xl shadow-md mb-4">
                <h3 className="font-semibold text-gray-800 dark:text-gray-200 mb-2">Your Dining Goals:</h3>
                <input
                  type="text"
                  value={userGoals}
                  onChange={(e) => {
                    setUserGoals(e.target.value);
                    localStorage.setItem('menuDecoder_userGoals', e.target.value);
                  }}
                  placeholder="e.g., high protein, low carb, heart healthy"
                  className="w-full p-3 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200"
                />
              </div>

              <div className="bg-white dark:bg-gray-800 p-8 rounded-2xl shadow-md text-center">
                <div className="mb-6">
                  <div className="w-24 h-24 mx-auto mb-4 bg-gradient-to-br from-orange-400 to-red-500 rounded-full flex items-center justify-center">
                    <span className="text-4xl">üçΩÔ∏è</span>
                  </div>
                  <h3 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-2">Scan Restaurant Menu</h3>
                  <p className="text-gray-600 dark:text-gray-400 mb-6">Take a photo of any restaurant menu and I'll highlight the healthiest options for your goals!</p>
                </div>
                
                <input
                  type="file"
                  accept="image/*"
                  capture="environment"
                  onChange={handleImageChange}
                  ref={fileInputRef}
                  className="hidden"
                />
                
                <button
                  onClick={() => fileInputRef.current?.click()}
                  className="w-full bg-gradient-to-r from-orange-500 to-red-500 text-white font-bold py-4 rounded-2xl shadow-lg hover:from-orange-600 hover:to-red-600 transition-all transform hover:scale-105"
                >
                  üì∑ Scan Menu
                </button>
                
                <div className="mt-6 p-4 bg-orange-50 dark:bg-orange-900/20 rounded-xl">
                  <h4 className="font-semibold text-orange-800 dark:text-orange-200 mb-2">üí° Pro Tips:</h4>
                  <ul className="text-sm text-orange-700 dark:text-orange-300 space-y-1">
                    <li>‚Ä¢ Ensure menu text is clearly visible</li>
                    <li>‚Ä¢ Include item descriptions when possible</li>
                    <li>‚Ä¢ Works with any restaurant menu!</li>
                  </ul>
                </div>
              </div>
            </div>
          )}

          {imagePreview && (
            <div className="max-w-md mx-auto">
              <div className="bg-white dark:bg-gray-800 rounded-2xl shadow-md overflow-hidden">
                <img src={imagePreview} alt="Restaurant menu" className="w-full h-64 object-cover" />
                
                {isLoading && (
                  <div className="p-6 text-center">
                    <div className="animate-spin w-8 h-8 border-4 border-orange-500 border-t-transparent rounded-full mx-auto mb-4"></div>
                    <p className="text-gray-600 dark:text-gray-400">Analyzing menu options...</p>
                  </div>
                )}

                {error && (
                  <div className="p-6 text-center">
                    <p className="text-red-500 mb-4">{error}</p>
                    <button onClick={resetScan} className="bg-gray-500 text-white px-4 py-2 rounded-lg">
                      Try Again
                    </button>
                  </div>
                )}

                {recommendations && (
                  <div className="p-6">
                    <div className="flex justify-between items-center mb-4">
                      <h3 className="font-bold text-gray-800 dark:text-gray-200">üéØ Smart Recommendations</h3>
                      <button onClick={resetScan} className="text-orange-500 font-semibold text-sm">
                        ‚Üê New Menu
                      </button>
                    </div>
                    
                    {/* Top Recommendations */}
                    {recommendations.top && recommendations.top.length > 0 && (
                      <div className="mb-6">
                        <h4 className="font-semibold text-green-600 dark:text-green-400 mb-3">‚úÖ Best Choices for You:</h4>
                        <div className="space-y-3">
                          {recommendations.top.map((rec, index) => (
                            <div key={index} className="bg-green-50 dark:bg-green-900/20 p-4 rounded-lg border-l-4 border-green-500">
                              <h5 className="font-bold text-gray-800 dark:text-gray-200">{rec.item_name}</h5>
                              <p className="text-sm text-gray-600 dark:text-gray-400 mt-1">{rec.why_recommended}</p>
                              {rec.modification_tip && (
                                <p className="text-sm text-green-700 dark:text-green-300 mt-2 font-medium">
                                  üí° Tip: {rec.modification_tip}
                                </p>
                              )}
                            </div>
                          ))}
                        </div>
                      </div>
                    )}

                    {/* Items to Avoid */}
                    {recommendations.avoid && recommendations.avoid.length > 0 && (
                      <div className="mb-6">
                        <h4 className="font-semibold text-red-600 dark:text-red-400 mb-3">‚ö†Ô∏è Consider Avoiding:</h4>
                        <div className="space-y-3">
                          {recommendations.avoid.map((avoid, index) => (
                            <div key={index} className="bg-red-50 dark:bg-red-900/20 p-4 rounded-lg border-l-4 border-red-500">
                              <h5 className="font-bold text-gray-800 dark:text-gray-200">{avoid.item_name}</h5>
                              <p className="text-sm text-gray-600 dark:text-gray-400 mt-1">{avoid.why_avoid}</p>
                            </div>
                          ))}
                        </div>
                      </div>
                    )}

                    {/* All Menu Items */}
                    {menuItems && menuItems.length > 0 && (
                      <div>
                        <h4 className="font-semibold text-gray-800 dark:text-gray-200 mb-3">üìã All Menu Items:</h4>
                        <div className="space-y-2">
                          {menuItems.map((item, index) => (
                            <div key={index} className="bg-gray-50 dark:bg-gray-700 p-3 rounded-lg">
                              <div className="flex justify-between items-start">
                                <div className="flex-1">
                                  <h5 className="font-semibold text-gray-800 dark:text-gray-200">{item.name}</h5>
                                  {item.description && (
                                    <p className="text-sm text-gray-600 dark:text-gray-400 mt-1">{item.description}</p>
                                  )}
                                  <p className="text-xs text-gray-500 dark:text-gray-500 mt-1">{item.recommendation_reason}</p>
                                </div>
                                <div className="text-right ml-3">
                                  {item.price && (
                                    <p className="font-semibold text-gray-800 dark:text-gray-200">{item.price}</p>
                                  )}
                                  <div className="flex items-center mt-1">
                                    <span className={`text-xs px-2 py-1 rounded-full ${
                                      item.health_score >= 8 ? 'bg-green-200 text-green-800 dark:bg-green-800 dark:text-green-200' :
                                      item.health_score >= 6 ? 'bg-yellow-200 text-yellow-800 dark:bg-yellow-800 dark:text-yellow-200' :
                                      'bg-red-200 text-red-800 dark:bg-red-800 dark:text-red-200'
                                    }`}>
                                      {item.health_score}/10
                                    </span>
                                  </div>
                                  <p className="text-xs text-gray-500 dark:text-gray-500 mt-1">~{item.estimated_calories} cal</p>
                                </div>
                              </div>
                            </div>
                          ))}
                        </div>
                      </div>
                    )}
                  </div>
                )}
              </div>
            </div>
          )}
        </div>
      );
    };

    // Smart Pantry Chef Component
    const SmartPantryChef = ({ goals, pantryState, setPantryState }) => {
      const { isLoading, ingredients, recipes, error, imagePreview } = pantryState;
      
      const setIsLoading = (value) => setPantryState(prev => ({ ...prev, isLoading: value }));
      const setIngredients = (value) => {
        setPantryState(prev => ({ ...prev, ingredients: value }));
        localStorage.setItem('pantryChef_ingredients', JSON.stringify(value));
      };
      const setRecipes = (value) => {
        setPantryState(prev => ({ ...prev, recipes: value }));
        localStorage.setItem('pantryChef_recipes', JSON.stringify(value));
      };
      const setError = (value) => setPantryState(prev => ({ ...prev, error: value }));
      const setImagePreview = (value) => {
        setPantryState(prev => ({ ...prev, imagePreview: value }));
        localStorage.setItem('pantryChef_imagePreview', value || '');
      };
      const fileInputRef = useRef(null);

      const fileToBase64 = (file) => new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = () => resolve(reader.result.split(',')[1]);
        reader.onerror = error => reject(error);
      });

      const handleImageChange = (event) => {
        const file = event.target.files[0];
        if (file) {
          const previewUrl = URL.createObjectURL(file);
          setImagePreview(previewUrl);
          
          // Store compressed image data for persistence across refreshes
          const reader = new FileReader();
          reader.onload = async (e) => {
            try {
              const compressedImage = await compressImageForMobile(e.target.result, 300, 0.6);
              setLocalStorageWithSync('pantryChef_imagePreview', compressedImage);
            } catch (error) {
              console.warn('Failed to store compressed image:', error);
            }
          };
          reader.readAsDataURL(file);
          
          setIngredients(null);
          localStorage.removeItem('pantryChef_ingredients');
          setRecipes(null);
          localStorage.removeItem('pantryChef_recipes');
          setError(null);
          handleScan(file);
        }
      };

      const handleScan = async (file) => {
        // Safety check - if already loading, don't start again
        if (isLoading) return;
        
        setIsLoading(true);
        setError(null);
        
        // Add manual timeout to prevent freezing
        const timeoutId = setTimeout(() => {
          console.warn('Scan timeout triggered - resetting component');
          setIsLoading(false);
          setError('Request timed out. Please try scanning again.');
          // Force clear any stuck state
          localStorage.removeItem('pantryChef_ingredients');
          localStorage.removeItem('pantryChef_recipes');
        }, 30000); // 30 second backup timeout
        
        try {
          const base64ImageData = await fileToBase64(file);
          const prompt = `Analyze this image of pantry/fridge ingredients.
1. Identify all visible food items and ingredients.
2. List them clearly with estimated quantities if visible.
3. Respond ONLY with a valid JSON object in this format:
{
  "ingredients": [
    {"name": "Ingredient Name", "quantity": "estimated amount or 'available'"},
    {"name": "Another Ingredient", "quantity": "estimated amount or 'available'"}
  ]
}`;

          const payload = {
            contents: [
              {
                parts: [
                  { text: prompt },
                  { inlineData: { mimeType: file.type, data: base64ImageData } }
                ]
              }
            ],
          };

          const response = await fetch(getDirectGeminiConfig().url, {
            method: 'POST',
            headers: getDirectGeminiConfig().headers,
            body: JSON.stringify({
              model: OPENROUTER_QWEN_VL_MODEL,
              messages: [{
                role: 'user',
                content: [
                  { type: 'text', text: prompt },
                  { type: 'image_url', image_url: `data:${file.type};base64,${base64ImageData}` }
                ]
              }]
            }),
            signal: AbortSignal.timeout(25000) // 25 second timeout
          });

          if (!response.ok) {
            throw new Error(`API Error: ${response.status} ${response.statusText}`);
          }

          const result = await response.json();
          const textResponse = (result.choices?.[0]?.message?.content || '');
          const jsonString = textResponse.replace(/```json|```/g, '').trim();
          const data = JSON.parse(jsonString);
          setIngredients(data.ingredients);
          localStorage.setItem('pantryChef_ingredients', JSON.stringify(data.ingredients));
          clearTimeout(timeoutId); // Clear timeout on success
        } catch (err) {
          console.error("Ingredient recognition failed:", err);
          setError('Could not identify ingredients. Please try again.');
          clearTimeout(timeoutId); // Clear timeout on error
        } finally {
          setIsLoading(false);
        }
      };

      const generateRecipes = async () => {
        if (!ingredients || ingredients.length === 0) return;
        
        // Safety check - if already loading, don't start again
        if (isLoading) return;
        
        setIsLoading(true);
        setError(null);
        
        // Add manual timeout to prevent freezing
        const timeoutId = setTimeout(() => {
          console.warn('Recipe generation timeout triggered - resetting component');
          setIsLoading(false);
          setError('Recipe generation timed out. Please try again.');
          // Force clear any stuck state
          localStorage.removeItem('pantryChef_recipes');
        }, 30000); // 30 second backup timeout
        
        try {
          const ingredientList = ingredients.map(ing => ing.name).join(', ');
          const prompt = `Create 3 quick recipes using: ${ingredientList}. Keep under ${goals.calories} calories. JSON only: {"recipes":[{"name":"Recipe","prep_time":"15 min","cook_time":"20 min","servings":2,"calories_per_serving":350,"ingredients_used":["ingredient1"],"instructions":["Step 1"],"nutrition":{"protein":25,"carbs":30,"fat":15}}]}`;

          const response = await fetch(getDirectGeminiConfig().url, {
            method: 'POST',
            headers: getDirectGeminiConfig().headers,
            body: JSON.stringify({
              model: OPENROUTER_QWEN_MODEL,
              messages: [{ role: 'user', content: prompt }]
            })
          });

          if (!response.ok) {
            throw new Error(`API Error: ${response.status} ${response.statusText}`);
          }

          const result = await response.json();
          const textResponse = (result.choices?.[0]?.message?.content || '');
          const jsonString = textResponse.replace(/```json|```/g, '').trim();
          const data = JSON.parse(jsonString);
          setRecipes(data.recipes);
          localStorage.setItem('pantryChef_recipes', JSON.stringify(data.recipes));
          clearTimeout(timeoutId); // Clear timeout on success
        } catch (err) {
          console.error("Recipe generation failed:", err);
          setError('Could not generate recipes. Please try again.');
          clearTimeout(timeoutId); // Clear timeout on error
        } finally {
          setIsLoading(false);
        }
      };

      const resetScan = () => {
        setImagePreview(null);
        localStorage.removeItem('pantryChef_imagePreview');
        setIngredients(null);
        localStorage.removeItem('pantryChef_ingredients');
        setRecipes(null);
        localStorage.removeItem('pantryChef_recipes');
        setError(null);
        if (fileInputRef.current) {
          fileInputRef.current.value = '';
        }
      };

      return (
        <div className="p-6 pb-24">
          <header className="mb-6 text-center">
            <h1 className="text-3xl font-bold text-gray-800 dark:text-gray-200">üßë‚Äçüç≥ Smart Pantry Chef</h1>
            <p className="text-gray-500 dark:text-gray-400">Snap your ingredients, get instant recipes!</p>
          </header>

          {!imagePreview && (
            <div className="max-w-md mx-auto">
              <div className="bg-white dark:bg-gray-800 p-8 rounded-2xl shadow-md text-center">
                <div className="mb-6">
                  <div className="w-24 h-24 mx-auto mb-4 bg-gradient-to-br from-green-400 to-blue-500 rounded-full flex items-center justify-center">
                    <span className="text-4xl">üì∏</span>
                  </div>
                  <h3 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-2">Scan Your Pantry</h3>
                  <p className="text-gray-600 dark:text-gray-400 mb-6">Take a photo of your fridge or pantry ingredients and I'll suggest recipes you can make right now!</p>
                </div>
                
                <input
                  type="file"
                  accept="image/*"
                  capture="environment"
                  onChange={handleImageChange}
                  ref={fileInputRef}
                  className="hidden"
                />
                
                <button
                  onClick={() => fileInputRef.current?.click()}
                  className="w-full bg-gradient-to-r from-green-500 to-blue-500 text-white font-bold py-4 rounded-2xl shadow-lg hover:from-green-600 hover:to-blue-600 transition-all transform hover:scale-105"
                >
                  üì∑ Scan Ingredients
                </button>
                
                <div className="mt-6 p-4 bg-blue-50 dark:bg-blue-900/20 rounded-xl">
                  <h4 className="font-semibold text-blue-800 dark:text-blue-200 mb-2">üí° Pro Tips:</h4>
                  <ul className="text-sm text-blue-700 dark:text-blue-300 space-y-1">
                    <li>‚Ä¢ Ensure good lighting for best results</li>
                    <li>‚Ä¢ Include labels and packaging when visible</li>
                    <li>‚Ä¢ Multiple ingredients in one photo work great!</li>
                  </ul>
                </div>
              </div>
            </div>
          )}

          {imagePreview && (
            <div className="max-w-md mx-auto">
              <div className="bg-white dark:bg-gray-800 rounded-2xl shadow-md overflow-hidden">
                <img src={imagePreview} alt="Scanned ingredients" className="w-full h-64 object-cover" />
                
                {isLoading && (
                  <div className="p-6 text-center">
                    <div className="animate-spin w-8 h-8 border-4 border-pink-500 border-t-transparent rounded-full mx-auto mb-4"></div>
                    <p className="text-gray-600 dark:text-gray-400 mb-4">
                      {!ingredients ? 'Identifying ingredients...' : 'Generating recipes...'}
                    </p>
                    <button 
                      onClick={() => {
                        setIsLoading(false);
                        setError('Process cancelled. You can try again.');
                      }}
                      className="text-sm bg-red-500 text-white px-4 py-2 rounded-lg hover:bg-red-600 transition-colors"
                    >
                      Cancel & Reset
                    </button>
                  </div>
                )}

                {error && (
                  <div className="p-6 text-center">
                    <p className="text-red-500 mb-4">{error}</p>
                    <button onClick={resetScan} className="bg-gray-500 text-white px-4 py-2 rounded-lg">
                      Try Again
                    </button>
                  </div>
                )}

                {ingredients && !recipes && !isLoading && (
                  <div className="p-6">
                    <h3 className="font-bold text-gray-800 dark:text-gray-200 mb-4">ü•ò Ingredients Found:</h3>
                    <div className="space-y-2 mb-6">
                      {ingredients.map((ingredient, index) => (
                        <div key={index} className="flex justify-between items-center p-2 bg-gray-50 dark:bg-gray-700 rounded-lg">
                          <span className="text-gray-800 dark:text-gray-200">{ingredient.name}</span>
                          <span className="text-sm text-gray-500 dark:text-gray-400">{ingredient.quantity}</span>
                        </div>
                      ))}
                    </div>
                    
                    <div className="space-y-3">
                      <button
                        onClick={generateRecipes}
                        className="w-full bg-green-500 text-white font-bold py-3 rounded-xl hover:bg-green-600 transition-colors"
                      >
                        üç≥ Get Recipe Ideas
                      </button>
                      
                      <button
                        onClick={resetScan}
                        className="w-full bg-gray-500 text-white font-bold py-2 rounded-xl hover:bg-gray-600 transition-colors"
                      >
                        üì∏ Scan Different Ingredients
                      </button>
                    </div>
                  </div>
                )}

                {recipes && (
                  <div className="p-6">
                    <div className="flex justify-between items-center mb-4">
                      <h3 className="font-bold text-gray-800 dark:text-gray-200">üçΩÔ∏è Recipe Suggestions</h3>
                      <button onClick={resetScan} className="text-pink-500 font-semibold text-sm">
                        ‚Üê New Scan
                      </button>
                    </div>
                    
                    <div className="space-y-4">
                      {recipes.map((recipe, index) => (
                        <RecipeCard key={index} recipe={recipe} />
                      ))}
                    </div>
                  </div>
                )}
              </div>
            </div>
          )}
        </div>
      );
    };

    // Recipe Card Component for Smart Pantry Chef
    const RecipeCard = ({ recipe }) => {
      const [isExpanded, setIsExpanded] = useState(false);
      
      return (
        <div className="border border-gray-200 dark:border-gray-700 rounded-xl overflow-hidden">
          <div className="p-4 bg-gradient-to-r from-green-50 to-blue-50 dark:from-green-900/20 dark:to-blue-900/20">
            <div className="flex justify-between items-start mb-2">
              <h4 className="font-bold text-gray-800 dark:text-gray-200">{recipe.name}</h4>
              <span className="text-sm bg-green-100 dark:bg-green-800 text-green-800 dark:text-green-200 px-2 py-1 rounded-full">
                {recipe.calories_per_serving} cal
              </span>
            </div>
            
            <div className="flex gap-4 text-sm text-gray-600 dark:text-gray-400 mb-3">
              <span>‚è±Ô∏è Prep: {recipe.prep_time}</span>
              <span>üî• Cook: {recipe.cook_time}</span>
              <span>üçΩÔ∏è Serves: {recipe.servings}</span>
            </div>
            
            <div className="mb-3">
              <p className="text-sm font-semibold text-gray-700 dark:text-gray-300 mb-1">Using your ingredients:</p>
              <div className="flex flex-wrap gap-1">
                {recipe.ingredients_used.map((ing, i) => (
                  <span key={i} className="text-xs bg-green-200 dark:bg-green-700 text-green-800 dark:text-green-200 px-2 py-1 rounded-full">
                    {ing}
                  </span>
                ))}
              </div>
            </div>
            
            {recipe.additional_needed && recipe.additional_needed.length > 0 && (
              <div className="mb-3">
                <p className="text-sm font-semibold text-gray-700 dark:text-gray-300 mb-1">You might need:</p>
                <div className="flex flex-wrap gap-1">
                  {recipe.additional_needed.map((item, i) => (
                    <span key={i} className="text-xs bg-yellow-200 dark:bg-yellow-700 text-yellow-800 dark:text-yellow-200 px-2 py-1 rounded-full">
                      {item}
                    </span>
                  ))}
                </div>
              </div>
            )}
            
            <button
              onClick={() => setIsExpanded(!isExpanded)}
              className="w-full bg-white dark:bg-gray-800 text-gray-800 dark:text-gray-200 font-semibold py-2 rounded-lg border border-gray-200 dark:border-gray-600 hover:bg-gray-50 dark:hover:bg-gray-700 transition-colors"
            >
              {isExpanded ? '‚ñ≤ Hide Details' : '‚ñº View Recipe'}
            </button>
          </div>
          
          {isExpanded && (
            <div className="p-4 border-t border-gray-200 dark:border-gray-700">
              <div className="grid md:grid-cols-2 gap-4 mb-4">
                <div>
                  <h5 className="font-semibold text-gray-800 dark:text-gray-200 mb-2">Instructions:</h5>
                  <ol className="list-decimal list-inside text-sm text-gray-600 dark:text-gray-400 space-y-1">
                    {recipe.instructions.map((step, i) => (
                      <li key={i}>{step}</li>
                    ))}
                  </ol>
                </div>
                
                <div>
                  <h5 className="font-semibold text-gray-800 dark:text-gray-200 mb-2">Nutrition per serving:</h5>
                  <div className="text-sm text-gray-600 dark:text-gray-400 space-y-1">
                    <p>ü•© Protein: {recipe.nutrition.protein}g</p>
                    <p>üçû Carbs: {recipe.nutrition.carbs}g</p>
                    <p>ü•ë Fat: {recipe.nutrition.fat}g</p>
                  </div>
                </div>
              </div>
              
              {recipe.health_tip && (
                <div className="bg-blue-50 dark:bg-blue-900/20 p-3 rounded-lg">
                  <h5 className="font-semibold text-blue-800 dark:text-blue-200 mb-1">üí° Health Tip:</h5>
                  <p className="text-sm text-blue-700 dark:text-blue-300">{recipe.health_tip}</p>
                </div>
              )}
            </div>
          )}
        </div>
      );
    };

    // Reusable Voice Button Component
    const VoiceButton = ({ text, buttonId, label, className = "" }) => {
      const [isPlaying, setIsPlaying] = useState(false);
      
      const handleVoiceControl = () => {
        const action = speechController.speak(text, buttonId);
        setIsPlaying(action === 'play');
        
        // Monitor speech end
        const checkEnd = setInterval(() => {
          if (!speechController.isActuallyPlaying() || speechController.activeButton !== buttonId) {
            setIsPlaying(false);
            clearInterval(checkEnd);
          }
        }, 500);
        
        // Cleanup after 2 minutes
        setTimeout(() => clearInterval(checkEnd), 120000);
      };
      
      return (
        <button
          onClick={handleVoiceControl}
          className={`inline-flex items-center px-3 py-2 text-sm font-medium rounded-md transition-colors ${
            isPlaying 
              ? 'bg-red-500 hover:bg-red-600 text-white' 
              : 'bg-blue-500 hover:bg-blue-600 text-white'
          } ${className}`}
        >
          {isPlaying ? '‚èπÔ∏è Stop' : 'üîä'} {label}
        </button>
      );
    };

    // Individual Meal Voice Button Component
    const MealVoiceButton = ({ meal, mealType, buttonId }) => {
      const [isPlaying, setIsPlaying] = useState(false);
      
      useEffect(() => {
        const checkStatus = () => {
          const actuallyPlaying = speechController.activeButton === buttonId && speechController.isActuallyPlaying();
          if (isPlaying !== actuallyPlaying) {
            setIsPlaying(actuallyPlaying);
          }
        };
        
        const interval = setInterval(checkStatus, 500);
        return () => clearInterval(interval);
      }, [buttonId, isPlaying]);
      
      const handleVoiceControl = () => {
        let text = `${mealType}: ${meal.name}. `;
        text += "Ingredients: " + meal.ingredients.join(", ") + ". ";
        text += "Instructions: " + meal.instructions.join(". ") + ".";
        
        const action = speechController.speak(text, buttonId);
        setIsPlaying(action === 'play');
      };
      
      return (
        <button
          onClick={handleVoiceControl}
          className={`w-full mb-3 py-2 px-4 rounded-lg font-medium transition-all duration-200 ${
            isPlaying 
              ? 'bg-red-500 hover:bg-red-600 text-white' 
              : 'bg-blue-500 hover:bg-blue-600 text-white'
          }`}
        >
          {isPlaying ? '‚èπÔ∏è Stop Reading' : `üîä Read ${mealType}`}
        </button>
      );
    };

    // Full Meal Plan Voice Button Component
    const MealPlanVoiceButton = ({ mealPlan }) => {
      const [isPlaying, setIsPlaying] = useState(false);
      const buttonId = 'full-meal-plan';
      
      useEffect(() => {
        const checkStatus = () => {
          const actuallyPlaying = speechController.activeButton === buttonId && speechController.isActuallyPlaying();
          if (isPlaying !== actuallyPlaying) {
            setIsPlaying(actuallyPlaying);
          }
        };
        
        const interval = setInterval(checkStatus, 500);
        return () => clearInterval(interval);
      }, [isPlaying]);
      
      const handleVoiceControl = () => {
        let text = "Here is your complete meal plan. ";
        
        // Breakfast
        text += `For breakfast, you will have ${mealPlan.breakfast.name}. `;
        text += "Ingredients needed: " + mealPlan.breakfast.ingredients.join(", ") + ". ";
        text += "Instructions: " + mealPlan.breakfast.instructions.join(". ") + ". ";
        
        // Lunch
        text += `For lunch, you will have ${mealPlan.lunch.name}. `;
        text += "Ingredients needed: " + mealPlan.lunch.ingredients.join(", ") + ". ";
        text += "Instructions: " + mealPlan.lunch.instructions.join(". ") + ". ";
        
        // Dinner
        text += `For dinner, you will have ${mealPlan.dinner.name}. `;
        text += "Ingredients needed: " + mealPlan.dinner.ingredients.join(", ") + ". ";
        text += "Instructions: " + mealPlan.dinner.instructions.join(". ") + ". ";
        
        text += "Enjoy your healthy meals!";
        
        const action = speechController.speak(text, buttonId);
        setIsPlaying(action === 'play');
      };
      
      return (
        <button
          onClick={handleVoiceControl}
          className={`mb-4 mx-auto block py-3 px-6 rounded-xl font-semibold transition-all duration-200 ${
            isPlaying 
              ? 'bg-red-500 hover:bg-red-600 text-white' 
              : 'bg-gradient-to-r from-blue-500 to-purple-500 hover:from-blue-600 hover:to-purple-600 text-white'
          }`}
        >
          {isPlaying ? '‚èπÔ∏è Stop Reading Full Plan' : 'üîä Read Complete Meal Plan'}
        </button>
      );
    };

    // Individual Exercise Voice Button Component
    const ExerciseVoiceButton = ({ exercise, index }) => {
      const [isPlaying, setIsPlaying] = useState(false);
      const buttonId = `exercise-${index}`;
      
      useEffect(() => {
        const checkStatus = () => {
          const actuallyPlaying = speechController.activeButton === buttonId && speechController.isActuallyPlaying();
          if (isPlaying !== actuallyPlaying) {
            setIsPlaying(actuallyPlaying);
          }
        };
        
        const interval = setInterval(checkStatus, 500);
        return () => clearInterval(interval);
      }, [buttonId, isPlaying]);
      
      const handleVoiceControl = () => {
        let text = `Exercise ${index + 1}: ${exercise.name}. `;
        text += `You will do ${exercise.sets} sets of ${exercise.reps} repetitions. `;
        text += `Instructions: ${exercise.instructions}.`;
        
        const action = speechController.speak(text, buttonId);
        setIsPlaying(action === 'play');
      };
      
      return (
        <button
          onClick={handleVoiceControl}
          className={`w-full mb-2 py-2 px-3 rounded-lg text-sm font-medium transition-all duration-200 ${
            isPlaying 
              ? 'bg-red-500 hover:bg-red-600 text-white' 
              : 'bg-blue-500 hover:bg-blue-600 text-white'
          }`}
        >
          {isPlaying ? '‚èπÔ∏è Stop' : `üîä Read Exercise ${index + 1}`}
        </button>
      );
    };

    // Full Workout Plan Voice Button Component
    const WorkoutPlanVoiceButton = ({ workoutPlan }) => {
      const [isPlaying, setIsPlaying] = useState(false);
      const buttonId = 'full-workout-plan';
      
      useEffect(() => {
        const checkStatus = () => {
          const actuallyPlaying = speechController.activeButton === buttonId && speechController.isActuallyPlaying();
          if (isPlaying !== actuallyPlaying) {
            setIsPlaying(actuallyPlaying);
          }
        };
        
        const interval = setInterval(checkStatus, 500);
        return () => clearInterval(interval);
      }, [isPlaying]);
      
      const handleVoiceControl = () => {
        let text = "Here is your complete workout plan. ";
        
        workoutPlan.exercises.forEach((exercise, index) => {
          text += `Exercise ${index + 1}: ${exercise.name}. `;
          text += `You will do ${exercise.sets} sets of ${exercise.reps} repetitions. `;
          text += `Instructions: ${exercise.instructions}. `;
        });
        
        text += "Great job on your workout plan!";
        
        const action = speechController.speak(text, buttonId);
        setIsPlaying(action === 'play');
      };
      
      return (
        <button
          onClick={handleVoiceControl}
          className={`mb-4 mx-auto block py-3 px-6 rounded-xl font-semibold transition-all duration-200 ${
            isPlaying 
              ? 'bg-red-500 hover:bg-red-600 text-white' 
              : 'bg-gradient-to-r from-blue-500 to-purple-500 hover:from-blue-600 hover:to-purple-600 text-white'
          }`}
        >
          {isPlaying ? '‚èπÔ∏è Stop Reading Full Plan' : 'üîä Read Complete Workout'}
        </button>
      );
    };

    // Meal Planner Screen Component
    const MealPlanner = ({ goals, mealPlan, setMealPlan, isLoading, setIsLoading, error, setError }) => {
      const [activeTab, setActiveTab] = useState('planner'); // 'planner', 'pantry', or 'menu'
      const [preferences, setPreferences] = useState({ cuisine: '', diet: '', calories: goals.calories, allergies: [] });
      
      // State to persist Smart Pantry Chef and Menu Decoder data
      const [pantryState, setPantryState] = useState(() => {
        const savedIngredients = localStorage.getItem('pantryChef_ingredients');
        const savedRecipes = localStorage.getItem('pantryChef_recipes');
        const savedImagePreview = localStorage.getItem('pantryChef_imagePreview');
        return {
          isLoading: false,
          ingredients: savedIngredients ? JSON.parse(savedIngredients) : null,
          recipes: savedRecipes ? JSON.parse(savedRecipes) : null,
          error: null,
          imagePreview: savedImagePreview || null
        };
      });
      
      const [menuState, setMenuState] = useState(() => {
        const savedMenuItems = localStorage.getItem('menuDecoder_menuItems');
        const savedRecommendations = localStorage.getItem('menuDecoder_recommendations');
        const savedImagePreview = localStorage.getItem('menuDecoder_imagePreview');
        const savedUserGoals = localStorage.getItem('menuDecoder_userGoals');
        return {
          isLoading: false,
          menuItems: savedMenuItems ? JSON.parse(savedMenuItems) : null,
          recommendations: savedRecommendations ? JSON.parse(savedRecommendations) : null,
          error: null,
          imagePreview: savedImagePreview || null,
          userGoals: savedUserGoals || 'high protein, low carb'
        };
      });

      const handlePreferenceChange = (key, value) => {
        setPreferences(prev => ({ ...prev, [key]: value }));
      };

      const handleAllergyChange = (allergy) => {
        setPreferences(prev => {
          const newAllergies = prev.allergies.includes(allergy)
            ? prev.allergies.filter(a => a !== allergy)
            : [...prev.allergies, allergy];
          return { ...prev, allergies: newAllergies };
        });
      };

      const generateMealPlan = async () => {
        setIsLoading(true);
        setError(null);
        setMealPlan(null);
        try {
          const prompt = `Create a ${preferences.diet || 'Standard'} ${preferences.cuisine || 'Any'} meal plan for ${preferences.calories} calories.
Allergies: ${preferences.allergies.join(', ') || 'None'}

Respond ONLY with a valid JSON object in this exact format:
{
  "breakfast": {"name": "Meal Name", "ingredients": ["ingredient1", "ingredient2"], "instructions": ["step1", "step2"]},
  "lunch": {"name": "Meal Name", "ingredients": ["ingredient1", "ingredient2"], "instructions": ["step1", "step2"]},
  "dinner": {"name": "Meal Name", "ingredients": ["ingredient1", "ingredient2"], "instructions": ["step1", "step2"]}
}`;

          const response = await fetch(getDirectGeminiConfig().url, {
            method: 'POST',
            headers: getDirectGeminiConfig().headers,
            body: JSON.stringify({
              model: OPENROUTER_QWEN_MODEL,
              messages: [{ role: 'user', content: prompt }]
            }),
            signal: AbortSignal.timeout(25000) // 25 second timeout
          });

          if (!response.ok) {
            throw new Error(`API Error: ${response.status} ${response.statusText}`);
          }

          const result = await response.json();
          const textResponse = (result.choices?.[0]?.message?.content || '');
          
          // Better JSON extraction and validation
          let jsonString = textResponse.replace(/```json|```/g, '').trim();
          
          // Remove any text before the first { and after the last }
          const firstBrace = jsonString.indexOf('{');
          const lastBrace = jsonString.lastIndexOf('}');
          
          if (firstBrace !== -1 && lastBrace !== -1) {
            jsonString = jsonString.substring(firstBrace, lastBrace + 1);
          }
          
          const data = JSON.parse(jsonString);
          
          // Validate the structure
          if (!data.breakfast || !data.lunch || !data.dinner) {
            throw new Error('Invalid meal plan structure');
          }
          
          setMealPlan(data);
        } catch (err) {
          console.error("Meal plan generation failed:", err);
          setError("Could not generate a meal plan. Please try again.");
        } finally {
          setIsLoading(false);
        }
      };

      return (
        <div className="p-6 pb-24">
          <header className="mb-6 text-center">
            <h1 className="text-3xl font-bold text-gray-800 dark:text-gray-200">Meal Planning</h1>
            <p className="text-gray-500 dark:text-gray-400">Plan meals, use ingredients, or decode menus</p>
          </header>

          {/* Tab Navigation */}
          <div className="flex mb-6 bg-gray-100 dark:bg-gray-800 rounded-2xl p-1 max-w-lg mx-auto">
            <button
              onClick={() => setActiveTab('planner')}
              className={`flex-1 py-3 px-2 rounded-xl font-semibold transition-all text-sm ${
                activeTab === 'planner'
                  ? 'bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 shadow-md'
                  : 'text-gray-600 dark:text-gray-400'
              }`}
            >
              üìã Planner
            </button>
            <button
              onClick={() => setActiveTab('pantry')}
              className={`flex-1 py-3 px-2 rounded-xl font-semibold transition-all text-sm ${
                activeTab === 'pantry'
                  ? 'bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 shadow-md'
                  : 'text-gray-600 dark:text-gray-400'
              }`}
            >
              üßë‚Äçüç≥ Pantry
            </button>
            <button
              onClick={() => setActiveTab('menu')}
              className={`flex-1 py-3 px-2 rounded-xl font-semibold transition-all text-sm ${
                activeTab === 'menu'
                  ? 'bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 shadow-md'
                  : 'text-gray-600 dark:text-gray-400'
              }`}
            >
              üçΩÔ∏è Menu
            </button>
          </div>

          {/* Tab Content */}
          {activeTab === 'planner' && (
            <div>
              {!mealPlan && (
                <div className="max-w-md mx-auto">
                  <div className="bg-white dark:bg-gray-800 p-6 rounded-2xl shadow-md space-y-4">
                    <div>
                      <h3 className="font-semibold mb-2 text-gray-800 dark:text-gray-200">Cuisine Type</h3>
                      <div className="grid grid-cols-2 sm:grid-cols-3 gap-2">
                        {['International', 'Indian', 'Mediterranean', 'Asian', 'Mexican', 'Italian'].map(c => (
                          <button
                            key={c}
                            onClick={() => handlePreferenceChange('cuisine', c)}
                            className={`p-2 rounded-lg border dark:border-gray-700 text-xs sm:text-sm font-medium min-h-[2.5rem] flex items-center justify-center ${
                              preferences.cuisine === c ? 'bg-pink-500 text-white' : 'bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200'
                            }`}
                          >
                            <span className="text-center leading-tight">{c}</span>
                          </button>
                        ))}
                      </div>
                    </div>

                    <div>
                      <h3 className="font-semibold mb-2 text-gray-800 dark:text-gray-200">Diet Type</h3>
                      <div className="grid grid-cols-3 gap-2">
                        {['Veg', 'Non-Veg', 'Vegan'].map(d => (
                          <button
                            key={d}
                            onClick={() => handlePreferenceChange('diet', d)}
                            className={`p-2 rounded-lg border dark:border-gray-700 ${preferences.diet === d ? 'bg-pink-500 text-white' : 'bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200'}`}
                          >
                            {d}
                          </button>
                        ))}
                      </div>
                    </div>

                    <div>
                      <h3 className="font-semibold mb-2 text-gray-800 dark:text-gray-200">Daily Calorie Target: {preferences.calories} kcal</h3>
                      <input type="range" min="1200" max="4000" step="50" value={preferences.calories} onChange={e => handlePreferenceChange('calories', e.target.value)} className="w-full" />
                    </div>

                    <div>
                      <h3 className="font-semibold mb-2 text-gray-800 dark:text-gray-200">Allergies & Restrictions</h3>
                      <div className="grid grid-cols-3 gap-2">
                        {['Nuts', 'Dairy', 'Gluten', 'Eggs', 'Seafood', 'Soy'].map(a => (
                          <button
                            key={a}
                            onClick={() => handleAllergyChange(a)}
                            className={`p-2 rounded-lg border dark:border-gray-700 ${preferences.allergies.includes(a) ? 'bg-pink-500 text-white' : 'bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200'}`}
                          >
                            {a}
                          </button>
                        ))}
                      </div>
                    </div>
                  </div>

                  <button
                    onClick={generateMealPlan}
                    disabled={isLoading}
                    className="w-full mt-6 bg-green-500 text-white font-bold py-4 rounded-2xl shadow-lg hover:bg-green-600 transition-colors disabled:bg-gray-400"
                  >
                    {isLoading ? 'Generating...' : 'Generate Meal Plan'}
                  </button>

                  {error && <div className="mt-4 text-center text-red-500">{error}</div>}
                </div>
              )}

              {mealPlan && (
                <div className="animate-fade-in">
                  <button onClick={() => setMealPlan(null)} className="mb-4 text-pink-500 font-semibold">&larr; Back to Preferences</button>
                  
                  {/* Voice Button with Pause/Resume - REMOVED */}
                  
                  <MealPlanDisplay mealPlan={mealPlan} />
                  
                  {/* Download Button */}
                  <button
                    onClick={() => {
                      // Format meal plan for PDF
                      const title = "Your Personalized Meal Plan";
                      let content = "";
                      
                      // Add meal plan details
                      content += "BREAKFAST\n";
                      content += `${mealPlan.breakfast.name}\n\n`;
                      content += "Ingredients:\n";
                      mealPlan.breakfast.ingredients.forEach(ing => {
                        content += `- ${ing}\n`;
                      });
                      content += "\nInstructions:\n";
                      mealPlan.breakfast.instructions.forEach((inst, i) => {
                        content += `${i+1}. ${inst}\n`;
                      });
                      
                      content += "\n\nLUNCH\n";
                      content += `${mealPlan.lunch.name}\n\n`;
                      content += "Ingredients:\n";
                      mealPlan.lunch.ingredients.forEach(ing => {
                        content += `- ${ing}\n`;
                      });
                      content += "\nInstructions:\n";
                      mealPlan.lunch.instructions.forEach((inst, i) => {
                        content += `${i+1}. ${inst}\n`;
                      });
                      
                      content += "\n\nDINNER\n";
                      content += `${mealPlan.dinner.name}\n\n`;
                      content += "Ingredients:\n";
                      mealPlan.dinner.ingredients.forEach(ing => {
                        content += `- ${ing}\n`;
                      });
                      content += "\nInstructions:\n";
                      mealPlan.dinner.instructions.forEach((inst, i) => {
                        content += `${i+1}. ${inst}\n`;
                      });
                      
                      // Generate and download PDF
                      generatePDF(title, content, "meal-plan.pdf");
                    }}
                    className="mt-6 mx-auto block bg-pink-500 text-white font-bold py-3 px-6 rounded-xl shadow-lg hover:bg-pink-600 transition-colors"
                  >
                    üì• Download Meal Plan PDF
                  </button>
                </div>
              )}
            </div>
          )}

          {activeTab === 'pantry' && (
            <SmartPantryChef 
              goals={goals} 
              pantryState={pantryState}
              setPantryState={setPantryState}
            />
          )}

          {activeTab === 'menu' && (
            <MenuDecoder 
              goals={goals}
              menuState={menuState}
              setMenuState={setMenuState}
            />
          )}
        </div>
      );
    };

    // AI Workout Form Coach Component
    const WorkoutFormCoach = () => {
      const [videoPreview, setVideoPreview] = useState(null);
      const [isRecording, setIsRecording] = useState(false);
      const [isLoading, setIsLoading] = useState(false);
      const [formAnalysis, setFormAnalysis] = useState(() => {
        const saved = localStorage.getItem('formAnalysis');
        return saved ? JSON.parse(saved) : null;
      });
      const [error, setError] = useState(null);
      const [selectedExercise, setSelectedExercise] = useState('squat');
      const [mediaRecorder, setMediaRecorder] = useState(null);
      const [recordedChunks, setRecordedChunks] = useState([]);
      const [recordingTime, setRecordingTime] = useState(0);
      const videoRef = useRef(null);
      const fileInputRef = useRef(null);
      const recordingTimerRef = useRef(null);

      const exercises = [
      // Strength Training - Upper Body
      { id: 'pushup', name: 'üí™ Push-up', tips: 'Maintain straight line from head to heels, lower chest to ground' },
      { id: 'pullup', name: 'üî• Pull-up', tips: 'Full range of motion, control the movement, engage lats' },
      { id: 'dips', name: 'üí∫ Dips', tips: 'Lower until shoulders below elbows, push up with control' },
      { id: 'overhead_press', name: 'üèãÔ∏è Overhead Press', tips: 'Press straight up, keep core tight, full lockout' },
      { id: 'bench_press', name: 'üèãÔ∏è‚Äç‚ôÇÔ∏è Bench Press', tips: 'Lower bar to chest, press up explosively, maintain arch' },
      { id: 'rows', name: 'üö£ Bent-Over Row', tips: 'Hinge at hips, pull to lower chest, squeeze shoulder blades' },
      
      // Strength Training - Lower Body
      { id: 'squat', name: 'üèãÔ∏è Squat', tips: 'Keep back straight, knees track over toes, hip hinge' },
      { id: 'deadlift', name: 'üèãÔ∏è‚Äç‚ôÄÔ∏è Deadlift', tips: 'Hinge at hips, keep bar close to body, drive through heels' },
      { id: 'lunge', name: 'ü¶µ Lunge', tips: 'Step forward, lower back knee toward ground, push back up' },
      { id: 'bulgarian_split_squat', name: 'ü¶µ Bulgarian Split Squat', tips: 'Rear foot elevated, lower into lunge, drive through front heel' },
      { id: 'hip_thrust', name: 'üçë Hip Thrust', tips: 'Squeeze glutes at top, maintain neutral spine, full hip extension' },
      { id: 'calf_raise', name: 'ü¶µ Calf Raise', tips: 'Rise onto toes, pause at top, control the descent' },
      
      // Core & Stability
      { id: 'plank', name: 'ü§∏ Plank', tips: 'Engage core, avoid sagging or arching, breathe normally' },
      { id: 'side_plank', name: 'ü§∏‚Äç‚ôÄÔ∏è Side Plank', tips: 'Stack shoulders and hips, lift hips up, hold straight line' },
      { id: 'mountain_climbers', name: '‚õ∞Ô∏è Mountain Climbers', tips: 'Keep hips level, drive knees to chest, maintain plank position' },
      { id: 'russian_twists', name: 'üå™Ô∏è Russian Twists', tips: 'Lean back slightly, rotate torso, keep feet off ground' },
      { id: 'bicycle_crunches', name: 'üö¥ Bicycle Crunches', tips: 'Bring opposite elbow to knee, extend other leg, control movement' },
      { id: 'dead_bug', name: 'üêõ Dead Bug', tips: 'Keep lower back pressed down, move opposite arm and leg' },
      
      // Cardio & Conditioning
      { id: 'burpees', name: 'üí• Burpees', tips: 'Jump back to plank, push-up, jump forward, jump up with arms overhead' },
      { id: 'jumping_jacks', name: 'ü§∏‚Äç‚ôÇÔ∏è Jumping Jacks', tips: 'Jump feet apart while raising arms, return to start position' },
      { id: 'high_knees', name: 'üèÉ‚Äç‚ôÄÔ∏è High Knees', tips: 'Drive knees up to waist level, pump arms, stay on balls of feet' },
      { id: 'butt_kicks', name: 'ü¶µ Butt Kicks', tips: 'Kick heels to glutes, keep knees pointing down, quick tempo' },
      { id: 'jump_squats', name: 'ü¶ò Jump Squats', tips: 'Squat down, explode up into jump, land softly, repeat' },
      
      // Functional Movement
      { id: 'bear_crawl', name: 'üêª Bear Crawl', tips: 'Keep knees just off ground, move opposite hand and foot together' },
      { id: 'crab_walk', name: 'ü¶Ä Crab Walk', tips: 'Keep hips up, move opposite hand and foot, face up' },
      { id: 'turkish_getup', name: 'üáπüá∑ Turkish Get-up', tips: 'Slow controlled movement, keep weight overhead, step by step' },
      { id: 'farmers_walk', name: 'üöú Farmer\'s Walk', tips: 'Keep shoulders back, core tight, walk with heavy weights' },
      
      // Flexibility & Mobility
      { id: 'downward_dog', name: 'üßò‚Äç‚ôÄÔ∏è Downward Dog', tips: 'Form inverted V, press hands down, lengthen spine' },
      { id: 'cat_cow', name: 'üê±üêÑ Cat-Cow Stretch', tips: 'Arch and round spine slowly, coordinate with breathing' },
      { id: 'pigeon_pose', name: 'üïäÔ∏è Pigeon Pose', tips: 'Hip opener, keep front knee at 90 degrees, square hips' },
      { id: 'child_pose', name: 'üßò Child\'s Pose', tips: 'Sit back on heels, reach arms forward, relax and breathe' },
      
      // Olympic Lifts (Advanced)
      { id: 'clean_and_press', name: 'üèãÔ∏è‚Äç‚ôÄÔ∏è Clean & Press', tips: 'Explosive hip drive, catch in front rack, press overhead' },
      { id: 'snatch', name: 'üèãÔ∏è Snatch', tips: 'Wide grip, explosive pull, catch overhead in squat position' },
      { id: 'clean_and_jerk', name: 'üèãÔ∏è‚Äç‚ôÇÔ∏è Clean & Jerk', tips: 'Clean to front rack, dip and drive, split or squat jerk' }
    ];

      // Persist formAnalysis to localStorage
      useEffect(() => {
        if (formAnalysis) {
          localStorage.setItem('formAnalysis', JSON.stringify(formAnalysis));
        }
      }, [formAnalysis]);

      const resetAnalysis = () => {
        setVideoPreview(null);
        setFormAnalysis(null);
        setError(null);
        setRecordedChunks([]);
        setRecordingTime(0);
        localStorage.removeItem('formAnalysis');
        if (recordingTimerRef.current) {
          clearInterval(recordingTimerRef.current);
        }
      };

      const startCamera = async () => {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ 
            video: { facingMode: 'user' }, 
            audio: false 
          });
          if (videoRef.current) {
            videoRef.current.srcObject = stream;
          }
        } catch (err) {
          console.error('Camera access failed:', err);
          setError('Camera access denied. Please use file upload instead.');
        }
      };

      const startRecording = async () => {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ 
            video: { facingMode: 'user' }, 
            audio: false 
          });
          
          setIsRecording(true);
          
          // Wait for the video element to be rendered, then set the stream
          setTimeout(async () => {
            if (videoRef.current) {
              videoRef.current.srcObject = stream;
              try {
                await videoRef.current.play();
                console.log('Video preview started successfully');
              } catch (playError) {
                console.error('Video play failed:', playError);
              }
            }
          }, 100);
          
          const recorder = new MediaRecorder(stream);
          const chunks = [];
          
          recorder.ondataavailable = (event) => {
            if (event.data.size > 0) {
              chunks.push(event.data);
            }
          };
          
          recorder.onstop = () => {
            const blob = new Blob(chunks, { type: 'video/webm' });
            const videoUrl = URL.createObjectURL(blob);
            setVideoPreview(videoUrl);
            setRecordedChunks(chunks);
            stream.getTracks().forEach(track => track.stop());
            // Clear live preview
            if (videoRef.current) {
              videoRef.current.srcObject = null;
            }
            clearInterval(recordingTimerRef.current);
            analyzeForm(blob);
          };
          
          setMediaRecorder(recorder);
          recorder.start();
          
          // Start 10-second timer
          let timeLeft = 10;
          setRecordingTime(timeLeft);
          recordingTimerRef.current = setInterval(() => {
            timeLeft--;
            setRecordingTime(timeLeft);
            if (timeLeft <= 0) {
              stopRecording();
            }
          }, 1000);
          
        } catch (err) {
          console.error('Recording failed:', err);
          setError('Recording failed. Please try file upload instead.');
          setIsRecording(false);
        }
      };

      const stopRecording = () => {
        if (mediaRecorder && mediaRecorder.state === 'recording') {
          mediaRecorder.stop();
          setIsRecording(false);
          clearInterval(recordingTimerRef.current);
        }
      };

      const handleVideoUpload = (e) => {
        const file = e.target.files[0];
        if (file) {
          const videoUrl = URL.createObjectURL(file);
          setVideoPreview(videoUrl);
          setFormAnalysis(null);
          setError(null);
          analyzeForm(file);
        }
      };

      const analyzeForm = async (videoBlob) => {
        setIsLoading(true);
        setError(null);
        
        try {
          // For video analysis, we'll extract a frame and analyze it
          const canvas = document.createElement('canvas');
          const video = document.createElement('video');
          
          // Add timeout promise to prevent hanging
          const timeoutPromise = new Promise((_, reject) => {
            setTimeout(() => reject(new Error('Video processing timeout')), 30000);
          });
          
          const processVideo = new Promise((resolve, reject) => {
            video.src = URL.createObjectURL(videoBlob);
            video.muted = true; // Ensure video can play
            
            video.onloadedmetadata = async () => {
              try {
                console.log('Video metadata loaded:', {
                  duration: video.duration,
                  width: video.videoWidth,
                  height: video.videoHeight
                });
                
                // Validate video dimensions
                if (!video.videoWidth || !video.videoHeight) {
                  throw new Error('Invalid video dimensions');
                }
                
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                
                // Seek to middle of video for analysis
                const seekTime = Math.min(video.duration / 2, 5); // Max 5 seconds in
                video.currentTime = seekTime;
                
                video.onseeked = async () => {
                  try {
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(video, 0, 0);
                    
                    // Validate canvas has content
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const hasContent = imageData.data.some(pixel => pixel !== 0);
                    
                    if (!hasContent) {
                      throw new Error('Failed to capture video frame');
                    }
                    
                    // Convert canvas to base64
                    const base64ImageData = canvas.toDataURL('image/jpeg', 0.8).split(',')[1];
                    
                    if (!base64ImageData) {
                      throw new Error('Failed to convert image to base64');
                    }
                    
                    const selectedExerciseData = exercises.find(ex => ex.id === selectedExercise);
                    
                    if (!selectedExerciseData) {
                      throw new Error('No exercise selected');
                    }
                    
                    console.log('Sending analysis request for:', selectedExerciseData.name);
                    
                    const prompt = `Analyze this image of someone performing a ${selectedExerciseData.name} exercise.

Even if the exercise is not clearly visible or the person is not performing the expected exercise, provide constructive feedback.

Provide detailed form analysis and feedback. Focus on:
1. Body alignment and posture (if visible)
2. Joint positioning and angles (if visible) 
3. Common mistakes to avoid
4. Specific improvements for better form
5. Safety considerations

If the exercise is not clearly visible, focus on video recording tips and general exercise guidance.

Respond ONLY with a valid JSON object in this format:
{
  "exercise_detected": "${selectedExerciseData.name}",
  "overall_score": 1-10,
  "form_analysis": {
    "posture": "Analysis of overall posture and alignment or recording feedback",
    "technique": "Assessment of exercise technique or guidance for better recording",
    "safety": "Safety considerations and injury prevention"
  },
  "feedback": {
    "positive_points": ["What they're doing well or encouraging notes"],
    "improvements": ["Specific areas to improve or recording suggestions"],
    "tips": ["Actionable tips for better form or video recording"]
  },
  "next_steps": "Recommendations for progression, modification, or re-recording"
}`;

                    const payload = {
                      contents: [
                        {
                          parts: [
                            { text: prompt },
                            { inlineData: { mimeType: 'image/jpeg', data: base64ImageData } }
                          ]
                        }
                      ],
                    };

                    const response = await fetch(getDirectGeminiConfig().url, {
                      method: 'POST',
                      headers: getDirectGeminiConfig().headers,
                      body: JSON.stringify({
                        model: OPENROUTER_QWEN_VL_MODEL,
                        messages: [{
                          role: 'user',
                          content: [
                            { type: 'text', text: prompt },
                            { type: 'image_url', image_url: `data:image/jpeg;base64,${base64ImageData}` }
                          ]
                        }]
                      })
                    });

                    if (!response.ok) {
                      const errorText = await response.text();
                      console.error('API Error Response:', errorText);
                      throw new Error(`API Error: ${response.status} ${response.statusText}`);
                    }

                    const result = await response.json();
                    console.log('API Response:', result);
                    
                    const textResponse = (result.choices?.[0]?.message?.content || '');
                    if (!textResponse) {
                      throw new Error('Invalid API response format');
                    }
                    
                    console.log('Raw AI Response:', textResponse);
                    
                    // Clean and parse JSON response
                    let jsonString = textResponse.replace(/```json|```/g, '').trim();
                    
                    // Handle potential markdown formatting
                    if (jsonString.includes('```')) {
                      const jsonMatch = jsonString.match(/```(?:json)?\s*({[\s\S]*?})\s*```/);
                      if (jsonMatch) {
                        jsonString = jsonMatch[1];
                      }
                    }
                    
                    // Find JSON object if wrapped in text
                    const jsonMatch = jsonString.match(/{[\s\S]*}/);
                    if (jsonMatch) {
                      jsonString = jsonMatch[0];
                    }
                    
                    console.log('Parsed JSON String:', jsonString);
                    
                    const data = JSON.parse(jsonString);
                    
                    // Updated validation - more flexible for "no exercise detected" cases
                    if (!data.overall_score && data.overall_score !== 0) {
                      // If no score provided, set a default low score
                      data.overall_score = 3;
                    }

                    // Ensure form_analysis exists with defaults
                    if (!data.form_analysis) {
                      data.form_analysis = {
                        posture: data.posture || "Unable to analyze posture from this video.",
                        technique: data.technique || "Unable to assess technique from this video.", 
                        safety: data.safety || "Please ensure proper form and safety when exercising."
                      };
                    }

                    // Ensure feedback exists with defaults
                    if (!data.feedback) {
                      data.feedback = {
                        positive_points: data.positive_points || [],
                        improvements: data.improvements || ["Please record a clearer video showing the full exercise movement"],
                        tips: data.tips || ["Ensure good lighting and clear view of your full body", "Record from a side or slightly angled perspective"]
                      };
                    }

                    // Handle "No [Exercise] Detected" cases
                    if (data.exercise_detected && data.exercise_detected.toLowerCase().includes('no ') && data.exercise_detected.toLowerCase().includes('detected')) {
                      const selectedExerciseData = exercises.find(ex => ex.id === selectedExercise);
                      data.exercise_detected = selectedExerciseData ? selectedExerciseData.name : 'Exercise';
                      data.overall_score = 2; // Low score for undetected exercise
                      
                      // Provide helpful feedback for undetected exercises
                      data.feedback.improvements = [
                        "The selected exercise was not clearly visible in the video",
                        "Please ensure your full body is visible in the frame", 
                        "Record from a side angle for better form analysis",
                        "Make sure lighting is adequate and background is clear"
                      ];
                      
                      data.feedback.tips = [
                        "Position camera 6-8 feet away to capture full body",
                        "Use good lighting - avoid backlighting",
                        "Perform the exercise slowly and with full range of motion",
                        "Ensure the camera is stable and at chest height"
                      ];
                      
                      data.next_steps = "Please re-record the video with better positioning and lighting for accurate form analysis.";
                    }

                    // Ensure next_steps exists
                    if (!data.next_steps) {
                      data.next_steps = "Continue practicing with proper form and consider recording from different angles for comprehensive analysis.";
                    }
                    
                    console.log('Analysis completed successfully:', data);
                    setFormAnalysis(data);
                    resolve(data);
                    
                  } catch (seekError) {
                    console.error('Seek error:', seekError);
                    reject(seekError);
                  }
                };
                
                video.onerror = (e) => {
                  console.error('Video seek error:', e);
                  reject(new Error('Failed to seek video'));
                };
                
              } catch (metadataError) {
                console.error('Metadata error:', metadataError);
                reject(metadataError);
              }
            };
            
            video.onerror = (e) => {
              console.error('Video load error:', e);
              reject(new Error('Failed to load video'));
            };
            
            // Ensure video loads
            video.load();
          });
          
          // Race between processing and timeout
          await Promise.race([processVideo, timeoutPromise]);
          
        } catch (err) {
          console.error('Form analysis failed:', err);
          
          // Provide specific error messages
          let errorMessage = 'Could not analyze form. ';
          
          if (err.message.includes('timeout')) {
            errorMessage += 'Video processing timed out. Please try a shorter video.';
          } else if (err.message.includes('dimensions')) {
            errorMessage += 'Invalid video format. Please record a new video.';
          } else if (err.message.includes('API Error')) {
            errorMessage += 'Analysis service unavailable. Please try again later.';
          } else if (err.message.includes('JSON')) {
            errorMessage += 'Analysis failed to complete. Please try again.';
          } else {
            errorMessage += 'Please try again with a clearer video.';
          }
          
          setError(errorMessage);
        } finally {
          setIsLoading(false);
        }
      };

      return (
        <div className="p-6 pb-24">
          <header className="mb-6 text-center">
            <h1 className="text-3xl font-bold text-gray-800 dark:text-gray-200">üèãÔ∏è AI Form Coach</h1>
            <p className="text-gray-500 dark:text-gray-400">Perfect your technique with AI feedback</p>
          </header>

          {!videoPreview && (
            <div className="max-w-md mx-auto">
              {/* Exercise Selection */}
              <div className="bg-white dark:bg-gray-800 p-4 rounded-2xl shadow-md mb-4">
                <h3 className="font-semibold text-gray-800 dark:text-gray-200 mb-3">Select Exercise:</h3>
                <div className="grid grid-cols-2 gap-2">
                  {exercises.map(exercise => (
                    <button
                      key={exercise.id}
                      onClick={() => setSelectedExercise(exercise.id)}
                      className={`p-3 rounded-lg border text-sm ${
                        selectedExercise === exercise.id
                          ? 'bg-purple-500 text-white border-purple-500'
                          : 'bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200 border-gray-300 dark:border-gray-600'
                      }`}
                    >
                      {exercise.name}
                    </button>
                  ))}
                </div>
                {selectedExercise && (
                  <div className="mt-3 p-3 bg-purple-50 dark:bg-purple-900/20 rounded-lg">
                    <p className="text-sm text-purple-700 dark:text-purple-300">
                      üí° {exercises.find(ex => ex.id === selectedExercise)?.tips}
                    </p>
                  </div>
                )}
              </div>

              <div className="bg-white dark:bg-gray-800 p-8 rounded-2xl shadow-md text-center">
                <div className="mb-6">
                  <div className="w-24 h-24 mx-auto mb-4 bg-gradient-to-br from-purple-400 to-pink-500 rounded-full flex items-center justify-center">
                    <span className="text-4xl">üé•</span>
                  </div>
                  <h3 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-2">Record Your Form</h3>
                  <p className="text-gray-600 dark:text-gray-400 mb-6">Record a short video of your exercise and get instant AI feedback on your form!</p>
                </div>
                
                {/* Recording Controls */}
                <div className="space-y-4">
                  {/* Live Camera Preview */}
                  {isRecording && (
                    <div className="mb-4">
                      <video
                        ref={videoRef}
                        autoPlay
                        muted
                        playsInline
                        className="w-full h-64 object-cover rounded-2xl bg-gray-200 dark:bg-gray-700"
                        style={{ transform: 'scaleX(-1)' }}
                        onLoadedMetadata={() => console.log('Video metadata loaded')}
                        onCanPlay={() => console.log('Video can play')}
                        onError={(e) => console.error('Video error:', e)}
                      />
                      <p className="text-center text-sm text-gray-600 dark:text-gray-400 mt-2">
                        Recording in progress... {recordingTime}s
                      </p>
                    </div>
                  )}
                  
                  {!isRecording ? (
                    <button
                      onClick={startRecording}
                      className="w-full bg-gradient-to-r from-purple-500 to-pink-500 text-white font-bold py-4 rounded-2xl shadow-lg hover:from-purple-600 hover:to-pink-600 transition-all transform hover:scale-105"
                    >
                      üé• Start Recording (10s)
                    </button>
                  ) : (
                    <button
                      onClick={stopRecording}
                      className="w-full bg-red-500 text-white font-bold py-4 rounded-2xl shadow-lg hover:bg-red-600 transition-all"
                    >
                      ‚èπÔ∏è Stop Recording
                    </button>
                  )}
                  
                  <div className="text-gray-500 dark:text-gray-400">or</div>
                  
                  <input
                    type="file"
                    accept="video/*"
                    onChange={handleVideoUpload}
                    ref={fileInputRef}
                    className="hidden"
                  />
                  
                  <button
                    onClick={() => fileInputRef.current?.click()}
                    className="w-full bg-gray-500 text-white font-bold py-3 rounded-2xl shadow-lg hover:bg-gray-600 transition-all"
                  >
                    üìÅ Upload Video
                  </button>
                </div>
                
                <div className="mt-6 p-4 bg-purple-50 dark:bg-purple-900/20 rounded-xl">
                  <h4 className="font-semibold text-purple-800 dark:text-purple-200 mb-2">üìã Recording Tips:</h4>
                  <ul className="text-sm text-purple-700 dark:text-purple-300 space-y-1">
                    <li>‚Ä¢ Position camera to show full body</li>
                    <li>‚Ä¢ Perform 2-3 reps of the exercise</li>
                    <li>‚Ä¢ Ensure good lighting and clear view</li>
                    <li>‚Ä¢ Keep movements slow and controlled</li>
                  </ul>
                </div>
              </div>
            </div>
          )}

          {videoPreview && (
            <div className="max-w-md mx-auto">
              <div className="bg-white dark:bg-gray-800 rounded-2xl shadow-md overflow-hidden">
                <video 
                  src={videoPreview} 
                  controls 
                  className="w-full h-64 object-cover"
                  poster="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='100' height='100'%3E%3Crect width='100' height='100' fill='%23f3f4f6'/%3E%3Ctext x='50%25' y='50%25' text-anchor='middle' dy='.3em' fill='%236b7280'%3EVideo%3C/text%3E%3C/svg%3E"
                />
                
                {isLoading && (
                  <div className="p-6 text-center">
                    <div className="animate-spin w-8 h-8 border-4 border-purple-500 border-t-transparent rounded-full mx-auto mb-4"></div>
                    <p className="text-gray-600 dark:text-gray-400">Analyzing your form...</p>
                  </div>
                )}

                {error && (
                  <div className="p-6 text-center">
                    <p className="text-red-500 mb-4">{error}</p>
                    <button onClick={resetAnalysis} className="bg-gray-500 text-white px-4 py-2 rounded-lg">
                      Try Again
                    </button>
                  </div>
                )}

                {formAnalysis && (
                  <div className="p-6">
                    <div className="flex justify-between items-center mb-4">
                      <h3 className="font-bold text-gray-800 dark:text-gray-200">üéØ Form Analysis</h3>
                      <button onClick={resetAnalysis} className="text-purple-500 font-semibold text-sm">
                        ‚Üê New Video
                      </button>
                    </div>
                    
                    {/* Overall Score */}
                    <div className="mb-6 text-center">
                      <div className={`inline-flex items-center justify-center w-20 h-20 rounded-full text-2xl font-bold ${
                        formAnalysis.overall_score >= 8 ? 'bg-green-100 text-green-600 dark:bg-green-900/20 dark:text-green-400' :
                        formAnalysis.overall_score >= 6 ? 'bg-yellow-100 text-yellow-600 dark:bg-yellow-900/20 dark:text-yellow-400' :
                        'bg-red-100 text-red-600 dark:bg-red-900/20 dark:text-red-400'
                      }`}>
                        {formAnalysis.overall_score}/10
                      </div>
                      <p className="text-sm text-gray-600 dark:text-gray-400 mt-2">Form Score</p>
                    </div>

                    {/* Form Analysis */}
                    <div className="space-y-4 mb-6">
                      <div className="bg-blue-50 dark:bg-blue-900/20 p-4 rounded-lg">
                        <h4 className="font-semibold text-blue-800 dark:text-blue-200 mb-2">üìê Posture Analysis</h4>
                        <p className="text-sm text-blue-700 dark:text-blue-300">{formAnalysis.form_analysis.posture}</p>
                      </div>
                      
                      <div className="bg-purple-50 dark:bg-purple-900/20 p-4 rounded-lg">
                        <h4 className="font-semibold text-purple-800 dark:text-purple-200 mb-2">‚ö° Technique</h4>
                        <p className="text-sm text-purple-700 dark:text-purple-300">{formAnalysis.form_analysis.technique}</p>
                      </div>
                      
                      <div className="bg-orange-50 dark:bg-orange-900/20 p-4 rounded-lg">
                        <h4 className="font-semibold text-orange-800 dark:text-orange-200 mb-2">üõ°Ô∏è Safety</h4>
                        <p className="text-sm text-orange-700 dark:text-orange-300">{formAnalysis.form_analysis.safety}</p>
                      </div>
                    </div>

                    {/* Positive Feedback */}
                    {formAnalysis.feedback.positive_points && formAnalysis.feedback.positive_points.length > 0 && (
                      <div className="mb-4">
                        <h4 className="font-semibold text-green-600 dark:text-green-400 mb-2">‚úÖ What You're Doing Well:</h4>
                        <ul className="space-y-1">
                          {formAnalysis.feedback.positive_points.map((point, index) => (
                            <li key={index} className="text-sm text-gray-600 dark:text-gray-400 flex items-start">
                              <span className="text-green-500 mr-2">‚Ä¢</span>
                              {point}
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}

                    {/* Improvements */}
                    {formAnalysis.feedback.improvements && formAnalysis.feedback.improvements.length > 0 && (
                      <div className="mb-4">
                        <h4 className="font-semibold text-yellow-600 dark:text-yellow-400 mb-2">üéØ Areas to Improve:</h4>
                        <ul className="space-y-1">
                          {formAnalysis.feedback.improvements.map((improvement, index) => (
                            <li key={index} className="text-sm text-gray-600 dark:text-gray-400 flex items-start">
                              <span className="text-yellow-500 mr-2">‚Ä¢</span>
                              {improvement}
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}

                    {/* Tips */}
                    {formAnalysis.feedback.tips && formAnalysis.feedback.tips.length > 0 && (
                      <div className="mb-4">
                        <h4 className="font-semibold text-purple-600 dark:text-purple-400 mb-2">üí° Pro Tips:</h4>
                        <ul className="space-y-1">
                          {formAnalysis.feedback.tips.map((tip, index) => (
                            <li key={index} className="text-sm text-gray-600 dark:text-gray-400 flex items-start">
                              <span className="text-purple-500 mr-2">‚Ä¢</span>
                              {tip}
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}

                    {/* Next Steps */}
                    {formAnalysis.next_steps && (
                      <div className="bg-gray-50 dark:bg-gray-700 p-4 rounded-lg">
                        <h4 className="font-semibold text-gray-800 dark:text-gray-200 mb-2">üöÄ Next Steps:</h4>
                        <p className="text-sm text-gray-600 dark:text-gray-400">{formAnalysis.next_steps}</p>
                      </div>
                    )}
                  </div>
                )}
              </div>
            </div>
          )}
        </div>
      );
    };

    // Workout Planner Screen Component
    const WorkoutPlanner = ({ workoutPlan, setWorkoutPlan, isLoading, setIsLoading, error, setError }) => {
      const [activeTab, setActiveTab] = useState('planner'); // 'planner', 'coach', or 'exercises'
      const [preferences, setPreferences] = useState({ goal: '', type: '', level: '', equipment: [] });
      const [selectedExercise, setSelectedExercise] = useState(null);
      const [currentSet, setCurrentSet] = useState(1);
      const [completedSets, setCompletedSets] = useState({});
      
      // Workout Session State Management
      const [workoutSession, setWorkoutSession] = useState({
        isActive: false,
        isPaused: false,
        currentExerciseIndex: 0,
        currentSet: 1,
        exerciseTime: 0,
        restTime: 0,
        totalTime: 0,
        isResting: false,
        completedExercises: [],
        sessionExercises: []
      });
      const [workoutTimer, setWorkoutTimer] = useState(null);
      const [audioEnabled, setAudioEnabled] = useState(true);
      const [voiceInstructions, setVoiceInstructions] = useState(true);
      const videoRef = useRef(null);
      const speechSynthesis = window.speechSynthesis;

      // Exercise database with video files from animations folder
      const exerciseDatabase = [
        {
          id: 1,
          name: 'Burpee and Jump',
          category: 'Full Body',
          difficulty: 'Advanced',
          sets: 3,
          reps: '8-12',
          duration: '45s',
          video: './animations/Burpee and Jump Exercise (1).mp4',
          muscles: ['Full Body', 'Cardio'],
          instructions: 'Start in standing position, drop to squat, kick back to plank, do push-up, jump feet back to squat, then jump up with arms overhead.'
        },
        {
          id: 2,
          name: 'Inchworm',
          category: 'Core',
          difficulty: 'Intermediate',
          sets: 3,
          reps: '10-15',
          duration: '30s',
          video: './animations/Inchworm.mp4',
          muscles: ['Core', 'Shoulders', 'Hamstrings'],
          instructions: 'Stand with feet hip-width apart, bend forward and walk hands out to plank position, then walk feet toward hands.'
        },
        {
          id: 3,
          name: 'Jumping Jack',
          category: 'Cardio',
          difficulty: 'Beginner',
          sets: 3,
          reps: '20-30',
          duration: '30s',
          video: './animations/Jumping Jack.mp4',
          muscles: ['Full Body', 'Cardio'],
          instructions: 'Jump feet apart while raising arms overhead, then jump back to starting position with arms at sides.'
        },
        {
          id: 4,
          name: 'Military Push Ups',
          category: 'Upper Body',
          difficulty: 'Intermediate',
          sets: 3,
          reps: '8-15',
          duration: '45s',
          video: './animations/Military Push Ups.mp4',
          muscles: ['Chest', 'Triceps', 'Shoulders'],
          instructions: 'Start in plank position with hands shoulder-width apart, lower body until chest nearly touches ground, push back up.'
        },
        {
          id: 5,
          name: 'Reverse Crunches',
          category: 'Core',
          difficulty: 'Beginner',
          sets: 3,
          reps: '12-20',
          duration: '30s',
          video: './animations/Reverse Crunches.mp4',
          muscles: ['Lower Abs', 'Core'],
          instructions: 'Lie on back with knees bent, lift hips off ground by contracting abs, slowly lower back down.'
        },
        {
          id: 6,
          name: 'Seated Abs Circles',
          category: 'Core',
          difficulty: 'Beginner',
          sets: 3,
          reps: '10 each direction',
          duration: '30s',
          video: './animations/Seated abs circles.mp4',
          muscles: ['Core', 'Obliques'],
          instructions: 'Sit with knees bent, lean back slightly, make circular motions with your torso while keeping core engaged.'
        },
        {
          id: 7,
          name: 'Single Leg Hip Rotation',
          category: 'Lower Body',
          difficulty: 'Beginner',
          sets: 3,
          reps: '10 each leg',
          duration: '30s',
          video: './animations/Single Leg Hip Rotation.mp4',
          muscles: ['Hips', 'Glutes', 'Balance'],
          instructions: 'Stand on one leg, rotate the other leg in circular motions, focusing on hip mobility and balance.'
        },
        {
          id: 8,
          name: 'Split Jump',
          category: 'Lower Body',
          difficulty: 'Advanced',
          sets: 3,
          reps: '10-15',
          duration: '45s',
          video: './animations/Split Jump Exercise.mp4',
          muscles: ['Legs', 'Glutes', 'Cardio'],
          instructions: 'Start in lunge position, jump up and switch leg positions in mid-air, land softly in opposite lunge.'
        },
        {
          id: 9,
          name: 'Squat Reach',
          category: 'Lower Body',
          difficulty: 'Beginner',
          sets: 3,
          reps: '12-20',
          duration: '30s',
          video: './animations/Squat Reach.mp4',
          muscles: ['Quads', 'Glutes', 'Core'],
          instructions: 'Perform a squat while reaching arms forward for balance, return to standing with arms at sides.'
        },
        {
          id: 10,
          name: 'Squat Kicks',
          category: 'Lower Body',
          difficulty: 'Intermediate',
          sets: 3,
          reps: '10-15',
          duration: '45s',
          video: './animations/Squat kicks.mp4',
          muscles: ['Quads', 'Glutes', 'Core'],
          instructions: 'Perform a squat, then as you stand up, kick one leg forward, alternate legs with each rep.'
        }
      ];

      // Workout Session Management Functions
      const speakInstruction = (text) => {
        if (voiceInstructions && speechSynthesis) {
          speechSynthesis.cancel();
          const utterance = new SpeechSynthesisUtterance(text);
          utterance.rate = 0.9;
          utterance.pitch = 1;
          utterance.volume = 0.8;
          speechSynthesis.speak(utterance);
        }
      };

      const startWorkoutSession = (exercises) => {
        const sessionExercises = exercises.length > 0 ? exercises : exerciseDatabase.slice(0, 5);
        setWorkoutSession({
          isActive: true,
          isPaused: false,
          currentExerciseIndex: 0,
          currentSet: 1,
          exerciseTime: 0,
          restTime: 0,
          totalTime: 0,
          isResting: false,
          completedExercises: [],
          sessionExercises
        });
        speakInstruction(`Starting workout with ${sessionExercises.length} exercises. First exercise: ${sessionExercises[0].name}`);
        startTimer();
      };

      const pauseWorkoutSession = () => {
        setWorkoutSession(prev => {
          const newPaused = !prev.isPaused;
          
          // Handle video controls
          if (videoRef.current) {
            if (newPaused) {
              videoRef.current.pause();
            } else {
              videoRef.current.play();
            }
          }
          
          if (newPaused) {
            clearInterval(workoutTimer);
            speakInstruction('Workout paused');
          } else {
            startTimer();
            speakInstruction('Workout resumed');
          }
          
          return { ...prev, isPaused: newPaused };
        });
      };

      const nextExercise = () => {
        const { currentExerciseIndex, sessionExercises, currentSet } = workoutSession;
        const currentExercise = sessionExercises[currentExerciseIndex];
        
        if (currentSet < currentExercise.sets) {
          // Next set of current exercise
          setWorkoutSession(prev => ({
            ...prev,
            currentSet: prev.currentSet + 1,
            isResting: true,
            restTime: 0
          }));
          speakInstruction(`Set ${currentSet + 1} of ${currentExercise.sets}. Rest for 30 seconds`);
        } else if (currentExerciseIndex < sessionExercises.length - 1) {
          // Next exercise
          const nextExerciseIndex = currentExerciseIndex + 1;
          const nextExercise = sessionExercises[nextExerciseIndex];
          setWorkoutSession(prev => ({
            ...prev,
            currentExerciseIndex: nextExerciseIndex,
            currentSet: 1,
            exerciseTime: 0,
            isResting: false,
            completedExercises: [...prev.completedExercises, currentExerciseIndex]
          }));
          speakInstruction(`Next exercise: ${nextExercise.name}. ${nextExercise.instructions}`);
        } else {
          // Workout complete
          endWorkoutSession();
        }
      };

      const previousExercise = () => {
        const { currentExerciseIndex, sessionExercises, currentSet } = workoutSession;
        
        if (currentSet > 1) {
          // Previous set of current exercise
          setWorkoutSession(prev => ({
            ...prev,
            currentSet: prev.currentSet - 1,
            isResting: false
          }));
        } else if (currentExerciseIndex > 0) {
          // Previous exercise
          const prevExerciseIndex = currentExerciseIndex - 1;
          const prevExercise = sessionExercises[prevExerciseIndex];
          setWorkoutSession(prev => ({
            ...prev,
            currentExerciseIndex: prevExerciseIndex,
            currentSet: prevExercise.sets,
            exerciseTime: 0,
            isResting: false,
            completedExercises: prev.completedExercises.filter(i => i !== prevExerciseIndex)
          }));
          speakInstruction(`Previous exercise: ${prevExercise.name}`);
        }
      };

      const endWorkoutSession = () => {
        clearInterval(workoutTimer);
        
        // Calculate workout metrics for health score integration
        const workoutData = {
          duration: Math.round(workoutSession.totalTime / 60), // Convert to minutes
          exercisesCompleted: workoutSession.completedExercises.length,
          totalExercises: workoutSession.sessionExercises.length,
          completionRate: (workoutSession.completedExercises.length / workoutSession.sessionExercises.length) * 100,
          timestamp: new Date().toISOString(),
          type: 'structured_workout'
        };
        
        // Log workout as activity minutes
        if (workoutData.duration > 0) {
          handleLogActivity({ minutes: workoutData.duration });
          
          // Store workout history for detailed tracking
          let workoutHistory;
          try {
            workoutHistory = JSON.parse(localStorage.getItem('workoutHistory') || '[]');
            if (!Array.isArray(workoutHistory)) {
              workoutHistory = [];
            }
          } catch (error) {
            console.warn('Error parsing workoutHistory in workout completion, resetting to empty array:', error);
            workoutHistory = [];
          }
          workoutHistory.push(workoutData);
          // Keep only last 30 workouts
          if (workoutHistory.length > 30) workoutHistory.shift();
          localStorage.setItem('workoutHistory', JSON.stringify(workoutHistory));
          
          // Sync workout data to Firebase if user is logged in
          if (user) {
            const userRef = db.ref(`users/${user.uid}/workoutHistory`);
            userRef.push(workoutData);
            // Bump root timestamp so other clients pick up latest workout history
            db.ref(`users/${user.uid}`).update({ updatedAt: Date.now() });
          }
        }
        
        setWorkoutSession({
          isActive: false,
          isPaused: false,
          currentExerciseIndex: 0,
          currentSet: 1,
          exerciseTime: 0,
          restTime: 0,
          totalTime: 0,
          isResting: false,
          completedExercises: [],
          sessionExercises: []
        });
        
        const completionMessage = workoutData.completionRate === 100 
          ? `Workout completed! Great job! You completed all ${workoutData.totalExercises} exercises in ${workoutData.duration} minutes.`
          : `Workout session ended. You completed ${workoutData.exercisesCompleted} out of ${workoutData.totalExercises} exercises in ${workoutData.duration} minutes.`;
        
        speakInstruction(completionMessage);
      };

      const startTimer = () => {
        const timer = setInterval(() => {
          setWorkoutSession(prev => {
            if (prev.isPaused) return prev;
            
            const newState = { ...prev, totalTime: prev.totalTime + 1 };
            
            if (prev.isResting) {
              newState.restTime = prev.restTime + 1;
              const restDuration = 30; // 30 second rest between sets
              
              // Countdown for last 5 seconds of rest
              const restTimeLeft = restDuration - prev.restTime;
              if (restTimeLeft <= 5 && restTimeLeft > 0 && prev.restTime > 0) {
                speakInstruction(`${restTimeLeft}`);
              }
              
              if (prev.restTime >= restDuration) {
                newState.isResting = false;
                newState.restTime = 0;
                const currentExercise = prev.sessionExercises[prev.currentExerciseIndex];
                speakInstruction(`Set ${prev.currentSet} of ${currentExercise.sets}. Begin!`);
                // Resume video after rest
                if (videoRef.current) {
                  videoRef.current.currentTime = 0;
                  videoRef.current.play();
                }
              }
            } else {
              newState.exerciseTime = prev.exerciseTime + 1;
              const currentExercise = prev.sessionExercises[prev.currentExerciseIndex];
              const exerciseDuration = parseInt(currentExercise.duration) || 45;
              
              // Voice counting every 5 seconds during exercise
              if (prev.exerciseTime > 0 && prev.exerciseTime % 5 === 0 && prev.exerciseTime <= exerciseDuration - 10) {
                const count = Math.floor(prev.exerciseTime / 5);
                speakInstruction(`${count * 5}`);
              }
              
              // Countdown for last 10 seconds
              const timeLeft = exerciseDuration - prev.exerciseTime;
              if (timeLeft <= 10 && timeLeft > 0) {
                speakInstruction(`${timeLeft}`);
              }
              
              // Ensure video is playing during exercise
              if (videoRef.current && videoRef.current.paused && !prev.isPaused) {
                videoRef.current.play();
              }
              
              if (prev.exerciseTime >= exerciseDuration) {
                // Auto-advance to next set/exercise
                if (prev.currentSet < currentExercise.sets) {
                  newState.currentSet = prev.currentSet + 1;
                  newState.isResting = true;
                  newState.exerciseTime = 0;
                  newState.restTime = 0;
                  speakInstruction(`Set complete. Rest for 30 seconds`);
                  // Pause video during rest
                  if (videoRef.current) {
                    videoRef.current.pause();
                  }
                } else {
                  // Move to next exercise
                  if (prev.currentExerciseIndex < prev.sessionExercises.length - 1) {
                    const nextIndex = prev.currentExerciseIndex + 1;
                    const nextExercise = prev.sessionExercises[nextIndex];
                    newState.currentExerciseIndex = nextIndex;
                    newState.currentSet = 1;
                    newState.exerciseTime = 0;
                    newState.isResting = true;
                    newState.restTime = 0;
                    newState.completedExercises = [...prev.completedExercises, prev.currentExerciseIndex];
                    speakInstruction(`Exercise complete. Next: ${nextExercise.name}. Get ready in 10 seconds`);
                    // Pause video during transition
                    if (videoRef.current) {
                      videoRef.current.pause();
                    }
                    // Set shorter transition time (10 seconds instead of 30)
                    setTimeout(() => {
                      setWorkoutSession(current => ({
                        ...current,
                        isResting: false,
                        restTime: 0
                      }));
                      speakInstruction(`Begin ${nextExercise.name}`);
                      if (videoRef.current) {
                        videoRef.current.currentTime = 0;
                        videoRef.current.play();
                      }
                    }, 10000);
                  } else {
                    // Workout completed
                    newState.isActive = false;
                    newState.completedExercises = [...prev.completedExercises, prev.currentExerciseIndex];
                    clearInterval(timer);
                    speakInstruction('Workout completed! Excellent work!');
                    if (videoRef.current) {
                      videoRef.current.pause();
                    }
                    return newState; // Exit early to prevent further timer execution
                  }
                }
              }
            }
            
            return newState;
          });
        }, 1000);
        
        setWorkoutTimer(timer);
      };

      useEffect(() => {
        return () => {
          if (workoutTimer) {
            clearInterval(workoutTimer);
          }
        };
      }, [workoutTimer]);

      const handlePreferenceChange = (key, value) => {
        setPreferences(prev => ({ ...prev, [key]: value }));
      };

      const handleEquipmentChange = (item) => {
        setPreferences(prev => {
          const newEquipment = prev.equipment.includes(item)
            ? prev.equipment.filter(e => e !== item)
            : [...prev.equipment, item];
          return { ...prev, equipment: newEquipment };
        });
      };

      const generateWorkoutPlan = async () => {
        setIsLoading(true);
        setError(null);
        setWorkoutPlan(null);
        try {
          const prompt = `Create a ${preferences.type || 'Full Body'} workout for ${preferences.goal || 'General Fitness'}.
Level: ${preferences.level || 'Beginner'}
Equipment: ${preferences.equipment.join(', ') || 'Bodyweight'}

Respond ONLY with a valid JSON object in this exact format:
{
  "plan_name": "Workout Plan Name",
  "exercises": [
    {"name": "Exercise Name", "sets": "3", "reps": "10-12", "instructions": "How to perform this exercise"}
  ]
}`;

          // Use OpenRouter API (Qwen) with obfuscated key
          const geminiConfig = getDirectGeminiConfig();
          const response = await fetch(geminiConfig.url, {
            method: 'POST',
            headers: geminiConfig.headers,
            body: JSON.stringify({
              model: OPENROUTER_QWEN_MODEL,
              messages: [{ role: 'user', content: prompt }]
            }),
            signal: AbortSignal.timeout(25000) // 25 second timeout
          });

          if (!response.ok) {
            throw new Error(`API Error: ${response.status} ${response.statusText}`);
          }

          const result = await response.json();
          const textResponse = (result.choices?.[0]?.message?.content || '');
          
          // Better JSON extraction and validation
          let jsonString = textResponse.replace(/```json|```/g, '').trim();
          
          // Remove any text before the first { and after the last }
          const firstBrace = jsonString.indexOf('{');
          const lastBrace = jsonString.lastIndexOf('}');
          
          if (firstBrace !== -1 && lastBrace !== -1) {
            jsonString = jsonString.substring(firstBrace, lastBrace + 1);
          }
          
          const data = JSON.parse(jsonString);
          
          // Validate the structure
          if (!data.plan_name || !data.exercises || !Array.isArray(data.exercises)) {
            throw new Error('Invalid workout plan structure');
          }
          
          setWorkoutPlan(data);
        } catch (err) {
          console.error("Workout plan generation failed:", err);
          setError("Could not generate a workout plan. Please try again.");
        } finally {
          setIsLoading(false);
        }
      };

      return (
        <div className="p-6 pb-24">
          <header className="mb-6 text-center">
            <h1 className="text-3xl font-bold text-gray-800 dark:text-gray-200">Workout Hub</h1>
            <p className="text-gray-500 dark:text-gray-400">Plan workouts or perfect your form</p>
          </header>

          {/* Tab Navigation - Fixed light gradients */}
          <div className="flex mb-6 bg-gray-100 dark:bg-gray-800 rounded-2xl p-1 max-w-lg mx-auto">
            <button
              onClick={() => setActiveTab('planner')}
              className={`flex-1 py-3 px-2 rounded-xl font-semibold transition-all text-sm ${
                activeTab === 'planner'
                  ? 'bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 shadow-md'
                  : 'text-gray-600 dark:text-gray-400'
              }`}
            >
              üìã Planner
            </button>
            <button
              onClick={() => setActiveTab('coach')}
              className={`flex-1 py-3 px-2 rounded-xl font-semibold transition-all text-sm ${
                activeTab === 'coach'
                  ? 'bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 shadow-md'
                  : 'text-gray-600 dark:text-gray-400'
              }`}
            >
              üèãÔ∏è Form Coach
            </button>
            <button
              onClick={() => setActiveTab('exercises')}
              className={`flex-1 py-3 px-2 rounded-xl font-semibold transition-all text-sm ${
                activeTab === 'exercises'
                  ? 'bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 shadow-md'
                  : 'text-gray-600 dark:text-gray-400'
              }`}
            >
              üí™ Exercises
            </button>
          </div>

          {/* Tab Content */}
          {activeTab === 'planner' && (
            <div>
              {!workoutPlan && (
                <div className="max-w-md mx-auto">
                  <div className="bg-white dark:bg-gray-800 p-6 rounded-2xl shadow-md space-y-4">
                    {/* Fitness Goal */}
                    <div>
                      <h3 className="font-semibold mb-2 text-gray-800 dark:text-gray-200">Fitness Goal</h3>
                      <div className="grid grid-cols-3 gap-2">
                        {['Weight Loss', 'Muscle Gain', 'Endurance'].map(g => (
                          <button
                            key={g}
                            onClick={() => handlePreferenceChange('goal', g)}
                            className={`p-2 rounded-lg border dark:border-gray-700 ${preferences.goal === g ? 'bg-pink-500 text-white' : 'bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200'}`}
                          >
                            {g}
                          </button>
                        ))}
                      </div>
                    </div>

                    {/* Workout Type */}
                    <div>
                      <h3 className="font-semibold mb-2 text-gray-800 dark:text-gray-200">Workout Type</h3>
                      <div className="grid grid-cols-3 gap-2">
                        {['Full Body', 'Upper Body', 'Lower Body'].map(t => (
                          <button
                            key={t}
                            onClick={() => handlePreferenceChange('type', t)}
                            className={`p-2 rounded-lg border dark:border-gray-700 ${preferences.type === t ? 'bg-pink-500 text-white' : 'bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200'}`}
                          >
                            {t}
                          </button>
                        ))}
                      </div>
                    </div>

                    {/* Experience Level */}
                    <div>
                      <h3 className="font-semibold mb-2 text-gray-800 dark:text-gray-200">Experience Level</h3>
                      <div className="grid grid-cols-3 gap-2">
                        {['Beginner', 'Intermediate', 'Advanced'].map(l => (
                          <button
                            key={l}
                            onClick={() => handlePreferenceChange('level', l)}
                            className={`p-2 rounded-lg border dark:border-gray-700 text-xs sm:text-sm ${preferences.level === l ? 'bg-pink-500 text-white' : 'bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200'}`}
                          >
                            {l}
                          </button>
                        ))}
                      </div>
                    </div>

                    {/* Equipment */}
                    <div>
                      <h3 className="font-semibold mb-2 text-gray-800 dark:text-gray-200">Available Equipment</h3>
                      <div className="grid grid-cols-3 gap-2">
                        {['Bodyweight', 'Dumbbells', 'Barbell', 'Kettlebell', 'Bands', 'Machine'].map(e => (
                          <button
                            key={e}
                            onClick={() => handleEquipmentChange(e)}
                            className={`p-2 rounded-lg border dark:border-gray-700 text-xs sm:text-sm ${preferences.equipment.includes(e) ? 'bg-pink-500 text-white' : 'bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200'}`}
                          >
                            {e}
                          </button>
                        ))}
                      </div>
                    </div>
                  </div>

                  <button
                    onClick={generateWorkoutPlan}
                    disabled={isLoading}
                    className="w-full mt-6 bg-green-500 text-white font-bold py-4 rounded-2xl shadow-lg hover:bg-green-600 transition-colors disabled:bg-gray-400"
                  >
                    {isLoading ? 'Generating...' : 'Generate Workout Plan'}
                  </button>

                  {error && <div className="mt-4 text-center text-red-500">{error}</div>}
                </div>
              )}

              {workoutPlan && (
                <div className="animate-fade-in">
                  <button onClick={() => setWorkoutPlan(null)} className="mb-4 text-pink-500 font-semibold">&larr; Back to Preferences</button>
                  
                  {/* Voice Button with Pause/Resume - REMOVED */}
                  
                  <div className="bg-white dark:bg-gray-800 p-6 rounded-2xl shadow-md">
                    <h2 className="text-2xl font-bold text-gray-800 dark:text-gray-200 mb-4">{workoutPlan.plan_name}</h2>
                    <WorkoutPlanDisplay workoutPlan={workoutPlan} />
                  </div>
                  
                  {/* Download Button */}
                  <button
                    onClick={() => {
                      // Format workout plan for PDF
                      const title = workoutPlan.plan_name;
                      let content = "";
                      
                      // Add workout details
                      workoutPlan.exercises.forEach((ex, i) => {
                        content += `${i+1}. ${ex.name}\n`;
                        content += `Sets: ${ex.sets} | Reps: ${ex.reps}\n`;
                        content += `Instructions: ${ex.instructions}\n\n`;
                      });
                      
                      // Generate and download PDF
                      generatePDF(title, content, "workout-plan.pdf");
                    }}
                    className="mt-6 mx-auto block bg-pink-500 text-white font-bold py-3 px-6 rounded-xl shadow-lg hover:bg-pink-600 transition-colors"
                  >
                    üì• Download Workout Plan PDF
                  </button>
                </div>
              )}
            </div>
          )}

          {activeTab === 'coach' && (
            <WorkoutFormCoach />
          )}

          {activeTab === 'exercises' && (
            <div className="w-full h-screen">
              <iframe 
                src="./workout.html" 
                className="w-full h-full border-0 rounded-lg"
                title="Workout Application"
              />
            </div>
          )}
        </div>
      );
    };

    // AI Coach Screen Component
    const Coach = ({ dailyIntake, recentMeals, goals, messages, setMessages, isDarkMode }) => {
      const [input, setInput] = useState('');
      const [isLoading, setIsLoading] = useState(false);
      const chatEndRef = useRef(null);
      const [attachment, setAttachment] = useState(null);
      const [attachmentPreview, setAttachmentPreview] = useState(null);
      const fileInputRef = useRef(null);

      // Function to start a new conversation
      const startNewConversation = () => {
        setMessages([{ text: "Hello! I'm your AI Health Coach. Ask me anything about your nutrition or meals.", sender: 'ai' }]);
        setInput('');
        setAttachment(null);
        setAttachmentPreview(null);
      };

      useEffect(() => {
        chatEndRef.current?.scrollIntoView({ behavior: "smooth" });
      }, [messages]);

      const fileToBase64 = (file) => new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = () => resolve(reader.result.split(',')[1]);
        reader.onerror = error => reject(error);
      });

      const handleAttachmentChange = (event) => {
        const file = event.target.files[0];
        if (file) {
          setAttachment(file);
          setAttachmentPreview(URL.createObjectURL(file));
        }
      };

      const handleSend = async () => {
        if (!input.trim() && !attachment) return;

        const userMessage = { text: input, sender: 'user', attachment: attachmentPreview };
        setMessages(prev => [...prev, userMessage]);
        setInput('');
        setAttachment(null);
        setAttachmentPreview(null);
        setIsLoading(true);

        try {
          const mealContext = recentMeals.map(m => `${m.name} (Felt: ${m.mood || 'Not specified'})`).join(', ');
          
          // Calculate progress percentages
          const calorieProgress = ((dailyIntake.calories / goals.calories) * 100).toFixed(0);
          const proteinProgress = ((dailyIntake.protein / goals.protein) * 100).toFixed(0);
          const carbProgress = ((dailyIntake.carbs / goals.carbs) * 100).toFixed(0);
          const fatProgress = ((dailyIntake.fat / goals.fat) * 100).toFixed(0);
          // Read habits safely from localStorage (chat context doesn't receive habits prop)
          const habitsLS = (() => { try { return JSON.parse(localStorage.getItem('habits') || '[]'); } catch (e) { return []; } })();

          // Consolidate activity: combine dashboard activity with completed activity habit for today
          const todayStrAct = new Date().toISOString().split('T')[0];
          const activityHabitMinutesCtx = habitsLS.reduce((max, h) => {
            const isActivity = /(cardio|exercise|workout|run|walk|gym)/i.test(h.name || '');
            const done = h.completed && h.completed[todayStrAct];
            if (!isActivity || !done) return max;
            const m = (h.name || '').match(/(\d+)\s*(min|mins|minutes)/i) || (h.name || '').match(/(\d+)/);
            const mins = m ? parseInt(m[1], 10) : 30;
            return Math.max(max, mins);
          }, 0);
          const effectiveActivityCtx = Math.max(dailyIntake.activity || 0, activityHabitMinutesCtx || 0);
          const activityProgress = ((effectiveActivityCtx / goals.activity) * 100).toFixed(0);
          
          // Consolidate hydration: combine dashboard water with completed water habit for today
          const todayStr = new Date().toISOString().split('T')[0];
          const waterHabitGlassesCtx = habitsLS.reduce((max, h) => {
            const isWater = /\b(drink)?\s*\d+\s*(glass|glasses)\s*of\s*water\b|\bwater\b|\bhydrate\b/i.test(h.name || '');
            const doneToday = h.completed && h.completed[todayStr];
            if (!isWater || !doneToday) return max;
            const m = (h.name || '').match(/(\d+)\s*(glass|glasses)/i);
            const g = m ? parseInt(m[1], 10) : 0;
            return Math.max(max, g);
          }, 0);
          const effectiveWaterCtx = Math.max(dailyIntake.water || 0, waterHabitGlassesCtx || 0);
          const waterProgress = ((effectiveWaterCtx / goals.water) * 100).toFixed(0);
          
          // Identify areas needing attention
          const lowAreas = [];
          const highAreas = [];
          if (calorieProgress < 80) lowAreas.push('calories');
          if (proteinProgress < 80) lowAreas.push('protein');
          if (activityProgress < 80) lowAreas.push('activity');
          if (waterProgress < 80) lowAreas.push('water');
          if (calorieProgress > 120) highAreas.push('calories');
          if (carbProgress > 120) highAreas.push('carbs');
          if (fatProgress > 120) highAreas.push('fat');
          
          // Get workout history for enhanced coaching
          let workoutHistory;
          try {
            workoutHistory = JSON.parse(localStorage.getItem('workoutHistory') || '[]');
            if (!Array.isArray(workoutHistory)) {
              workoutHistory = [];
            }
          } catch (error) {
            console.warn('Error parsing workoutHistory in coaching, resetting to empty array:', error);
            workoutHistory = [];
          }
          const recentWorkouts = workoutHistory.slice(-5); // Last 5 workouts
          const workoutContext = recentWorkouts.map(w => 
            `${w.workoutTitle} (${w.workoutLevel || 'Unknown'} level) - ${w.completionRate}% completed on ${new Date(w.timestamp).toLocaleDateString()}`
          ).join('; ');
          
          let prompt = `You are an AI Health Coach specializing in FITNESS, WORKOUTS, and NUTRITION. You have comprehensive knowledge of the FitnessMate app's features and can provide expert guidance.

üìä USER'S CURRENT STATUS:
Daily Intake vs Goals:
- Calories: ${dailyIntake.calories}/${goals.calories} (${calorieProgress}%)
- Protein: ${dailyIntake.protein}g/${goals.protein}g (${proteinProgress}%)
- Carbs: ${dailyIntake.carbs}g/${goals.carbs}g (${carbProgress}%)
- Fat: ${dailyIntake.fat}g/${goals.fat}g (${fatProgress}%)
- Activity: ${Math.min(effectiveActivityCtx, goals.activity)}/${goals.activity} mins (${Math.min(100, Number(activityProgress))}%)
- Water: ${dailyIntake.water}/${goals.water} glasses (${waterProgress}%)

üèãÔ∏è WORKOUT DATA:
- Recent workouts: ${workoutContext || 'No recent workouts'}
- Available workout types: Upper Body, Lower Body, Full Body, Core & Abs, Cardio HIIT
- Difficulty levels: Beginner, Intermediate, Advanced
- Features: AI Form Coach, Workout Planner, Progress Tracking

üéØ HEALTH SCORING SYSTEM:
- Nutrition: 40% (based on macro balance and calorie goals)
- Activity + Workouts: 45% max (workouts can replace activity points)
- Hydration: 15% (water intake vs goals)
- Workouts provide structured exercise that counts toward activity goals
- Quality workouts can compensate for lower general activity

Recent meals: ${mealContext || 'None logged'}
${lowAreas.length > 0 ? `\n‚ö†Ô∏è LOW AREAS: ${lowAreas.join(', ')}` : ''}
${highAreas.length > 0 ? `\nüî¥ HIGH AREAS: ${highAreas.join(', ')}` : ''}

üéØ ENHANCED RESPONSE RULES:
1. IDENTIFY QUESTION TYPE:
   - WORKOUT PLANNING ‚Üí Recommend specific workouts based on goals/level
   - EXERCISE FORM ‚Üí Reference AI Form Coach feature for technique help
   - WORKOUT PROGRESS ‚Üí Analyze completion rates and suggest improvements
   - INJURY/PAIN ‚Üí Focus on recovery, rest, form correction
   - NUTRITION ‚Üí Use macro data and meal timing advice
   - HEALTH SCORE ‚Üí Explain the 40/45/15 scoring system
   - APP FEATURES ‚Üí Guide users to relevant FitnessMate tools

2. RESPONSE FORMAT (MAX 120 WORDS):
   - Direct answer to their specific question
   - 2-3 actionable bullet points
   - Reference their actual data when applicable
   - Suggest relevant app features (Workout Planner, AI Form Coach, etc.)
   - Use emojis for readability

3. WORKOUT EXPERTISE:
   - Recommend difficulty progression (Beginner ‚Üí Intermediate ‚Üí Advanced)
   - Suggest workout types based on goals and current activity
   - Explain how workouts contribute to health score
   - Reference specific exercises and proper form
   - Encourage use of AI Form Coach for technique improvement

User's question: "${userMessage.text}"`;

          const parts = [{ text: prompt }];

          if (attachment) {
            const base64ImageData = await fileToBase64(attachment);
            parts.push({ inlineData: { mimeType: attachment.type, data: base64ImageData } });
            prompt += "\n\nPlease also consider the attached document in your analysis.";
          }

          const orMessages = [
            attachment ? {
              role: 'user',
              content: [
                { type: 'text', text: prompt },
                { type: 'image_url', image_url: `data:${attachment.type};base64,${await fileToBase64(attachment)}` }
              ]
            } : { role: 'user', content: prompt }
          ];

          const response = await fetch(getDirectGeminiConfig().url, {
            method: 'POST',
            headers: getDirectGeminiConfig().headers,
            body: JSON.stringify({
              model: attachment ? OPENROUTER_QWEN_VL_MODEL : OPENROUTER_QWEN_MODEL,
              messages: orMessages
            })
          });

          if (!response.ok) {
            throw new Error(`API Error: ${response.status} ${response.statusText}`);
          }

          const result = await response.json();
          const aiResponse = (result.choices?.[0]?.message?.content || '');
          setMessages(prev => [...prev, { text: aiResponse, sender: 'ai' }]);
        } catch (err) {
          console.error("Chatbot error:", err);
          setMessages(prev => [...prev, { text: "Sorry, I'm having trouble connecting. Please try again.", sender: 'ai' }]);
        } finally {
          setIsLoading(false);
        }
      };

      return (
        <div className="p-6 pb-24 h-screen flex flex-col">
          <header className="mb-6 text-center">
            <div className="flex items-center justify-between mb-2">
              <div></div> {/* Spacer for centering */}
              <h1 className="text-3xl font-bold text-gray-800 dark:text-gray-200">AI Health Coach</h1>
              <button
                onClick={startNewConversation}
                className="bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded-lg text-sm font-medium transition-colors flex items-center gap-1"
                title="Start New Conversation"
              >
                üîÑ New
              </button>
            </div>
            <p className="text-gray-500 dark:text-gray-400">Your personal health assistant</p>
          </header>

          <div className="flex-grow overflow-y-auto p-4 rounded-2xl shadow-md relative" 
               style={{
                 backgroundColor: isDarkMode ? '#1f2937' : '#f8fafc',
                 backgroundImage: `
                   radial-gradient(circle at 25px 25px, rgba(59, 130, 246, 0.15) 6px, transparent 6px),
                   radial-gradient(circle at 75px 75px, rgba(168, 85, 247, 0.12) 8px, transparent 8px),
                   radial-gradient(circle at 50px 100px, rgba(236, 72, 153, 0.08) 4px, transparent 4px)
                 `,
                 backgroundSize: '100px 100px'
               }}>
            
            {/* Bigger dots pattern for dark mode */}
            <div className="absolute inset-0 rounded-2xl dark:bg-gray-800" 
                 style={{
                   backgroundImage: `
                     radial-gradient(circle at 25px 25px, rgba(59, 130, 246, 0.2) 5px, transparent 5px),
                     radial-gradient(circle at 75px 75px, rgba(168, 85, 247, 0.15) 7px, transparent 7px)
                   `,
                   backgroundSize: '100px 100px'
                 }}></div>
            
            {/* Content container */}
            <div className="relative z-10">
              <div className="text-center text-xs text-gray-600 dark:text-gray-400 p-2 mb-2 bg-white dark:bg-gray-700 rounded-lg shadow-sm">
                Disclaimer: This AI is for informational purposes only and is not a substitute for professional medical advice. Always consult a doctor for health concerns.
              </div>

              {messages.map((msg, i) => (
                <div key={i} className={`flex mb-3 ${msg.sender === 'user' ? 'justify-end' : 'justify-start'}`}>
                  <div className={`p-3 rounded-2xl max-w-xs shadow-lg ${
                    msg.sender === 'user' 
                      ? 'bg-pink-500 text-white' 
                      : 'bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200'
                  }`}>
                    {msg.attachment && <img src={msg.attachment} alt="attachment" className="rounded-lg mb-2 max-w-full h-auto" />}
                    {msg.text}
                  </div>
                </div>
              ))}
              <div ref={chatEndRef} />
            </div>
          </div>

          {attachmentPreview && (
            <div className="mt-2 p-2 bg-gray-200 dark:bg-gray-700 rounded-lg flex items-center justify-between">
              <img src={attachmentPreview} alt="preview" className="w-12 h-12 rounded-md object-cover" />
              <button onClick={() => { setAttachment(null); setAttachmentPreview(null); }} className="text-red-500 font-bold">Remove</button>
            </div>
          )}

          <div className="mt-4 flex">
            <input type="file" accept="image/*" ref={fileInputRef} onChange={handleAttachmentChange} className="hidden" />
            <button onClick={() => fileInputRef.current.click()} className="p-3 border dark:border-gray-700 rounded-l-lg bg-gray-100 dark:bg-gray-700">üìé</button>
            <input
              type="text"
              value={input}
              onChange={e => setInput(e.target.value)}
              onKeyDown={e => e.key === 'Enter' && handleSend()}
              placeholder="Ask a question..."
              className="flex-grow p-3 border-t border-b dark:border-gray-700 focus:outline-none focus:ring-2 focus:ring-pink-500 bg-white dark:bg-gray-800 text-gray-800 dark:text-gray-200"
              disabled={isLoading}
            />
            <button onClick={handleSend} disabled={isLoading} className="bg-pink-500 text-white p-3 rounded-r-lg font-bold">
              {isLoading ? '...' : 'Send'}
            </button>
          </div>
        </div>
      );
    };

    // Progress Screen Component
    const Progress = ({ dailyHistory, goals, dailyIntake, habitAIAdvice, setHabitAIAdvice, isLoadingAdvice, setIsLoadingAdvice }) => {
      const { updateUserData, user } = useAuth();
      const [currentDate, setCurrentDate] = useState(new Date());
      const [selectedDay, setSelectedDay] = useState(null);
      const [viewMode, setViewMode] = useState('month'); // 'month' or 'year'
      const [activeTab, setActiveTab] = useState('progress'); // 'progress' or 'habits'
      const [habits, setHabits] = useState(() => {
        const savedHabits = localStorage.getItem('habits');
        return savedHabits ? JSON.parse(savedHabits) : [];
      });
      const [newHabit, setNewHabit] = useState('');

      // Helper function to get local date string
      const getLocalDateString = (date) => {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
      };

      // Save habits to localStorage and sync with Firebase whenever they change
      useEffect(() => {
        localStorage.setItem('habits', JSON.stringify(habits));
        // Sync with Firebase if user is authenticated
        if (user && updateUserData) {
          updateUserData({ habits });
        }
      }, [habits, user, updateUserData]);

      const startOfMonth = new Date(currentDate.getFullYear(), currentDate.getMonth(), 1);
      const endOfMonth = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 0);
      // Adjust start day for Monday-first calendar (0=Sunday becomes 6, 1=Monday becomes 0)
      const startDay = (startOfMonth.getDay() + 6) % 7;
      const daysInMonth = endOfMonth.getDate();

      const getScoreColor = (score) => {
        if (score >= 90) return 'from-emerald-400 to-emerald-600';
        if (score >= 80) return 'from-green-400 to-green-600';
        if (score >= 70) return 'from-lime-400 to-lime-600';
        if (score >= 60) return 'from-yellow-400 to-yellow-600';
        if (score >= 50) return 'from-orange-400 to-orange-600';
        return 'from-red-400 to-red-600';
      };

      const getScoreGlow = (score) => {
        if (score >= 90) return 'shadow-emerald-500/50';
        if (score >= 80) return 'shadow-green-500/50';
        if (score >= 70) return 'shadow-lime-500/50';
        if (score >= 60) return 'shadow-yellow-500/50';
        if (score >= 50) return 'shadow-orange-500/50';
        return 'shadow-red-500/50';
      };

      // Calculate current streak
      const calculateStreak = () => {
        const today = new Date();
        let streak = 0;
        let currentDay = new Date(today);
        
        while (currentDay >= new Date(today.getTime() - 365 * 24 * 60 * 60 * 1000)) {
          const dateString = currentDay.toISOString().split('T')[0];
          const data = dailyHistory[dateString];
          
          if (data && data.score >= 70) {
            streak++;
          } else {
            break;
          }
          
          currentDay.setDate(currentDay.getDate() - 1);
        }
        
        return streak;
      };

      // Calculate monthly stats
      const getMonthlyStats = () => {
        const monthData = Object.entries(dailyHistory)
          .filter(([date]) => {
            const d = new Date(date);
            return d.getMonth() === currentDate.getMonth() && d.getFullYear() === currentDate.getFullYear();
          })
          .map(([_, data]) => data);

        if (monthData.length === 0) return { avg: 0, best: 0, days: 0 };

        const avg = monthData.reduce((sum, data) => sum + data.score, 0) / monthData.length;
        const best = Math.max(...monthData.map(data => data.score));
        
        return { avg: Math.round(avg), best, days: monthData.length };
      };

      const currentStreak = calculateStreak();
      const monthlyStats = getMonthlyStats();

      return (
        <div className="p-6 pb-24 bg-gradient-to-br from-purple-50 via-pink-50 to-blue-50 dark:from-gray-900 dark:via-purple-900/20 dark:to-blue-900/20 min-h-screen">
          {/* Header */}
          <header className="mb-8 text-center">
            <div className="inline-flex items-center justify-center w-16 h-16 bg-gradient-to-r from-purple-500 to-pink-500 rounded-2xl mb-4 shadow-lg">
              <span className="text-2xl">üìä</span>
            </div>
            <h1 className="text-4xl font-bold bg-gradient-to-r from-purple-600 to-pink-600 bg-clip-text text-transparent mb-2">Your Progress</h1>
            <p className="text-gray-600 dark:text-gray-400 text-lg">Track your fitness journey</p>
          </header>

          {/* Tab Navigation */}
          <div className="flex justify-center mb-6">
            <div className="bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm p-1 rounded-xl shadow-md border border-white/20 flex">
              <button 
                onClick={() => setActiveTab('progress')} 
                className={`px-6 py-3 rounded-lg font-semibold transition-all duration-200 ${activeTab === 'progress' ? 'bg-gradient-to-r from-purple-500 to-pink-500 text-white shadow-md' : 'text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700'}`}
              >
                Progress
              </button>
              <button 
                onClick={() => setActiveTab('habits')} 
                className={`px-6 py-3 rounded-lg font-semibold transition-all duration-200 ${activeTab === 'habits' ? 'bg-gradient-to-r from-purple-500 to-pink-500 text-white shadow-md' : 'text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700'}`}
              >
                Habit Tracker
              </button>
            </div>
          </div>

          {/* Tab Content */}
          {activeTab === 'progress' && (
            <>
              {/* Streak & Stats Cards */}
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-8">
            {/* Current Streak */}
            <div className="bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm p-6 rounded-3xl shadow-xl border border-white/20">
              <div className="flex items-center justify-between mb-3">
                <div className="w-12 h-12 bg-gradient-to-r from-orange-400 to-red-500 rounded-2xl flex items-center justify-center">
                  <span className="text-xl">üî•</span>
                </div>
                <span className="text-3xl font-bold bg-gradient-to-r from-orange-500 to-red-500 bg-clip-text text-transparent">
                  {currentStreak}
                </span>
              </div>
              <h3 className="font-semibold text-gray-800 dark:text-gray-200">Day Streak</h3>
              <p className="text-sm text-gray-600 dark:text-gray-400">Keep it going! üí™</p>
            </div>

            {/* Monthly Average */}
            <div className="bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm p-6 rounded-3xl shadow-xl border border-white/20">
              <div className="flex items-center justify-between mb-3">
                <div className="w-12 h-12 bg-gradient-to-r from-blue-400 to-purple-500 rounded-2xl flex items-center justify-center">
                  <span className="text-xl">üìà</span>
                </div>
                <span className="text-3xl font-bold bg-gradient-to-r from-blue-500 to-purple-500 bg-clip-text text-transparent">
                  {monthlyStats.avg}
                </span>
              </div>
              <h3 className="font-semibold text-gray-800 dark:text-gray-200">Monthly Avg</h3>
              <p className="text-sm text-gray-600 dark:text-gray-400">{monthlyStats.days} active days</p>
            </div>

            {/* Best Score */}
            <div className="bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm p-6 rounded-3xl shadow-xl border border-white/20">
              <div className="flex items-center justify-between mb-3">
                <div className="w-12 h-12 bg-gradient-to-r from-emerald-400 to-green-500 rounded-2xl flex items-center justify-center">
                  <span className="text-xl">üèÜ</span>
                </div>
                <span className="text-3xl font-bold bg-gradient-to-r from-emerald-500 to-green-500 bg-clip-text text-transparent">
                  {monthlyStats.best}
                </span>
              </div>
              <h3 className="font-semibold text-gray-800 dark:text-gray-200">Best Score</h3>
              <p className="text-sm text-gray-600 dark:text-gray-400">This month</p>
            </div>
          </div>

          {/* Modern Calendar */}
          <div className="bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm rounded-3xl shadow-2xl border border-white/20 overflow-hidden">
            {/* Calendar Header */}
            <div className="bg-blue-500 p-6">
              <div className="flex justify-between items-center">
                <button 
                  onClick={() => setCurrentDate(new Date(currentDate.setMonth(currentDate.getMonth() - 1)))} 
                  className="w-12 h-12 bg-white/20 hover:bg-white/30 rounded-2xl flex items-center justify-center text-white transition-all duration-200 hover:scale-105"
                >
                  <span className="text-xl">‚Üê</span>
                </button>
                
                <div className="text-center">
                  <h2 className="text-2xl font-bold text-white mb-1">
                    {currentDate.toLocaleString('default', { month: 'long', year: 'numeric' })}
                  </h2>
                  <p className="text-white/80 text-sm">Tap any day to see details</p>
                </div>
                
                <button 
                  onClick={() => setCurrentDate(new Date(currentDate.setMonth(currentDate.getMonth() + 1)))} 
                  className="w-12 h-12 bg-white/20 hover:bg-white/30 rounded-2xl flex items-center justify-center text-white transition-all duration-200 hover:scale-105"
                >
                  <span className="text-xl">‚Üí</span>
                </button>
              </div>
            </div>

            {/* Calendar Grid */}
            <div className="p-6">
              {/* Day Headers - Monday to Sunday */}
              <div className="grid grid-cols-7 gap-1 mb-2 bg-gray-100 dark:bg-gray-700 rounded-xl p-2">
                {['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'].map((day, index) => (
                  <div key={day} className={`text-center py-3 text-sm font-semibold rounded-lg border ${
                    index === 5 || index === 6 
                      ? 'bg-red-50 dark:bg-red-900/20 text-red-600 dark:text-red-400 border-red-200 dark:border-red-700' 
                      : 'bg-white dark:bg-gray-600 text-gray-600 dark:text-gray-300 border-gray-200 dark:border-gray-500'
                  }`}>
                    {day}
                  </div>
                ))}
              </div>

              {/* Calendar Days with Monday-first layout */}
              <div className="grid grid-cols-7 gap-1 bg-gray-100 dark:bg-gray-700 p-2 rounded-xl">
                {Array.from({ length: startDay }).map((_, i) => {
                  const dayOfWeek = i;
                  const isWeekend = dayOfWeek === 5 || dayOfWeek === 6; // Saturday=5, Sunday=6
                  return (
                    <div key={`empty-${i}`} className={`aspect-square rounded-lg border ${
                      isWeekend 
                        ? 'bg-red-50 dark:bg-red-900/10 border-red-200 dark:border-red-700' 
                        : 'bg-white dark:bg-gray-600 border-gray-200 dark:border-gray-500'
                    }`}></div>
                  );
                })}
                
                {Array.from({ length: daysInMonth }).map((_, day) => {
                  const date = new Date(currentDate.getFullYear(), currentDate.getMonth(), day + 1);
                  const dateString = getLocalDateString(date);
                  const data = dailyHistory[dateString];
                  const isToday = dateString === getLocalDateString(new Date());
                  // Adjust day of week calculation for Monday-first calendar
                  const dayOfWeek = (startDay + day) % 7;
                  const isWeekend = dayOfWeek === 5 || dayOfWeek === 6; // Saturday=5, Sunday=6
                  
                  return (
                    <div 
                      key={day} 
                      onClick={() => data && setSelectedDay({date: dateString, ...data})} 
                      className={`aspect-square flex items-center justify-center cursor-pointer group relative rounded-lg border transition-all duration-200 ${
                        isWeekend 
                          ? 'bg-red-50 dark:bg-red-900/10 border-red-200 dark:border-red-700 hover:border-red-300 dark:hover:border-red-600' 
                          : 'bg-white dark:bg-gray-600 border-gray-200 dark:border-gray-500 hover:border-gray-300 dark:hover:border-gray-400'
                      }`}
                    >
                      {data ? (
                        <div className={`w-10 h-10 bg-gradient-to-br ${getScoreColor(data.score)} rounded-xl flex items-center justify-center text-white font-bold text-sm shadow-lg ${getScoreGlow(data.score)} transform transition-all duration-200 group-hover:scale-110 group-hover:shadow-2xl ${isToday ? 'ring-3 ring-purple-400 ring-opacity-60' : ''} ${isWeekend ? 'ring-2 ring-red-300 dark:ring-red-600' : ''}`}>
                          {data.score}
                        </div>
                      ) : (
                        <div className={`w-10 h-10 rounded-xl flex items-center justify-center font-medium transition-all duration-200 ${
                          isWeekend 
                            ? 'text-red-500 dark:text-red-400 group-hover:bg-red-100 dark:group-hover:bg-red-900/20' 
                            : 'text-gray-500 dark:text-gray-400 group-hover:bg-gray-50 dark:group-hover:bg-gray-500'
                        } ${isToday ? 'bg-purple-100 dark:bg-purple-900/40 text-purple-600 dark:text-purple-400 ring-2 ring-purple-400 ring-opacity-60' : ''}`}>
                          {day + 1}
                        </div>
                      )}
                      
                      {/* Weekend Corner Marker */}
                      {isWeekend && (
                        <div className="absolute top-1 right-1 w-2 h-2 bg-red-400 dark:bg-red-500 rounded-full opacity-60"></div>
                      )}
                    </div>
                  );
                })}
              </div>
            </div>
          </div>

          {/* Workout Analytics Dashboard */}
          <div className="mt-8 bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm p-6 rounded-3xl shadow-xl border border-white/20">
            <h3 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-4 flex items-center">
              <span className="mr-2">üí™</span>
              Workout Analytics
            </h3>
            {(() => {
              let workoutHistory;
              try {
                workoutHistory = JSON.parse(localStorage.getItem('workoutHistory') || '[]');
                if (!Array.isArray(workoutHistory)) {
                  workoutHistory = [];
                  localStorage.setItem('workoutHistory', '[]');
                }
              } catch (error) {
                console.warn('Error parsing workoutHistory in analytics, resetting to empty array:', error);
                workoutHistory = [];
                localStorage.setItem('workoutHistory', '[]');
              }
              const last7Days = Array.from({length: 7}, (_, i) => {
                const date = new Date();
                date.setDate(date.getDate() - i);
                return date.toDateString();
              }).reverse();
              
              const weeklyWorkouts = last7Days.map(dateStr => {
                const dayWorkouts = workoutHistory.filter(w => new Date(w.timestamp).toDateString() === dateStr);
                return {
                  date: dateStr,
                  count: dayWorkouts.length,
                  totalTime: dayWorkouts.reduce((sum, w) => sum + w.duration, 0),
                  avgCompletion: dayWorkouts.length > 0 ? dayWorkouts.reduce((sum, w) => sum + w.completionRate, 0) / dayWorkouts.length : 0
                };
              });
              
              const totalWorkouts = workoutHistory.length;
              const avgCompletionRate = totalWorkouts > 0 ? workoutHistory.reduce((sum, w) => sum + w.completionRate, 0) / totalWorkouts : 0;
              const totalWorkoutTime = workoutHistory.reduce((sum, w) => sum + w.duration, 0);
              const workoutStreak = (() => {
                let streak = 0;
                for (let i = 0; i < 30; i++) {
                  const date = new Date();
                  date.setDate(date.getDate() - i);
                  const hasWorkout = workoutHistory.some(w => new Date(w.timestamp).toDateString() === date.toDateString());
                  if (hasWorkout) streak++;
                  else break;
                }
                return streak;
              })();
              
              return (
                <div className="space-y-4">
                  {/* Key Metrics */}
                  <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                    <div className="bg-gradient-to-br from-purple-500 to-pink-500 p-4 rounded-2xl text-white text-center">
                      <div className="text-2xl font-bold">{totalWorkouts}</div>
                      <div className="text-xs opacity-90">Total Workouts</div>
                    </div>
                    <div className="bg-gradient-to-br from-blue-500 to-cyan-500 p-4 rounded-2xl text-white text-center">
                      <div className="text-2xl font-bold">{Math.round(avgCompletionRate)}%</div>
                      <div className="text-xs opacity-90">Avg Completion</div>
                    </div>
                    <div className="bg-gradient-to-br from-green-500 to-emerald-500 p-4 rounded-2xl text-white text-center">
                      <div className="text-2xl font-bold">
                        {totalWorkoutTime >= 60 
                          ? `${Math.floor(totalWorkoutTime/60)}h ${totalWorkoutTime%60}m`
                          : `${totalWorkoutTime}m`
                        }
                      </div>
                      <div className="text-xs opacity-90">Total Time</div>
                    </div>
                    <div className="bg-gradient-to-br from-orange-500 to-red-500 p-4 rounded-2xl text-white text-center">
                      <div className="text-2xl font-bold">{workoutStreak}</div>
                      <div className="text-xs opacity-90">Day Streak</div>
                    </div>
                  </div>
                  
                  {/* Weekly Activity Chart */}
                  <div className="bg-gray-50 dark:bg-gray-700/50 p-4 rounded-2xl">
                    <h4 className="text-sm font-semibold text-gray-700 dark:text-gray-300 mb-3">7-Day Activity</h4>
                    <div className="flex items-end justify-between h-20 space-x-1">
                      {weeklyWorkouts.map((day, index) => {
                        const maxTime = Math.max(...weeklyWorkouts.map(d => d.totalTime), 1);
                        const height = (day.totalTime / maxTime) * 100;
                        return (
                          <div key={index} className="flex-1 flex flex-col items-center">
                            <div 
                              className={`w-full rounded-t transition-all duration-300 ${
                                day.count > 0 
                                  ? 'bg-gradient-to-t from-purple-500 to-pink-500' 
                                  : 'bg-gray-300 dark:bg-gray-600'
                              }`}
                              style={{height: `${Math.max(height, 5)}%`}}
                              title={`${day.count} workouts, ${day.totalTime}min`}
                            ></div>
                            <div className="text-xs text-gray-500 dark:text-gray-400 mt-1">
                              {new Date(day.date).toLocaleDateString('en', {weekday: 'short'}).slice(0,1)}
                            </div>
                          </div>
                        );
                      })}
                    </div>
                  </div>
                  
                  {/* Recent Workouts */}
                  {workoutHistory.length > 0 && (
                    <div className="bg-gray-50 dark:bg-gray-700/50 p-4 rounded-2xl">
                      <h4 className="text-sm font-semibold text-gray-700 dark:text-gray-300 mb-3">üìã Recent Workouts</h4>
                      <div className="space-y-2 max-h-40 overflow-y-auto">
                        {workoutHistory.slice(-5).reverse().map((workout, index) => (
                          <div key={index} className="flex justify-between items-center p-3 bg-white dark:bg-gray-600 rounded-lg text-xs">
                            <div className="flex-1">
                              <div className="font-medium text-gray-800 dark:text-gray-200">{workout.workoutTitle}</div>
                              <div className="text-gray-500 dark:text-gray-400 space-y-1">
                                <div className="flex items-center gap-2">
                                  <span className={`px-2 py-0.5 rounded-full text-xs font-medium ${
                                    workout.workoutLevel === 'beginner' ? 'bg-green-100 text-green-700 dark:bg-green-900/30 dark:text-green-400' :
                                    workout.workoutLevel === 'intermediate' ? 'bg-yellow-100 text-yellow-700 dark:bg-yellow-900/30 dark:text-yellow-400' :
                                    'bg-red-100 text-red-700 dark:bg-red-900/30 dark:text-red-400'
                                  }`}>
                                    {workout.workoutLevel ? workout.workoutLevel.charAt(0).toUpperCase() + workout.workoutLevel.slice(1) : 'Beginner'}
                                  </span>
                                  <span>‚Ä¢</span>
                                  <span>{workout.duration}min</span>
                                  <span>‚Ä¢</span>
                                  <span>{Math.round(workout.completionRate)}% complete</span>
                                </div>
                                <div className="text-xs">
                                  {new Date(workout.timestamp).toLocaleDateString()} at {new Date(workout.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}
                                </div>
                              </div>
                            </div>
                            <div className="text-right">
                              <div className="text-green-600 dark:text-green-400 font-medium">{workout.exercisesCompleted}/{workout.totalExercises}</div>
                            </div>
                          </div>
                        ))}
                      </div>
                    </div>
                  )}
                  
                  {/* Workout Quality Insights */}
                  {workoutHistory.length > 0 && (
                    <div className="bg-gradient-to-r from-indigo-50 to-purple-50 dark:from-indigo-900/20 dark:to-purple-900/20 p-4 rounded-2xl">
                      <h4 className="text-sm font-semibold text-gray-700 dark:text-gray-300 mb-2">üí° Insights</h4>
                      <div className="text-sm text-gray-600 dark:text-gray-400 space-y-1">
                        {avgCompletionRate >= 90 && <div>üåü Excellent completion rate! You're crushing your workouts.</div>}
                        {workoutStreak >= 7 && <div>üî• Amazing streak! Consistency is key to success.</div>}
                        {totalWorkoutTime >= 300 && <div>‚è±Ô∏è You've invested serious time in your fitness journey.</div>}
                        {workoutHistory.filter(w => new Date(w.timestamp).toDateString() === new Date().toDateString()).length > 0 && 
                         <div>‚úÖ Great job working out today!</div>}
                      </div>
                    </div>
                  )}
                </div>
              );
            })()}
          </div>

          {/* Achievement Badges */}
          <div className="mt-8 bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm p-6 rounded-3xl shadow-xl border border-white/20">
            <h3 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-4 flex items-center">
              <span className="mr-2">üèÖ</span>
              Achievement Badges
            </h3>
            {(() => {
              let workoutHistory;
              try {
                workoutHistory = JSON.parse(localStorage.getItem('workoutHistory') || '[]');
                if (!Array.isArray(workoutHistory)) {
                  workoutHistory = [];
                  localStorage.setItem('workoutHistory', '[]');
                }
              } catch (error) {
                console.warn('Error parsing workoutHistory in badges, resetting to empty array:', error);
                workoutHistory = [];
                localStorage.setItem('workoutHistory', '[]');
              }
              const totalWorkouts = workoutHistory.length;
              const workoutStreak = (() => {
                let streak = 0;
                for (let i = 0; i < 30; i++) {
                  const date = new Date();
                  date.setDate(date.getDate() - i);
                  const hasWorkout = workoutHistory.some(w => new Date(w.timestamp).toDateString() === date.toDateString());
                  if (hasWorkout) streak++;
                  else break;
                }
                return streak;
              })();
              const avgCompletionRate = totalWorkouts > 0 ? workoutHistory.reduce((sum, w) => sum + w.completionRate, 0) / totalWorkouts : 0;
              const totalWorkoutTime = workoutHistory.reduce((sum, w) => sum + w.duration, 0);
              
              return (
                <div className="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-6 gap-4">
                  {/* Health Score Achievements */}
                  <div className={`p-4 rounded-2xl text-center ${currentStreak >= 7 ? 'bg-gradient-to-br from-yellow-400 to-orange-500 text-white' : 'bg-gray-100 dark:bg-gray-700 text-gray-400'}`}>
                    <div className="text-2xl mb-2">üî•</div>
                    <div className="text-xs font-semibold">Week Warrior</div>
                    <div className="text-xs opacity-80">7 day streak</div>
                  </div>
                  
                  <div className={`p-4 rounded-2xl text-center ${currentStreak >= 30 ? 'bg-gradient-to-br from-purple-400 to-pink-500 text-white' : 'bg-gray-100 dark:bg-gray-700 text-gray-400'}`}>
                    <div className="text-2xl mb-2">üíé</div>
                    <div className="text-xs font-semibold">Diamond</div>
                    <div className="text-xs opacity-80">30 day streak</div>
                  </div>
                  
                  <div className={`p-4 rounded-2xl text-center ${monthlyStats.avg >= 80 ? 'bg-gradient-to-br from-green-400 to-emerald-500 text-white' : 'bg-gray-100 dark:bg-gray-700 text-gray-400'}`}>
                    <div className="text-2xl mb-2">‚≠ê</div>
                    <div className="text-xs font-semibold">Superstar</div>
                    <div className="text-xs opacity-80">80+ avg score</div>
                  </div>
                  
                  <div className={`p-4 rounded-2xl text-center ${monthlyStats.best >= 95 ? 'bg-gradient-to-br from-blue-400 to-cyan-500 text-white' : 'bg-gray-100 dark:bg-gray-700 text-gray-400'}`}>
                    <div className="text-2xl mb-2">üöÄ</div>
                    <div className="text-xs font-semibold">Perfectionist</div>
                    <div className="text-xs opacity-80">95+ best score</div>
                  </div>
                  
                  {/* Workout Achievements */}
                  <div className={`p-4 rounded-2xl text-center ${totalWorkouts >= 10 ? 'bg-gradient-to-br from-indigo-400 to-blue-500 text-white' : 'bg-gray-100 dark:bg-gray-700 text-gray-400'}`}>
                    <div className="text-2xl mb-2">üí™</div>
                    <div className="text-xs font-semibold">Fitness Starter</div>
                    <div className="text-xs opacity-80">10 workouts</div>
                  </div>
                  
                  <div className={`p-4 rounded-2xl text-center ${workoutStreak >= 5 ? 'bg-gradient-to-br from-red-400 to-pink-500 text-white' : 'bg-gray-100 dark:bg-gray-700 text-gray-400'}`}>
                    <div className="text-2xl mb-2">üèÉ</div>
                    <div className="text-xs font-semibold">Consistent</div>
                    <div className="text-xs opacity-80">5 workout streak</div>
                  </div>
                  
                  <div className={`p-4 rounded-2xl text-center ${avgCompletionRate >= 90 ? 'bg-gradient-to-br from-emerald-400 to-teal-500 text-white' : 'bg-gray-100 dark:bg-gray-700 text-gray-400'}`}>
                    <div className="text-2xl mb-2">üéØ</div>
                    <div className="text-xs font-semibold">Finisher</div>
                    <div className="text-xs opacity-80">90% completion</div>
                  </div>
                  
                  <div className={`p-4 rounded-2xl text-center ${totalWorkoutTime >= 600 ? 'bg-gradient-to-br from-amber-400 to-yellow-500 text-white' : 'bg-gray-100 dark:bg-gray-700 text-gray-400'}`}>
                    <div className="text-2xl mb-2">‚è∞</div>
                    <div className="text-xs font-semibold">Time Master</div>
                    <div className="text-xs opacity-80">10+ hours</div>
                  </div>
                </div>
              );
            })()}
          </div>

          {/* Health Score Info */}
          <div className="mt-8 bg-gradient-to-r from-indigo-500/10 to-purple-500/10 dark:from-indigo-500/5 dark:to-purple-500/5 p-6 rounded-3xl border border-indigo-200/50 dark:border-indigo-700/50">
            <h3 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-3 flex items-center">
              <span className="mr-2">üßÆ</span>
              Health Score Formula
            </h3>
            <div className="grid grid-cols-1 md:grid-cols-4 gap-4 text-center">
              <div className="bg-white/50 dark:bg-gray-800/50 p-4 rounded-2xl">
                <div className="text-2xl font-bold text-pink-500 mb-1">40%</div>
                <div className="text-sm font-semibold text-gray-700 dark:text-gray-300">Nutrition</div>
                <div className="text-xs text-gray-600 dark:text-gray-400">Calorie goals</div>
              </div>
              
              <div className="bg-white/50 dark:bg-gray-800/50 p-4 rounded-2xl">
                <div className="text-2xl font-bold text-purple-500 mb-1">25%</div>
                <div className="text-sm font-semibold text-gray-700 dark:text-gray-300">Activity</div>
                <div className="text-xs text-gray-600 dark:text-gray-400">Exercise minutes</div>
              </div>
              
              <div className="bg-white/50 dark:bg-gray-800/50 p-4 rounded-2xl">
                <div className="text-2xl font-bold text-indigo-500 mb-1">20%</div>
                <div className="text-sm font-semibold text-gray-700 dark:text-gray-300">Workout Quality</div>
                <div className="text-xs text-gray-600 dark:text-gray-400">Completion & consistency</div>
              </div>
              
              <div className="bg-white/50 dark:bg-gray-800/50 p-4 rounded-2xl">
                <div className="text-2xl font-bold text-blue-500 mb-1">15%</div>
                <div className="text-sm font-semibold text-gray-700 dark:text-gray-300">Hydration</div>
                <div className="text-xs text-gray-600 dark:text-gray-400">Water intake</div>
              </div>

            </div>
          </div>
            </>
          )}

          {activeTab === 'habits' && (
            <div className="space-y-8">
              {/* Habit Tracker Content */}
              <div className="bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm p-6 rounded-3xl shadow-xl border border-white/20">
                <h3 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-4 flex items-center">
                  <span className="mr-2">‚úÖ</span>
                  My Habits
                </h3>
                
                {/* Add New Habit */}
                <div className="flex mb-6">
                  <input 
                    type="text" 
                    value={newHabit}
                    onChange={(e) => setNewHabit(e.target.value)}
                    placeholder="Add a new habit..."
                    className="flex-grow p-3 rounded-l-xl border border-gray-200 dark:border-gray-600 bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-200 focus:outline-none focus:ring-2 focus:ring-purple-500"
                  />
                  <button 
                    onClick={() => {
                      if (newHabit.trim()) {
                        setHabits([...habits, {
                          id: Date.now().toString(),
                          name: newHabit.trim(),
                          streak: 0,
                          completed: {},
                          created: new Date().toISOString()
                        }]);
                        setNewHabit('');
                      }
                    }}
                    className="bg-gradient-to-r from-purple-500 to-pink-500 text-white font-bold p-3 rounded-r-xl hover:from-purple-600 hover:to-pink-600 transition-all duration-200"
                  >
                    Add
                  </button>
                </div>
                
                {/* Habits List */}
                <div className="space-y-4 max-h-96 overflow-y-auto">
                  {habits.length === 0 ? (
                    <div className="text-center p-8 text-gray-500 dark:text-gray-400">
                      <div className="text-4xl mb-2">üå±</div>
                      <p>No habits yet. Add your first habit to start tracking!</p>
                    </div>
                  ) : (
                    habits.map(habit => {
                      const today = new Date().toISOString().split('T')[0];
                      const isCompletedToday = habit.completed && habit.completed[today];
                      
                      return (
                        <div key={habit.id} className="bg-white dark:bg-gray-700 rounded-2xl p-4 shadow-md border border-gray-100 dark:border-gray-600">
                          <div className="flex items-center justify-between">
                            <div className="flex items-center">
                              <button 
                                onClick={() => {
                                  const updatedHabits = habits.map(h => {
                                    if (h.id === habit.id) {
                                      const completed = {...h.completed};
                                      const wasCompleted = completed[today];
                                      
                                      if (completed[today]) {
                                        delete completed[today];
                                      } else {
                                        completed[today] = true;
                                      }
                                      
                                      // Note: Auto-sync with dailyIntake would require passing setDailyIntake as prop
                                      // This functionality is commented out to avoid prop drilling
                                      // if (!wasCompleted && (h.name.toLowerCase().includes('cardio') || h.name.toLowerCase().includes('exercise') || h.name.toLowerCase().includes('workout') || h.name.toLowerCase().includes('run') || h.name.toLowerCase().includes('walk') || h.name.toLowerCase().includes('gym'))) {
                                      //   const minutes = parseInt(h.name.match(/\d+/)?.[0]) || 30;
                                      //   setDailyIntake(prev => ({ ...prev, activity: prev.activity + minutes }));
                                      // }
                                      // if (!wasCompleted && h.name.toLowerCase().includes('water')) {
                                      //   const glasses = parseInt(h.name.match(/\d+/)?.[0]) || 1;
                                      //   setDailyIntake(prev => ({ ...prev, water: prev.water + glasses }));
                                      // }
                                      
                                      // Calculate streak
                                      let streak = 0;
                                      let currentDate = new Date();
                                      
                                      while (true) {
                                        const dateStr = currentDate.toISOString().split('T')[0];
                                        if (completed[dateStr]) {
                                          streak++;
                                          currentDate.setDate(currentDate.getDate() - 1);
                                        } else {
                                          break;
                                        }
                                      }
                                      
                                      return {...h, completed, streak};
                                    }
                                    return h;
                                  });
                                  
                                  setHabits(updatedHabits);
                                }}
                                className={`w-8 h-8 rounded-lg mr-3 flex items-center justify-center transition-all duration-200 ${isCompletedToday ? 'bg-gradient-to-r from-green-400 to-emerald-500 text-white' : 'bg-gray-100 dark:bg-gray-600 text-gray-400 dark:text-gray-500'}`}
                              >
                                {isCompletedToday ? '‚úì' : ''}
                              </button>
                              <div>
                                <h4 className="font-semibold text-gray-800 dark:text-gray-200">{habit.name}</h4>
                                <div className="text-xs text-gray-500 dark:text-gray-400 flex items-center">
                                  <span className="mr-2">üî•</span>
                                  <span>{habit.streak} day streak</span>
                                </div>
                              </div>
                            </div>
                            <button 
                              onClick={() => {
                                setHabits(habits.filter(h => h.id !== habit.id));
                              }}
                              className="text-gray-400 hover:text-red-500 transition-colors duration-200"
                            >
                              √ó
                            </button>
                          </div>
                        </div>
                      );
                    })
                  )}
                </div>
              </div>
              
              {/* AI Habit Coach */}
              <div className="bg-gradient-to-r from-blue-500/10 to-purple-500/10 dark:from-blue-500/5 dark:to-purple-500/5 p-6 rounded-3xl border border-blue-200/50 dark:border-blue-700/50">
                <h3 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-4 flex items-center">
                  <span className="mr-2">ü§ñ</span>
                  AI Habit Coach
                </h3>
                
                <div className="bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm p-4 rounded-2xl mb-4">
                  {habitAIAdvice ? (
                    <div className="text-gray-800 dark:text-gray-200">
                      {habitAIAdvice}
                    </div>
                  ) : (
                    <div className="text-center p-4 text-gray-500 dark:text-gray-400">
                      <p>Ask for habit recommendations or insights</p>
                    </div>
                  )}
                </div>
                
                <div className="flex">
                  <button 
                    onClick={async () => {
                      setIsLoadingAdvice(true);
                      try {
                        // Get habits data for context
                        const habitsContext = habits.map(h => `${h.name} (${h.streak} day streak)`);

                        // Consolidate hydration: combine dashboard water with completed water habit for today
                        const _today = new Date().toISOString().split('T')[0];
                        const waterHabitGlasses = habits.reduce((max, h) => {
                          const isWater = /\b(drink)?\s*\d+\s*(glass|glasses)\s*of\s*water\b|\bwater\b|\bhydrate\b/i.test(h.name);
                          const doneToday = h.completed && h.completed[_today];
                          if (!isWater || !doneToday) return max;
                          const m = h.name.match(/(\d+)\s*(glass|glasses)/i);
                          const g = m ? parseInt(m[1], 10) : 0;
                          return Math.max(max, g);
                        }, 0);
                        const effectiveWater = Math.max(dailyIntake.water || 0, waterHabitGlasses || 0);
                        
                        // Consolidate activity: include completed activity habit for today
                        const _todayAct = new Date().toISOString().split('T')[0];
                        const activityHabitMins = habits.reduce((max, h) => {
                          const isAct = /(cardio|exercise|workout|run|walk|gym)/i.test(h.name || '');
                          const done = h.completed && h.completed[_todayAct];
                          if (!isAct || !done) return max;
                          const m = (h.name || '').match(/(\d+)\s*(min|mins|minutes)/i) || (h.name || '').match(/(\d+)/);
                          const mins = m ? parseInt(m[1], 10) : 30;
                          return Math.max(max, mins);
                        }, 0);
                        const effectiveActivity = Math.max(dailyIntake.activity || 0, activityHabitMins || 0);

                        // Create prompt for the AI
                        let prompt = `You are an AI Habit Coach. Analyze user data and provide smart recommendations.

**HABIT STATUS TODAY:**
${habits.map(habit => {
  const today = new Date().toISOString().split('T')[0];
  const isCompleted = habit.completed && habit.completed[today];
  return `‚Ä¢ ${habit.name}: ${isCompleted ? '‚úÖ COMPLETED' : '‚ùå NOT DONE'} (${habit.streak}d streak)`;
}).join('\n')}

**DAILY PROGRESS:**
‚Ä¢ Calories: ${dailyIntake.calories}/${goals.calories} (${((dailyIntake.calories / goals.calories) * 100).toFixed(0)}%)
‚Ä¢ Protein: ${dailyIntake.protein}g/${goals.protein}g (${((dailyIntake.protein / goals.protein) * 100).toFixed(0)}%)
‚Ä¢ Activity: ${Math.min(effectiveActivity, goals.activity)}/${goals.activity}min (${Math.min(100, ((effectiveActivity / goals.activity) * 100)).toFixed(0)}%)
‚Ä¢ Water: ${Math.min(effectiveWater, goals.water)}/${goals.water} glasses (${Math.min(100, ((effectiveWater / goals.water) * 100)).toFixed(0)}%)

**INSTRUCTIONS:**
1. If habits are completed today, congratulate and suggest maintaining momentum
2. If habits are incomplete, focus on the most important one to complete
3. For daily progress, only mention areas below 80%
4. Be encouraging about completed habits

**FORMAT (exactly 4 lines, max 100 chars total):**
üéØ [Focus area or congratulations]
‚ö° [Specific action for today]
üî• [Simple habit tip]
üí™ [Motivation based on actual progress]

**RULES:**
- Maximum 100 characters total
- Acknowledge completed habits positively
- Only suggest improvements for incomplete items
- Use actual percentages, not assumptions`;
                        
                        // Call the AI API
                        const response = await fetch(getDirectGeminiConfig().url, {
                          method: 'POST',
                          headers: getDirectGeminiConfig().headers,
                          signal: AbortSignal.timeout(25000),
                          body: JSON.stringify({
                            model: OPENROUTER_QWEN_MODEL,
                            messages: [{ role: 'user', content: prompt }]
                          })
                        });
                        
                        if (!response.ok) {
                          let details = '';
                          try {
                            const errText = await response.text();
                            try { const errJson = JSON.parse(errText); details = errJson?.error?.message || errJson?.message || errText; } catch { details = errText; }
                          } catch {}
                          throw new Error(`OpenRouter API error (${response.status}): ${details}`);
                        }
                        
                        const result = await response.json();
                        const advice = (result.choices?.[0]?.message?.content || '');
                        setHabitAIAdvice(advice);
                      } catch (error) {
                        console.error("Failed to get habit recommendations:", error);
                        setHabitAIAdvice("Sorry, I couldn't generate recommendations right now. Please try again later.");
                      } finally {
                        setIsLoadingAdvice(false);
                      }
                    }}
                    disabled={isLoadingAdvice}
                    className="flex-grow bg-gradient-to-r from-blue-500 to-purple-500 text-white font-bold p-3 rounded-xl hover:from-blue-600 hover:to-purple-600 transition-all duration-200 disabled:opacity-50"
                  >
                    {isLoadingAdvice ? 'Thinking...' : 'Get AI Recommendations'}
                  </button>
                </div>
              </div>
              
              {/* Habit Statistics */}
              <div className="bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm p-6 rounded-3xl shadow-xl border border-white/20">
                <h3 className="text-xl font-bold text-gray-800 dark:text-gray-200 mb-4 flex items-center">
                  <span className="mr-2">üìà</span>
                  Habit Statistics
                </h3>
                
                <div className="grid grid-cols-1 md:grid-cols-3 gap-4 text-center">
                  <div className="bg-gradient-to-br from-purple-500/10 to-pink-500/10 dark:from-purple-500/5 dark:to-pink-500/5 p-4 rounded-2xl">
                    <div className="text-2xl font-bold text-purple-500 mb-1">{habits.length}</div>
                    <div className="text-sm font-semibold text-gray-700 dark:text-gray-300">Active Habits</div>
                  </div>
                  <div className="bg-gradient-to-br from-blue-500/10 to-cyan-500/10 dark:from-blue-500/5 dark:to-cyan-500/5 p-4 rounded-2xl">
                    <div className="text-2xl font-bold text-blue-500 mb-1">
                      {habits.reduce((total, habit) => {
                        const today = new Date().toISOString().split('T')[0];
                        return total + (habit.completed && habit.completed[today] ? 1 : 0);
                      }, 0)}
                    </div>
                    <div className="text-sm font-semibold text-gray-700 dark:text-gray-300">Completed Today</div>
                  </div>
                  <div className="bg-gradient-to-br from-green-500/10 to-emerald-500/10 dark:from-green-500/5 dark:to-emerald-500/5 p-4 rounded-2xl">
                    <div className="text-2xl font-bold text-green-500 mb-1">
                      {habits.length > 0 ? Math.max(...habits.map(h => h.streak)) : 0}
                    </div>
                    <div className="text-sm font-semibold text-gray-700 dark:text-gray-300">Longest Streak</div>
                  </div>
                </div>
              </div>
            </div>
          )}

          {/* Day Detail Modal */}
          {selectedDay && (
            <div className="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center p-4 z-50 animate-fade-in" onClick={() => setSelectedDay(null)}>
              <div className="bg-white dark:bg-gray-800 p-8 rounded-3xl shadow-2xl max-w-md w-full transform transition-all duration-300 scale-100" onClick={e => e.stopPropagation()}>
                <div className="text-center mb-6">
                  <div className={`w-20 h-20 bg-gradient-to-br ${getScoreColor(selectedDay.score)} rounded-3xl flex items-center justify-center text-white font-bold text-2xl mx-auto mb-4 shadow-lg ${getScoreGlow(selectedDay.score)}`}>
                    {selectedDay.score}
                  </div>
                  <h3 className="text-2xl font-bold text-gray-800 dark:text-gray-200 mb-2">
                    {new Date(selectedDay.date).toLocaleDateString('en-US', { 
                      weekday: 'long', 
                      year: 'numeric', 
                      month: 'long', 
                      day: 'numeric' 
                    })}
                  </h3>
                </div>
                
                <div className="space-y-4 mb-6">
                  <div className="flex justify-between items-center p-3 bg-gray-50 dark:bg-gray-700 rounded-2xl">
                    <span className="font-semibold text-gray-700 dark:text-gray-300">üçΩÔ∏è Calories</span>
                    <span className="font-bold text-gray-800 dark:text-gray-200">{selectedDay.intake.calories.toFixed(0)}</span>
                  </div>
                  <div className="flex justify-between items-center p-3 bg-gray-50 dark:bg-gray-700 rounded-2xl">
                    <span className="font-semibold text-gray-700 dark:text-gray-300">üèÉ Activity</span>
                    <span className="font-bold text-gray-800 dark:text-gray-200">{selectedDay.intake.activity} mins</span>
                  </div>
                  <div className="flex justify-between items-center p-3 bg-gray-50 dark:bg-gray-700 rounded-2xl">
                    <span className="font-semibold text-gray-700 dark:text-gray-300">üíß Water</span>
                    <span className="font-bold text-gray-800 dark:text-gray-200">{selectedDay.intake.water} glasses</span>
                  </div>
                </div>
                
                {selectedDay.meals && selectedDay.meals.length > 0 && (
                  <div className="mb-6">
                    <h4 className="font-bold text-gray-800 dark:text-gray-200 mb-3 flex items-center">
                      <span className="mr-2">üçΩÔ∏è</span>
                      Meals
                    </h4>
                    <div className="space-y-2 max-h-32 overflow-y-auto">
                      {selectedDay.meals.map(m => (
                        <div key={m.id} className="p-2 bg-gray-50 dark:bg-gray-700 rounded-xl text-sm text-gray-700 dark:text-gray-300">
                          {m.name}
                        </div>
                      ))}
                    </div>
                  </div>
                )}
                
                <button 
                  onClick={() => setSelectedDay(null)} 
                  className="w-full bg-gradient-to-r from-purple-500 to-pink-500 text-white font-bold py-4 rounded-2xl hover:from-purple-600 hover:to-pink-600 transition-all duration-200 transform hover:scale-105 shadow-lg"
                >
                  Close
                </button>
              </div>
            </div>
          )}
        </div>
      );
    };

    // --- Helper Components ---

    // Activity Timer Component (for Dashboard)
    const ActivityTimer = ({ onLogActivity }) => {
      const [timeLeft, setTimeLeft] = useState(0);
      const [isActive, setIsActive] = useState(false);
      const [duration, setDuration] = useState(0);
      const timerRef = useRef(null);

      useEffect(() => {
        if (timeLeft > 0 && isActive) {
          timerRef.current = setTimeout(() => setTimeLeft(timeLeft - 1), 1000);
        } else if (timeLeft === 0 && isActive) {
          setIsActive(false);
          onLogActivity({ minutes: duration });
          if ('Notification' in window && Notification.permission === "granted") {
            new Notification("Activity Complete!", { body: `Great job! You've logged ${duration} minutes.` });
          }
        }
        return () => clearTimeout(timerRef.current);
      }, [timeLeft, isActive, onLogActivity, duration]);

      const startTimer = (minutes) => {
        setTimeLeft(minutes * 60);
        setDuration(minutes);
        setIsActive(true);
      };

      const formatTime = (seconds) => {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins}:${secs < 10 ? '0' : ''}${secs}`;
      };

      if (isActive) {
        return <div className="text-center font-bold text-3xl text-pink-500">{formatTime(timeLeft)}</div>;
      }

      return (
        <div className="space-y-2">
          <p className="font-semibold text-gray-800 dark:text-gray-200 text-center">Start a quick session:</p>
          <div className="grid grid-cols-3 gap-2">
            <button onClick={() => startTimer(10)} className="p-2 bg-pink-500 text-white rounded-lg">10 min</button>
            <button onClick={() => startTimer(20)} className="p-2 bg-pink-500 text-white rounded-lg">20 min</button>
            <button onClick={() => startTimer(30)} className="p-2 bg-pink-500 text-white rounded-lg">30 min</button>
          </div>
        </div>
      );
    };

    // Water Tracker Component (for Dashboard)
    const WaterTracker = ({ onLogWater, dailyIntake, goals }) => {
      useEffect(() => {
        const interval = setInterval(() => {
          if ('Notification' in window && Notification.permission === "granted") {
            new Notification("Stay Hydrated!", { body: "Time for a glass of water to keep you going." });
          }
        }, 2 * 60 * 60 * 1000); // Remind every 2 hours
        return () => clearInterval(interval);
      }, []);

      return (
        <div>
          <p className="font-semibold text-gray-800 dark:text-gray-200 text-center">Water Intake: {dailyIntake.water} / {goals.water} glasses</p>
          <button onClick={onLogWater} className="w-full mt-2 bg-blue-500 text-white font-bold py-2 rounded-xl">Log a Glass</button>
        </div>
      );
    };

    const MacroCard = ({ title, value, goal, unit, color }) => (
      <div className="bg-white dark:bg-gray-800 rounded-2xl p-4 flex flex-col items-center justify-center shadow-md">
        <p className={`font-bold ${color}`}>{title}</p>
        <p className="text-xl font-bold my-1 text-gray-800 dark:text-gray-200">{Math.round(value)}{unit}</p>
        <p className="text-xs text-gray-500 dark:text-gray-400">Goal: {goal}{unit}</p>
      </div>
    );

    const MealCard = ({ meal }) => (
      <div className="flex items-center bg-white dark:bg-gray-800 rounded-2xl p-3 shadow-md">
        <img src={meal.image} alt={meal.name} className="w-16 h-16 rounded-lg" />
        <div className="ml-4 flex-grow">
          <p className="font-bold text-gray-800 dark:text-gray-200">{meal.name}</p>
          <p className="text-gray-500 dark:text-gray-400">{Math.round(meal.calories)} kcal</p>
        </div>
        {meal.mood && (
          <span className="text-3xl">{{ Energized: '‚ö°Ô∏è', Happy: 'üòä', Sluggish: 'üò¥', Bloated: 'ü§¢' }[meal.mood]}</span>
        )}
      </div>
    );

    const GoalItem = ({ label, value }) => (
      <div className="flex justify-between items-center p-2">
        <p className="text-gray-600 dark:text-gray-300">{label}</p>
        <p className="font-bold text-gray-800 dark:text-gray-200">{value}</p>
      </div>
    );

    const SettingItem = ({ label }) => (
      <button className="w-full text-left p-3 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-300 transition-colors">
        {label}
      </button>
    );

    const MealPlanDisplay = ({ mealPlan }) => {
      return (
        <div className="space-y-8">
          {/* Breakfast Section */}
          <div className="bg-white dark:bg-gray-800 rounded-lg p-6 shadow-md">
            <h3 className="text-xl font-bold text-gray-800 dark:text-white mb-4">Breakfast: {mealPlan.breakfast.name}</h3>
            
            <div className="mb-4">
              <div className="flex items-center justify-between mb-2">
                <h4 className="font-semibold text-gray-700 dark:text-gray-300">Ingredients:</h4>
                <VoiceButton 
                  text={`Breakfast ingredients: ${mealPlan.breakfast.ingredients.join(', ')}`}
                  buttonId="breakfast-ingredients"
                  label="Ingredients"
                  className="ml-2"
                />
              </div>
              <ul className="list-disc list-inside text-gray-600 dark:text-gray-400">
                {mealPlan.breakfast.ingredients.map((ingredient, index) => (
                  <li key={index}>{ingredient}</li>
                ))}
              </ul>
            </div>
            
            <div>
              <div className="flex items-center justify-between mb-2">
                <h4 className="font-semibold text-gray-700 dark:text-gray-300">Instructions:</h4>
                <VoiceButton 
                  text={`Breakfast instructions: ${mealPlan.breakfast.instructions.join('. ')}`}
                  buttonId="breakfast-instructions"
                  label="Instructions"
                  className="ml-2"
                />
              </div>
              <ol className="list-decimal list-inside text-gray-600 dark:text-gray-400 space-y-1">
                {mealPlan.breakfast.instructions.map((instruction, index) => (
                  <li key={index}>{instruction}</li>
                ))}
              </ol>
            </div>
          </div>

          {/* Lunch Section */}
          <div className="bg-white dark:bg-gray-800 rounded-lg p-6 shadow-md">
            <h3 className="text-xl font-bold text-gray-800 dark:text-white mb-4">Lunch: {mealPlan.lunch.name}</h3>
            
            <div className="mb-4">
              <div className="flex items-center justify-between mb-2">
                <h4 className="font-semibold text-gray-700 dark:text-gray-300">Ingredients:</h4>
                <VoiceButton 
                  text={`Lunch ingredients: ${mealPlan.lunch.ingredients.join(', ')}`}
                  buttonId="lunch-ingredients"
                  label="Ingredients"
                  className="ml-2"
                />
              </div>
              <ul className="list-disc list-inside text-gray-600 dark:text-gray-400">
                {mealPlan.lunch.ingredients.map((ingredient, index) => (
                  <li key={index}>{ingredient}</li>
                ))}
              </ul>
            </div>
            
            <div>
              <div className="flex items-center justify-between mb-2">
                <h4 className="font-semibold text-gray-700 dark:text-gray-300">Instructions:</h4>
                <VoiceButton 
                  text={`Lunch instructions: ${mealPlan.lunch.instructions.join('. ')}`}
                  buttonId="lunch-instructions"
                  label="Instructions"
                  className="ml-2"
                />
              </div>
              <ol className="list-decimal list-inside text-gray-600 dark:text-gray-400 space-y-1">
                {mealPlan.lunch.instructions.map((instruction, index) => (
                  <li key={index}>{instruction}</li>
                ))}
              </ol>
            </div>
          </div>

          {/* Dinner Section */}
          <div className="bg-white dark:bg-gray-800 rounded-lg p-6 shadow-md">
            <h3 className="text-xl font-bold text-gray-800 dark:text-white mb-4">Dinner: {mealPlan.dinner.name}</h3>
            
            <div className="mb-4">
              <div className="flex items-center justify-between mb-2">
                <h4 className="font-semibold text-gray-700 dark:text-gray-300">Ingredients:</h4>
                <VoiceButton 
                  text={`Dinner ingredients: ${mealPlan.dinner.ingredients.join(', ')}`}
                  buttonId="dinner-ingredients"
                  label="Ingredients"
                  className="ml-2"
                />
              </div>
              <ul className="list-disc list-inside text-gray-600 dark:text-gray-400">
                {mealPlan.dinner.ingredients.map((ingredient, index) => (
                  <li key={index}>{ingredient}</li>
                ))}
              </ul>
            </div>
            
            <div>
              <div className="flex items-center justify-between mb-2">
                <h4 className="font-semibold text-gray-700 dark:text-gray-300">Instructions:</h4>
                <VoiceButton 
                  text={`Dinner instructions: ${mealPlan.dinner.instructions.join('. ')}`}
                  buttonId="dinner-instructions"
                  label="Instructions"
                  className="ml-2"
                />
              </div>
              <ol className="list-decimal list-inside text-gray-600 dark:text-gray-400 space-y-1">
                {mealPlan.dinner.instructions.map((instruction, index) => (
                  <li key={index}>{instruction}</li>
                ))}
              </ol>
            </div>
          </div>
        </div>
      );
    };

    // Workout Plan Display Component
    const WorkoutPlanDisplay = ({ workoutPlan }) => {
      return (
        <div className="space-y-6">
          {workoutPlan.exercises.map((exercise, index) => (
            <div key={index} className="bg-white dark:bg-gray-800 rounded-lg p-6 shadow-md">
              <div className="flex items-center justify-between mb-4">
                <h3 className="text-xl font-bold text-gray-800 dark:text-white">
                  Exercise {index + 1}: {exercise.name}
                </h3>
                <VoiceButton 
                  text={`Exercise ${index + 1}: ${exercise.name}. You will do ${exercise.sets} sets of ${exercise.reps} repetitions. Instructions: ${exercise.instructions}`}
                  buttonId={`exercise-${index}`}
                  label="Listen"
                  className="ml-2"
                />
              </div>
              
              <div className="grid grid-cols-2 gap-4 mb-4">
                <div className="text-center p-3 bg-blue-50 dark:bg-blue-900/20 rounded-lg">
                  <div className="text-2xl font-bold text-blue-600 dark:text-blue-400">{exercise.sets}</div>
                  <div className="text-sm text-gray-600 dark:text-gray-400">Sets</div>
                </div>
                <div className="text-center p-3 bg-green-50 dark:bg-green-900/20 rounded-lg">
                  <div className="text-2xl font-bold text-green-600 dark:text-green-400">{exercise.reps}</div>
                  <div className="text-sm text-gray-600 dark:text-gray-400">Reps</div>
                </div>
              </div>
              
              <div>
                <h4 className="font-semibold text-gray-700 dark:text-gray-300 mb-2">Instructions:</h4>
                <p className="text-gray-600 dark:text-gray-400">{exercise.instructions}</p>
              </div>
            </div>
          ))}
        </div>
      );
    };


    const BottomNavBar = ({ screen, setScreen }) => (
      <nav className="fixed bottom-0 left-0 right-0 bg-white/80 dark:bg-gray-900/80 backdrop-blur-sm shadow-[0_-2px_10px_rgba(0,0,0,0.05)] dark:shadow-[0_-2px_10px_rgba(0,0,0,0.2)] h-20 flex justify-around items-center px-4">
        <button onClick={() => setScreen('dashboard')} className={`flex flex-col items-center justify-center font-semibold transition-colors ${screen === 'dashboard' ? 'text-pink-500' : 'text-gray-400'}`}>
          <span className="text-2xl mb-1">üè†</span>
        </button>
        <button onClick={() => setScreen('planner')} className={`flex flex-col items-center justify-center font-semibold transition-colors ${screen === 'planner' ? 'text-pink-500' : 'text-gray-400'}`}>
          <span className="text-2xl mb-1">üìã</span>
        </button>
        <button onClick={() => setScreen('progress')} className={`flex flex-col items-center justify-center font-semibold transition-colors ${screen === 'progress' ? 'text-pink-500' : 'text-gray-400'}`}>
          <span className="text-2xl mb-1">üìä</span>
        </button>
        <button onClick={() => setScreen('scan')} className="bg-blue-500 text-white w-14 h-14 rounded-full flex items-center justify-center text-lg font-bold shadow-lg">
          Cal
        </button>
        <button onClick={() => setScreen('workout')} className={`flex flex-col items-center justify-center font-semibold transition-colors ${screen === 'workout' ? 'text-pink-500' : 'text-gray-400'}`}>
          <span className="text-2xl mb-1">üèãÔ∏è</span>
        </button>
        <button onClick={() => setScreen('coach')} className={`flex flex-col items-center justify-center font-semibold transition-colors ${screen === 'coach' ? 'text-pink-500' : 'text-gray-400'}`}>
          <span className="text-2xl mb-1">ü§ñ</span>
        </button>
        <button onClick={() => setScreen('profile')} className={`flex flex-col items-center justify-center font-semibold transition-colors ${screen === 'profile' ? 'text-pink-500' : 'text-gray-400'}`}>
          <span className="text-2xl mb-1">üë§</span>
        </button>
      </nav>
    );

    // --- Mount App ---
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(
      <AuthProvider>
        <App />
      </AuthProvider>
    );
  </script>
  <!-- PDF Generation Library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
</body>
</html>


